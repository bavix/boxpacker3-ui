(function () {
	'use strict';

	/**
	 * @license
	 * Copyright 2010-2025 Three.js Authors
	 * SPDX-License-Identifier: MIT
	 */const REVISION='181';/**
	 * Represents mouse buttons and interaction types in context of controls.
	 *
	 * @type {ConstantsMouse}
	 * @constant
	 */const MOUSE={ROTATE:0,DOLLY:1,PAN:2};/**
	 * Represents touch interaction types in context of controls.
	 *
	 * @type {ConstantsTouch}
	 * @constant
	 */const TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3};/**
	 * Disables face culling.
	 *
	 * @type {number}
	 * @constant
	 */const CullFaceNone=0;/**
	 * Culls back faces.
	 *
	 * @type {number}
	 * @constant
	 */const CullFaceBack=1;/**
	 * Culls front faces.
	 *
	 * @type {number}
	 * @constant
	 */const CullFaceFront=2;/**
	 * Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm.
	 *
	 * @type {number}
	 * @constant
	 */const PCFShadowMap=1;/**
	 * Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm with
	 * better soft shadows especially when using low-resolution shadow maps.
	 *
	 * @type {number}
	 * @constant
	 */const PCFSoftShadowMap=2;/**
	 * Filters shadow maps using the Variance Shadow Map (VSM) algorithm.
	 * When using VSMShadowMap all shadow receivers will also cast shadows.
	 *
	 * @type {number}
	 * @constant
	 */const VSMShadowMap=3;/**
	 * Only front faces are rendered.
	 *
	 * @type {number}
	 * @constant
	 */const FrontSide=0;/**
	 * Only back faces are rendered.
	 *
	 * @type {number}
	 * @constant
	 */const BackSide=1;/**
	 * Both front and back faces are rendered.
	 *
	 * @type {number}
	 * @constant
	 */const DoubleSide=2;/**
	 * No blending is performed which effectively disables
	 * alpha transparency.
	 *
	 * @type {number}
	 * @constant
	 */const NoBlending=0;/**
	 * The default blending.
	 *
	 * @type {number}
	 * @constant
	 */const NormalBlending=1;/**
	 * Represents additive blending.
	 *
	 * @type {number}
	 * @constant
	 */const AdditiveBlending=2;/**
	 * Represents subtractive blending.
	 *
	 * @type {number}
	 * @constant
	 */const SubtractiveBlending=3;/**
	 * Represents multiply blending.
	 *
	 * @type {number}
	 * @constant
	 */const MultiplyBlending=4;/**
	 * Represents custom blending.
	 *
	 * @type {number}
	 * @constant
	 */const CustomBlending=5;/**
	 * A `source + destination` blending equation.
	 *
	 * @type {number}
	 * @constant
	 */const AddEquation=100;/**
	 * A `source - destination` blending equation.
	 *
	 * @type {number}
	 * @constant
	 */const SubtractEquation=101;/**
	 * A `destination - source` blending equation.
	 *
	 * @type {number}
	 * @constant
	 */const ReverseSubtractEquation=102;/**
	 * A blend equation that uses the minimum of source and destination.
	 *
	 * @type {number}
	 * @constant
	 */const MinEquation=103;/**
	 * A blend equation that uses the maximum of source and destination.
	 *
	 * @type {number}
	 * @constant
	 */const MaxEquation=104;/**
	 * Multiplies all colors by `0`.
	 *
	 * @type {number}
	 * @constant
	 */const ZeroFactor=200;/**
	 * Multiplies all colors by `1`.
	 *
	 * @type {number}
	 * @constant
	 */const OneFactor=201;/**
	 * Multiplies all colors by the source colors.
	 *
	 * @type {number}
	 * @constant
	 */const SrcColorFactor=202;/**
	 * Multiplies all colors by `1` minus each source color.
	 *
	 * @type {number}
	 * @constant
	 */const OneMinusSrcColorFactor=203;/**
	 * Multiplies all colors by the source alpha value.
	 *
	 * @type {number}
	 * @constant
	 */const SrcAlphaFactor=204;/**
	 * Multiplies all colors by 1 minus the source alpha value.
	 *
	 * @type {number}
	 * @constant
	 */const OneMinusSrcAlphaFactor=205;/**
	 * Multiplies all colors by the destination alpha value.
	 *
	 * @type {number}
	 * @constant
	 */const DstAlphaFactor=206;/**
	 * Multiplies all colors by `1` minus the destination alpha value.
	 *
	 * @type {number}
	 * @constant
	 */const OneMinusDstAlphaFactor=207;/**
	 * Multiplies all colors by the destination color.
	 *
	 * @type {number}
	 * @constant
	 */const DstColorFactor=208;/**
	 * Multiplies all colors by `1` minus each destination color.
	 *
	 * @type {number}
	 * @constant
	 */const OneMinusDstColorFactor=209;/**
	 * Multiplies the RGB colors by the smaller of either the source alpha
	 * value or the value of `1` minus the destination alpha value. The alpha
	 * value is multiplied by `1`.
	 *
	 * @type {number}
	 * @constant
	 */const SrcAlphaSaturateFactor=210;/**
	 * Multiplies all colors by a constant color.
	 *
	 * @type {number}
	 * @constant
	 */const ConstantColorFactor=211;/**
	 * Multiplies all colors by `1` minus a constant color.
	 *
	 * @type {number}
	 * @constant
	 */const OneMinusConstantColorFactor=212;/**
	 * Multiplies all colors by a constant alpha value.
	 *
	 * @type {number}
	 * @constant
	 */const ConstantAlphaFactor=213;/**
	 * Multiplies all colors by 1 minus a constant alpha value.
	 *
	 * @type {number}
	 * @constant
	 */const OneMinusConstantAlphaFactor=214;/**
	 * Never pass.
	 *
	 * @type {number}
	 * @constant
	 */const NeverDepth=0;/**
	 * Always pass.
	 *
	 * @type {number}
	 * @constant
	 */const AlwaysDepth=1;/**
	 * Pass if the incoming value is less than the depth buffer value.
	 *
	 * @type {number}
	 * @constant
	 */const LessDepth=2;/**
	 * Pass if the incoming value is less than or equal to the depth buffer value.
	 *
	 * @type {number}
	 * @constant
	 */const LessEqualDepth=3;/**
	 * Pass if the incoming value equals the depth buffer value.
	 *
	 * @type {number}
	 * @constant
	 */const EqualDepth=4;/**
	 * Pass if the incoming value is greater than or equal to the depth buffer value.
	 *
	 * @type {number}
	 * @constant
	 */const GreaterEqualDepth=5;/**
	 * Pass if the incoming value is greater than the depth buffer value.
	 *
	 * @type {number}
	 * @constant
	 */const GreaterDepth=6;/**
	 * Pass if the incoming value is not equal to the depth buffer value.
	 *
	 * @type {number}
	 * @constant
	 */const NotEqualDepth=7;/**
	 * Multiplies the environment map color with the surface color.
	 *
	 * @type {number}
	 * @constant
	 */const MultiplyOperation=0;/**
	 * Uses reflectivity to blend between the two colors.
	 *
	 * @type {number}
	 * @constant
	 */const MixOperation=1;/**
	 * Adds the two colors.
	 *
	 * @type {number}
	 * @constant
	 */const AddOperation=2;/**
	 * No tone mapping is applied.
	 *
	 * @type {number}
	 * @constant
	 */const NoToneMapping=0;/**
	 * Linear tone mapping.
	 *
	 * @type {number}
	 * @constant
	 */const LinearToneMapping=1;/**
	 * Reinhard tone mapping.
	 *
	 * @type {number}
	 * @constant
	 */const ReinhardToneMapping=2;/**
	 * Cineon tone mapping.
	 *
	 * @type {number}
	 * @constant
	 */const CineonToneMapping=3;/**
	 * ACES Filmic tone mapping.
	 *
	 * @type {number}
	 * @constant
	 */const ACESFilmicToneMapping=4;/**
	 * Custom tone mapping.
	 *
	 * Expects a custom implementation by modifying shader code of the material's fragment shader.
	 *
	 * @type {number}
	 * @constant
	 */const CustomToneMapping=5;/**
	 * AgX tone mapping.
	 *
	 * @type {number}
	 * @constant
	 */const AgXToneMapping=6;/**
	 * Neutral tone mapping.
	 *
	 * Implementation based on the Khronos 3D Commerce Group standard tone mapping.
	 *
	 * @type {number}
	 * @constant
	 */const NeutralToneMapping=7;/**
	 * Maps textures using the geometry's UV coordinates.
	 *
	 * @type {number}
	 * @constant
	 */const UVMapping=300;/**
	 * Reflection mapping for cube textures.
	 *
	 * @type {number}
	 * @constant
	 */const CubeReflectionMapping=301;/**
	 * Refraction mapping for cube textures.
	 *
	 * @type {number}
	 * @constant
	 */const CubeRefractionMapping=302;/**
	 * Reflection mapping for equirectangular textures.
	 *
	 * @type {number}
	 * @constant
	 */const EquirectangularReflectionMapping=303;/**
	 * Refraction mapping for equirectangular textures.
	 *
	 * @type {number}
	 * @constant
	 */const EquirectangularRefractionMapping=304;/**
	 * Reflection mapping for PMREM textures.
	 *
	 * @type {number}
	 * @constant
	 */const CubeUVReflectionMapping=306;/**
	 * The texture will simply repeat to infinity.
	 *
	 * @type {number}
	 * @constant
	 */const RepeatWrapping=1000;/**
	 * The last pixel of the texture stretches to the edge of the mesh.
	 *
	 * @type {number}
	 * @constant
	 */const ClampToEdgeWrapping=1001;/**
	 * The texture will repeats to infinity, mirroring on each repeat.
	 *
	 * @type {number}
	 * @constant
	 */const MirroredRepeatWrapping=1002;/**
	 * Returns the value of the texture element that is nearest (in Manhattan distance)
	 * to the specified texture coordinates.
	 *
	 * @type {number}
	 * @constant
	 */const NearestFilter=1003;/**
	 * Chooses the mipmap that most closely matches the size of the pixel being textured
	 * and uses the `NearestFilter` criterion (the texel nearest to the center of the pixel)
	 * to produce a texture value.
	 *
	 * @type {number}
	 * @constant
	 */const NearestMipmapNearestFilter=1004;/**
	 * Chooses the two mipmaps that most closely match the size of the pixel being textured and
	 * uses the `NearestFilter` criterion to produce a texture value from each mipmap.
	 * The final texture value is a weighted average of those two values.
	 *
	 * @type {number}
	 * @constant
	 */const NearestMipmapLinearFilter=1005;/**
	 * Returns the weighted average of the four texture elements that are closest to the specified
	 * texture coordinates, and can include items wrapped or repeated from other parts of a texture,
	 * depending on the values of `wrapS` and `wrapT`, and on the exact mapping.
	 *
	 * @type {number}
	 * @constant
	 */const LinearFilter=1006;/**
	 * Chooses the mipmap that most closely matches the size of the pixel being textured and uses
	 * the `LinearFilter` criterion (a weighted average of the four texels that are closest to the
	 * center of the pixel) to produce a texture value.
	 *
	 * @type {number}
	 * @constant
	 */const LinearMipmapNearestFilter=1007;/**
	 * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses
	 * the `LinearFilter` criterion to produce a texture value from each mipmap. The final texture value
	 * is a weighted average of those two values.
	 *
	 * @type {number}
	 * @constant
	 */const LinearMipmapLinearFilter=1008;/**
	 * An unsigned byte data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */const UnsignedByteType=1009;/**
	 * A byte data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */const ByteType=1010;/**
	 * A short data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */const ShortType=1011;/**
	 * An unsigned short data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */const UnsignedShortType=1012;/**
	 * An int data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */const IntType=1013;/**
	 * An unsigned int data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */const UnsignedIntType=1014;/**
	 * A float data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */const FloatType$1=1015;/**
	 * A half float data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */const HalfFloatType=1016;/**
	 * An unsigned short 4_4_4_4 (packed) data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */const UnsignedShort4444Type=1017;/**
	 * An unsigned short 5_5_5_1 (packed) data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */const UnsignedShort5551Type=1018;/**
	 * An unsigned int 24_8 data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */const UnsignedInt248Type=1020;/**
	 * An unsigned int 5_9_9_9 (packed) data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */const UnsignedInt5999Type=35902;/**
	 * An unsigned int 10_11_11 (packed) data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */const UnsignedInt101111Type=35899;/**
	 * Discards the red, green and blue components and reads just the alpha component.
	 *
	 * @type {number}
	 * @constant
	 */const AlphaFormat=1021;/**
	 * Discards the alpha component and reads the red, green and blue component.
	 *
	 * @type {number}
	 * @constant
	 */const RGBFormat=1022;/**
	 * Reads the red, green, blue and alpha components.
	 *
	 * @type {number}
	 * @constant
	 */const RGBAFormat=1023;/**
	 * Reads each element as a single depth value, converts it to floating point, and clamps to the range `[0,1]`.
	 *
	 * @type {number}
	 * @constant
	 */const DepthFormat=1026;/**
	 * Reads each element is a pair of depth and stencil values. The depth component of the pair is interpreted as
	 * in `DepthFormat`. The stencil component is interpreted based on the depth + stencil internal format.
	 *
	 * @type {number}
	 * @constant
	 */const DepthStencilFormat=1027;/**
	 * Discards the green, blue and alpha components and reads just the red component.
	 *
	 * @type {number}
	 * @constant
	 */const RedFormat=1028;/**
	 * Discards the green, blue and alpha components and reads just the red component. The texels are read as integers instead of floating point.
	 *
	 * @type {number}
	 * @constant
	 */const RedIntegerFormat=1029;/**
	 * Discards the alpha, and blue components and reads the red, and green components.
	 *
	 * @type {number}
	 * @constant
	 */const RGFormat=1030;/**
	 * Discards the alpha, and blue components and reads the red, and green components. The texels are read as integers instead of floating point.
	 *
	 * @type {number}
	 * @constant
	 */const RGIntegerFormat=1031;/**
	 * Reads the red, green, blue and alpha components. The texels are read as integers instead of floating point.
	 *
	 * @type {number}
	 * @constant
	 */const RGBAIntegerFormat=1033;/**
	 * A DXT1-compressed image in an RGB image format.
	 *
	 * @type {number}
	 * @constant
	 */const RGB_S3TC_DXT1_Format=33776;/**
	 * A DXT1-compressed image in an RGB image format with a simple on/off alpha value.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_S3TC_DXT1_Format=33777;/**
	 * A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_S3TC_DXT3_Format=33778;/**
	 * A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3
	 * compression in how the alpha compression is done.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_S3TC_DXT5_Format=33779;/**
	 * PVRTC RGB compression in 4-bit mode. One block for each 4×4 pixels.
	 *
	 * @type {number}
	 * @constant
	 */const RGB_PVRTC_4BPPV1_Format=35840;/**
	 * PVRTC RGB compression in 2-bit mode. One block for each 8×4 pixels.
	 *
	 * @type {number}
	 * @constant
	 */const RGB_PVRTC_2BPPV1_Format=35841;/**
	 * PVRTC RGBA compression in 4-bit mode. One block for each 4×4 pixels.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_PVRTC_4BPPV1_Format=35842;/**
	 * PVRTC RGBA compression in 2-bit mode. One block for each 8×4 pixels.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_PVRTC_2BPPV1_Format=35843;/**
	 * ETC1 RGB format.
	 *
	 * @type {number}
	 * @constant
	 */const RGB_ETC1_Format=36196;/**
	 * ETC2 RGB format.
	 *
	 * @type {number}
	 * @constant
	 */const RGB_ETC2_Format=37492;/**
	 * ETC2 RGBA format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ETC2_EAC_Format=37496;/**
	 * ASTC RGBA 4x4 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_4x4_Format=37808;/**
	 * ASTC RGBA 5x4 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_5x4_Format=37809;/**
	 * ASTC RGBA 5x5 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_5x5_Format=37810;/**
	 * ASTC RGBA 6x5 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_6x5_Format=37811;/**
	 * ASTC RGBA 6x6 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_6x6_Format=37812;/**
	 * ASTC RGBA 8x5 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_8x5_Format=37813;/**
	 * ASTC RGBA 8x6 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_8x6_Format=37814;/**
	 * ASTC RGBA 8x8 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_8x8_Format=37815;/**
	 * ASTC RGBA 10x5 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_10x5_Format=37816;/**
	 * ASTC RGBA 10x6 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_10x6_Format=37817;/**
	 * ASTC RGBA 10x8 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_10x8_Format=37818;/**
	 * ASTC RGBA 10x10 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_10x10_Format=37819;/**
	 * ASTC RGBA 12x10 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_12x10_Format=37820;/**
	 * ASTC RGBA 12x12 format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_ASTC_12x12_Format=37821;/**
	 * BPTC RGBA format.
	 *
	 * @type {number}
	 * @constant
	 */const RGBA_BPTC_Format=36492;/**
	 * BPTC Signed RGB format.
	 *
	 * @type {number}
	 * @constant
	 */const RGB_BPTC_SIGNED_Format=36494;/**
	 * BPTC Unsigned RGB format.
	 *
	 * @type {number}
	 * @constant
	 */const RGB_BPTC_UNSIGNED_Format=36495;/**
	 * RGTC1 Red format.
	 *
	 * @type {number}
	 * @constant
	 */const RED_RGTC1_Format=36283;/**
	 * RGTC1 Signed Red format.
	 *
	 * @type {number}
	 * @constant
	 */const SIGNED_RED_RGTC1_Format=36284;/**
	 * RGTC2 Red Green format.
	 *
	 * @type {number}
	 * @constant
	 */const RED_GREEN_RGTC2_Format=36285;/**
	 * RGTC2 Signed Red Green format.
	 *
	 * @type {number}
	 * @constant
	 */const SIGNED_RED_GREEN_RGTC2_Format=36286;/**
	 * Basic depth packing.
	 *
	 * @type {number}
	 * @constant
	 */const BasicDepthPacking=3200;/**
	 * A depth value is packed into 32 bit RGBA.
	 *
	 * @type {number}
	 * @constant
	 */const RGBADepthPacking=3201;/**
	 * Normal information is relative to the underlying surface.
	 *
	 * @type {number}
	 * @constant
	 */const TangentSpaceNormalMap=0;/**
	 * Normal information is relative to the object orientation.
	 *
	 * @type {number}
	 * @constant
	 */const ObjectSpaceNormalMap=1;// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
	/**
	 * No color space.
	 *
	 * @type {string}
	 * @constant
	 */const NoColorSpace='';/**
	 * sRGB color space.
	 *
	 * @type {string}
	 * @constant
	 */const SRGBColorSpace='srgb';/**
	 * sRGB-linear color space.
	 *
	 * @type {string}
	 * @constant
	 */const LinearSRGBColorSpace='srgb-linear';/**
	 * Linear transfer function.
	 *
	 * @type {string}
	 * @constant
	 */const LinearTransfer='linear';/**
	 * sRGB transfer function.
	 *
	 * @type {string}
	 * @constant
	 */const SRGBTransfer='srgb';/**
	 * Keeps the current value.
	 *
	 * @type {number}
	 * @constant
	 */const KeepStencilOp=7680;/**
	 * Will always return true.
	 *
	 * @type {number}
	 * @constant
	 */const AlwaysStencilFunc=519;/**
	 * Never pass.
	 *
	 * @type {number}
	 * @constant
	 */const NeverCompare=512;/**
	 * Pass if the incoming value is less than the texture value.
	 *
	 * @type {number}
	 * @constant
	 */const LessCompare=513;/**
	 * Pass if the incoming value equals the texture value.
	 *
	 * @type {number}
	 * @constant
	 */const EqualCompare=514;/**
	 * Pass if the incoming value is less than or equal to the texture value.
	 *
	 * @type {number}
	 * @constant
	 */const LessEqualCompare=515;/**
	 * Pass if the incoming value is greater than the texture value.
	 *
	 * @type {number}
	 * @constant
	 */const GreaterCompare=516;/**
	 * Pass if the incoming value is not equal to the texture value.
	 *
	 * @type {number}
	 * @constant
	 */const NotEqualCompare=517;/**
	 * Pass if the incoming value is greater than or equal to the texture value.
	 *
	 * @type {number}
	 * @constant
	 */const GreaterEqualCompare=518;/**
	 * Always pass.
	 *
	 * @type {number}
	 * @constant
	 */const AlwaysCompare=519;/**
	 * The contents are intended to be specified once by the application, and used many
	 * times as the source for drawing and image specification commands.
	 *
	 * @type {number}
	 * @constant
	 */const StaticDrawUsage$1=35044;/**
	 * GLSL 3 shader code.
	 *
	 * @type {string}
	 * @constant
	 */const GLSL3='300 es';/**
	 * WebGL coordinate system.
	 *
	 * @type {number}
	 * @constant
	 */const WebGLCoordinateSystem$1=2000;/**
	 * WebGPU coordinate system.
	 *
	 * @type {number}
	 * @constant
	 */const WebGPUCoordinateSystem$1=2001;/**
	 * This type represents mouse buttons and interaction types in context of controls.
	 *
	 * @typedef {Object} ConstantsMouse
	 * @property {number} MIDDLE - The left mouse button.
	 * @property {number} LEFT - The middle mouse button.
	 * @property {number} RIGHT - The right mouse button.
	 * @property {number} ROTATE - A rotate interaction.
	 * @property {number} DOLLY - A dolly interaction.
	 * @property {number} PAN - A pan interaction.
	 **//**
	 * This type represents touch interaction types in context of controls.
	 *
	 * @typedef {Object} ConstantsTouch
	 * @property {number} ROTATE - A rotate interaction.
	 * @property {number} PAN - A pan interaction.
	 * @property {number} DOLLY_PAN - The dolly-pan interaction.
	 * @property {number} DOLLY_ROTATE - A dolly-rotate interaction.
	 **//**
	 * This type represents the different timestamp query types.
	 *
	 * @typedef {Object} ConstantsTimestampQuery
	 * @property {string} COMPUTE - A `compute` timestamp query.
	 * @property {string} RENDER - A `render` timestamp query.
	 **//**
	 * Represents the different interpolation sampling types.
	 *
	 * @typedef {Object} ConstantsInterpolationSamplingType
	 * @property {string} PERSPECTIVE - Perspective-correct interpolation.
	 * @property {string} LINEAR - Linear interpolation.
	 * @property {string} FLAT - Flat interpolation.
	 *//**
	 * Represents the different interpolation sampling modes.
	 *
	 * @typedef {Object} ConstantsInterpolationSamplingMode
	 * @property {string} NORMAL - Normal sampling mode.
	 * @property {string} CENTROID - Centroid sampling mode.
	 * @property {string} SAMPLE - Sample-specific sampling mode.
	 * @property {string} FIRST - Flat interpolation using the first vertex.
	 * @property {string} EITHER - Flat interpolation using either vertex.
	 */function arrayNeedsUint32$1(array){// assumes larger values usually on last
	for(let i=array.length-1;i>=0;--i){if(array[i]>=65535)return true;// account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
	}return false;}function createElementNS(name){return document.createElementNS('http://www.w3.org/1999/xhtml',name);}function createCanvasElement(){const canvas=createElementNS('canvas');canvas.style.display='block';return canvas;}const _cache={};function log(...params){const message='THREE.'+params.shift();{console.log(message,...params);}}function warn$1(...params){const message='THREE.'+params.shift();{console.warn(message,...params);}}function error$1(...params){const message='THREE.'+params.shift();{console.error(message,...params);}}function warnOnce(...params){const message=params.join(' ');if(message in _cache)return;_cache[message]=true;warn$1(...params);}function probeAsync(gl,sync,interval){return new Promise(function(resolve,reject){function probe(){switch(gl.clientWaitSync(sync,gl.SYNC_FLUSH_COMMANDS_BIT,0)){case gl.WAIT_FAILED:reject();break;case gl.TIMEOUT_EXPIRED:setTimeout(probe,interval);break;default:resolve();}}setTimeout(probe,interval);});}/**
	 * This modules allows to dispatch event objects on custom JavaScript objects.
	 *
	 * Main repository: [eventdispatcher.js](https://github.com/mrdoob/eventdispatcher.js/)
	 *
	 * Code Example:
	 * ```js
	 * class Car extends EventDispatcher {
	 * 	start() {
	 *		this.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );
	 *	}
	 *};
	 *
	 * // Using events with the custom object
	 * const car = new Car();
	 * car.addEventListener( 'start', function ( event ) {
	 * 	alert( event.message );
	 * } );
	 *
	 * car.start();
	 * ```
	 */let EventDispatcher$1 = class EventDispatcher{/**
		 * Adds the given event listener to the given event type.
		 *
		 * @param {string} type - The type of event to listen to.
		 * @param {Function} listener - The function that gets called when the event is fired.
		 */addEventListener(type,listener){if(this._listeners===undefined)this._listeners={};const listeners=this._listeners;if(listeners[type]===undefined){listeners[type]=[];}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener);}}/**
		 * Returns `true` if the given event listener has been added to the given event type.
		 *
		 * @param {string} type - The type of event.
		 * @param {Function} listener - The listener to check.
		 * @return {boolean} Whether the given event listener has been added to the given event type.
		 */hasEventListener(type,listener){const listeners=this._listeners;if(listeners===undefined)return false;return listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;}/**
		 * Removes the given event listener from the given event type.
		 *
		 * @param {string} type - The type of event.
		 * @param {Function} listener - The listener to remove.
		 */removeEventListener(type,listener){const listeners=this._listeners;if(listeners===undefined)return;const listenerArray=listeners[type];if(listenerArray!==undefined){const index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1);}}}/**
		 * Dispatches an event object.
		 *
		 * @param {Object} event - The event that gets fired.
		 */dispatchEvent(event){const listeners=this._listeners;if(listeners===undefined)return;const listenerArray=listeners[event.type];if(listenerArray!==undefined){event.target=this;// Make a copy, in case listeners are removed while iterating.
	const array=listenerArray.slice(0);for(let i=0,l=array.length;i<l;i++){array[i].call(this,event);}event.target=null;}}};const _lut$1=['00','01','02','03','04','05','06','07','08','09','0a','0b','0c','0d','0e','0f','10','11','12','13','14','15','16','17','18','19','1a','1b','1c','1d','1e','1f','20','21','22','23','24','25','26','27','28','29','2a','2b','2c','2d','2e','2f','30','31','32','33','34','35','36','37','38','39','3a','3b','3c','3d','3e','3f','40','41','42','43','44','45','46','47','48','49','4a','4b','4c','4d','4e','4f','50','51','52','53','54','55','56','57','58','59','5a','5b','5c','5d','5e','5f','60','61','62','63','64','65','66','67','68','69','6a','6b','6c','6d','6e','6f','70','71','72','73','74','75','76','77','78','79','7a','7b','7c','7d','7e','7f','80','81','82','83','84','85','86','87','88','89','8a','8b','8c','8d','8e','8f','90','91','92','93','94','95','96','97','98','99','9a','9b','9c','9d','9e','9f','a0','a1','a2','a3','a4','a5','a6','a7','a8','a9','aa','ab','ac','ad','ae','af','b0','b1','b2','b3','b4','b5','b6','b7','b8','b9','ba','bb','bc','bd','be','bf','c0','c1','c2','c3','c4','c5','c6','c7','c8','c9','ca','cb','cc','cd','ce','cf','d0','d1','d2','d3','d4','d5','d6','d7','d8','d9','da','db','dc','dd','de','df','e0','e1','e2','e3','e4','e5','e6','e7','e8','e9','ea','eb','ec','ed','ee','ef','f0','f1','f2','f3','f4','f5','f6','f7','f8','f9','fa','fb','fc','fd','fe','ff'];const DEG2RAD=Math.PI/180;const RAD2DEG=180/Math.PI;/**
	 * Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
	 * (universally unique identifier).
	 *
	 * @return {string} The UUID.
	 */function generateUUID$1(){// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
	const d0=Math.random()*0xffffffff|0;const d1=Math.random()*0xffffffff|0;const d2=Math.random()*0xffffffff|0;const d3=Math.random()*0xffffffff|0;const uuid=_lut$1[d0&0xff]+_lut$1[d0>>8&0xff]+_lut$1[d0>>16&0xff]+_lut$1[d0>>24&0xff]+'-'+_lut$1[d1&0xff]+_lut$1[d1>>8&0xff]+'-'+_lut$1[d1>>16&0x0f|0x40]+_lut$1[d1>>24&0xff]+'-'+_lut$1[d2&0x3f|0x80]+_lut$1[d2>>8&0xff]+'-'+_lut$1[d2>>16&0xff]+_lut$1[d2>>24&0xff]+_lut$1[d3&0xff]+_lut$1[d3>>8&0xff]+_lut$1[d3>>16&0xff]+_lut$1[d3>>24&0xff];// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();}/**
	 * Clamps the given value between min and max.
	 *
	 * @param {number} value - The value to clamp.
	 * @param {number} min - The min value.
	 * @param {number} max - The max value.
	 * @return {number} The clamped value.
	 */function clamp$1(value,min,max){return Math.max(min,Math.min(max,value));}/**
	 * Computes the Euclidean modulo of the given parameters that
	 * is `( ( n % m ) + m ) % m`.
	 *
	 * @param {number} n - The first parameter.
	 * @param {number} m - The second parameter.
	 * @return {number} The Euclidean modulo.
	 */function euclideanModulo(n,m){// https://en.wikipedia.org/wiki/Modulo_operation
	return (n%m+m)%m;}/**
	 * Returns a value linearly interpolated from two known points based on the given interval -
	 * `t = 0` will return `x` and `t = 1` will return `y`.
	 *
	 * @param {number} x - The start point
	 * @param {number} y - The end point.
	 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
	 * @return {number} The interpolated value.
	 */function lerp(x,y,t){return (1-t)*x+t*y;}/**
	 * Denormalizes the given value according to the given typed array.
	 *
	 * @param {number} value - The value to denormalize.
	 * @param {TypedArray} array - The typed array that defines the data type of the value.
	 * @return {number} The denormalize (float) value in the range `[0,1]`.
	 */function denormalize$1(value,array){switch(array.constructor){case Float32Array:return value;case Uint32Array:return value/4294967295.0;case Uint16Array:return value/65535.0;case Uint8Array:return value/255.0;case Int32Array:return Math.max(value/2147483647.0,-1);case Int16Array:return Math.max(value/32767.0,-1);case Int8Array:return Math.max(value/127.0,-1);default:throw new Error('Invalid component type.');}}/**
	 * Normalizes the given value according to the given typed array.
	 *
	 * @param {number} value - The float value in the range `[0,1]` to normalize.
	 * @param {TypedArray} array - The typed array that defines the data type of the value.
	 * @return {number} The normalize value.
	 */function normalize$1(value,array){switch(array.constructor){case Float32Array:return value;case Uint32Array:return Math.round(value*4294967295.0);case Uint16Array:return Math.round(value*65535.0);case Uint8Array:return Math.round(value*255.0);case Int32Array:return Math.round(value*2147483647.0);case Int16Array:return Math.round(value*32767.0);case Int8Array:return Math.round(value*127.0);default:throw new Error('Invalid component type.');}}/**
	 * @class
	 * @classdesc A collection of math utility functions.
	 * @hideconstructor
	 */const MathUtils={DEG2RAD:DEG2RAD};/**
	 * Class representing a 2D vector. A 2D vector is an ordered pair of numbers
	 * (labeled x and y), which can be used to represent a number of things, such as:
	 *
	 * - A point in 2D space (i.e. a position on a plane).
	 * - A direction and length across a plane. In three.js the length will
	 * always be the Euclidean distance(straight-line distance) from `(0, 0)` to `(x, y)`
	 * and the direction is also measured from `(0, 0)` towards `(x, y)`.
	 * - Any arbitrary ordered pair of numbers.
	 *
	 * There are other things a 2D vector can be used to represent, such as
	 * momentum vectors, complex numbers and so on, however these are the most
	 * common uses in three.js.
	 *
	 * Iterating through a vector instance will yield its components `(x, y)` in
	 * the corresponding order.
	 * ```js
	 * const a = new THREE.Vector2( 0, 1 );
	 *
	 * //no arguments; will be initialised to (0, 0)
	 * const b = new THREE.Vector2( );
	 *
	 * const d = a.distanceTo( b );
	 * ```
	 */let Vector2$1 = class Vector2{/**
		 * Constructs a new 2D vector.
		 *
		 * @param {number} [x=0] - The x value of this vector.
		 * @param {number} [y=0] - The y value of this vector.
		 */constructor(x=0,y=0){/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */Vector2.prototype.isVector2=true;/**
			 * The x value of this vector.
			 *
			 * @type {number}
			 */this.x=x;/**
			 * The y value of this vector.
			 *
			 * @type {number}
			 */this.y=y;}/**
		 * Alias for {@link Vector2#x}.
		 *
		 * @type {number}
		 */get width(){return this.x;}set width(value){this.x=value;}/**
		 * Alias for {@link Vector2#y}.
		 *
		 * @type {number}
		 */get height(){return this.y;}set height(value){this.y=value;}/**
		 * Sets the vector components.
		 *
		 * @param {number} x - The value of the x component.
		 * @param {number} y - The value of the y component.
		 * @return {Vector2} A reference to this vector.
		 */set(x,y){this.x=x;this.y=y;return this;}/**
		 * Sets the vector components to the same value.
		 *
		 * @param {number} scalar - The value to set for all vector components.
		 * @return {Vector2} A reference to this vector.
		 */setScalar(scalar){this.x=scalar;this.y=scalar;return this;}/**
		 * Sets the vector's x component to the given value
		 *
		 * @param {number} x - The value to set.
		 * @return {Vector2} A reference to this vector.
		 */setX(x){this.x=x;return this;}/**
		 * Sets the vector's y component to the given value
		 *
		 * @param {number} y - The value to set.
		 * @return {Vector2} A reference to this vector.
		 */setY(y){this.y=y;return this;}/**
		 * Allows to set a vector component with an index.
		 *
		 * @param {number} index - The component index. `0` equals to x, `1` equals to y.
		 * @param {number} value - The value to set.
		 * @return {Vector2} A reference to this vector.
		 */setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error('index is out of range: '+index);}return this;}/**
		 * Returns the value of the vector component which matches the given index.
		 *
		 * @param {number} index - The component index. `0` equals to x, `1` equals to y.
		 * @return {number} A vector component value.
		 */getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error('index is out of range: '+index);}}/**
		 * Returns a new vector with copied values from this instance.
		 *
		 * @return {Vector2} A clone of this instance.
		 */clone(){return new this.constructor(this.x,this.y);}/**
		 * Copies the values of the given vector to this instance.
		 *
		 * @param {Vector2} v - The vector to copy.
		 * @return {Vector2} A reference to this vector.
		 */copy(v){this.x=v.x;this.y=v.y;return this;}/**
		 * Adds the given vector to this instance.
		 *
		 * @param {Vector2} v - The vector to add.
		 * @return {Vector2} A reference to this vector.
		 */add(v){this.x+=v.x;this.y+=v.y;return this;}/**
		 * Adds the given scalar value to all components of this instance.
		 *
		 * @param {number} s - The scalar to add.
		 * @return {Vector2} A reference to this vector.
		 */addScalar(s){this.x+=s;this.y+=s;return this;}/**
		 * Adds the given vectors and stores the result in this instance.
		 *
		 * @param {Vector2} a - The first vector.
		 * @param {Vector2} b - The second vector.
		 * @return {Vector2} A reference to this vector.
		 */addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this;}/**
		 * Adds the given vector scaled by the given factor to this instance.
		 *
		 * @param {Vector2} v - The vector.
		 * @param {number} s - The factor that scales `v`.
		 * @return {Vector2} A reference to this vector.
		 */addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;return this;}/**
		 * Subtracts the given vector from this instance.
		 *
		 * @param {Vector2} v - The vector to subtract.
		 * @return {Vector2} A reference to this vector.
		 */sub(v){this.x-=v.x;this.y-=v.y;return this;}/**
		 * Subtracts the given scalar value from all components of this instance.
		 *
		 * @param {number} s - The scalar to subtract.
		 * @return {Vector2} A reference to this vector.
		 */subScalar(s){this.x-=s;this.y-=s;return this;}/**
		 * Subtracts the given vectors and stores the result in this instance.
		 *
		 * @param {Vector2} a - The first vector.
		 * @param {Vector2} b - The second vector.
		 * @return {Vector2} A reference to this vector.
		 */subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this;}/**
		 * Multiplies the given vector with this instance.
		 *
		 * @param {Vector2} v - The vector to multiply.
		 * @return {Vector2} A reference to this vector.
		 */multiply(v){this.x*=v.x;this.y*=v.y;return this;}/**
		 * Multiplies the given scalar value with all components of this instance.
		 *
		 * @param {number} scalar - The scalar to multiply.
		 * @return {Vector2} A reference to this vector.
		 */multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;return this;}/**
		 * Divides this instance by the given vector.
		 *
		 * @param {Vector2} v - The vector to divide.
		 * @return {Vector2} A reference to this vector.
		 */divide(v){this.x/=v.x;this.y/=v.y;return this;}/**
		 * Divides this vector by the given scalar.
		 *
		 * @param {number} scalar - The scalar to divide.
		 * @return {Vector2} A reference to this vector.
		 */divideScalar(scalar){return this.multiplyScalar(1/scalar);}/**
		 * Multiplies this vector (with an implicit 1 as the 3rd component) by
		 * the given 3x3 matrix.
		 *
		 * @param {Matrix3} m - The matrix to apply.
		 * @return {Vector2} A reference to this vector.
		 */applyMatrix3(m){const x=this.x,y=this.y;const e=m.elements;this.x=e[0]*x+e[3]*y+e[6];this.y=e[1]*x+e[4]*y+e[7];return this;}/**
		 * If this vector's x or y value is greater than the given vector's x or y
		 * value, replace that value with the corresponding min value.
		 *
		 * @param {Vector2} v - The vector.
		 * @return {Vector2} A reference to this vector.
		 */min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this;}/**
		 * If this vector's x or y value is less than the given vector's x or y
		 * value, replace that value with the corresponding max value.
		 *
		 * @param {Vector2} v - The vector.
		 * @return {Vector2} A reference to this vector.
		 */max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this;}/**
		 * If this vector's x or y value is greater than the max vector's x or y
		 * value, it is replaced by the corresponding value.
		 * If this vector's x or y value is less than the min vector's x or y value,
		 * it is replaced by the corresponding value.
		 *
		 * @param {Vector2} min - The minimum x and y values.
		 * @param {Vector2} max - The maximum x and y values in the desired range.
		 * @return {Vector2} A reference to this vector.
		 */clamp(min,max){// assumes min < max, componentwise
	this.x=clamp$1(this.x,min.x,max.x);this.y=clamp$1(this.y,min.y,max.y);return this;}/**
		 * If this vector's x or y values are greater than the max value, they are
		 * replaced by the max value.
		 * If this vector's x or y values are less than the min value, they are
		 * replaced by the min value.
		 *
		 * @param {number} minVal - The minimum value the components will be clamped to.
		 * @param {number} maxVal - The maximum value the components will be clamped to.
		 * @return {Vector2} A reference to this vector.
		 */clampScalar(minVal,maxVal){this.x=clamp$1(this.x,minVal,maxVal);this.y=clamp$1(this.y,minVal,maxVal);return this;}/**
		 * If this vector's length is greater than the max value, it is replaced by
		 * the max value.
		 * If this vector's length is less than the min value, it is replaced by the
		 * min value.
		 *
		 * @param {number} min - The minimum value the vector length will be clamped to.
		 * @param {number} max - The maximum value the vector length will be clamped to.
		 * @return {Vector2} A reference to this vector.
		 */clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(clamp$1(length,min,max));}/**
		 * The components of this vector are rounded down to the nearest integer value.
		 *
		 * @return {Vector2} A reference to this vector.
		 */floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this;}/**
		 * The components of this vector are rounded up to the nearest integer value.
		 *
		 * @return {Vector2} A reference to this vector.
		 */ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this;}/**
		 * The components of this vector are rounded to the nearest integer value
		 *
		 * @return {Vector2} A reference to this vector.
		 */round(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this;}/**
		 * The components of this vector are rounded towards zero (up if negative,
		 * down if positive) to an integer value.
		 *
		 * @return {Vector2} A reference to this vector.
		 */roundToZero(){this.x=Math.trunc(this.x);this.y=Math.trunc(this.y);return this;}/**
		 * Inverts this vector - i.e. sets x = -x and y = -y.
		 *
		 * @return {Vector2} A reference to this vector.
		 */negate(){this.x=-this.x;this.y=-this.y;return this;}/**
		 * Calculates the dot product of the given vector with this instance.
		 *
		 * @param {Vector2} v - The vector to compute the dot product with.
		 * @return {number} The result of the dot product.
		 */dot(v){return this.x*v.x+this.y*v.y;}/**
		 * Calculates the cross product of the given vector with this instance.
		 *
		 * @param {Vector2} v - The vector to compute the cross product with.
		 * @return {number} The result of the cross product.
		 */cross(v){return this.x*v.y-this.y*v.x;}/**
		 * Computes the square of the Euclidean length (straight-line length) from
		 * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
		 * compare the length squared instead as it is slightly more efficient to calculate.
		 *
		 * @return {number} The square length of this vector.
		 */lengthSq(){return this.x*this.x+this.y*this.y;}/**
		 * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
		 *
		 * @return {number} The length of this vector.
		 */length(){return Math.sqrt(this.x*this.x+this.y*this.y);}/**
		 * Computes the Manhattan length of this vector.
		 *
		 * @return {number} The length of this vector.
		 */manhattanLength(){return Math.abs(this.x)+Math.abs(this.y);}/**
		 * Converts this vector to a unit vector - that is, sets it equal to a vector
		 * with the same direction as this one, but with a vector length of `1`.
		 *
		 * @return {Vector2} A reference to this vector.
		 */normalize(){return this.divideScalar(this.length()||1);}/**
		 * Computes the angle in radians of this vector with respect to the positive x-axis.
		 *
		 * @return {number} The angle in radians.
		 */angle(){const angle=Math.atan2(-this.y,-this.x)+Math.PI;return angle;}/**
		 * Returns the angle between the given vector and this instance in radians.
		 *
		 * @param {Vector2} v - The vector to compute the angle with.
		 * @return {number} The angle in radians.
		 */angleTo(v){const denominator=Math.sqrt(this.lengthSq()*v.lengthSq());if(denominator===0)return Math.PI/2;const theta=this.dot(v)/denominator;// clamp, to handle numerical problems
	return Math.acos(clamp$1(theta,-1,1));}/**
		 * Computes the distance from the given vector to this instance.
		 *
		 * @param {Vector2} v - The vector to compute the distance to.
		 * @return {number} The distance.
		 */distanceTo(v){return Math.sqrt(this.distanceToSquared(v));}/**
		 * Computes the squared distance from the given vector to this instance.
		 * If you are just comparing the distance with another distance, you should compare
		 * the distance squared instead as it is slightly more efficient to calculate.
		 *
		 * @param {Vector2} v - The vector to compute the squared distance to.
		 * @return {number} The squared distance.
		 */distanceToSquared(v){const dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy;}/**
		 * Computes the Manhattan distance from the given vector to this instance.
		 *
		 * @param {Vector2} v - The vector to compute the Manhattan distance to.
		 * @return {number} The Manhattan distance.
		 */manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y);}/**
		 * Sets this vector to a vector with the same direction as this one, but
		 * with the specified length.
		 *
		 * @param {number} length - The new length of this vector.
		 * @return {Vector2} A reference to this vector.
		 */setLength(length){return this.normalize().multiplyScalar(length);}/**
		 * Linearly interpolates between the given vector and this instance, where
		 * alpha is the percent distance along the line - alpha = 0 will be this
		 * vector, and alpha = 1 will be the given one.
		 *
		 * @param {Vector2} v - The vector to interpolate towards.
		 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
		 * @return {Vector2} A reference to this vector.
		 */lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;return this;}/**
		 * Linearly interpolates between the given vectors, where alpha is the percent
		 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
		 * be the second one. The result is stored in this instance.
		 *
		 * @param {Vector2} v1 - The first vector.
		 * @param {Vector2} v2 - The second vector.
		 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
		 * @return {Vector2} A reference to this vector.
		 */lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;return this;}/**
		 * Returns `true` if this vector is equal with the given one.
		 *
		 * @param {Vector2} v - The vector to test for equality.
		 * @return {boolean} Whether this vector is equal with the given one.
		 */equals(v){return v.x===this.x&&v.y===this.y;}/**
		 * Sets this vector's x value to be `array[ offset ]` and y
		 * value to be `array[ offset + 1 ]`.
		 *
		 * @param {Array<number>} array - An array holding the vector component values.
		 * @param {number} [offset=0] - The offset into the array.
		 * @return {Vector2} A reference to this vector.
		 */fromArray(array,offset=0){this.x=array[offset];this.y=array[offset+1];return this;}/**
		 * Writes the components of this vector to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the vector components.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The vector components.
		 */toArray(array=[],offset=0){array[offset]=this.x;array[offset+1]=this.y;return array;}/**
		 * Sets the components of this vector from the given buffer attribute.
		 *
		 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
		 * @param {number} index - The index into the attribute.
		 * @return {Vector2} A reference to this vector.
		 */fromBufferAttribute(attribute,index){this.x=attribute.getX(index);this.y=attribute.getY(index);return this;}/**
		 * Rotates this vector around the given center by the given angle.
		 *
		 * @param {Vector2} center - The point around which to rotate.
		 * @param {number} angle - The angle to rotate, in radians.
		 * @return {Vector2} A reference to this vector.
		 */rotateAround(center,angle){const c=Math.cos(angle),s=Math.sin(angle);const x=this.x-center.x;const y=this.y-center.y;this.x=x*c-y*s+center.x;this.y=x*s+y*c+center.y;return this;}/**
		 * Sets each component of this vector to a pseudo-random value between `0` and
		 * `1`, excluding `1`.
		 *
		 * @return {Vector2} A reference to this vector.
		 */random(){this.x=Math.random();this.y=Math.random();return this;}*[Symbol.iterator](){yield this.x;yield this.y;}};/**
	 * Class for representing a Quaternion. Quaternions are used in three.js to represent rotations.
	 *
	 * Iterating through a vector instance will yield its components `(x, y, z, w)` in
	 * the corresponding order.
	 *
	 * Note that three.js expects Quaternions to be normalized.
	 * ```js
	 * const quaternion = new THREE.Quaternion();
	 * quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
	 *
	 * const vector = new THREE.Vector3( 1, 0, 0 );
	 * vector.applyQuaternion( quaternion );
	 * ```
	 */let Quaternion$1 = class Quaternion{/**
		 * Constructs a new quaternion.
		 *
		 * @param {number} [x=0] - The x value of this quaternion.
		 * @param {number} [y=0] - The y value of this quaternion.
		 * @param {number} [z=0] - The z value of this quaternion.
		 * @param {number} [w=1] - The w value of this quaternion.
		 */constructor(x=0,y=0,z=0,w=1){/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isQuaternion=true;this._x=x;this._y=y;this._z=z;this._w=w;}/**
		 * Interpolates between two quaternions via SLERP. This implementation assumes the
		 * quaternion data are managed in flat arrays.
		 *
		 * @param {Array<number>} dst - The destination array.
		 * @param {number} dstOffset - An offset into the destination array.
		 * @param {Array<number>} src0 - The source array of the first quaternion.
		 * @param {number} srcOffset0 - An offset into the first source array.
		 * @param {Array<number>} src1 -  The source array of the second quaternion.
		 * @param {number} srcOffset1 - An offset into the second source array.
		 * @param {number} t - The interpolation factor in the range `[0,1]`.
		 * @see {@link Quaternion#slerp}
		 */static slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){let x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3];let x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(t<=0){dst[dstOffset+0]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;return;}if(t>=1){dst[dstOffset+0]=x1;dst[dstOffset+1]=y1;dst[dstOffset+2]=z1;dst[dstOffset+3]=w1;return;}if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){let dot=x0*x1+y0*y1+z0*z1+w0*w1;if(dot<0){x1=-x1;y1=-y1;z1=-z1;w1=-w1;dot=-dot;}let s=1-t;if(dot<0.9995){// slerp
	const theta=Math.acos(dot);const sin=Math.sin(theta);s=Math.sin(s*theta)/sin;t=Math.sin(t*theta)/sin;x0=x0*s+x1*t;y0=y0*s+y1*t;z0=z0*s+z1*t;w0=w0*s+w1*t;}else {// for small angles, lerp then normalize
	x0=x0*s+x1*t;y0=y0*s+y1*t;z0=z0*s+z1*t;w0=w0*s+w1*t;const f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f;y0*=f;z0*=f;w0*=f;}}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;}/**
		 * Multiplies two quaternions. This implementation assumes the quaternion data are managed
		 * in flat arrays.
		 *
		 * @param {Array<number>} dst - The destination array.
		 * @param {number} dstOffset - An offset into the destination array.
		 * @param {Array<number>} src0 - The source array of the first quaternion.
		 * @param {number} srcOffset0 - An offset into the first source array.
		 * @param {Array<number>} src1 -  The source array of the second quaternion.
		 * @param {number} srcOffset1 - An offset into the second source array.
		 * @return {Array<number>} The destination array.
		 * @see {@link Quaternion#multiplyQuaternions}.
		 */static multiplyQuaternionsFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1){const x0=src0[srcOffset0];const y0=src0[srcOffset0+1];const z0=src0[srcOffset0+2];const w0=src0[srcOffset0+3];const x1=src1[srcOffset1];const y1=src1[srcOffset1+1];const z1=src1[srcOffset1+2];const w1=src1[srcOffset1+3];dst[dstOffset]=x0*w1+w0*x1+y0*z1-z0*y1;dst[dstOffset+1]=y0*w1+w0*y1+z0*x1-x0*z1;dst[dstOffset+2]=z0*w1+w0*z1+x0*y1-y0*x1;dst[dstOffset+3]=w0*w1-x0*x1-y0*y1-z0*z1;return dst;}/**
		 * The x value of this quaternion.
		 *
		 * @type {number}
		 * @default 0
		 */get x(){return this._x;}set x(value){this._x=value;this._onChangeCallback();}/**
		 * The y value of this quaternion.
		 *
		 * @type {number}
		 * @default 0
		 */get y(){return this._y;}set y(value){this._y=value;this._onChangeCallback();}/**
		 * The z value of this quaternion.
		 *
		 * @type {number}
		 * @default 0
		 */get z(){return this._z;}set z(value){this._z=value;this._onChangeCallback();}/**
		 * The w value of this quaternion.
		 *
		 * @type {number}
		 * @default 1
		 */get w(){return this._w;}set w(value){this._w=value;this._onChangeCallback();}/**
		 * Sets the quaternion components.
		 *
		 * @param {number} x - The x value of this quaternion.
		 * @param {number} y - The y value of this quaternion.
		 * @param {number} z - The z value of this quaternion.
		 * @param {number} w - The w value of this quaternion.
		 * @return {Quaternion} A reference to this quaternion.
		 */set(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this._onChangeCallback();return this;}/**
		 * Returns a new quaternion with copied values from this instance.
		 *
		 * @return {Quaternion} A clone of this instance.
		 */clone(){return new this.constructor(this._x,this._y,this._z,this._w);}/**
		 * Copies the values of the given quaternion to this instance.
		 *
		 * @param {Quaternion} quaternion - The quaternion to copy.
		 * @return {Quaternion} A reference to this quaternion.
		 */copy(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this._onChangeCallback();return this;}/**
		 * Sets this quaternion from the rotation specified by the given
		 * Euler angles.
		 *
		 * @param {Euler} euler - The Euler angles.
		 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
		 * @return {Quaternion} A reference to this quaternion.
		 */setFromEuler(euler,update=true){const x=euler._x,y=euler._y,z=euler._z,order=euler._order;// http://www.mathworks.com/matlabcentral/fileexchange/
	// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
	//	content/SpinCalc.m
	const cos=Math.cos;const sin=Math.sin;const c1=cos(x/2);const c2=cos(y/2);const c3=cos(z/2);const s1=sin(x/2);const s2=sin(y/2);const s3=sin(z/2);switch(order){case 'XYZ':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case 'YXZ':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;case 'ZXY':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case 'ZYX':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;case 'YZX':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case 'XZY':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;default:warn$1('Quaternion: .setFromEuler() encountered an unknown order: '+order);}if(update===true)this._onChangeCallback();return this;}/**
		 * Sets this quaternion from the given axis and angle.
		 *
		 * @param {Vector3} axis - The normalized axis.
		 * @param {number} angle - The angle in radians.
		 * @return {Quaternion} A reference to this quaternion.
		 */setFromAxisAngle(axis,angle){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	const halfAngle=angle/2,s=Math.sin(halfAngle);this._x=axis.x*s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(halfAngle);this._onChangeCallback();return this;}/**
		 * Sets this quaternion from the given rotation matrix.
		 *
		 * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
		 * @return {Quaternion} A reference to this quaternion.
		 */setFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	const te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33;if(trace>0){const s=0.5/Math.sqrt(trace+1.0);this._w=0.25/s;this._x=(m32-m23)*s;this._y=(m13-m31)*s;this._z=(m21-m12)*s;}else if(m11>m22&&m11>m33){const s=2.0*Math.sqrt(1.0+m11-m22-m33);this._w=(m32-m23)/s;this._x=0.25*s;this._y=(m12+m21)/s;this._z=(m13+m31)/s;}else if(m22>m33){const s=2.0*Math.sqrt(1.0+m22-m11-m33);this._w=(m13-m31)/s;this._x=(m12+m21)/s;this._y=0.25*s;this._z=(m23+m32)/s;}else {const s=2.0*Math.sqrt(1.0+m33-m11-m22);this._w=(m21-m12)/s;this._x=(m13+m31)/s;this._y=(m23+m32)/s;this._z=0.25*s;}this._onChangeCallback();return this;}/**
		 * Sets this quaternion to the rotation required to rotate the direction vector
		 * `vFrom` to the direction vector `vTo`.
		 *
		 * @param {Vector3} vFrom - The first (normalized) direction vector.
		 * @param {Vector3} vTo - The second (normalized) direction vector.
		 * @return {Quaternion} A reference to this quaternion.
		 */setFromUnitVectors(vFrom,vTo){// assumes direction vectors vFrom and vTo are normalized
	let r=vFrom.dot(vTo)+1;if(r<1e-8){// the epsilon value has been discussed in #31286
	// vFrom and vTo point in opposite directions
	r=0;if(Math.abs(vFrom.x)>Math.abs(vFrom.z)){this._x=-vFrom.y;this._y=vFrom.x;this._z=0;this._w=r;}else {this._x=0;this._y=-vFrom.z;this._z=vFrom.y;this._w=r;}}else {// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
	this._x=vFrom.y*vTo.z-vFrom.z*vTo.y;this._y=vFrom.z*vTo.x-vFrom.x*vTo.z;this._z=vFrom.x*vTo.y-vFrom.y*vTo.x;this._w=r;}return this.normalize();}/**
		 * Returns the angle between this quaternion and the given one in radians.
		 *
		 * @param {Quaternion} q - The quaternion to compute the angle with.
		 * @return {number} The angle in radians.
		 */angleTo(q){return 2*Math.acos(Math.abs(clamp$1(this.dot(q),-1,1)));}/**
		 * Rotates this quaternion by a given angular step to the given quaternion.
		 * The method ensures that the final quaternion will not overshoot `q`.
		 *
		 * @param {Quaternion} q - The target quaternion.
		 * @param {number} step - The angular step in radians.
		 * @return {Quaternion} A reference to this quaternion.
		 */rotateTowards(q,step){const angle=this.angleTo(q);if(angle===0)return this;const t=Math.min(1,step/angle);this.slerp(q,t);return this;}/**
		 * Sets this quaternion to the identity quaternion; that is, to the
		 * quaternion that represents "no rotation".
		 *
		 * @return {Quaternion} A reference to this quaternion.
		 */identity(){return this.set(0,0,0,1);}/**
		 * Inverts this quaternion via {@link Quaternion#conjugate}. The
		 * quaternion is assumed to have unit length.
		 *
		 * @return {Quaternion} A reference to this quaternion.
		 */invert(){return this.conjugate();}/**
		 * Returns the rotational conjugate of this quaternion. The conjugate of a
		 * quaternion represents the same rotation in the opposite direction about
		 * the rotational axis.
		 *
		 * @return {Quaternion} A reference to this quaternion.
		 */conjugate(){this._x*=-1;this._y*=-1;this._z*=-1;this._onChangeCallback();return this;}/**
		 * Calculates the dot product of this quaternion and the given one.
		 *
		 * @param {Quaternion} v - The quaternion to compute the dot product with.
		 * @return {number} The result of the dot product.
		 */dot(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;}/**
		 * Computes the squared Euclidean length (straight-line length) of this quaternion,
		 * considered as a 4 dimensional vector. This can be useful if you are comparing the
		 * lengths of two quaternions, as this is a slightly more efficient calculation than
		 * {@link Quaternion#length}.
		 *
		 * @return {number} The squared Euclidean length.
		 */lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;}/**
		 * Computes the Euclidean length (straight-line length) of this quaternion,
		 * considered as a 4 dimensional vector.
		 *
		 * @return {number} The Euclidean length.
		 */length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);}/**
		 * Normalizes this quaternion - that is, calculated the quaternion that performs
		 * the same rotation as this one, but has a length equal to `1`.
		 *
		 * @return {Quaternion} A reference to this quaternion.
		 */normalize(){let l=this.length();if(l===0){this._x=0;this._y=0;this._z=0;this._w=1;}else {l=1/l;this._x=this._x*l;this._y=this._y*l;this._z=this._z*l;this._w=this._w*l;}this._onChangeCallback();return this;}/**
		 * Multiplies this quaternion by the given one.
		 *
		 * @param {Quaternion} q - The quaternion.
		 * @return {Quaternion} A reference to this quaternion.
		 */multiply(q){return this.multiplyQuaternions(this,q);}/**
		 * Pre-multiplies this quaternion by the given one.
		 *
		 * @param {Quaternion} q - The quaternion.
		 * @return {Quaternion} A reference to this quaternion.
		 */premultiply(q){return this.multiplyQuaternions(q,this);}/**
		 * Multiplies the given quaternions and stores the result in this instance.
		 *
		 * @param {Quaternion} a - The first quaternion.
		 * @param {Quaternion} b - The second quaternion.
		 * @return {Quaternion} A reference to this quaternion.
		 */multiplyQuaternions(a,b){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	const qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;const qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;this._onChangeCallback();return this;}/**
		 * Performs a spherical linear interpolation between quaternions.
		 *
		 * @param {Quaternion} qb - The target quaternion.
		 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
		 * @return {Quaternion} A reference to this quaternion.
		 */slerp(qb,t){if(t<=0)return this;if(t>=1)return this.copy(qb);// copy calls _onChangeCallback()
	let x=qb._x,y=qb._y,z=qb._z,w=qb._w;let dot=this.dot(qb);if(dot<0){x=-x;y=-y;z=-z;w=-w;dot=-dot;}let s=1-t;if(dot<0.9995){// slerp
	const theta=Math.acos(dot);const sin=Math.sin(theta);s=Math.sin(s*theta)/sin;t=Math.sin(t*theta)/sin;this._x=this._x*s+x*t;this._y=this._y*s+y*t;this._z=this._z*s+z*t;this._w=this._w*s+w*t;this._onChangeCallback();}else {// for small angles, lerp then normalize
	this._x=this._x*s+x*t;this._y=this._y*s+y*t;this._z=this._z*s+z*t;this._w=this._w*s+w*t;this.normalize();// normalize calls _onChangeCallback()
	}return this;}/**
		 * Performs a spherical linear interpolation between the given quaternions
		 * and stores the result in this quaternion.
		 *
		 * @param {Quaternion} qa - The source quaternion.
		 * @param {Quaternion} qb - The target quaternion.
		 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
		 * @return {Quaternion} A reference to this quaternion.
		 */slerpQuaternions(qa,qb,t){return this.copy(qa).slerp(qb,t);}/**
		 * Sets this quaternion to a uniformly random, normalized quaternion.
		 *
		 * @return {Quaternion} A reference to this quaternion.
		 */random(){// Ken Shoemake
	// Uniform random rotations
	// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.
	const theta1=2*Math.PI*Math.random();const theta2=2*Math.PI*Math.random();const x0=Math.random();const r1=Math.sqrt(1-x0);const r2=Math.sqrt(x0);return this.set(r1*Math.sin(theta1),r1*Math.cos(theta1),r2*Math.sin(theta2),r2*Math.cos(theta2));}/**
		 * Returns `true` if this quaternion is equal with the given one.
		 *
		 * @param {Quaternion} quaternion - The quaternion to test for equality.
		 * @return {boolean} Whether this quaternion is equal with the given one.
		 */equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;}/**
		 * Sets this quaternion's components from the given array.
		 *
		 * @param {Array<number>} array - An array holding the quaternion component values.
		 * @param {number} [offset=0] - The offset into the array.
		 * @return {Quaternion} A reference to this quaternion.
		 */fromArray(array,offset=0){this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this._onChangeCallback();return this;}/**
		 * Writes the components of this quaternion to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The quaternion components.
		 */toArray(array=[],offset=0){array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array;}/**
		 * Sets the components of this quaternion from the given buffer attribute.
		 *
		 * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
		 * @param {number} index - The index into the attribute.
		 * @return {Quaternion} A reference to this quaternion.
		 */fromBufferAttribute(attribute,index){this._x=attribute.getX(index);this._y=attribute.getY(index);this._z=attribute.getZ(index);this._w=attribute.getW(index);this._onChangeCallback();return this;}/**
		 * This methods defines the serialization result of this class. Returns the
		 * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
		 *
		 * @return {Array<number>} The serialized quaternion.
		 */toJSON(){return this.toArray();}_onChange(callback){this._onChangeCallback=callback;return this;}_onChangeCallback(){}*[Symbol.iterator](){yield this._x;yield this._y;yield this._z;yield this._w;}};/**
	 * Class representing a 3D vector. A 3D vector is an ordered triplet of numbers
	 * (labeled x, y and z), which can be used to represent a number of things, such as:
	 *
	 * - A point in 3D space.
	 * - A direction and length in 3D space. In three.js the length will
	 * always be the Euclidean distance(straight-line distance) from `(0, 0, 0)` to `(x, y, z)`
	 * and the direction is also measured from `(0, 0, 0)` towards `(x, y, z)`.
	 * - Any arbitrary ordered triplet of numbers.
	 *
	 * There are other things a 3D vector can be used to represent, such as
	 * momentum vectors and so on, however these are the most
	 * common uses in three.js.
	 *
	 * Iterating through a vector instance will yield its components `(x, y, z)` in
	 * the corresponding order.
	 * ```js
	 * const a = new THREE.Vector3( 0, 1, 0 );
	 *
	 * //no arguments; will be initialised to (0, 0, 0)
	 * const b = new THREE.Vector3( );
	 *
	 * const d = a.distanceTo( b );
	 * ```
	 */let Vector3$1 = class Vector3{/**
		 * Constructs a new 3D vector.
		 *
		 * @param {number} [x=0] - The x value of this vector.
		 * @param {number} [y=0] - The y value of this vector.
		 * @param {number} [z=0] - The z value of this vector.
		 */constructor(x=0,y=0,z=0){/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */Vector3.prototype.isVector3=true;/**
			 * The x value of this vector.
			 *
			 * @type {number}
			 */this.x=x;/**
			 * The y value of this vector.
			 *
			 * @type {number}
			 */this.y=y;/**
			 * The z value of this vector.
			 *
			 * @type {number}
			 */this.z=z;}/**
		 * Sets the vector components.
		 *
		 * @param {number} x - The value of the x component.
		 * @param {number} y - The value of the y component.
		 * @param {number} z - The value of the z component.
		 * @return {Vector3} A reference to this vector.
		 */set(x,y,z){if(z===undefined)z=this.z;// sprite.scale.set(x,y)
	this.x=x;this.y=y;this.z=z;return this;}/**
		 * Sets the vector components to the same value.
		 *
		 * @param {number} scalar - The value to set for all vector components.
		 * @return {Vector3} A reference to this vector.
		 */setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;return this;}/**
		 * Sets the vector's x component to the given value
		 *
		 * @param {number} x - The value to set.
		 * @return {Vector3} A reference to this vector.
		 */setX(x){this.x=x;return this;}/**
		 * Sets the vector's y component to the given value
		 *
		 * @param {number} y - The value to set.
		 * @return {Vector3} A reference to this vector.
		 */setY(y){this.y=y;return this;}/**
		 * Sets the vector's z component to the given value
		 *
		 * @param {number} z - The value to set.
		 * @return {Vector3} A reference to this vector.
		 */setZ(z){this.z=z;return this;}/**
		 * Allows to set a vector component with an index.
		 *
		 * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
		 * @param {number} value - The value to set.
		 * @return {Vector3} A reference to this vector.
		 */setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error('index is out of range: '+index);}return this;}/**
		 * Returns the value of the vector component which matches the given index.
		 *
		 * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
		 * @return {number} A vector component value.
		 */getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error('index is out of range: '+index);}}/**
		 * Returns a new vector with copied values from this instance.
		 *
		 * @return {Vector3} A clone of this instance.
		 */clone(){return new this.constructor(this.x,this.y,this.z);}/**
		 * Copies the values of the given vector to this instance.
		 *
		 * @param {Vector3} v - The vector to copy.
		 * @return {Vector3} A reference to this vector.
		 */copy(v){this.x=v.x;this.y=v.y;this.z=v.z;return this;}/**
		 * Adds the given vector to this instance.
		 *
		 * @param {Vector3} v - The vector to add.
		 * @return {Vector3} A reference to this vector.
		 */add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;}/**
		 * Adds the given scalar value to all components of this instance.
		 *
		 * @param {number} s - The scalar to add.
		 * @return {Vector3} A reference to this vector.
		 */addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this;}/**
		 * Adds the given vectors and stores the result in this instance.
		 *
		 * @param {Vector3} a - The first vector.
		 * @param {Vector3} b - The second vector.
		 * @return {Vector3} A reference to this vector.
		 */addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this;}/**
		 * Adds the given vector scaled by the given factor to this instance.
		 *
		 * @param {Vector3|Vector4} v - The vector.
		 * @param {number} s - The factor that scales `v`.
		 * @return {Vector3} A reference to this vector.
		 */addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;return this;}/**
		 * Subtracts the given vector from this instance.
		 *
		 * @param {Vector3} v - The vector to subtract.
		 * @return {Vector3} A reference to this vector.
		 */sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;}/**
		 * Subtracts the given scalar value from all components of this instance.
		 *
		 * @param {number} s - The scalar to subtract.
		 * @return {Vector3} A reference to this vector.
		 */subScalar(s){this.x-=s;this.y-=s;this.z-=s;return this;}/**
		 * Subtracts the given vectors and stores the result in this instance.
		 *
		 * @param {Vector3} a - The first vector.
		 * @param {Vector3} b - The second vector.
		 * @return {Vector3} A reference to this vector.
		 */subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this;}/**
		 * Multiplies the given vector with this instance.
		 *
		 * @param {Vector3} v - The vector to multiply.
		 * @return {Vector3} A reference to this vector.
		 */multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;return this;}/**
		 * Multiplies the given scalar value with all components of this instance.
		 *
		 * @param {number} scalar - The scalar to multiply.
		 * @return {Vector3} A reference to this vector.
		 */multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;return this;}/**
		 * Multiplies the given vectors and stores the result in this instance.
		 *
		 * @param {Vector3} a - The first vector.
		 * @param {Vector3} b - The second vector.
		 * @return {Vector3} A reference to this vector.
		 */multiplyVectors(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this;}/**
		 * Applies the given Euler rotation to this vector.
		 *
		 * @param {Euler} euler - The Euler angles.
		 * @return {Vector3} A reference to this vector.
		 */applyEuler(euler){return this.applyQuaternion(_quaternion$4.setFromEuler(euler));}/**
		 * Applies a rotation specified by an axis and an angle to this vector.
		 *
		 * @param {Vector3} axis - A normalized vector representing the rotation axis.
		 * @param {number} angle - The angle in radians.
		 * @return {Vector3} A reference to this vector.
		 */applyAxisAngle(axis,angle){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis,angle));}/**
		 * Multiplies this vector with the given 3x3 matrix.
		 *
		 * @param {Matrix3} m - The 3x3 matrix.
		 * @return {Vector3} A reference to this vector.
		 */applyMatrix3(m){const x=this.x,y=this.y,z=this.z;const e=m.elements;this.x=e[0]*x+e[3]*y+e[6]*z;this.y=e[1]*x+e[4]*y+e[7]*z;this.z=e[2]*x+e[5]*y+e[8]*z;return this;}/**
		 * Multiplies this vector by the given normal matrix and normalizes
		 * the result.
		 *
		 * @param {Matrix3} m - The normal matrix.
		 * @return {Vector3} A reference to this vector.
		 */applyNormalMatrix(m){return this.applyMatrix3(m).normalize();}/**
		 * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
		 * divides by perspective.
		 *
		 * @param {Matrix4} m - The matrix to apply.
		 * @return {Vector3} A reference to this vector.
		 */applyMatrix4(m){const x=this.x,y=this.y,z=this.z;const e=m.elements;const w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);this.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w;this.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w;this.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w;return this;}/**
		 * Applies the given Quaternion to this vector.
		 *
		 * @param {Quaternion} q - The Quaternion.
		 * @return {Vector3} A reference to this vector.
		 */applyQuaternion(q){// quaternion q is assumed to have unit length
	const vx=this.x,vy=this.y,vz=this.z;const qx=q.x,qy=q.y,qz=q.z,qw=q.w;// t = 2 * cross( q.xyz, v );
	const tx=2*(qy*vz-qz*vy);const ty=2*(qz*vx-qx*vz);const tz=2*(qx*vy-qy*vx);// v + q.w * t + cross( q.xyz, t );
	this.x=vx+qw*tx+qy*tz-qz*ty;this.y=vy+qw*ty+qz*tx-qx*tz;this.z=vz+qw*tz+qx*ty-qy*tx;return this;}/**
		 * Projects this vector from world space into the camera's normalized
		 * device coordinate (NDC) space.
		 *
		 * @param {Camera} camera - The camera.
		 * @return {Vector3} A reference to this vector.
		 */project(camera){return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);}/**
		 * Unprojects this vector from the camera's normalized device coordinate (NDC)
		 * space into world space.
		 *
		 * @param {Camera} camera - The camera.
		 * @return {Vector3} A reference to this vector.
		 */unproject(camera){return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);}/**
		 * Transforms the direction of this vector by a matrix (the upper left 3 x 3
		 * subset of the given 4x4 matrix and then normalizes the result.
		 *
		 * @param {Matrix4} m - The matrix.
		 * @return {Vector3} A reference to this vector.
		 */transformDirection(m){// input: THREE.Matrix4 affine matrix
	// vector interpreted as a direction
	const x=this.x,y=this.y,z=this.z;const e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z;this.y=e[1]*x+e[5]*y+e[9]*z;this.z=e[2]*x+e[6]*y+e[10]*z;return this.normalize();}/**
		 * Divides this instance by the given vector.
		 *
		 * @param {Vector3} v - The vector to divide.
		 * @return {Vector3} A reference to this vector.
		 */divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this;}/**
		 * Divides this vector by the given scalar.
		 *
		 * @param {number} scalar - The scalar to divide.
		 * @return {Vector3} A reference to this vector.
		 */divideScalar(scalar){return this.multiplyScalar(1/scalar);}/**
		 * If this vector's x, y or z value is greater than the given vector's x, y or z
		 * value, replace that value with the corresponding min value.
		 *
		 * @param {Vector3} v - The vector.
		 * @return {Vector3} A reference to this vector.
		 */min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this;}/**
		 * If this vector's x, y or z value is less than the given vector's x, y or z
		 * value, replace that value with the corresponding max value.
		 *
		 * @param {Vector3} v - The vector.
		 * @return {Vector3} A reference to this vector.
		 */max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this;}/**
		 * If this vector's x, y or z value is greater than the max vector's x, y or z
		 * value, it is replaced by the corresponding value.
		 * If this vector's x, y or z value is less than the min vector's x, y or z value,
		 * it is replaced by the corresponding value.
		 *
		 * @param {Vector3} min - The minimum x, y and z values.
		 * @param {Vector3} max - The maximum x, y and z values in the desired range.
		 * @return {Vector3} A reference to this vector.
		 */clamp(min,max){// assumes min < max, componentwise
	this.x=clamp$1(this.x,min.x,max.x);this.y=clamp$1(this.y,min.y,max.y);this.z=clamp$1(this.z,min.z,max.z);return this;}/**
		 * If this vector's x, y or z values are greater than the max value, they are
		 * replaced by the max value.
		 * If this vector's x, y or z values are less than the min value, they are
		 * replaced by the min value.
		 *
		 * @param {number} minVal - The minimum value the components will be clamped to.
		 * @param {number} maxVal - The maximum value the components will be clamped to.
		 * @return {Vector3} A reference to this vector.
		 */clampScalar(minVal,maxVal){this.x=clamp$1(this.x,minVal,maxVal);this.y=clamp$1(this.y,minVal,maxVal);this.z=clamp$1(this.z,minVal,maxVal);return this;}/**
		 * If this vector's length is greater than the max value, it is replaced by
		 * the max value.
		 * If this vector's length is less than the min value, it is replaced by the
		 * min value.
		 *
		 * @param {number} min - The minimum value the vector length will be clamped to.
		 * @param {number} max - The maximum value the vector length will be clamped to.
		 * @return {Vector3} A reference to this vector.
		 */clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(clamp$1(length,min,max));}/**
		 * The components of this vector are rounded down to the nearest integer value.
		 *
		 * @return {Vector3} A reference to this vector.
		 */floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this;}/**
		 * The components of this vector are rounded up to the nearest integer value.
		 *
		 * @return {Vector3} A reference to this vector.
		 */ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this;}/**
		 * The components of this vector are rounded to the nearest integer value
		 *
		 * @return {Vector3} A reference to this vector.
		 */round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this;}/**
		 * The components of this vector are rounded towards zero (up if negative,
		 * down if positive) to an integer value.
		 *
		 * @return {Vector3} A reference to this vector.
		 */roundToZero(){this.x=Math.trunc(this.x);this.y=Math.trunc(this.y);this.z=Math.trunc(this.z);return this;}/**
		 * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
		 *
		 * @return {Vector3} A reference to this vector.
		 */negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;}/**
		 * Calculates the dot product of the given vector with this instance.
		 *
		 * @param {Vector3} v - The vector to compute the dot product with.
		 * @return {number} The result of the dot product.
		 */dot(v){return this.x*v.x+this.y*v.y+this.z*v.z;}// TODO lengthSquared?
	/**
		 * Computes the square of the Euclidean length (straight-line length) from
		 * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
		 * compare the length squared instead as it is slightly more efficient to calculate.
		 *
		 * @return {number} The square length of this vector.
		 */lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z;}/**
		 * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
		 *
		 * @return {number} The length of this vector.
		 */length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);}/**
		 * Computes the Manhattan length of this vector.
		 *
		 * @return {number} The length of this vector.
		 */manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);}/**
		 * Converts this vector to a unit vector - that is, sets it equal to a vector
		 * with the same direction as this one, but with a vector length of `1`.
		 *
		 * @return {Vector3} A reference to this vector.
		 */normalize(){return this.divideScalar(this.length()||1);}/**
		 * Sets this vector to a vector with the same direction as this one, but
		 * with the specified length.
		 *
		 * @param {number} length - The new length of this vector.
		 * @return {Vector3} A reference to this vector.
		 */setLength(length){return this.normalize().multiplyScalar(length);}/**
		 * Linearly interpolates between the given vector and this instance, where
		 * alpha is the percent distance along the line - alpha = 0 will be this
		 * vector, and alpha = 1 will be the given one.
		 *
		 * @param {Vector3} v - The vector to interpolate towards.
		 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
		 * @return {Vector3} A reference to this vector.
		 */lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this;}/**
		 * Linearly interpolates between the given vectors, where alpha is the percent
		 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
		 * be the second one. The result is stored in this instance.
		 *
		 * @param {Vector3} v1 - The first vector.
		 * @param {Vector3} v2 - The second vector.
		 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
		 * @return {Vector3} A reference to this vector.
		 */lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;return this;}/**
		 * Calculates the cross product of the given vector with this instance.
		 *
		 * @param {Vector3} v - The vector to compute the cross product with.
		 * @return {Vector3} The result of the cross product.
		 */cross(v){return this.crossVectors(this,v);}/**
		 * Calculates the cross product of the given vectors and stores the result
		 * in this instance.
		 *
		 * @param {Vector3} a - The first vector.
		 * @param {Vector3} b - The second vector.
		 * @return {Vector3} A reference to this vector.
		 */crossVectors(a,b){const ax=a.x,ay=a.y,az=a.z;const bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;}/**
		 * Projects this vector onto the given one.
		 *
		 * @param {Vector3} v - The vector to project to.
		 * @return {Vector3} A reference to this vector.
		 */projectOnVector(v){const denominator=v.lengthSq();if(denominator===0)return this.set(0,0,0);const scalar=v.dot(this)/denominator;return this.copy(v).multiplyScalar(scalar);}/**
		 * Projects this vector onto a plane by subtracting this
		 * vector projected onto the plane's normal from this vector.
		 *
		 * @param {Vector3} planeNormal - The plane normal.
		 * @return {Vector3} A reference to this vector.
		 */projectOnPlane(planeNormal){_vector$c.copy(this).projectOnVector(planeNormal);return this.sub(_vector$c);}/**
		 * Reflects this vector off a plane orthogonal to the given normal vector.
		 *
		 * @param {Vector3} normal - The (normalized) normal vector.
		 * @return {Vector3} A reference to this vector.
		 */reflect(normal){return this.sub(_vector$c.copy(normal).multiplyScalar(2*this.dot(normal)));}/**
		 * Returns the angle between the given vector and this instance in radians.
		 *
		 * @param {Vector3} v - The vector to compute the angle with.
		 * @return {number} The angle in radians.
		 */angleTo(v){const denominator=Math.sqrt(this.lengthSq()*v.lengthSq());if(denominator===0)return Math.PI/2;const theta=this.dot(v)/denominator;// clamp, to handle numerical problems
	return Math.acos(clamp$1(theta,-1,1));}/**
		 * Computes the distance from the given vector to this instance.
		 *
		 * @param {Vector3} v - The vector to compute the distance to.
		 * @return {number} The distance.
		 */distanceTo(v){return Math.sqrt(this.distanceToSquared(v));}/**
		 * Computes the squared distance from the given vector to this instance.
		 * If you are just comparing the distance with another distance, you should compare
		 * the distance squared instead as it is slightly more efficient to calculate.
		 *
		 * @param {Vector3} v - The vector to compute the squared distance to.
		 * @return {number} The squared distance.
		 */distanceToSquared(v){const dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz;}/**
		 * Computes the Manhattan distance from the given vector to this instance.
		 *
		 * @param {Vector3} v - The vector to compute the Manhattan distance to.
		 * @return {number} The Manhattan distance.
		 */manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);}/**
		 * Sets the vector components from the given spherical coordinates.
		 *
		 * @param {Spherical} s - The spherical coordinates.
		 * @return {Vector3} A reference to this vector.
		 */setFromSpherical(s){return this.setFromSphericalCoords(s.radius,s.phi,s.theta);}/**
		 * Sets the vector components from the given spherical coordinates.
		 *
		 * @param {number} radius - The radius.
		 * @param {number} phi - The phi angle in radians.
		 * @param {number} theta - The theta angle in radians.
		 * @return {Vector3} A reference to this vector.
		 */setFromSphericalCoords(radius,phi,theta){const sinPhiRadius=Math.sin(phi)*radius;this.x=sinPhiRadius*Math.sin(theta);this.y=Math.cos(phi)*radius;this.z=sinPhiRadius*Math.cos(theta);return this;}/**
		 * Sets the vector components from the given cylindrical coordinates.
		 *
		 * @param {Cylindrical} c - The cylindrical coordinates.
		 * @return {Vector3} A reference to this vector.
		 */setFromCylindrical(c){return this.setFromCylindricalCoords(c.radius,c.theta,c.y);}/**
		 * Sets the vector components from the given cylindrical coordinates.
		 *
		 * @param {number} radius - The radius.
		 * @param {number} theta - The theta angle in radians.
		 * @param {number} y - The y value.
		 * @return {Vector3} A reference to this vector.
		 */setFromCylindricalCoords(radius,theta,y){this.x=radius*Math.sin(theta);this.y=y;this.z=radius*Math.cos(theta);return this;}/**
		 * Sets the vector components to the position elements of the
		 * given transformation matrix.
		 *
		 * @param {Matrix4} m - The 4x4 matrix.
		 * @return {Vector3} A reference to this vector.
		 */setFromMatrixPosition(m){const e=m.elements;this.x=e[12];this.y=e[13];this.z=e[14];return this;}/**
		 * Sets the vector components to the scale elements of the
		 * given transformation matrix.
		 *
		 * @param {Matrix4} m - The 4x4 matrix.
		 * @return {Vector3} A reference to this vector.
		 */setFromMatrixScale(m){const sx=this.setFromMatrixColumn(m,0).length();const sy=this.setFromMatrixColumn(m,1).length();const sz=this.setFromMatrixColumn(m,2).length();this.x=sx;this.y=sy;this.z=sz;return this;}/**
		 * Sets the vector components from the specified matrix column.
		 *
		 * @param {Matrix4} m - The 4x4 matrix.
		 * @param {number} index - The column index.
		 * @return {Vector3} A reference to this vector.
		 */setFromMatrixColumn(m,index){return this.fromArray(m.elements,index*4);}/**
		 * Sets the vector components from the specified matrix column.
		 *
		 * @param {Matrix3} m - The 3x3 matrix.
		 * @param {number} index - The column index.
		 * @return {Vector3} A reference to this vector.
		 */setFromMatrix3Column(m,index){return this.fromArray(m.elements,index*3);}/**
		 * Sets the vector components from the given Euler angles.
		 *
		 * @param {Euler} e - The Euler angles to set.
		 * @return {Vector3} A reference to this vector.
		 */setFromEuler(e){this.x=e._x;this.y=e._y;this.z=e._z;return this;}/**
		 * Sets the vector components from the RGB components of the
		 * given color.
		 *
		 * @param {Color} c - The color to set.
		 * @return {Vector3} A reference to this vector.
		 */setFromColor(c){this.x=c.r;this.y=c.g;this.z=c.b;return this;}/**
		 * Returns `true` if this vector is equal with the given one.
		 *
		 * @param {Vector3} v - The vector to test for equality.
		 * @return {boolean} Whether this vector is equal with the given one.
		 */equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z;}/**
		 * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
		 * and z value to be `array[ offset + 2 ]`.
		 *
		 * @param {Array<number>} array - An array holding the vector component values.
		 * @param {number} [offset=0] - The offset into the array.
		 * @return {Vector3} A reference to this vector.
		 */fromArray(array,offset=0){this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];return this;}/**
		 * Writes the components of this vector to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the vector components.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The vector components.
		 */toArray(array=[],offset=0){array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array;}/**
		 * Sets the components of this vector from the given buffer attribute.
		 *
		 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
		 * @param {number} index - The index into the attribute.
		 * @return {Vector3} A reference to this vector.
		 */fromBufferAttribute(attribute,index){this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);return this;}/**
		 * Sets each component of this vector to a pseudo-random value between `0` and
		 * `1`, excluding `1`.
		 *
		 * @return {Vector3} A reference to this vector.
		 */random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();return this;}/**
		 * Sets this vector to a uniformly random point on a unit sphere.
		 *
		 * @return {Vector3} A reference to this vector.
		 */randomDirection(){// https://mathworld.wolfram.com/SpherePointPicking.html
	const theta=Math.random()*Math.PI*2;const u=Math.random()*2-1;const c=Math.sqrt(1-u*u);this.x=c*Math.cos(theta);this.y=u;this.z=c*Math.sin(theta);return this;}*[Symbol.iterator](){yield this.x;yield this.y;yield this.z;}};const _vector$c=/*@__PURE__*/new Vector3$1();const _quaternion$4=/*@__PURE__*/new Quaternion$1();/**
	 * Represents a 3x3 matrix.
	 *
	 * A Note on Row-Major and Column-Major Ordering:
	 *
	 * The constructor and {@link Matrix3#set} method take arguments in
	 * [row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
	 * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
	 * This means that calling:
	 * ```js
	 * const m = new THREE.Matrix();
	 * m.set( 11, 12, 13,
	 *        21, 22, 23,
	 *        31, 32, 33 );
	 * ```
	 * will result in the elements array containing:
	 * ```js
	 * m.elements = [ 11, 21, 31,
	 *                12, 22, 32,
	 *                13, 23, 33 ];
	 * ```
	 * and internally all calculations are performed using column-major ordering.
	 * However, as the actual ordering makes no difference mathematically and
	 * most people are used to thinking about matrices in row-major order, the
	 * three.js documentation shows matrices in row-major order. Just bear in
	 * mind that if you are reading the source code, you'll have to take the
	 * transpose of any matrices outlined here to make sense of the calculations.
	 */let Matrix3$1 = class Matrix3{/**
		 * Constructs a new 3x3 matrix. The arguments are supposed to be
		 * in row-major order. If no arguments are provided, the constructor
		 * initializes the matrix as an identity matrix.
		 *
		 * @param {number} [n11] - 1-1 matrix element.
		 * @param {number} [n12] - 1-2 matrix element.
		 * @param {number} [n13] - 1-3 matrix element.
		 * @param {number} [n21] - 2-1 matrix element.
		 * @param {number} [n22] - 2-2 matrix element.
		 * @param {number} [n23] - 2-3 matrix element.
		 * @param {number} [n31] - 3-1 matrix element.
		 * @param {number} [n32] - 3-2 matrix element.
		 * @param {number} [n33] - 3-3 matrix element.
		 */constructor(n11,n12,n13,n21,n22,n23,n31,n32,n33){/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */Matrix3.prototype.isMatrix3=true;/**
			 * A column-major list of matrix values.
			 *
			 * @type {Array<number>}
			 */this.elements=[1,0,0,0,1,0,0,0,1];if(n11!==undefined){this.set(n11,n12,n13,n21,n22,n23,n31,n32,n33);}}/**
		 * Sets the elements of the matrix.The arguments are supposed to be
		 * in row-major order.
		 *
		 * @param {number} [n11] - 1-1 matrix element.
		 * @param {number} [n12] - 1-2 matrix element.
		 * @param {number} [n13] - 1-3 matrix element.
		 * @param {number} [n21] - 2-1 matrix element.
		 * @param {number} [n22] - 2-2 matrix element.
		 * @param {number} [n23] - 2-3 matrix element.
		 * @param {number} [n31] - 3-1 matrix element.
		 * @param {number} [n32] - 3-2 matrix element.
		 * @param {number} [n33] - 3-3 matrix element.
		 * @return {Matrix3} A reference to this matrix.
		 */set(n11,n12,n13,n21,n22,n23,n31,n32,n33){const te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this;}/**
		 * Sets this matrix to the 3x3 identity matrix.
		 *
		 * @return {Matrix3} A reference to this matrix.
		 */identity(){this.set(1,0,0,0,1,0,0,0,1);return this;}/**
		 * Copies the values of the given matrix to this instance.
		 *
		 * @param {Matrix3} m - The matrix to copy.
		 * @return {Matrix3} A reference to this matrix.
		 */copy(m){const te=this.elements;const me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];return this;}/**
		 * Extracts the basis of this matrix into the three axis vectors provided.
		 *
		 * @param {Vector3} xAxis - The basis's x axis.
		 * @param {Vector3} yAxis - The basis's y axis.
		 * @param {Vector3} zAxis - The basis's z axis.
		 * @return {Matrix3} A reference to this matrix.
		 */extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrix3Column(this,0);yAxis.setFromMatrix3Column(this,1);zAxis.setFromMatrix3Column(this,2);return this;}/**
		 * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
		 *
		 * @param {Matrix4} m - The 4x4 matrix.
		 * @return {Matrix3} A reference to this matrix.
		 */setFromMatrix4(m){const me=m.elements;this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]);return this;}/**
		 * Post-multiplies this matrix by the given 3x3 matrix.
		 *
		 * @param {Matrix3} m - The matrix to multiply with.
		 * @return {Matrix3} A reference to this matrix.
		 */multiply(m){return this.multiplyMatrices(this,m);}/**
		 * Pre-multiplies this matrix by the given 3x3 matrix.
		 *
		 * @param {Matrix3} m - The matrix to multiply with.
		 * @return {Matrix3} A reference to this matrix.
		 */premultiply(m){return this.multiplyMatrices(m,this);}/**
		 * Multiples the given 3x3 matrices and stores the result
		 * in this matrix.
		 *
		 * @param {Matrix3} a - The first matrix.
		 * @param {Matrix3} b - The second matrix.
		 * @return {Matrix3} A reference to this matrix.
		 */multiplyMatrices(a,b){const ae=a.elements;const be=b.elements;const te=this.elements;const a11=ae[0],a12=ae[3],a13=ae[6];const a21=ae[1],a22=ae[4],a23=ae[7];const a31=ae[2],a32=ae[5],a33=ae[8];const b11=be[0],b12=be[3],b13=be[6];const b21=be[1],b22=be[4],b23=be[7];const b31=be[2],b32=be[5],b33=be[8];te[0]=a11*b11+a12*b21+a13*b31;te[3]=a11*b12+a12*b22+a13*b32;te[6]=a11*b13+a12*b23+a13*b33;te[1]=a21*b11+a22*b21+a23*b31;te[4]=a21*b12+a22*b22+a23*b32;te[7]=a21*b13+a22*b23+a23*b33;te[2]=a31*b11+a32*b21+a33*b31;te[5]=a31*b12+a32*b22+a33*b32;te[8]=a31*b13+a32*b23+a33*b33;return this;}/**
		 * Multiplies every component of the matrix by the given scalar.
		 *
		 * @param {number} s - The scalar.
		 * @return {Matrix3} A reference to this matrix.
		 */multiplyScalar(s){const te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this;}/**
		 * Computes and returns the determinant of this matrix.
		 *
		 * @return {number} The determinant.
		 */determinant(){const te=this.elements;const a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;}/**
		 * Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
		 * You can not invert with a determinant of zero. If you attempt this, the method produces
		 * a zero matrix instead.
		 *
		 * @return {Matrix3} A reference to this matrix.
		 */invert(){const te=this.elements,n11=te[0],n21=te[1],n31=te[2],n12=te[3],n22=te[4],n32=te[5],n13=te[6],n23=te[7],n33=te[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0)return this.set(0,0,0,0,0,0,0,0,0);const detInv=1/det;te[0]=t11*detInv;te[1]=(n31*n23-n33*n21)*detInv;te[2]=(n32*n21-n31*n22)*detInv;te[3]=t12*detInv;te[4]=(n33*n11-n31*n13)*detInv;te[5]=(n31*n12-n32*n11)*detInv;te[6]=t13*detInv;te[7]=(n21*n13-n23*n11)*detInv;te[8]=(n22*n11-n21*n12)*detInv;return this;}/**
		 * Transposes this matrix in place.
		 *
		 * @return {Matrix3} A reference to this matrix.
		 */transpose(){let tmp;const m=this.elements;tmp=m[1];m[1]=m[3];m[3]=tmp;tmp=m[2];m[2]=m[6];m[6]=tmp;tmp=m[5];m[5]=m[7];m[7]=tmp;return this;}/**
		 * Computes the normal matrix which is the inverse transpose of the upper
		 * left 3x3 portion of the given 4x4 matrix.
		 *
		 * @param {Matrix4} matrix4 - The 4x4 matrix.
		 * @return {Matrix3} A reference to this matrix.
		 */getNormalMatrix(matrix4){return this.setFromMatrix4(matrix4).invert().transpose();}/**
		 * Transposes this matrix into the supplied array, and returns itself unchanged.
		 *
		 * @param {Array<number>} r - An array to store the transposed matrix elements.
		 * @return {Matrix3} A reference to this matrix.
		 */transposeIntoArray(r){const m=this.elements;r[0]=m[0];r[1]=m[3];r[2]=m[6];r[3]=m[1];r[4]=m[4];r[5]=m[7];r[6]=m[2];r[7]=m[5];r[8]=m[8];return this;}/**
		 * Sets the UV transform matrix from offset, repeat, rotation, and center.
		 *
		 * @param {number} tx - Offset x.
		 * @param {number} ty - Offset y.
		 * @param {number} sx - Repeat x.
		 * @param {number} sy - Repeat y.
		 * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
		 * @param {number} cx - Center x of rotation.
		 * @param {number} cy - Center y of rotation
		 * @return {Matrix3} A reference to this matrix.
		 */setUvTransform(tx,ty,sx,sy,rotation,cx,cy){const c=Math.cos(rotation);const s=Math.sin(rotation);this.set(sx*c,sx*s,-sx*(c*cx+s*cy)+cx+tx,-sy*s,sy*c,-sy*(-s*cx+c*cy)+cy+ty,0,0,1);return this;}/**
		 * Scales this matrix with the given scalar values.
		 *
		 * @param {number} sx - The amount to scale in the X axis.
		 * @param {number} sy - The amount to scale in the Y axis.
		 * @return {Matrix3} A reference to this matrix.
		 */scale(sx,sy){this.premultiply(_m3$1.makeScale(sx,sy));return this;}/**
		 * Rotates this matrix by the given angle.
		 *
		 * @param {number} theta - The rotation in radians.
		 * @return {Matrix3} A reference to this matrix.
		 */rotate(theta){this.premultiply(_m3$1.makeRotation(-theta));return this;}/**
		 * Translates this matrix by the given scalar values.
		 *
		 * @param {number} tx - The amount to translate in the X axis.
		 * @param {number} ty - The amount to translate in the Y axis.
		 * @return {Matrix3} A reference to this matrix.
		 */translate(tx,ty){this.premultiply(_m3$1.makeTranslation(tx,ty));return this;}// for 2D Transforms
	/**
		 * Sets this matrix as a 2D translation transform.
		 *
		 * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
		 * @param {number} y - The amount to translate in the Y axis.
		 * @return {Matrix3} A reference to this matrix.
		 */makeTranslation(x,y){if(x.isVector2){this.set(1,0,x.x,0,1,x.y,0,0,1);}else {this.set(1,0,x,0,1,y,0,0,1);}return this;}/**
		 * Sets this matrix as a 2D rotational transformation.
		 *
		 * @param {number} theta - The rotation in radians.
		 * @return {Matrix3} A reference to this matrix.
		 */makeRotation(theta){// counterclockwise
	const c=Math.cos(theta);const s=Math.sin(theta);this.set(c,-s,0,s,c,0,0,0,1);return this;}/**
		 * Sets this matrix as a 2D scale transform.
		 *
		 * @param {number} x - The amount to scale in the X axis.
		 * @param {number} y - The amount to scale in the Y axis.
		 * @return {Matrix3} A reference to this matrix.
		 */makeScale(x,y){this.set(x,0,0,0,y,0,0,0,1);return this;}/**
		 * Returns `true` if this matrix is equal with the given one.
		 *
		 * @param {Matrix3} matrix - The matrix to test for equality.
		 * @return {boolean} Whether this matrix is equal with the given one.
		 */equals(matrix){const te=this.elements;const me=matrix.elements;for(let i=0;i<9;i++){if(te[i]!==me[i])return false;}return true;}/**
		 * Sets the elements of the matrix from the given array.
		 *
		 * @param {Array<number>} array - The matrix elements in column-major order.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Matrix3} A reference to this matrix.
		 */fromArray(array,offset=0){for(let i=0;i<9;i++){this.elements[i]=array[i+offset];}return this;}/**
		 * Writes the elements of this matrix to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The matrix elements in column-major order.
		 */toArray(array=[],offset=0){const te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];return array;}/**
		 * Returns a matrix with copied values from this instance.
		 *
		 * @return {Matrix3} A clone of this instance.
		 */clone(){return new this.constructor().fromArray(this.elements);}};const _m3$1=/*@__PURE__*/new Matrix3$1();const LINEAR_REC709_TO_XYZ=/*@__PURE__*/new Matrix3$1().set(0.4123908,0.3575843,0.1804808,0.2126390,0.7151687,0.0721923,0.0193308,0.1191948,0.9505322);const XYZ_TO_LINEAR_REC709=/*@__PURE__*/new Matrix3$1().set(3.2409699,-1.5373832,-0.4986108,-0.9692436,1.8759675,0.0415551,0.0556301,-0.203977,1.0569715);function createColorManagement(){const ColorManagement={enabled:true,workingColorSpace:LinearSRGBColorSpace,/**
			 * Implementations of supported color spaces.
			 *
			 * Required:
			 *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
			 *	- whitePoint: reference white [ x y ]
			 *	- transfer: transfer function (pre-defined)
			 *	- toXYZ: Matrix3 RGB to XYZ transform
			 *	- fromXYZ: Matrix3 XYZ to RGB transform
			 *	- luminanceCoefficients: RGB luminance coefficients
			 *
			 * Optional:
			 *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace, toneMappingMode: 'extended' | 'standard' }
			 *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
			 *
			 * Reference:
			 * - https://www.russellcottrell.com/photo/matrixCalculator.htm
			 */spaces:{},convert:function(color,sourceColorSpace,targetColorSpace){if(this.enabled===false||sourceColorSpace===targetColorSpace||!sourceColorSpace||!targetColorSpace){return color;}if(this.spaces[sourceColorSpace].transfer===SRGBTransfer){color.r=SRGBToLinear(color.r);color.g=SRGBToLinear(color.g);color.b=SRGBToLinear(color.b);}if(this.spaces[sourceColorSpace].primaries!==this.spaces[targetColorSpace].primaries){color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);}if(this.spaces[targetColorSpace].transfer===SRGBTransfer){color.r=LinearToSRGB(color.r);color.g=LinearToSRGB(color.g);color.b=LinearToSRGB(color.b);}return color;},workingToColorSpace:function(color,targetColorSpace){return this.convert(color,this.workingColorSpace,targetColorSpace);},colorSpaceToWorking:function(color,sourceColorSpace){return this.convert(color,sourceColorSpace,this.workingColorSpace);},getPrimaries:function(colorSpace){return this.spaces[colorSpace].primaries;},getTransfer:function(colorSpace){if(colorSpace===NoColorSpace)return LinearTransfer;return this.spaces[colorSpace].transfer;},getToneMappingMode:function(colorSpace){return this.spaces[colorSpace].outputColorSpaceConfig.toneMappingMode||'standard';},getLuminanceCoefficients:function(target,colorSpace=this.workingColorSpace){return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);},define:function(colorSpaces){Object.assign(this.spaces,colorSpaces);},// Internal APIs
	_getMatrix:function(targetMatrix,sourceColorSpace,targetColorSpace){return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);},_getDrawingBufferColorSpace:function(colorSpace){return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;},_getUnpackColorSpace:function(colorSpace=this.workingColorSpace){return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;},// Deprecated
	fromWorkingColorSpace:function(color,targetColorSpace){warnOnce('ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().');// @deprecated, r177
	return ColorManagement.workingToColorSpace(color,targetColorSpace);},toWorkingColorSpace:function(color,sourceColorSpace){warnOnce('ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().');// @deprecated, r177
	return ColorManagement.colorSpaceToWorking(color,sourceColorSpace);}};/******************************************************************************
		 * sRGB definitions
		 */const REC709_PRIMARIES=[0.640,0.330,0.300,0.600,0.150,0.060];const REC709_LUMINANCE_COEFFICIENTS=[0.2126,0.7152,0.0722];const D65=[0.3127,0.3290];ColorManagement.define({[LinearSRGBColorSpace]:{primaries:REC709_PRIMARIES,whitePoint:D65,transfer:LinearTransfer,toXYZ:LINEAR_REC709_TO_XYZ,fromXYZ:XYZ_TO_LINEAR_REC709,luminanceCoefficients:REC709_LUMINANCE_COEFFICIENTS,workingColorSpaceConfig:{unpackColorSpace:SRGBColorSpace},outputColorSpaceConfig:{drawingBufferColorSpace:SRGBColorSpace}},[SRGBColorSpace]:{primaries:REC709_PRIMARIES,whitePoint:D65,transfer:SRGBTransfer,toXYZ:LINEAR_REC709_TO_XYZ,fromXYZ:XYZ_TO_LINEAR_REC709,luminanceCoefficients:REC709_LUMINANCE_COEFFICIENTS,outputColorSpaceConfig:{drawingBufferColorSpace:SRGBColorSpace}}});return ColorManagement;}const ColorManagement=/*@__PURE__*/createColorManagement();function SRGBToLinear(c){return c<0.04045?c*0.0773993808:Math.pow(c*0.9478672986+0.0521327014,2.4);}function LinearToSRGB(c){return c<0.0031308?c*12.92:1.055*Math.pow(c,0.41666)-0.055;}let _canvas;/**
	 * A class containing utility functions for images.
	 *
	 * @hideconstructor
	 */class ImageUtils{/**
		 * Returns a data URI containing a representation of the given image.
		 *
		 * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
		 * @param {string} [type='image/png'] - Indicates the image format.
		 * @return {string} The data URI.
		 */static getDataURL(image,type='image/png'){if(/^data:/i.test(image.src)){return image.src;}if(typeof HTMLCanvasElement==='undefined'){return image.src;}let canvas;if(image instanceof HTMLCanvasElement){canvas=image;}else {if(_canvas===undefined)_canvas=createElementNS('canvas');_canvas.width=image.width;_canvas.height=image.height;const context=_canvas.getContext('2d');if(image instanceof ImageData){context.putImageData(image,0,0);}else {context.drawImage(image,0,0,image.width,image.height);}canvas=_canvas;}return canvas.toDataURL(type);}/**
		 * Converts the given sRGB image data to linear color space.
		 *
		 * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
		 * @return {HTMLCanvasElement|Object} The converted image.
		 */static sRGBToLinear(image){if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){const canvas=createElementNS('canvas');canvas.width=image.width;canvas.height=image.height;const context=canvas.getContext('2d');context.drawImage(image,0,0,image.width,image.height);const imageData=context.getImageData(0,0,image.width,image.height);const data=imageData.data;for(let i=0;i<data.length;i++){data[i]=SRGBToLinear(data[i]/255)*255;}context.putImageData(imageData,0,0);return canvas;}else if(image.data){const data=image.data.slice(0);for(let i=0;i<data.length;i++){if(data instanceof Uint8Array||data instanceof Uint8ClampedArray){data[i]=Math.floor(SRGBToLinear(data[i]/255)*255);}else {// assuming float
	data[i]=SRGBToLinear(data[i]);}}return {data:data,width:image.width,height:image.height};}else {warn$1('ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');return image;}}}let _sourceId=0;/**
	 * Represents the data source of a texture.
	 *
	 * The main purpose of this class is to decouple the data definition from the texture
	 * definition so the same data can be used with multiple texture instances.
	 */class Source{/**
		 * Constructs a new video texture.
		 *
		 * @param {any} [data=null] - The data definition of a texture.
		 */constructor(data=null){/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isSource=true;/**
			 * The ID of the source.
			 *
			 * @name Source#id
			 * @type {number}
			 * @readonly
			 */Object.defineProperty(this,'id',{value:_sourceId++});/**
			 * The UUID of the source.
			 *
			 * @type {string}
			 * @readonly
			 */this.uuid=generateUUID$1();/**
			 * The data definition of a texture.
			 *
			 * @type {any}
			 */this.data=data;/**
			 * This property is only relevant when {@link Source#needsUpdate} is set to `true` and
			 * provides more control on how texture data should be processed. When `dataReady` is set
			 * to `false`, the engine performs the memory allocation (if necessary) but does not transfer
			 * the data into the GPU memory.
			 *
			 * @type {boolean}
			 * @default true
			 */this.dataReady=true;/**
			 * This starts at `0` and counts how many times {@link Source#needsUpdate} is set to `true`.
			 *
			 * @type {number}
			 * @readonly
			 * @default 0
			 */this.version=0;}/**
		 * Returns the dimensions of the source into the given target vector.
		 *
		 * @param {(Vector2|Vector3)} target - The target object the result is written into.
		 * @return {(Vector2|Vector3)} The dimensions of the source.
		 */getSize(target){const data=this.data;if(typeof HTMLVideoElement!=='undefined'&&data instanceof HTMLVideoElement){target.set(data.videoWidth,data.videoHeight,0);}else if(data instanceof VideoFrame){target.set(data.displayHeight,data.displayWidth,0);}else if(data!==null){target.set(data.width,data.height,data.depth||0);}else {target.set(0,0,0);}return target;}/**
		 * When the property is set to `true`, the engine allocates the memory
		 * for the texture (if necessary) and triggers the actual texture upload
		 * to the GPU next time the source is used.
		 *
		 * @type {boolean}
		 * @default false
		 * @param {boolean} value
		 */set needsUpdate(value){if(value===true)this.version++;}/**
		 * Serializes the source into JSON.
		 *
		 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
		 * @return {Object} A JSON object representing the serialized source.
		 * @see {@link ObjectLoader#parse}
		 */toJSON(meta){const isRootObject=meta===undefined||typeof meta==='string';if(!isRootObject&&meta.images[this.uuid]!==undefined){return meta.images[this.uuid];}const output={uuid:this.uuid,url:''};const data=this.data;if(data!==null){let url;if(Array.isArray(data)){// cube texture
	url=[];for(let i=0,l=data.length;i<l;i++){if(data[i].isDataTexture){url.push(serializeImage(data[i].image));}else {url.push(serializeImage(data[i]));}}}else {// texture
	url=serializeImage(data);}output.url=url;}if(!isRootObject){meta.images[this.uuid]=output;}return output;}}function serializeImage(image){if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){// default images
	return ImageUtils.getDataURL(image);}else {if(image.data){// images of DataTexture
	return {data:Array.from(image.data),width:image.width,height:image.height,type:image.data.constructor.name};}else {warn$1('Texture: Unable to serialize Texture.');return {};}}}let _textureId=0;const _tempVec3=/*@__PURE__*/new Vector3$1();/**
	 * Base class for all textures.
	 *
	 * Note: After the initial use of a texture, its dimensions, format, and type
	 * cannot be changed. Instead, call {@link Texture#dispose} on the texture and instantiate a new one.
	 *
	 * @augments EventDispatcher
	 */class Texture extends EventDispatcher$1{/**
		 * Constructs a new texture.
		 *
		 * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
		 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
		 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
		 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
		 * @param {number} [magFilter=LinearFilter] - The mag filter value.
		 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
		 * @param {number} [format=RGBAFormat] - The texture format.
		 * @param {number} [type=UnsignedByteType] - The texture type.
		 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
		 * @param {string} [colorSpace=NoColorSpace] - The color space.
		 */constructor(image=Texture.DEFAULT_IMAGE,mapping=Texture.DEFAULT_MAPPING,wrapS=ClampToEdgeWrapping,wrapT=ClampToEdgeWrapping,magFilter=LinearFilter,minFilter=LinearMipmapLinearFilter,format=RGBAFormat,type=UnsignedByteType,anisotropy=Texture.DEFAULT_ANISOTROPY,colorSpace=NoColorSpace){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isTexture=true;/**
			 * The ID of the texture.
			 *
			 * @name Texture#id
			 * @type {number}
			 * @readonly
			 */Object.defineProperty(this,'id',{value:_textureId++});/**
			 * The UUID of the material.
			 *
			 * @type {string}
			 * @readonly
			 */this.uuid=generateUUID$1();/**
			 * The name of the material.
			 *
			 * @type {string}
			 */this.name='';/**
			 * The data definition of a texture. A reference to the data source can be
			 * shared across textures. This is often useful in context of spritesheets
			 * where multiple textures render the same data but with different texture
			 * transformations.
			 *
			 * @type {Source}
			 */this.source=new Source(image);/**
			 * An array holding user-defined mipmaps.
			 *
			 * @type {Array<Object>}
			 */this.mipmaps=[];/**
			 * How the texture is applied to the object. The value `UVMapping`
			 * is the default, where texture or uv coordinates are used to apply the map.
			 *
			 * @type {(UVMapping|CubeReflectionMapping|CubeRefractionMapping|EquirectangularReflectionMapping|EquirectangularRefractionMapping|CubeUVReflectionMapping)}
			 * @default UVMapping
			*/this.mapping=mapping;/**
			 * Lets you select the uv attribute to map the texture to. `0` for `uv`,
			 * `1` for `uv1`, `2` for `uv2` and `3` for `uv3`.
			 *
			 * @type {number}
			 * @default 0
			 */this.channel=0;/**
			 * This defines how the texture is wrapped horizontally and corresponds to
			 * *U* in UV mapping.
			 *
			 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
			 * @default ClampToEdgeWrapping
			 */this.wrapS=wrapS;/**
			 * This defines how the texture is wrapped horizontally and corresponds to
			 * *V* in UV mapping.
			 *
			 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
			 * @default ClampToEdgeWrapping
			 */this.wrapT=wrapT;/**
			 * How the texture is sampled when a texel covers more than one pixel.
			 *
			 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
			 * @default LinearFilter
			 */this.magFilter=magFilter;/**
			 * How the texture is sampled when a texel covers less than one pixel.
			 *
			 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
			 * @default LinearMipmapLinearFilter
			 */this.minFilter=minFilter;/**
			 * The number of samples taken along the axis through the pixel that has the
			 * highest density of texels. By default, this value is `1`. A higher value
			 * gives a less blurry result than a basic mipmap, at the cost of more
			 * texture samples being used.
			 *
			 * @type {number}
			 * @default 0
			 */this.anisotropy=anisotropy;/**
			 * The format of the texture.
			 *
			 * @type {number}
			 * @default RGBAFormat
			 */this.format=format;/**
			 * The default internal format is derived from {@link Texture#format} and {@link Texture#type} and
			 * defines how the texture data is going to be stored on the GPU.
			 *
			 * This property allows to overwrite the default format.
			 *
			 * @type {?string}
			 * @default null
			 */this.internalFormat=null;/**
			 * The data type of the texture.
			 *
			 * @type {number}
			 * @default UnsignedByteType
			 */this.type=type;/**
			 * How much a single repetition of the texture is offset from the beginning,
			 * in each direction U and V. Typical range is `0.0` to `1.0`.
			 *
			 * @type {Vector2}
			 * @default (0,0)
			 */this.offset=new Vector2$1(0,0);/**
			 * How many times the texture is repeated across the surface, in each
			 * direction U and V. If repeat is set greater than `1` in either direction,
			 * the corresponding wrap parameter should also be set to `RepeatWrapping`
			 * or `MirroredRepeatWrapping` to achieve the desired tiling effect.
			 *
			 * @type {Vector2}
			 * @default (1,1)
			 */this.repeat=new Vector2$1(1,1);/**
			 * The point around which rotation occurs. A value of `(0.5, 0.5)` corresponds
			 * to the center of the texture. Default is `(0, 0)`, the lower left.
			 *
			 * @type {Vector2}
			 * @default (0,0)
			 */this.center=new Vector2$1(0,0);/**
			 * How much the texture is rotated around the center point, in radians.
			 * Positive values are counter-clockwise.
			 *
			 * @type {number}
			 * @default 0
			 */this.rotation=0;/**
			 * Whether to update the texture's uv-transformation {@link Texture#matrix}
			 * from the properties {@link Texture#offset}, {@link Texture#repeat},
			 * {@link Texture#rotation}, and {@link Texture#center}.
			 *
			 * Set this to `false` if you are specifying the uv-transform matrix directly.
			 *
			 * @type {boolean}
			 * @default true
			 */this.matrixAutoUpdate=true;/**
			 * The uv-transformation matrix of the texture.
			 *
			 * @type {Matrix3}
			 */this.matrix=new Matrix3$1();/**
			 * Whether to generate mipmaps (if possible) for a texture.
			 *
			 * Set this to `false` if you are creating mipmaps manually.
			 *
			 * @type {boolean}
			 * @default true
			 */this.generateMipmaps=true;/**
			 * If set to `true`, the alpha channel, if present, is multiplied into the
			 * color channels when the texture is uploaded to the GPU.
			 *
			 * Note that this property has no effect when using `ImageBitmap`. You need to
			 * configure premultiply alpha on bitmap creation instead.
			 *
			 * @type {boolean}
			 * @default false
			 */this.premultiplyAlpha=false;/**
			 * If set to `true`, the texture is flipped along the vertical axis when
			 * uploaded to the GPU.
			 *
			 * Note that this property has no effect when using `ImageBitmap`. You need to
			 * configure the flip on bitmap creation instead.
			 *
			 * @type {boolean}
			 * @default true
			 */this.flipY=true;/**
			 * Specifies the alignment requirements for the start of each pixel row in memory.
			 * The allowable values are `1` (byte-alignment), `2` (rows aligned to even-numbered bytes),
			 * `4` (word-alignment), and `8` (rows start on double-word boundaries).
			 *
			 * @type {number}
			 * @default 4
			 */this.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	/**
			 * Textures containing color data should be annotated with `SRGBColorSpace` or `LinearSRGBColorSpace`.
			 *
			 * @type {string}
			 * @default NoColorSpace
			 */this.colorSpace=colorSpace;/**
			 * An object that can be used to store custom data about the texture. It
			 * should not hold references to functions as these will not be cloned.
			 *
			 * @type {Object}
			 */this.userData={};/**
			 * This can be used to only update a subregion or specific rows of the texture (for example, just the
			 * first 3 rows). Use the `addUpdateRange()` function to add ranges to this array.
			 *
			 * @type {Array<Object>}
			 */this.updateRanges=[];/**
			 * This starts at `0` and counts how many times {@link Texture#needsUpdate} is set to `true`.
			 *
			 * @type {number}
			 * @readonly
			 * @default 0
			 */this.version=0;/**
			 * A callback function, called when the texture is updated (e.g., when
			 * {@link Texture#needsUpdate} has been set to true and then the texture is used).
			 *
			 * @type {?Function}
			 * @default null
			 */this.onUpdate=null;/**
			 * An optional back reference to the textures render target.
			 *
			 * @type {?(RenderTarget|WebGLRenderTarget)}
			 * @default null
			 */this.renderTarget=null;/**
			 * Indicates whether a texture belongs to a render target or not.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default false
			 */this.isRenderTargetTexture=false;/**
			 * Indicates if a texture should be handled like a texture array.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default false
			 */this.isArrayTexture=image&&image.depth&&image.depth>1?true:false;/**
			 * Indicates whether this texture should be processed by `PMREMGenerator` or not
			 * (only relevant for render target textures).
			 *
			 * @type {number}
			 * @readonly
			 * @default 0
			 */this.pmremVersion=0;}/**
		 * The width of the texture in pixels.
		 */get width(){return this.source.getSize(_tempVec3).x;}/**
		 * The height of the texture in pixels.
		 */get height(){return this.source.getSize(_tempVec3).y;}/**
		 * The depth of the texture in pixels.
		 */get depth(){return this.source.getSize(_tempVec3).z;}/**
		 * The image object holding the texture data.
		 *
		 * @type {?Object}
		 */get image(){return this.source.data;}set image(value=null){this.source.data=value;}/**
		 * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
		 * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
		 */updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y);}/**
		 * Adds a range of data in the data texture to be updated on the GPU.
		 *
		 * @param {number} start - Position at which to start update.
		 * @param {number} count - The number of components to update.
		 */addUpdateRange(start,count){this.updateRanges.push({start,count});}/**
		 * Clears the update ranges.
		 */clearUpdateRanges(){this.updateRanges.length=0;}/**
		 * Returns a new texture with copied values from this instance.
		 *
		 * @return {Texture} A clone of this instance.
		 */clone(){return new this.constructor().copy(this);}/**
		 * Copies the values of the given texture to this instance.
		 *
		 * @param {Texture} source - The texture to copy.
		 * @return {Texture} A reference to this instance.
		 */copy(source){this.name=source.name;this.source=source.source;this.mipmaps=source.mipmaps.slice(0);this.mapping=source.mapping;this.channel=source.channel;this.wrapS=source.wrapS;this.wrapT=source.wrapT;this.magFilter=source.magFilter;this.minFilter=source.minFilter;this.anisotropy=source.anisotropy;this.format=source.format;this.internalFormat=source.internalFormat;this.type=source.type;this.offset.copy(source.offset);this.repeat.copy(source.repeat);this.center.copy(source.center);this.rotation=source.rotation;this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrix.copy(source.matrix);this.generateMipmaps=source.generateMipmaps;this.premultiplyAlpha=source.premultiplyAlpha;this.flipY=source.flipY;this.unpackAlignment=source.unpackAlignment;this.colorSpace=source.colorSpace;this.renderTarget=source.renderTarget;this.isRenderTargetTexture=source.isRenderTargetTexture;this.isArrayTexture=source.isArrayTexture;this.userData=JSON.parse(JSON.stringify(source.userData));this.needsUpdate=true;return this;}/**
		 * Sets this texture's properties based on `values`.
		 * @param {Object} values - A container with texture parameters.
		 */setValues(values){for(const key in values){const newValue=values[key];if(newValue===undefined){warn$1(`Texture.setValues(): parameter '${key}' has value of undefined.`);continue;}const currentValue=this[key];if(currentValue===undefined){warn$1(`Texture.setValues(): property '${key}' does not exist.`);continue;}if(currentValue&&newValue&&currentValue.isVector2&&newValue.isVector2){currentValue.copy(newValue);}else if(currentValue&&newValue&&currentValue.isVector3&&newValue.isVector3){currentValue.copy(newValue);}else if(currentValue&&newValue&&currentValue.isMatrix3&&newValue.isMatrix3){currentValue.copy(newValue);}else {this[key]=newValue;}}}/**
		 * Serializes the texture into JSON.
		 *
		 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
		 * @return {Object} A JSON object representing the serialized texture.
		 * @see {@link ObjectLoader#parse}
		 */toJSON(meta){const isRootObject=meta===undefined||typeof meta==='string';if(!isRootObject&&meta.textures[this.uuid]!==undefined){return meta.textures[this.uuid];}const output={metadata:{version:4.7,type:'Texture',generator:'Texture.toJSON'},uuid:this.uuid,name:this.name,image:this.source.toJSON(meta).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(Object.keys(this.userData).length>0)output.userData=this.userData;if(!isRootObject){meta.textures[this.uuid]=output;}return output;}/**
		 * Frees the GPU-related resources allocated by this instance. Call this
		 * method whenever this instance is no longer used in your app.
		 *
		 * @fires Texture#dispose
		 */dispose(){/**
			 * Fires when the texture has been disposed of.
			 *
			 * @event Texture#dispose
			 * @type {Object}
			 */this.dispatchEvent({type:'dispose'});}/**
		 * Transforms the given uv vector with the textures uv transformation matrix.
		 *
		 * @param {Vector2} uv - The uv vector.
		 * @return {Vector2} The transformed uv vector.
		 */transformUv(uv){if(this.mapping!==UVMapping)return uv;uv.applyMatrix3(this.matrix);if(uv.x<0||uv.x>1){switch(this.wrapS){case RepeatWrapping:uv.x=uv.x-Math.floor(uv.x);break;case ClampToEdgeWrapping:uv.x=uv.x<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.x)%2)===1){uv.x=Math.ceil(uv.x)-uv.x;}else {uv.x=uv.x-Math.floor(uv.x);}break;}}if(uv.y<0||uv.y>1){switch(this.wrapT){case RepeatWrapping:uv.y=uv.y-Math.floor(uv.y);break;case ClampToEdgeWrapping:uv.y=uv.y<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.y)%2)===1){uv.y=Math.ceil(uv.y)-uv.y;}else {uv.y=uv.y-Math.floor(uv.y);}break;}}if(this.flipY){uv.y=1-uv.y;}return uv;}/**
		 * Setting this property to `true` indicates the engine the texture
		 * must be updated in the next render. This triggers a texture upload
		 * to the GPU and ensures correct texture parameter configuration.
		 *
		 * @type {boolean}
		 * @default false
		 * @param {boolean} value
		 */set needsUpdate(value){if(value===true){this.version++;this.source.needsUpdate=true;}}/**
		 * Setting this property to `true` indicates the engine the PMREM
		 * must be regenerated.
		 *
		 * @type {boolean}
		 * @default false
		 * @param {boolean} value
		 */set needsPMREMUpdate(value){if(value===true){this.pmremVersion++;}}}/**
	 * The default image for all textures.
	 *
	 * @static
	 * @type {?Image}
	 * @default null
	 */Texture.DEFAULT_IMAGE=null;/**
	 * The default mapping for all textures.
	 *
	 * @static
	 * @type {number}
	 * @default UVMapping
	 */Texture.DEFAULT_MAPPING=UVMapping;/**
	 * The default anisotropy value for all textures.
	 *
	 * @static
	 * @type {number}
	 * @default 1
	 */Texture.DEFAULT_ANISOTROPY=1;/**
	 * Class representing a 4D vector. A 4D vector is an ordered quadruplet of numbers
	 * (labeled x, y, z and w), which can be used to represent a number of things, such as:
	 *
	 * - A point in 4D space.
	 * - A direction and length in 4D space. In three.js the length will
	 * always be the Euclidean distance(straight-line distance) from `(0, 0, 0, 0)` to `(x, y, z, w)`
	 * and the direction is also measured from `(0, 0, 0, 0)` towards `(x, y, z, w)`.
	 * - Any arbitrary ordered quadruplet of numbers.
	 *
	 * There are other things a 4D vector can be used to represent, however these
	 * are the most common uses in *three.js*.
	 *
	 * Iterating through a vector instance will yield its components `(x, y, z, w)` in
	 * the corresponding order.
	 * ```js
	 * const a = new THREE.Vector4( 0, 1, 0, 0 );
	 *
	 * //no arguments; will be initialised to (0, 0, 0, 1)
	 * const b = new THREE.Vector4( );
	 *
	 * const d = a.dot( b );
	 * ```
	 */class Vector4{/**
		 * Constructs a new 4D vector.
		 *
		 * @param {number} [x=0] - The x value of this vector.
		 * @param {number} [y=0] - The y value of this vector.
		 * @param {number} [z=0] - The z value of this vector.
		 * @param {number} [w=1] - The w value of this vector.
		 */constructor(x=0,y=0,z=0,w=1){/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */Vector4.prototype.isVector4=true;/**
			 * The x value of this vector.
			 *
			 * @type {number}
			 */this.x=x;/**
			 * The y value of this vector.
			 *
			 * @type {number}
			 */this.y=y;/**
			 * The z value of this vector.
			 *
			 * @type {number}
			 */this.z=z;/**
			 * The w value of this vector.
			 *
			 * @type {number}
			 */this.w=w;}/**
		 * Alias for {@link Vector4#z}.
		 *
		 * @type {number}
		 */get width(){return this.z;}set width(value){this.z=value;}/**
		 * Alias for {@link Vector4#w}.
		 *
		 * @type {number}
		 */get height(){return this.w;}set height(value){this.w=value;}/**
		 * Sets the vector components.
		 *
		 * @param {number} x - The value of the x component.
		 * @param {number} y - The value of the y component.
		 * @param {number} z - The value of the z component.
		 * @param {number} w - The value of the w component.
		 * @return {Vector4} A reference to this vector.
		 */set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this;}/**
		 * Sets the vector components to the same value.
		 *
		 * @param {number} scalar - The value to set for all vector components.
		 * @return {Vector4} A reference to this vector.
		 */setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;this.w=scalar;return this;}/**
		 * Sets the vector's x component to the given value
		 *
		 * @param {number} x - The value to set.
		 * @return {Vector4} A reference to this vector.
		 */setX(x){this.x=x;return this;}/**
		 * Sets the vector's y component to the given value
		 *
		 * @param {number} y - The value to set.
		 * @return {Vector4} A reference to this vector.
		 */setY(y){this.y=y;return this;}/**
		 * Sets the vector's z component to the given value
		 *
		 * @param {number} z - The value to set.
		 * @return {Vector4} A reference to this vector.
		 */setZ(z){this.z=z;return this;}/**
		 * Sets the vector's w component to the given value
		 *
		 * @param {number} w - The value to set.
		 * @return {Vector4} A reference to this vector.
		 */setW(w){this.w=w;return this;}/**
		 * Allows to set a vector component with an index.
		 *
		 * @param {number} index - The component index. `0` equals to x, `1` equals to y,
		 * `2` equals to z, `3` equals to w.
		 * @param {number} value - The value to set.
		 * @return {Vector4} A reference to this vector.
		 */setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error('index is out of range: '+index);}return this;}/**
		 * Returns the value of the vector component which matches the given index.
		 *
		 * @param {number} index - The component index. `0` equals to x, `1` equals to y,
		 * `2` equals to z, `3` equals to w.
		 * @return {number} A vector component value.
		 */getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error('index is out of range: '+index);}}/**
		 * Returns a new vector with copied values from this instance.
		 *
		 * @return {Vector4} A clone of this instance.
		 */clone(){return new this.constructor(this.x,this.y,this.z,this.w);}/**
		 * Copies the values of the given vector to this instance.
		 *
		 * @param {Vector3|Vector4} v - The vector to copy.
		 * @return {Vector4} A reference to this vector.
		 */copy(v){this.x=v.x;this.y=v.y;this.z=v.z;this.w=v.w!==undefined?v.w:1;return this;}/**
		 * Adds the given vector to this instance.
		 *
		 * @param {Vector4} v - The vector to add.
		 * @return {Vector4} A reference to this vector.
		 */add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this;}/**
		 * Adds the given scalar value to all components of this instance.
		 *
		 * @param {number} s - The scalar to add.
		 * @return {Vector4} A reference to this vector.
		 */addScalar(s){this.x+=s;this.y+=s;this.z+=s;this.w+=s;return this;}/**
		 * Adds the given vectors and stores the result in this instance.
		 *
		 * @param {Vector4} a - The first vector.
		 * @param {Vector4} b - The second vector.
		 * @return {Vector4} A reference to this vector.
		 */addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this;}/**
		 * Adds the given vector scaled by the given factor to this instance.
		 *
		 * @param {Vector4} v - The vector.
		 * @param {number} s - The factor that scales `v`.
		 * @return {Vector4} A reference to this vector.
		 */addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;this.w+=v.w*s;return this;}/**
		 * Subtracts the given vector from this instance.
		 *
		 * @param {Vector4} v - The vector to subtract.
		 * @return {Vector4} A reference to this vector.
		 */sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this;}/**
		 * Subtracts the given scalar value from all components of this instance.
		 *
		 * @param {number} s - The scalar to subtract.
		 * @return {Vector4} A reference to this vector.
		 */subScalar(s){this.x-=s;this.y-=s;this.z-=s;this.w-=s;return this;}/**
		 * Subtracts the given vectors and stores the result in this instance.
		 *
		 * @param {Vector4} a - The first vector.
		 * @param {Vector4} b - The second vector.
		 * @return {Vector4} A reference to this vector.
		 */subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this;}/**
		 * Multiplies the given vector with this instance.
		 *
		 * @param {Vector4} v - The vector to multiply.
		 * @return {Vector4} A reference to this vector.
		 */multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;this.w*=v.w;return this;}/**
		 * Multiplies the given scalar value with all components of this instance.
		 *
		 * @param {number} scalar - The scalar to multiply.
		 * @return {Vector4} A reference to this vector.
		 */multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;return this;}/**
		 * Multiplies this vector with the given 4x4 matrix.
		 *
		 * @param {Matrix4} m - The 4x4 matrix.
		 * @return {Vector4} A reference to this vector.
		 */applyMatrix4(m){const x=this.x,y=this.y,z=this.z,w=this.w;const e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;return this;}/**
		 * Divides this instance by the given vector.
		 *
		 * @param {Vector4} v - The vector to divide.
		 * @return {Vector4} A reference to this vector.
		 */divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;this.w/=v.w;return this;}/**
		 * Divides this vector by the given scalar.
		 *
		 * @param {number} scalar - The scalar to divide.
		 * @return {Vector4} A reference to this vector.
		 */divideScalar(scalar){return this.multiplyScalar(1/scalar);}/**
		 * Sets the x, y and z components of this
		 * vector to the quaternion's axis and w to the angle.
		 *
		 * @param {Quaternion} q - The Quaternion to set.
		 * @return {Vector4} A reference to this vector.
		 */setAxisAngleFromQuaternion(q){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	// q is assumed to be normalized
	this.w=2*Math.acos(q.w);const s=Math.sqrt(1-q.w*q.w);if(s<0.0001){this.x=1;this.y=0;this.z=0;}else {this.x=q.x/s;this.y=q.y/s;this.z=q.z/s;}return this;}/**
		 * Sets the x, y and z components of this
		 * vector to the axis of rotation and w to the angle.
		 *
		 * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
		 * @return {Vector4} A reference to this vector.
		 */setAxisAngleFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	let angle,x,y,z;// variables for result
	const epsilon=0.01,// margin to allow for rounding errors
	epsilon2=0.1,// margin to distinguish between 0 and 180 degrees
	te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<epsilon&&Math.abs(m13-m31)<epsilon&&Math.abs(m23-m32)<epsilon){// singularity found
	// first check for identity matrix which must have +1 for all terms
	// in leading diagonal and zero in other terms
	if(Math.abs(m12+m21)<epsilon2&&Math.abs(m13+m31)<epsilon2&&Math.abs(m23+m32)<epsilon2&&Math.abs(m11+m22+m33-3)<epsilon2){// this singularity is identity matrix so angle = 0
	this.set(1,0,0,0);return this;// zero angle, arbitrary axis
	}// otherwise this singularity is angle = 180
	angle=Math.PI;const xx=(m11+1)/2;const yy=(m22+1)/2;const zz=(m33+1)/2;const xy=(m12+m21)/4;const xz=(m13+m31)/4;const yz=(m23+m32)/4;if(xx>yy&&xx>zz){// m11 is the largest diagonal term
	if(xx<epsilon){x=0;y=0.707106781;z=0.707106781;}else {x=Math.sqrt(xx);y=xy/x;z=xz/x;}}else if(yy>zz){// m22 is the largest diagonal term
	if(yy<epsilon){x=0.707106781;y=0;z=0.707106781;}else {y=Math.sqrt(yy);x=xy/y;z=yz/y;}}else {// m33 is the largest diagonal term so base result on this
	if(zz<epsilon){x=0.707106781;y=0.707106781;z=0;}else {z=Math.sqrt(zz);x=xz/z;y=yz/z;}}this.set(x,y,z,angle);return this;// return 180 deg rotation
	}// as we have reached here there are no singularities so we can handle normally
	let s=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));// used to normalize
	if(Math.abs(s)<0.001)s=1;// prevent divide by zero, should not happen if matrix is orthogonal and should be
	// caught by singularity test above, but I've left it in just in case
	this.x=(m32-m23)/s;this.y=(m13-m31)/s;this.z=(m21-m12)/s;this.w=Math.acos((m11+m22+m33-1)/2);return this;}/**
		 * Sets the vector components to the position elements of the
		 * given transformation matrix.
		 *
		 * @param {Matrix4} m - The 4x4 matrix.
		 * @return {Vector4} A reference to this vector.
		 */setFromMatrixPosition(m){const e=m.elements;this.x=e[12];this.y=e[13];this.z=e[14];this.w=e[15];return this;}/**
		 * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
		 * value, replace that value with the corresponding min value.
		 *
		 * @param {Vector4} v - The vector.
		 * @return {Vector4} A reference to this vector.
		 */min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);this.w=Math.min(this.w,v.w);return this;}/**
		 * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
		 * value, replace that value with the corresponding max value.
		 *
		 * @param {Vector4} v - The vector.
		 * @return {Vector4} A reference to this vector.
		 */max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);this.w=Math.max(this.w,v.w);return this;}/**
		 * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
		 * value, it is replaced by the corresponding value.
		 * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
		 * it is replaced by the corresponding value.
		 *
		 * @param {Vector4} min - The minimum x, y and z values.
		 * @param {Vector4} max - The maximum x, y and z values in the desired range.
		 * @return {Vector4} A reference to this vector.
		 */clamp(min,max){// assumes min < max, componentwise
	this.x=clamp$1(this.x,min.x,max.x);this.y=clamp$1(this.y,min.y,max.y);this.z=clamp$1(this.z,min.z,max.z);this.w=clamp$1(this.w,min.w,max.w);return this;}/**
		 * If this vector's x, y, z or w values are greater than the max value, they are
		 * replaced by the max value.
		 * If this vector's x, y, z or w values are less than the min value, they are
		 * replaced by the min value.
		 *
		 * @param {number} minVal - The minimum value the components will be clamped to.
		 * @param {number} maxVal - The maximum value the components will be clamped to.
		 * @return {Vector4} A reference to this vector.
		 */clampScalar(minVal,maxVal){this.x=clamp$1(this.x,minVal,maxVal);this.y=clamp$1(this.y,minVal,maxVal);this.z=clamp$1(this.z,minVal,maxVal);this.w=clamp$1(this.w,minVal,maxVal);return this;}/**
		 * If this vector's length is greater than the max value, it is replaced by
		 * the max value.
		 * If this vector's length is less than the min value, it is replaced by the
		 * min value.
		 *
		 * @param {number} min - The minimum value the vector length will be clamped to.
		 * @param {number} max - The maximum value the vector length will be clamped to.
		 * @return {Vector4} A reference to this vector.
		 */clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(clamp$1(length,min,max));}/**
		 * The components of this vector are rounded down to the nearest integer value.
		 *
		 * @return {Vector4} A reference to this vector.
		 */floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this;}/**
		 * The components of this vector are rounded up to the nearest integer value.
		 *
		 * @return {Vector4} A reference to this vector.
		 */ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this;}/**
		 * The components of this vector are rounded to the nearest integer value
		 *
		 * @return {Vector4} A reference to this vector.
		 */round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this;}/**
		 * The components of this vector are rounded towards zero (up if negative,
		 * down if positive) to an integer value.
		 *
		 * @return {Vector4} A reference to this vector.
		 */roundToZero(){this.x=Math.trunc(this.x);this.y=Math.trunc(this.y);this.z=Math.trunc(this.z);this.w=Math.trunc(this.w);return this;}/**
		 * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
		 *
		 * @return {Vector4} A reference to this vector.
		 */negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this;}/**
		 * Calculates the dot product of the given vector with this instance.
		 *
		 * @param {Vector4} v - The vector to compute the dot product with.
		 * @return {number} The result of the dot product.
		 */dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;}/**
		 * Computes the square of the Euclidean length (straight-line length) from
		 * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
		 * compare the length squared instead as it is slightly more efficient to calculate.
		 *
		 * @return {number} The square length of this vector.
		 */lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;}/**
		 * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
		 *
		 * @return {number} The length of this vector.
		 */length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);}/**
		 * Computes the Manhattan length of this vector.
		 *
		 * @return {number} The length of this vector.
		 */manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);}/**
		 * Converts this vector to a unit vector - that is, sets it equal to a vector
		 * with the same direction as this one, but with a vector length of `1`.
		 *
		 * @return {Vector4} A reference to this vector.
		 */normalize(){return this.divideScalar(this.length()||1);}/**
		 * Sets this vector to a vector with the same direction as this one, but
		 * with the specified length.
		 *
		 * @param {number} length - The new length of this vector.
		 * @return {Vector4} A reference to this vector.
		 */setLength(length){return this.normalize().multiplyScalar(length);}/**
		 * Linearly interpolates between the given vector and this instance, where
		 * alpha is the percent distance along the line - alpha = 0 will be this
		 * vector, and alpha = 1 will be the given one.
		 *
		 * @param {Vector4} v - The vector to interpolate towards.
		 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
		 * @return {Vector4} A reference to this vector.
		 */lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this;}/**
		 * Linearly interpolates between the given vectors, where alpha is the percent
		 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
		 * be the second one. The result is stored in this instance.
		 *
		 * @param {Vector4} v1 - The first vector.
		 * @param {Vector4} v2 - The second vector.
		 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
		 * @return {Vector4} A reference to this vector.
		 */lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;this.w=v1.w+(v2.w-v1.w)*alpha;return this;}/**
		 * Returns `true` if this vector is equal with the given one.
		 *
		 * @param {Vector4} v - The vector to test for equality.
		 * @return {boolean} Whether this vector is equal with the given one.
		 */equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;}/**
		 * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
		 * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
		 *
		 * @param {Array<number>} array - An array holding the vector component values.
		 * @param {number} [offset=0] - The offset into the array.
		 * @return {Vector4} A reference to this vector.
		 */fromArray(array,offset=0){this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this;}/**
		 * Writes the components of this vector to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the vector components.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The vector components.
		 */toArray(array=[],offset=0){array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array;}/**
		 * Sets the components of this vector from the given buffer attribute.
		 *
		 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
		 * @param {number} index - The index into the attribute.
		 * @return {Vector4} A reference to this vector.
		 */fromBufferAttribute(attribute,index){this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);this.w=attribute.getW(index);return this;}/**
		 * Sets each component of this vector to a pseudo-random value between `0` and
		 * `1`, excluding `1`.
		 *
		 * @return {Vector4} A reference to this vector.
		 */random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();this.w=Math.random();return this;}*[Symbol.iterator](){yield this.x;yield this.y;yield this.z;yield this.w;}}/**
	 * A render target is a buffer where the video card draws pixels for a scene
	 * that is being rendered in the background. It is used in different effects,
	 * such as applying postprocessing to a rendered image before displaying it
	 * on the screen.
	 *
	 * @augments EventDispatcher
	 */class RenderTarget extends EventDispatcher$1{/**
		 * Render target options.
		 *
		 * @typedef {Object} RenderTarget~Options
		 * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
		 * @property {number} [magFilter=LinearFilter] - The mag filter.
		 * @property {number} [minFilter=LinearFilter] - The min filter.
		 * @property {number} [format=RGBAFormat] - The texture format.
		 * @property {number} [type=UnsignedByteType] - The texture type.
		 * @property {?string} [internalFormat=null] - The texture's internal format.
		 * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
		 * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
		 * @property {number} [anisotropy=1] - The texture's anisotropy value.
		 * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
		 * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
		 * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
		 * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
		 * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
		 * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
		 * @property {number} [samples=0] - The MSAA samples count.
		 * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
		 * @property {number} [depth=1] - The texture depth.
		 * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
		 *//**
		 * Constructs a new render target.
		 *
		 * @param {number} [width=1] - The width of the render target.
		 * @param {number} [height=1] - The height of the render target.
		 * @param {RenderTarget~Options} [options] - The configuration object.
		 */constructor(width=1,height=1,options={}){super();options=Object.assign({generateMipmaps:false,internalFormat:null,minFilter:LinearFilter,depthBuffer:true,stencilBuffer:false,resolveDepthBuffer:true,resolveStencilBuffer:true,depthTexture:null,samples:0,count:1,depth:1,multiview:false},options);/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isRenderTarget=true;/**
			 * The width of the render target.
			 *
			 * @type {number}
			 * @default 1
			 */this.width=width;/**
			 * The height of the render target.
			 *
			 * @type {number}
			 * @default 1
			 */this.height=height;/**
			 * The depth of the render target.
			 *
			 * @type {number}
			 * @default 1
			 */this.depth=options.depth;/**
			 * A rectangular area inside the render target's viewport. Fragments that are
			 * outside the area will be discarded.
			 *
			 * @type {Vector4}
			 * @default (0,0,width,height)
			 */this.scissor=new Vector4(0,0,width,height);/**
			 * Indicates whether the scissor test should be enabled when rendering into
			 * this render target or not.
			 *
			 * @type {boolean}
			 * @default false
			 */this.scissorTest=false;/**
			 * A rectangular area representing the render target's viewport.
			 *
			 * @type {Vector4}
			 * @default (0,0,width,height)
			 */this.viewport=new Vector4(0,0,width,height);const image={width:width,height:height,depth:options.depth};const texture=new Texture(image);/**
			 * An array of textures. Each color attachment is represented as a separate texture.
			 * Has at least a single entry for the default color attachment.
			 *
			 * @type {Array<Texture>}
			 */this.textures=[];const count=options.count;for(let i=0;i<count;i++){this.textures[i]=texture.clone();this.textures[i].isRenderTargetTexture=true;this.textures[i].renderTarget=this;}this._setTextureOptions(options);/**
			 * Whether to allocate a depth buffer or not.
			 *
			 * @type {boolean}
			 * @default true
			 */this.depthBuffer=options.depthBuffer;/**
			 * Whether to allocate a stencil buffer or not.
			 *
			 * @type {boolean}
			 * @default false
			 */this.stencilBuffer=options.stencilBuffer;/**
			 * Whether to resolve the depth buffer or not.
			 *
			 * @type {boolean}
			 * @default true
			 */this.resolveDepthBuffer=options.resolveDepthBuffer;/**
			 * Whether to resolve the stencil buffer or not.
			 *
			 * @type {boolean}
			 * @default true
			 */this.resolveStencilBuffer=options.resolveStencilBuffer;this._depthTexture=null;this.depthTexture=options.depthTexture;/**
			 * The number of MSAA samples.
			 *
			 * A value of `0` disables MSAA.
			 *
			 * @type {number}
			 * @default 0
			 */this.samples=options.samples;/**
			 * Whether to this target is used in multiview rendering.
			 *
			 * @type {boolean}
			 * @default false
			 */this.multiview=options.multiview;}_setTextureOptions(options={}){const values={minFilter:LinearFilter,generateMipmaps:false,flipY:false,internalFormat:null};if(options.mapping!==undefined)values.mapping=options.mapping;if(options.wrapS!==undefined)values.wrapS=options.wrapS;if(options.wrapT!==undefined)values.wrapT=options.wrapT;if(options.wrapR!==undefined)values.wrapR=options.wrapR;if(options.magFilter!==undefined)values.magFilter=options.magFilter;if(options.minFilter!==undefined)values.minFilter=options.minFilter;if(options.format!==undefined)values.format=options.format;if(options.type!==undefined)values.type=options.type;if(options.anisotropy!==undefined)values.anisotropy=options.anisotropy;if(options.colorSpace!==undefined)values.colorSpace=options.colorSpace;if(options.flipY!==undefined)values.flipY=options.flipY;if(options.generateMipmaps!==undefined)values.generateMipmaps=options.generateMipmaps;if(options.internalFormat!==undefined)values.internalFormat=options.internalFormat;for(let i=0;i<this.textures.length;i++){const texture=this.textures[i];texture.setValues(values);}}/**
		 * The texture representing the default color attachment.
		 *
		 * @type {Texture}
		 */get texture(){return this.textures[0];}set texture(value){this.textures[0]=value;}set depthTexture(current){if(this._depthTexture!==null)this._depthTexture.renderTarget=null;if(current!==null)current.renderTarget=this;this._depthTexture=current;}/**
		 * Instead of saving the depth in a renderbuffer, a texture
		 * can be used instead which is useful for further processing
		 * e.g. in context of post-processing.
		 *
		 * @type {?DepthTexture}
		 * @default null
		 */get depthTexture(){return this._depthTexture;}/**
		 * Sets the size of this render target.
		 *
		 * @param {number} width - The width.
		 * @param {number} height - The height.
		 * @param {number} [depth=1] - The depth.
		 */setSize(width,height,depth=1){if(this.width!==width||this.height!==height||this.depth!==depth){this.width=width;this.height=height;this.depth=depth;for(let i=0,il=this.textures.length;i<il;i++){this.textures[i].image.width=width;this.textures[i].image.height=height;this.textures[i].image.depth=depth;if(this.textures[i].isData3DTexture!==true){// Fix for #31693
	// TODO: Reconsider setting isArrayTexture flag here and in the ctor of Texture.
	// Maybe a method `isArrayTexture()` or just a getter could replace a flag since
	// both are evaluated on each call?
	this.textures[i].isArrayTexture=this.textures[i].image.depth>1;}}this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);}/**
		 * Returns a new render target with copied values from this instance.
		 *
		 * @return {RenderTarget} A clone of this instance.
		 */clone(){return new this.constructor().copy(this);}/**
		 * Copies the settings of the given render target. This is a structural copy so
		 * no resources are shared between render targets after the copy. That includes
		 * all MRT textures and the depth texture.
		 *
		 * @param {RenderTarget} source - The render target to copy.
		 * @return {RenderTarget} A reference to this instance.
		 */copy(source){this.width=source.width;this.height=source.height;this.depth=source.depth;this.scissor.copy(source.scissor);this.scissorTest=source.scissorTest;this.viewport.copy(source.viewport);this.textures.length=0;for(let i=0,il=source.textures.length;i<il;i++){this.textures[i]=source.textures[i].clone();this.textures[i].isRenderTargetTexture=true;this.textures[i].renderTarget=this;// ensure image object is not shared, see #20328
	const image=Object.assign({},source.textures[i].image);this.textures[i].source=new Source(image);}this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;this.resolveDepthBuffer=source.resolveDepthBuffer;this.resolveStencilBuffer=source.resolveStencilBuffer;if(source.depthTexture!==null)this.depthTexture=source.depthTexture.clone();this.samples=source.samples;return this;}/**
		 * Frees the GPU-related resources allocated by this instance. Call this
		 * method whenever this instance is no longer used in your app.
		 *
		 * @fires RenderTarget#dispose
		 */dispose(){this.dispatchEvent({type:'dispose'});}}/**
	 * A render target used in context of {@link WebGLRenderer}.
	 *
	 * @augments RenderTarget
	 */class WebGLRenderTarget extends RenderTarget{/**
		 * Constructs a new 3D render target.
		 *
		 * @param {number} [width=1] - The width of the render target.
		 * @param {number} [height=1] - The height of the render target.
		 * @param {RenderTarget~Options} [options] - The configuration object.
		 */constructor(width=1,height=1,options={}){super(width,height,options);/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isWebGLRenderTarget=true;}}/**
	 * Creates an array of textures directly from raw buffer data.
	 *
	 * @augments Texture
	 */class DataArrayTexture extends Texture{/**
		 * Constructs a new data array texture.
		 *
		 * @param {?TypedArray} [data=null] - The buffer data.
		 * @param {number} [width=1] - The width of the texture.
		 * @param {number} [height=1] - The height of the texture.
		 * @param {number} [depth=1] - The depth of the texture.
		 */constructor(data=null,width=1,height=1,depth=1){super(null);/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isDataArrayTexture=true;/**
			 * The image definition of a data texture.
			 *
			 * @type {{data:TypedArray,width:number,height:number,depth:number}}
			 */this.image={data,width,height,depth};/**
			 * How the texture is sampled when a texel covers more than one pixel.
			 *
			 * Overwritten and set to `NearestFilter` by default.
			 *
			 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
			 * @default NearestFilter
			 */this.magFilter=NearestFilter;/**
			 * How the texture is sampled when a texel covers less than one pixel.
			 *
			 * Overwritten and set to `NearestFilter` by default.
			 *
			 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
			 * @default NearestFilter
			 */this.minFilter=NearestFilter;/**
			 * This defines how the texture is wrapped in the depth and corresponds to
			 * *W* in UVW mapping.
			 *
			 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
			 * @default ClampToEdgeWrapping
			 */this.wrapR=ClampToEdgeWrapping;/**
			 * Whether to generate mipmaps (if possible) for a texture.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */this.generateMipmaps=false;/**
			 * If set to `true`, the texture is flipped along the vertical axis when
			 * uploaded to the GPU.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */this.flipY=false;/**
			 * Specifies the alignment requirements for the start of each pixel row in memory.
			 *
			 * Overwritten and set to `1` by default.
			 *
			 * @type {boolean}
			 * @default 1
			 */this.unpackAlignment=1;/**
			 * A set of all layers which need to be updated in the texture.
			 *
			 * @type {Set<number>}
			 */this.layerUpdates=new Set();}/**
		 * Describes that a specific layer of the texture needs to be updated.
		 * Normally when {@link Texture#needsUpdate} is set to `true`, the
		 * entire data texture array is sent to the GPU. Marking specific
		 * layers will only transmit subsets of all mipmaps associated with a
		 * specific depth in the array which is often much more performant.
		 *
		 * @param {number} layerIndex - The layer index that should be updated.
		 */addLayerUpdate(layerIndex){this.layerUpdates.add(layerIndex);}/**
		 * Resets the layer updates registry.
		 */clearLayerUpdates(){this.layerUpdates.clear();}}/**
	 * Creates a three-dimensional texture from raw data, with parameters to
	 * divide it into width, height, and depth.
	 *
	 * @augments Texture
	 */class Data3DTexture extends Texture{/**
		 * Constructs a new data array texture.
		 *
		 * @param {?TypedArray} [data=null] - The buffer data.
		 * @param {number} [width=1] - The width of the texture.
		 * @param {number} [height=1] - The height of the texture.
		 * @param {number} [depth=1] - The depth of the texture.
		 */constructor(data=null,width=1,height=1,depth=1){// We're going to add .setXXX() methods for setting properties later.
	// Users can still set in Data3DTexture directly.
	//
	//	const texture = new THREE.Data3DTexture( data, width, height, depth );
	// 	texture.anisotropy = 16;
	//
	// See #14839
	super(null);/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isData3DTexture=true;/**
			 * The image definition of a data texture.
			 *
			 * @type {{data:TypedArray,width:number,height:number,depth:number}}
			 */this.image={data,width,height,depth};/**
			 * How the texture is sampled when a texel covers more than one pixel.
			 *
			 * Overwritten and set to `NearestFilter` by default.
			 *
			 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
			 * @default NearestFilter
			 */this.magFilter=NearestFilter;/**
			 * How the texture is sampled when a texel covers less than one pixel.
			 *
			 * Overwritten and set to `NearestFilter` by default.
			 *
			 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
			 * @default NearestFilter
			 */this.minFilter=NearestFilter;/**
			 * This defines how the texture is wrapped in the depth and corresponds to
			 * *W* in UVW mapping.
			 *
			 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
			 * @default ClampToEdgeWrapping
			 */this.wrapR=ClampToEdgeWrapping;/**
			 * Whether to generate mipmaps (if possible) for a texture.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */this.generateMipmaps=false;/**
			 * If set to `true`, the texture is flipped along the vertical axis when
			 * uploaded to the GPU.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */this.flipY=false;/**
			 * Specifies the alignment requirements for the start of each pixel row in memory.
			 *
			 * Overwritten and set to `1` by default.
			 *
			 * @type {boolean}
			 * @default 1
			 */this.unpackAlignment=1;}}/**
	 * Represents an axis-aligned bounding box (AABB) in 3D space.
	 */let Box3$1 = class Box3{/**
		 * Constructs a new bounding box.
		 *
		 * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
		 * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
		 */constructor(min=new Vector3$1(+Infinity,+Infinity,+Infinity),max=new Vector3$1(-Infinity,-Infinity,-Infinity)){/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isBox3=true;/**
			 * The lower boundary of the box.
			 *
			 * @type {Vector3}
			 */this.min=min;/**
			 * The upper boundary of the box.
			 *
			 * @type {Vector3}
			 */this.max=max;}/**
		 * Sets the lower and upper boundaries of this box.
		 * Please note that this method only copies the values from the given objects.
		 *
		 * @param {Vector3} min - The lower boundary of the box.
		 * @param {Vector3} max - The upper boundary of the box.
		 * @return {Box3} A reference to this bounding box.
		 */set(min,max){this.min.copy(min);this.max.copy(max);return this;}/**
		 * Sets the upper and lower bounds of this box so it encloses the position data
		 * in the given array.
		 *
		 * @param {Array<number>} array - An array holding 3D position data.
		 * @return {Box3} A reference to this bounding box.
		 */setFromArray(array){this.makeEmpty();for(let i=0,il=array.length;i<il;i+=3){this.expandByPoint(_vector$b.fromArray(array,i));}return this;}/**
		 * Sets the upper and lower bounds of this box so it encloses the position data
		 * in the given buffer attribute.
		 *
		 * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
		 * @return {Box3} A reference to this bounding box.
		 */setFromBufferAttribute(attribute){this.makeEmpty();for(let i=0,il=attribute.count;i<il;i++){this.expandByPoint(_vector$b.fromBufferAttribute(attribute,i));}return this;}/**
		 * Sets the upper and lower bounds of this box so it encloses the position data
		 * in the given array.
		 *
		 * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
		 * @return {Box3} A reference to this bounding box.
		 */setFromPoints(points){this.makeEmpty();for(let i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;}/**
		 * Centers this box on the given center vector and sets this box's width, height and
		 * depth to the given size values.
		 *
		 * @param {Vector3} center - The center of the box.
		 * @param {Vector3} size - The x, y and z dimensions of the box.
		 * @return {Box3} A reference to this bounding box.
		 */setFromCenterAndSize(center,size){const halfSize=_vector$b.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;}/**
		 * Computes the world-axis-aligned bounding box for the given 3D object
		 * (including its children), accounting for the object's, and children's,
		 * world transforms. The function may result in a larger box than strictly necessary.
		 *
		 * @param {Object3D} object - The 3D object to compute the bounding box for.
		 * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
		 * world-axis-aligned bounding box at the expense of more computation.
		 * @return {Box3} A reference to this bounding box.
		 */setFromObject(object,precise=false){this.makeEmpty();return this.expandByObject(object,precise);}/**
		 * Returns a new box with copied values from this instance.
		 *
		 * @return {Box3} A clone of this instance.
		 */clone(){return new this.constructor().copy(this);}/**
		 * Copies the values of the given box to this instance.
		 *
		 * @param {Box3} box - The box to copy.
		 * @return {Box3} A reference to this bounding box.
		 */copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;}/**
		 * Makes this box empty which means in encloses a zero space in 3D.
		 *
		 * @return {Box3} A reference to this bounding box.
		 */makeEmpty(){this.min.x=this.min.y=this.min.z=+Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this;}/**
		 * Returns true if this box includes zero points within its bounds.
		 * Note that a box with equal lower and upper bounds still includes one
		 * point, the one both bounds share.
		 *
		 * @return {boolean} Whether this box is empty or not.
		 */isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;}/**
		 * Returns the center point of this box.
		 *
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The center point.
		 */getCenter(target){return this.isEmpty()?target.set(0,0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);}/**
		 * Returns the dimensions of this box.
		 *
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The size.
		 */getSize(target){return this.isEmpty()?target.set(0,0,0):target.subVectors(this.max,this.min);}/**
		 * Expands the boundaries of this box to include the given point.
		 *
		 * @param {Vector3} point - The point that should be included by the bounding box.
		 * @return {Box3} A reference to this bounding box.
		 */expandByPoint(point){this.min.min(point);this.max.max(point);return this;}/**
		 * Expands this box equilaterally by the given vector. The width of this
		 * box will be expanded by the x component of the vector in both
		 * directions. The height of this box will be expanded by the y component of
		 * the vector in both directions. The depth of this box will be
		 * expanded by the z component of the vector in both directions.
		 *
		 * @param {Vector3} vector - The vector that should expand the bounding box.
		 * @return {Box3} A reference to this bounding box.
		 */expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;}/**
		 * Expands each dimension of the box by the given scalar. If negative, the
		 * dimensions of the box will be contracted.
		 *
		 * @param {number} scalar - The scalar value that should expand the bounding box.
		 * @return {Box3} A reference to this bounding box.
		 */expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;}/**
		 * Expands the boundaries of this box to include the given 3D object and
		 * its children, accounting for the object's, and children's, world
		 * transforms. The function may result in a larger box than strictly
		 * necessary (unless the precise parameter is set to true).
		 *
		 * @param {Object3D} object - The 3D object that should expand the bounding box.
		 * @param {boolean} precise - If set to `true`, the method expands the bounding box
		 * as little as necessary at the expense of more computation.
		 * @return {Box3} A reference to this bounding box.
		 */expandByObject(object,precise=false){// Computes the world-axis-aligned bounding box of an object (including its children),
	// accounting for both the object's, and children's, world transforms
	object.updateWorldMatrix(false,false);const geometry=object.geometry;if(geometry!==undefined){const positionAttribute=geometry.getAttribute('position');// precise AABB computation based on vertex data requires at least a position attribute.
	// instancing isn't supported so far and uses the normal (conservative) code path.
	if(precise===true&&positionAttribute!==undefined&&object.isInstancedMesh!==true){for(let i=0,l=positionAttribute.count;i<l;i++){if(object.isMesh===true){object.getVertexPosition(i,_vector$b);}else {_vector$b.fromBufferAttribute(positionAttribute,i);}_vector$b.applyMatrix4(object.matrixWorld);this.expandByPoint(_vector$b);}}else {if(object.boundingBox!==undefined){// object-level bounding box
	if(object.boundingBox===null){object.computeBoundingBox();}_box$4.copy(object.boundingBox);}else {// geometry-level bounding box
	if(geometry.boundingBox===null){geometry.computeBoundingBox();}_box$4.copy(geometry.boundingBox);}_box$4.applyMatrix4(object.matrixWorld);this.union(_box$4);}}const children=object.children;for(let i=0,l=children.length;i<l;i++){this.expandByObject(children[i],precise);}return this;}/**
		 * Returns `true` if the given point lies within or on the boundaries of this box.
		 *
		 * @param {Vector3} point - The point to test.
		 * @return {boolean} Whether the bounding box contains the given point or not.
		 */containsPoint(point){return point.x>=this.min.x&&point.x<=this.max.x&&point.y>=this.min.y&&point.y<=this.max.y&&point.z>=this.min.z&&point.z<=this.max.z;}/**
		 * Returns `true` if this bounding box includes the entirety of the given bounding box.
		 * If this box and the given one are identical, this function also returns `true`.
		 *
		 * @param {Box3} box - The bounding box to test.
		 * @return {boolean} Whether the bounding box contains the given bounding box or not.
		 */containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z;}/**
		 * Returns a point as a proportion of this box's width, height and depth.
		 *
		 * @param {Vector3} point - A point in 3D space.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} A point as a proportion of this box's width, height and depth.
		 */getParameter(point,target){// This can potentially have a divide by zero if the box
	// has a size dimension of 0.
	return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z));}/**
		 * Returns `true` if the given bounding box intersects with this bounding box.
		 *
		 * @param {Box3} box - The bounding box to test.
		 * @return {boolean} Whether the given bounding box intersects with this bounding box.
		 */intersectsBox(box){// using 6 splitting planes to rule out intersections.
	return box.max.x>=this.min.x&&box.min.x<=this.max.x&&box.max.y>=this.min.y&&box.min.y<=this.max.y&&box.max.z>=this.min.z&&box.min.z<=this.max.z;}/**
		 * Returns `true` if the given bounding sphere intersects with this bounding box.
		 *
		 * @param {Sphere} sphere - The bounding sphere to test.
		 * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
		 */intersectsSphere(sphere){// Find the point on the AABB closest to the sphere center.
	this.clampPoint(sphere.center,_vector$b);// If that point is inside the sphere, the AABB and sphere intersect.
	return _vector$b.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;}/**
		 * Returns `true` if the given plane intersects with this bounding box.
		 *
		 * @param {Plane} plane - The plane to test.
		 * @return {boolean} Whether the given plane intersects with this bounding box.
		 */intersectsPlane(plane){// We compute the minimum and maximum dot product values. If those values
	// are on the same side (back or front) of the plane, then there is no intersection.
	let min,max;if(plane.normal.x>0){min=plane.normal.x*this.min.x;max=plane.normal.x*this.max.x;}else {min=plane.normal.x*this.max.x;max=plane.normal.x*this.min.x;}if(plane.normal.y>0){min+=plane.normal.y*this.min.y;max+=plane.normal.y*this.max.y;}else {min+=plane.normal.y*this.max.y;max+=plane.normal.y*this.min.y;}if(plane.normal.z>0){min+=plane.normal.z*this.min.z;max+=plane.normal.z*this.max.z;}else {min+=plane.normal.z*this.max.z;max+=plane.normal.z*this.min.z;}return min<=-plane.constant&&max>=-plane.constant;}/**
		 * Returns `true` if the given triangle intersects with this bounding box.
		 *
		 * @param {Triangle} triangle - The triangle to test.
		 * @return {boolean} Whether the given triangle intersects with this bounding box.
		 */intersectsTriangle(triangle){if(this.isEmpty()){return false;}// compute box center and extents
	this.getCenter(_center$1);_extents$1.subVectors(this.max,_center$1);// translate triangle to aabb origin
	_v0$2.subVectors(triangle.a,_center$1);_v1$7.subVectors(triangle.b,_center$1);_v2$4.subVectors(triangle.c,_center$1);// compute edge vectors for triangle
	_f0$1.subVectors(_v1$7,_v0$2);_f1$1.subVectors(_v2$4,_v1$7);_f2$1.subVectors(_v0$2,_v2$4);// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
	// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
	// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
	let axes=[0,-_f0$1.z,_f0$1.y,0,-_f1$1.z,_f1$1.y,0,-_f2$1.z,_f2$1.y,_f0$1.z,0,-_f0$1.x,_f1$1.z,0,-_f1$1.x,_f2$1.z,0,-_f2$1.x,-_f0$1.y,_f0$1.x,0,-_f1$1.y,_f1$1.x,0,-_f2$1.y,_f2$1.x,0];if(!satForAxes$1(axes,_v0$2,_v1$7,_v2$4,_extents$1)){return false;}// test 3 face normals from the aabb
	axes=[1,0,0,0,1,0,0,0,1];if(!satForAxes$1(axes,_v0$2,_v1$7,_v2$4,_extents$1)){return false;}// finally testing the face normal of the triangle
	// use already existing triangle edge vectors here
	_triangleNormal$1.crossVectors(_f0$1,_f1$1);axes=[_triangleNormal$1.x,_triangleNormal$1.y,_triangleNormal$1.z];return satForAxes$1(axes,_v0$2,_v1$7,_v2$4,_extents$1);}/**
		 * Clamps the given point within the bounds of this box.
		 *
		 * @param {Vector3} point - The point to clamp.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The clamped point.
		 */clampPoint(point,target){return target.copy(point).clamp(this.min,this.max);}/**
		 * Returns the euclidean distance from any edge of this box to the specified point. If
		 * the given point lies inside of this box, the distance will be `0`.
		 *
		 * @param {Vector3} point - The point to compute the distance to.
		 * @return {number} The euclidean distance.
		 */distanceToPoint(point){return this.clampPoint(point,_vector$b).distanceTo(point);}/**
		 * Returns a bounding sphere that encloses this bounding box.
		 *
		 * @param {Sphere} target - The target sphere that is used to store the method's result.
		 * @return {Sphere} The bounding sphere that encloses this bounding box.
		 */getBoundingSphere(target){if(this.isEmpty()){target.makeEmpty();}else {this.getCenter(target.center);target.radius=this.getSize(_vector$b).length()*0.5;}return target;}/**
		 * Computes the intersection of this bounding box and the given one, setting the upper
		 * bound of this box to the lesser of the two boxes' upper bounds and the
		 * lower bound of this box to the greater of the two boxes' lower bounds. If
		 * there's no overlap, makes this box empty.
		 *
		 * @param {Box3} box - The bounding box to intersect with.
		 * @return {Box3} A reference to this bounding box.
		 */intersect(box){this.min.max(box.min);this.max.min(box.max);// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
	if(this.isEmpty())this.makeEmpty();return this;}/**
		 * Computes the union of this box and another and the given one, setting the upper
		 * bound of this box to the greater of the two boxes' upper bounds and the
		 * lower bound of this box to the lesser of the two boxes' lower bounds.
		 *
		 * @param {Box3} box - The bounding box that will be unioned with this instance.
		 * @return {Box3} A reference to this bounding box.
		 */union(box){this.min.min(box.min);this.max.max(box.max);return this;}/**
		 * Transforms this bounding box by the given 4x4 transformation matrix.
		 *
		 * @param {Matrix4} matrix - The transformation matrix.
		 * @return {Box3} A reference to this bounding box.
		 */applyMatrix4(matrix){// transform of empty box is an empty box.
	if(this.isEmpty())return this;// NOTE: I am using a binary pattern to specify all 2^3 combinations below
	_points$1[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000
	_points$1[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001
	_points$1[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010
	_points$1[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011
	_points$1[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100
	_points$1[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101
	_points$1[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110
	_points$1[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111
	this.setFromPoints(_points$1);return this;}/**
		 * Adds the given offset to both the upper and lower bounds of this bounding box,
		 * effectively moving it in 3D space.
		 *
		 * @param {Vector3} offset - The offset that should be used to translate the bounding box.
		 * @return {Box3} A reference to this bounding box.
		 */translate(offset){this.min.add(offset);this.max.add(offset);return this;}/**
		 * Returns `true` if this bounding box is equal with the given one.
		 *
		 * @param {Box3} box - The box to test for equality.
		 * @return {boolean} Whether this bounding box is equal with the given one.
		 */equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}/**
		 * Returns a serialized structure of the bounding box.
		 *
		 * @return {Object} Serialized structure with fields representing the object state.
		 */toJSON(){return {min:this.min.toArray(),max:this.max.toArray()};}/**
		 * Returns a serialized structure of the bounding box.
		 *
		 * @param {Object} json - The serialized json to set the box from.
		 * @return {Box3} A reference to this bounding box.
		 */fromJSON(json){this.min.fromArray(json.min);this.max.fromArray(json.max);return this;}};const _points$1=[/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1()];const _vector$b=/*@__PURE__*/new Vector3$1();const _box$4=/*@__PURE__*/new Box3$1();// triangle centered vertices
	const _v0$2=/*@__PURE__*/new Vector3$1();const _v1$7=/*@__PURE__*/new Vector3$1();const _v2$4=/*@__PURE__*/new Vector3$1();// triangle edge vectors
	const _f0$1=/*@__PURE__*/new Vector3$1();const _f1$1=/*@__PURE__*/new Vector3$1();const _f2$1=/*@__PURE__*/new Vector3$1();const _center$1=/*@__PURE__*/new Vector3$1();const _extents$1=/*@__PURE__*/new Vector3$1();const _triangleNormal$1=/*@__PURE__*/new Vector3$1();const _testAxis$1=/*@__PURE__*/new Vector3$1();function satForAxes$1(axes,v0,v1,v2,extents){for(let i=0,j=axes.length-3;i<=j;i+=3){_testAxis$1.fromArray(axes,i);// project the aabb onto the separating axis
	const r=extents.x*Math.abs(_testAxis$1.x)+extents.y*Math.abs(_testAxis$1.y)+extents.z*Math.abs(_testAxis$1.z);// project all 3 vertices of the triangle onto the separating axis
	const p0=v0.dot(_testAxis$1);const p1=v1.dot(_testAxis$1);const p2=v2.dot(_testAxis$1);// actual test, basically see if either of the most extreme of the triangle points intersects r
	if(Math.max(-Math.max(p0,p1,p2),Math.min(p0,p1,p2))>r){// points of the projected triangle are outside the projected half-length of the aabb
	// the axis is separating and we can exit
	return false;}}return true;}const _box$3=/*@__PURE__*/new Box3$1();const _v1$6=/*@__PURE__*/new Vector3$1();const _v2$3=/*@__PURE__*/new Vector3$1();/**
	 * An analytical 3D sphere defined by a center and radius. This class is mainly
	 * used as a Bounding Sphere for 3D objects.
	 */let Sphere$1 = class Sphere{/**
		 * Constructs a new sphere.
		 *
		 * @param {Vector3} [center=(0,0,0)] - The center of the sphere
		 * @param {number} [radius=-1] - The radius of the sphere.
		 */constructor(center=new Vector3$1(),radius=-1){/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isSphere=true;/**
			 * The center of the sphere
			 *
			 * @type {Vector3}
			 */this.center=center;/**
			 * The radius of the sphere.
			 *
			 * @type {number}
			 */this.radius=radius;}/**
		 * Sets the sphere's components by copying the given values.
		 *
		 * @param {Vector3} center - The center.
		 * @param {number} radius - The radius.
		 * @return {Sphere} A reference to this sphere.
		 */set(center,radius){this.center.copy(center);this.radius=radius;return this;}/**
		 * Computes the minimum bounding sphere for list of points.
		 * If the optional center point is given, it is used as the sphere's
		 * center. Otherwise, the center of the axis-aligned bounding box
		 * encompassing the points is calculated.
		 *
		 * @param {Array<Vector3>} points - A list of points in 3D space.
		 * @param {Vector3} [optionalCenter] - The center of the sphere.
		 * @return {Sphere} A reference to this sphere.
		 */setFromPoints(points,optionalCenter){const center=this.center;if(optionalCenter!==undefined){center.copy(optionalCenter);}else {_box$3.setFromPoints(points).getCenter(center);}let maxRadiusSq=0;for(let i=0,il=points.length;i<il;i++){maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i]));}this.radius=Math.sqrt(maxRadiusSq);return this;}/**
		 * Copies the values of the given sphere to this instance.
		 *
		 * @param {Sphere} sphere - The sphere to copy.
		 * @return {Sphere} A reference to this sphere.
		 */copy(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this;}/**
		 * Returns `true` if the sphere is empty (the radius set to a negative number).
		 *
		 * Spheres with a radius of `0` contain only their center point and are not
		 * considered to be empty.
		 *
		 * @return {boolean} Whether this sphere is empty or not.
		 */isEmpty(){return this.radius<0;}/**
		 * Makes this sphere empty which means in encloses a zero space in 3D.
		 *
		 * @return {Sphere} A reference to this sphere.
		 */makeEmpty(){this.center.set(0,0,0);this.radius=-1;return this;}/**
		 * Returns `true` if this sphere contains the given point inclusive of
		 * the surface of the sphere.
		 *
		 * @param {Vector3} point - The point to check.
		 * @return {boolean} Whether this sphere contains the given point or not.
		 */containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius;}/**
		 * Returns the closest distance from the boundary of the sphere to the
		 * given point. If the sphere contains the point, the distance will
		 * be negative.
		 *
		 * @param {Vector3} point - The point to compute the distance to.
		 * @return {number} The distance to the point.
		 */distanceToPoint(point){return point.distanceTo(this.center)-this.radius;}/**
		 * Returns `true` if this sphere intersects with the given one.
		 *
		 * @param {Sphere} sphere - The sphere to test.
		 * @return {boolean} Whether this sphere intersects with the given one or not.
		 */intersectsSphere(sphere){const radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;}/**
		 * Returns `true` if this sphere intersects with the given box.
		 *
		 * @param {Box3} box - The box to test.
		 * @return {boolean} Whether this sphere intersects with the given box or not.
		 */intersectsBox(box){return box.intersectsSphere(this);}/**
		 * Returns `true` if this sphere intersects with the given plane.
		 *
		 * @param {Plane} plane - The plane to test.
		 * @return {boolean} Whether this sphere intersects with the given plane or not.
		 */intersectsPlane(plane){return Math.abs(plane.distanceToPoint(this.center))<=this.radius;}/**
		 * Clamps a point within the sphere. If the point is outside the sphere, it
		 * will clamp it to the closest point on the edge of the sphere. Points
		 * already inside the sphere will not be affected.
		 *
		 * @param {Vector3} point - The plane to clamp.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The clamped point.
		 */clampPoint(point,target){const deltaLengthSq=this.center.distanceToSquared(point);target.copy(point);if(deltaLengthSq>this.radius*this.radius){target.sub(this.center).normalize();target.multiplyScalar(this.radius).add(this.center);}return target;}/**
		 * Returns a bounding box that encloses this sphere.
		 *
		 * @param {Box3} target - The target box that is used to store the method's result.
		 * @return {Box3} The bounding box that encloses this sphere.
		 */getBoundingBox(target){if(this.isEmpty()){// Empty sphere produces empty bounding box
	target.makeEmpty();return target;}target.set(this.center,this.center);target.expandByScalar(this.radius);return target;}/**
		 * Transforms this sphere with the given 4x4 transformation matrix.
		 *
		 * @param {Matrix4} matrix - The transformation matrix.
		 * @return {Sphere} A reference to this sphere.
		 */applyMatrix4(matrix){this.center.applyMatrix4(matrix);this.radius=this.radius*matrix.getMaxScaleOnAxis();return this;}/**
		 * Translates the sphere's center by the given offset.
		 *
		 * @param {Vector3} offset - The offset.
		 * @return {Sphere} A reference to this sphere.
		 */translate(offset){this.center.add(offset);return this;}/**
		 * Expands the boundaries of this sphere to include the given point.
		 *
		 * @param {Vector3} point - The point to include.
		 * @return {Sphere} A reference to this sphere.
		 */expandByPoint(point){if(this.isEmpty()){this.center.copy(point);this.radius=0;return this;}_v1$6.subVectors(point,this.center);const lengthSq=_v1$6.lengthSq();if(lengthSq>this.radius*this.radius){// calculate the minimal sphere
	const length=Math.sqrt(lengthSq);const delta=(length-this.radius)*0.5;this.center.addScaledVector(_v1$6,delta/length);this.radius+=delta;}return this;}/**
		 * Expands this sphere to enclose both the original sphere and the given sphere.
		 *
		 * @param {Sphere} sphere - The sphere to include.
		 * @return {Sphere} A reference to this sphere.
		 */union(sphere){if(sphere.isEmpty()){return this;}if(this.isEmpty()){this.copy(sphere);return this;}if(this.center.equals(sphere.center)===true){this.radius=Math.max(this.radius,sphere.radius);}else {_v2$3.subVectors(sphere.center,this.center).setLength(sphere.radius);this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));}return this;}/**
		 * Returns `true` if this sphere is equal with the given one.
		 *
		 * @param {Sphere} sphere - The sphere to test for equality.
		 * @return {boolean} Whether this bounding sphere is equal with the given one.
		 */equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius;}/**
		 * Returns a new sphere with copied values from this instance.
		 *
		 * @return {Sphere} A clone of this instance.
		 */clone(){return new this.constructor().copy(this);}/**
		 * Returns a serialized structure of the bounding sphere.
		 *
		 * @return {Object} Serialized structure with fields representing the object state.
		 */toJSON(){return {radius:this.radius,center:this.center.toArray()};}/**
		 * Returns a serialized structure of the bounding sphere.
		 *
		 * @param {Object} json - The serialized json to set the sphere from.
		 * @return {Box3} A reference to this bounding sphere.
		 */fromJSON(json){this.radius=json.radius;this.center.fromArray(json.center);return this;}};const _vector$a=/*@__PURE__*/new Vector3$1();const _segCenter=/*@__PURE__*/new Vector3$1();const _segDir=/*@__PURE__*/new Vector3$1();const _diff=/*@__PURE__*/new Vector3$1();const _edge1=/*@__PURE__*/new Vector3$1();const _edge2=/*@__PURE__*/new Vector3$1();const _normal$1=/*@__PURE__*/new Vector3$1();/**
	 * A ray that emits from an origin in a certain direction. The class is used by
	 * {@link Raycaster} to assist with raycasting. Raycasting is used for
	 * mouse picking (working out what objects in the 3D space the mouse is over)
	 * amongst other things.
	 */class Ray{/**
		 * Constructs a new ray.
		 *
		 * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
		 * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
		 */constructor(origin=new Vector3$1(),direction=new Vector3$1(0,0,-1)){/**
			 * The origin of the ray.
			 *
			 * @type {Vector3}
			 */this.origin=origin;/**
			 * The (normalized) direction of the ray.
			 *
			 * @type {Vector3}
			 */this.direction=direction;}/**
		 * Sets the ray's components by copying the given values.
		 *
		 * @param {Vector3} origin - The origin.
		 * @param {Vector3} direction - The direction.
		 * @return {Ray} A reference to this ray.
		 */set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this;}/**
		 * Copies the values of the given ray to this instance.
		 *
		 * @param {Ray} ray - The ray to copy.
		 * @return {Ray} A reference to this ray.
		 */copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this;}/**
		 * Returns a vector that is located at a given distance along this ray.
		 *
		 * @param {number} t - The distance along the ray to retrieve a position for.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} A position on the ray.
		 */at(t,target){return target.copy(this.origin).addScaledVector(this.direction,t);}/**
		 * Adjusts the direction of the ray to point at the given vector in world space.
		 *
		 * @param {Vector3} v - The target position.
		 * @return {Ray} A reference to this ray.
		 */lookAt(v){this.direction.copy(v).sub(this.origin).normalize();return this;}/**
		 * Shift the origin of this ray along its direction by the given distance.
		 *
		 * @param {number} t - The distance along the ray to interpolate.
		 * @return {Ray} A reference to this ray.
		 */recast(t){this.origin.copy(this.at(t,_vector$a));return this;}/**
		 * Returns the point along this ray that is closest to the given point.
		 *
		 * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The closest point on this ray.
		 */closestPointToPoint(point,target){target.subVectors(point,this.origin);const directionDistance=target.dot(this.direction);if(directionDistance<0){return target.copy(this.origin);}return target.copy(this.origin).addScaledVector(this.direction,directionDistance);}/**
		 * Returns the distance of the closest approach between this ray and the given point.
		 *
		 * @param {Vector3} point - A point in 3D space to compute the distance to.
		 * @return {number} The distance.
		 */distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point));}/**
		 * Returns the squared distance of the closest approach between this ray and the given point.
		 *
		 * @param {Vector3} point - A point in 3D space to compute the distance to.
		 * @return {number} The squared distance.
		 */distanceSqToPoint(point){const directionDistance=_vector$a.subVectors(point,this.origin).dot(this.direction);// point behind the ray
	if(directionDistance<0){return this.origin.distanceToSquared(point);}_vector$a.copy(this.origin).addScaledVector(this.direction,directionDistance);return _vector$a.distanceToSquared(point);}/**
		 * Returns the squared distance between this ray and the given line segment.
		 *
		 * @param {Vector3} v0 - The start point of the line segment.
		 * @param {Vector3} v1 - The end point of the line segment.
		 * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
		 * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
		 * @return {number} The squared distance.
		 */distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
	// It returns the min distance between the ray and the segment
	// defined by v0 and v1
	// It can also set two optional targets :
	// - The closest point on the ray
	// - The closest point on the segment
	_segCenter.copy(v0).add(v1).multiplyScalar(0.5);_segDir.copy(v1).sub(v0).normalize();_diff.copy(this.origin).sub(_segCenter);const segExtent=v0.distanceTo(v1)*0.5;const a01=-this.direction.dot(_segDir);const b0=_diff.dot(this.direction);const b1=-_diff.dot(_segDir);const c=_diff.lengthSq();const det=Math.abs(1-a01*a01);let s0,s1,sqrDist,extDet;if(det>0){// The ray and segment are not parallel.
	s0=a01*b1-b0;s1=a01*b0-b1;extDet=segExtent*det;if(s0>=0){if(s1>=-extDet){if(s1<=extDet){// region 0
	// Minimum at interior points of ray and segment.
	const invDet=1/det;s0*=invDet;s1*=invDet;sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;}else {// region 1
	s1=segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else {// region 5
	s1=-segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else {if(s1<=-extDet){// region 4
	s0=Math.max(0,-(-a01*segExtent+b0));s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}else if(s1<=extDet){// region 3
	s0=0;s1=Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=s1*(s1+2*b1)+c;}else {// region 2
	s0=Math.max(0,-(a01*segExtent+b0));s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}}else {// Ray and segment are parallel.
	s1=a01>0?-segExtent:segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}if(optionalPointOnRay){optionalPointOnRay.copy(this.origin).addScaledVector(this.direction,s0);}if(optionalPointOnSegment){optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir,s1);}return sqrDist;}/**
		 * Intersects this ray with the given sphere, returning the intersection
		 * point or `null` if there is no intersection.
		 *
		 * @param {Sphere} sphere - The sphere to intersect.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The intersection point.
		 */intersectSphere(sphere,target){_vector$a.subVectors(sphere.center,this.origin);const tca=_vector$a.dot(this.direction);const d2=_vector$a.dot(_vector$a)-tca*tca;const radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;const thc=Math.sqrt(radius2-d2);// t0 = first intersect point - entrance on front of sphere
	const t0=tca-thc;// t1 = second intersect point - exit point on back of sphere
	const t1=tca+thc;// test to see if t1 is behind the ray - if so, return null
	if(t1<0)return null;// test to see if t0 is behind the ray:
	// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
	// in order to always return an intersect point that is in front of the ray.
	if(t0<0)return this.at(t1,target);// else t0 is in front of the ray, so return the first collision point scaled by t0
	return this.at(t0,target);}/**
		 * Returns `true` if this ray intersects with the given sphere.
		 *
		 * @param {Sphere} sphere - The sphere to intersect.
		 * @return {boolean} Whether this ray intersects with the given sphere or not.
		 */intersectsSphere(sphere){if(sphere.radius<0)return false;// handle empty spheres, see #31187
	return this.distanceSqToPoint(sphere.center)<=sphere.radius*sphere.radius;}/**
		 * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
		 * does not intersect with the plane.
		 *
		 * @param {Plane} plane - The plane to compute the distance to.
		 * @return {?number} Whether this ray intersects with the given sphere or not.
		 */distanceToPlane(plane){const denominator=plane.normal.dot(this.direction);if(denominator===0){// line is coplanar, return origin
	if(plane.distanceToPoint(this.origin)===0){return 0;}// Null is preferable to undefined since undefined means.... it is undefined
	return null;}const t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;// Return if the ray never intersects the plane
	return t>=0?t:null;}/**
		 * Intersects this ray with the given plane, returning the intersection
		 * point or `null` if there is no intersection.
		 *
		 * @param {Plane} plane - The plane to intersect.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The intersection point.
		 */intersectPlane(plane,target){const t=this.distanceToPlane(plane);if(t===null){return null;}return this.at(t,target);}/**
		 * Returns `true` if this ray intersects with the given plane.
		 *
		 * @param {Plane} plane - The plane to intersect.
		 * @return {boolean} Whether this ray intersects with the given plane or not.
		 */intersectsPlane(plane){// check if the ray lies on the plane first
	const distToPoint=plane.distanceToPoint(this.origin);if(distToPoint===0){return true;}const denominator=plane.normal.dot(this.direction);if(denominator*distToPoint<0){return true;}// ray origin is behind the plane (and is pointing behind it)
	return false;}/**
		 * Intersects this ray with the given bounding box, returning the intersection
		 * point or `null` if there is no intersection.
		 *
		 * @param {Box3} box - The box to intersect.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The intersection point.
		 */intersectBox(box,target){let tmin,tmax,tymin,tymax,tzmin,tzmax;const invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z;const origin=this.origin;if(invdirx>=0){tmin=(box.min.x-origin.x)*invdirx;tmax=(box.max.x-origin.x)*invdirx;}else {tmin=(box.max.x-origin.x)*invdirx;tmax=(box.min.x-origin.x)*invdirx;}if(invdiry>=0){tymin=(box.min.y-origin.y)*invdiry;tymax=(box.max.y-origin.y)*invdiry;}else {tymin=(box.max.y-origin.y)*invdiry;tymax=(box.min.y-origin.y)*invdiry;}if(tmin>tymax||tymin>tmax)return null;if(tymin>tmin||isNaN(tmin))tmin=tymin;if(tymax<tmax||isNaN(tmax))tmax=tymax;if(invdirz>=0){tzmin=(box.min.z-origin.z)*invdirz;tzmax=(box.max.z-origin.z)*invdirz;}else {tzmin=(box.max.z-origin.z)*invdirz;tzmax=(box.min.z-origin.z)*invdirz;}if(tmin>tzmax||tzmin>tmax)return null;if(tzmin>tmin||tmin!==tmin)tmin=tzmin;if(tzmax<tmax||tmax!==tmax)tmax=tzmax;//return point closest to the ray (positive side)
	if(tmax<0)return null;return this.at(tmin>=0?tmin:tmax,target);}/**
		 * Returns `true` if this ray intersects with the given box.
		 *
		 * @param {Box3} box - The box to intersect.
		 * @return {boolean} Whether this ray intersects with the given box or not.
		 */intersectsBox(box){return this.intersectBox(box,_vector$a)!==null;}/**
		 * Intersects this ray with the given triangle, returning the intersection
		 * point or `null` if there is no intersection.
		 *
		 * @param {Vector3} a - The first vertex of the triangle.
		 * @param {Vector3} b - The second vertex of the triangle.
		 * @param {Vector3} c - The third vertex of the triangle.
		 * @param {boolean} backfaceCulling - Whether to use backface culling or not.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The intersection point.
		 */intersectTriangle(a,b,c,backfaceCulling,target){// Compute the offset origin, edges, and normal.
	// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
	_edge1.subVectors(b,a);_edge2.subVectors(c,a);_normal$1.crossVectors(_edge1,_edge2);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
	// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
	//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
	//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
	//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
	let DdN=this.direction.dot(_normal$1);let sign;if(DdN>0){if(backfaceCulling)return null;sign=1;}else if(DdN<0){sign=-1;DdN=-DdN;}else {return null;}_diff.subVectors(this.origin,a);const DdQxE2=sign*this.direction.dot(_edge2.crossVectors(_diff,_edge2));// b1 < 0, no intersection
	if(DdQxE2<0){return null;}const DdE1xQ=sign*this.direction.dot(_edge1.cross(_diff));// b2 < 0, no intersection
	if(DdE1xQ<0){return null;}// b1+b2 > 1, no intersection
	if(DdQxE2+DdE1xQ>DdN){return null;}// Line intersects triangle, check if ray does.
	const QdN=-sign*_diff.dot(_normal$1);// t < 0, no intersection
	if(QdN<0){return null;}// Ray intersects triangle.
	return this.at(QdN/DdN,target);}/**
		 * Transforms this ray with the given 4x4 transformation matrix.
		 *
		 * @param {Matrix4} matrix4 - The transformation matrix.
		 * @return {Ray} A reference to this ray.
		 */applyMatrix4(matrix4){this.origin.applyMatrix4(matrix4);this.direction.transformDirection(matrix4);return this;}/**
		 * Returns `true` if this ray is equal with the given one.
		 *
		 * @param {Ray} ray - The ray to test for equality.
		 * @return {boolean} Whether this ray is equal with the given one.
		 */equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);}/**
		 * Returns a new ray with copied values from this instance.
		 *
		 * @return {Ray} A clone of this instance.
		 */clone(){return new this.constructor().copy(this);}}/**
	 * Represents a 4x4 matrix.
	 *
	 * The most common use of a 4x4 matrix in 3D computer graphics is as a transformation matrix.
	 * For an introduction to transformation matrices as used in WebGL, check out [this tutorial](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices)
	 *
	 * This allows a 3D vector representing a point in 3D space to undergo
	 * transformations such as translation, rotation, shear, scale, reflection,
	 * orthogonal or perspective projection and so on, by being multiplied by the
	 * matrix. This is known as `applying` the matrix to the vector.
	 *
	 * A Note on Row-Major and Column-Major Ordering:
	 *
	 * The constructor and {@link Matrix3#set} method take arguments in
	 * [row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
	 * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
	 * This means that calling:
	 * ```js
	 * const m = new THREE.Matrix4();
	 * m.set( 11, 12, 13, 14,
	 *        21, 22, 23, 24,
	 *        31, 32, 33, 34,
	 *        41, 42, 43, 44 );
	 * ```
	 * will result in the elements array containing:
	 * ```js
	 * m.elements = [ 11, 21, 31, 41,
	 *                12, 22, 32, 42,
	 *                13, 23, 33, 43,
	 *                14, 24, 34, 44 ];
	 * ```
	 * and internally all calculations are performed using column-major ordering.
	 * However, as the actual ordering makes no difference mathematically and
	 * most people are used to thinking about matrices in row-major order, the
	 * three.js documentation shows matrices in row-major order. Just bear in
	 * mind that if you are reading the source code, you'll have to take the
	 * transpose of any matrices outlined here to make sense of the calculations.
	 */let Matrix4$1 = class Matrix4{/**
		 * Constructs a new 4x4 matrix. The arguments are supposed to be
		 * in row-major order. If no arguments are provided, the constructor
		 * initializes the matrix as an identity matrix.
		 *
		 * @param {number} [n11] - 1-1 matrix element.
		 * @param {number} [n12] - 1-2 matrix element.
		 * @param {number} [n13] - 1-3 matrix element.
		 * @param {number} [n14] - 1-4 matrix element.
		 * @param {number} [n21] - 2-1 matrix element.
		 * @param {number} [n22] - 2-2 matrix element.
		 * @param {number} [n23] - 2-3 matrix element.
		 * @param {number} [n24] - 2-4 matrix element.
		 * @param {number} [n31] - 3-1 matrix element.
		 * @param {number} [n32] - 3-2 matrix element.
		 * @param {number} [n33] - 3-3 matrix element.
		 * @param {number} [n34] - 3-4 matrix element.
		 * @param {number} [n41] - 4-1 matrix element.
		 * @param {number} [n42] - 4-2 matrix element.
		 * @param {number} [n43] - 4-3 matrix element.
		 * @param {number} [n44] - 4-4 matrix element.
		 */constructor(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */Matrix4.prototype.isMatrix4=true;/**
			 * A column-major list of matrix values.
			 *
			 * @type {Array<number>}
			 */this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];if(n11!==undefined){this.set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44);}}/**
		 * Sets the elements of the matrix.The arguments are supposed to be
		 * in row-major order.
		 *
		 * @param {number} [n11] - 1-1 matrix element.
		 * @param {number} [n12] - 1-2 matrix element.
		 * @param {number} [n13] - 1-3 matrix element.
		 * @param {number} [n14] - 1-4 matrix element.
		 * @param {number} [n21] - 2-1 matrix element.
		 * @param {number} [n22] - 2-2 matrix element.
		 * @param {number} [n23] - 2-3 matrix element.
		 * @param {number} [n24] - 2-4 matrix element.
		 * @param {number} [n31] - 3-1 matrix element.
		 * @param {number} [n32] - 3-2 matrix element.
		 * @param {number} [n33] - 3-3 matrix element.
		 * @param {number} [n34] - 3-4 matrix element.
		 * @param {number} [n41] - 4-1 matrix element.
		 * @param {number} [n42] - 4-2 matrix element.
		 * @param {number} [n43] - 4-3 matrix element.
		 * @param {number} [n44] - 4-4 matrix element.
		 * @return {Matrix4} A reference to this matrix.
		 */set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){const te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this;}/**
		 * Sets this matrix to the 4x4 identity matrix.
		 *
		 * @return {Matrix4} A reference to this matrix.
		 */identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this;}/**
		 * Returns a matrix with copied values from this instance.
		 *
		 * @return {Matrix4} A clone of this instance.
		 */clone(){return new Matrix4().fromArray(this.elements);}/**
		 * Copies the values of the given matrix to this instance.
		 *
		 * @param {Matrix4} m - The matrix to copy.
		 * @return {Matrix4} A reference to this matrix.
		 */copy(m){const te=this.elements;const me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];te[9]=me[9];te[10]=me[10];te[11]=me[11];te[12]=me[12];te[13]=me[13];te[14]=me[14];te[15]=me[15];return this;}/**
		 * Copies the translation component of the given matrix
		 * into this matrix's translation component.
		 *
		 * @param {Matrix4} m - The matrix to copy the translation component.
		 * @return {Matrix4} A reference to this matrix.
		 */copyPosition(m){const te=this.elements,me=m.elements;te[12]=me[12];te[13]=me[13];te[14]=me[14];return this;}/**
		 * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
		 *
		 * @param {Matrix3} m - The 3x3 matrix.
		 * @return {Matrix4} A reference to this matrix.
		 */setFromMatrix3(m){const me=m.elements;this.set(me[0],me[3],me[6],0,me[1],me[4],me[7],0,me[2],me[5],me[8],0,0,0,0,1);return this;}/**
		 * Extracts the basis of this matrix into the three axis vectors provided.
		 *
		 * @param {Vector3} xAxis - The basis's x axis.
		 * @param {Vector3} yAxis - The basis's y axis.
		 * @param {Vector3} zAxis - The basis's z axis.
		 * @return {Matrix4} A reference to this matrix.
		 */extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this;}/**
		 * Sets the given basis vectors to this matrix.
		 *
		 * @param {Vector3} xAxis - The basis's x axis.
		 * @param {Vector3} yAxis - The basis's y axis.
		 * @param {Vector3} zAxis - The basis's z axis.
		 * @return {Matrix4} A reference to this matrix.
		 */makeBasis(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this;}/**
		 * Extracts the rotation component of the given matrix
		 * into this matrix's rotation component.
		 *
		 * Note: This method does not support reflection matrices.
		 *
		 * @param {Matrix4} m - The matrix.
		 * @return {Matrix4} A reference to this matrix.
		 */extractRotation(m){const te=this.elements;const me=m.elements;const scaleX=1/_v1$5.setFromMatrixColumn(m,0).length();const scaleY=1/_v1$5.setFromMatrixColumn(m,1).length();const scaleZ=1/_v1$5.setFromMatrixColumn(m,2).length();te[0]=me[0]*scaleX;te[1]=me[1]*scaleX;te[2]=me[2]*scaleX;te[3]=0;te[4]=me[4]*scaleY;te[5]=me[5]*scaleY;te[6]=me[6]*scaleY;te[7]=0;te[8]=me[8]*scaleZ;te[9]=me[9]*scaleZ;te[10]=me[10]*scaleZ;te[11]=0;te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;}/**
		 * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
		 * the rotation specified by the given Euler angles. The rest of
		 * the matrix is set to the identity. Depending on the {@link Euler#order},
		 * there are six possible outcomes. See [this page](https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix)
		 * for a complete list.
		 *
		 * @param {Euler} euler - The Euler angles.
		 * @return {Matrix4} A reference to this matrix.
		 */makeRotationFromEuler(euler){const te=this.elements;const x=euler.x,y=euler.y,z=euler.z;const a=Math.cos(x),b=Math.sin(x);const c=Math.cos(y),d=Math.sin(y);const e=Math.cos(z),f=Math.sin(z);if(euler.order==='XYZ'){const ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=-c*f;te[8]=d;te[1]=af+be*d;te[5]=ae-bf*d;te[9]=-b*c;te[2]=bf-ae*d;te[6]=be+af*d;te[10]=a*c;}else if(euler.order==='YXZ'){const ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b;te[4]=de*b-cf;te[8]=a*d;te[1]=a*f;te[5]=a*e;te[9]=-b;te[2]=cf*b-de;te[6]=df+ce*b;te[10]=a*c;}else if(euler.order==='ZXY'){const ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce-df*b;te[4]=-a*f;te[8]=de+cf*b;te[1]=cf+de*b;te[5]=a*e;te[9]=df-ce*b;te[2]=-a*d;te[6]=b;te[10]=a*c;}else if(euler.order==='ZYX'){const ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=be*d-af;te[8]=ae*d+bf;te[1]=c*f;te[5]=bf*d+ae;te[9]=af*d-be;te[2]=-d;te[6]=b*c;te[10]=a*c;}else if(euler.order==='YZX'){const ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=bd-ac*f;te[8]=bc*f+ad;te[1]=f;te[5]=a*e;te[9]=-b*e;te[2]=-d*e;te[6]=ad*f+bc;te[10]=ac-bd*f;}else if(euler.order==='XZY'){const ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=-f;te[8]=d*e;te[1]=ac*f+bd;te[5]=a*e;te[9]=ad*f-bc;te[2]=bc*f-ad;te[6]=b*e;te[10]=bd*f+ac;}// bottom row
	te[3]=0;te[7]=0;te[11]=0;// last column
	te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;}/**
		 * Sets the rotation component of this matrix to the rotation specified by
		 * the given Quaternion as outlined [here](https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion)
		 * The rest of the matrix is set to the identity.
		 *
		 * @param {Quaternion} q - The Quaternion.
		 * @return {Matrix4} A reference to this matrix.
		 */makeRotationFromQuaternion(q){return this.compose(_zero$1,q,_one$1);}/**
		 * Sets the rotation component of the transformation matrix, looking from `eye` towards
		 * `target`, and oriented by the up-direction.
		 *
		 * @param {Vector3} eye - The eye vector.
		 * @param {Vector3} target - The target vector.
		 * @param {Vector3} up - The up vector.
		 * @return {Matrix4} A reference to this matrix.
		 */lookAt(eye,target,up){const te=this.elements;_z$1.subVectors(eye,target);if(_z$1.lengthSq()===0){// eye and target are in the same position
	_z$1.z=1;}_z$1.normalize();_x$1.crossVectors(up,_z$1);if(_x$1.lengthSq()===0){// up and z are parallel
	if(Math.abs(up.z)===1){_z$1.x+=0.0001;}else {_z$1.z+=0.0001;}_z$1.normalize();_x$1.crossVectors(up,_z$1);}_x$1.normalize();_y$1.crossVectors(_z$1,_x$1);te[0]=_x$1.x;te[4]=_y$1.x;te[8]=_z$1.x;te[1]=_x$1.y;te[5]=_y$1.y;te[9]=_z$1.y;te[2]=_x$1.z;te[6]=_y$1.z;te[10]=_z$1.z;return this;}/**
		 * Post-multiplies this matrix by the given 4x4 matrix.
		 *
		 * @param {Matrix4} m - The matrix to multiply with.
		 * @return {Matrix4} A reference to this matrix.
		 */multiply(m){return this.multiplyMatrices(this,m);}/**
		 * Pre-multiplies this matrix by the given 4x4 matrix.
		 *
		 * @param {Matrix4} m - The matrix to multiply with.
		 * @return {Matrix4} A reference to this matrix.
		 */premultiply(m){return this.multiplyMatrices(m,this);}/**
		 * Multiples the given 4x4 matrices and stores the result
		 * in this matrix.
		 *
		 * @param {Matrix4} a - The first matrix.
		 * @param {Matrix4} b - The second matrix.
		 * @return {Matrix4} A reference to this matrix.
		 */multiplyMatrices(a,b){const ae=a.elements;const be=b.elements;const te=this.elements;const a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];const a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];const a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];const a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];const b11=be[0],b12=be[4],b13=be[8],b14=be[12];const b21=be[1],b22=be[5],b23=be[9],b24=be[13];const b31=be[2],b32=be[6],b33=be[10],b34=be[14];const b41=be[3],b42=be[7],b43=be[11],b44=be[15];te[0]=a11*b11+a12*b21+a13*b31+a14*b41;te[4]=a11*b12+a12*b22+a13*b32+a14*b42;te[8]=a11*b13+a12*b23+a13*b33+a14*b43;te[12]=a11*b14+a12*b24+a13*b34+a14*b44;te[1]=a21*b11+a22*b21+a23*b31+a24*b41;te[5]=a21*b12+a22*b22+a23*b32+a24*b42;te[9]=a21*b13+a22*b23+a23*b33+a24*b43;te[13]=a21*b14+a22*b24+a23*b34+a24*b44;te[2]=a31*b11+a32*b21+a33*b31+a34*b41;te[6]=a31*b12+a32*b22+a33*b32+a34*b42;te[10]=a31*b13+a32*b23+a33*b33+a34*b43;te[14]=a31*b14+a32*b24+a33*b34+a34*b44;te[3]=a41*b11+a42*b21+a43*b31+a44*b41;te[7]=a41*b12+a42*b22+a43*b32+a44*b42;te[11]=a41*b13+a42*b23+a43*b33+a44*b43;te[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this;}/**
		 * Multiplies every component of the matrix by the given scalar.
		 *
		 * @param {number} s - The scalar.
		 * @return {Matrix4} A reference to this matrix.
		 */multiplyScalar(s){const te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this;}/**
		 * Computes and returns the determinant of this matrix.
		 *
		 * Based on the method outlined [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html).
		 *
		 * @return {number} The determinant.
		 */determinant(){const te=this.elements;const n11=te[0],n12=te[4],n13=te[8],n14=te[12];const n21=te[1],n22=te[5],n23=te[9],n24=te[13];const n31=te[2],n32=te[6],n33=te[10],n34=te[14];const n41=te[3],n42=te[7],n43=te[11],n44=te[15];//TODO: make this more efficient
	return n41*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+n42*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+n43*(+n11*n24*n32-n11*n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+n44*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31);}/**
		 * Transposes this matrix in place.
		 *
		 * @return {Matrix4} A reference to this matrix.
		 */transpose(){const te=this.elements;let tmp;tmp=te[1];te[1]=te[4];te[4]=tmp;tmp=te[2];te[2]=te[8];te[8]=tmp;tmp=te[6];te[6]=te[9];te[9]=tmp;tmp=te[3];te[3]=te[12];te[12]=tmp;tmp=te[7];te[7]=te[13];te[13]=tmp;tmp=te[11];te[11]=te[14];te[14]=tmp;return this;}/**
		 * Sets the position component for this matrix from the given vector,
		 * without affecting the rest of the matrix.
		 *
		 * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
		 * @param {number} y - The y component of the vector.
		 * @param {number} z - The z component of the vector.
		 * @return {Matrix4} A reference to this matrix.
		 */setPosition(x,y,z){const te=this.elements;if(x.isVector3){te[12]=x.x;te[13]=x.y;te[14]=x.z;}else {te[12]=x;te[13]=y;te[14]=z;}return this;}/**
		 * Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
		 * You can not invert with a determinant of zero. If you attempt this, the method produces
		 * a zero matrix instead.
		 *
		 * @return {Matrix4} A reference to this matrix.
		 */invert(){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
	const te=this.elements,n11=te[0],n21=te[1],n31=te[2],n41=te[3],n12=te[4],n22=te[5],n32=te[6],n42=te[7],n13=te[8],n23=te[9],n33=te[10],n43=te[11],n14=te[12],n24=te[13],n34=te[14],n44=te[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;const det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const detInv=1/det;te[0]=t11*detInv;te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;te[4]=t12*detInv;te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;te[8]=t13*detInv;te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;te[12]=t14*detInv;te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this;}/**
		 * Multiplies the columns of this matrix by the given vector.
		 *
		 * @param {Vector3} v - The scale vector.
		 * @return {Matrix4} A reference to this matrix.
		 */scale(v){const te=this.elements;const x=v.x,y=v.y,z=v.z;te[0]*=x;te[4]*=y;te[8]*=z;te[1]*=x;te[5]*=y;te[9]*=z;te[2]*=x;te[6]*=y;te[10]*=z;te[3]*=x;te[7]*=y;te[11]*=z;return this;}/**
		 * Gets the maximum scale value of the three axes.
		 *
		 * @return {number} The maximum scale.
		 */getMaxScaleOnAxis(){const te=this.elements;const scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];const scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];const scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));}/**
		 * Sets this matrix as a translation transform from the given vector.
		 *
		 * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
		 * @param {number} y - The amount to translate in the Y axis.
		 * @param {number} z - The amount to translate in the z axis.
		 * @return {Matrix4} A reference to this matrix.
		 */makeTranslation(x,y,z){if(x.isVector3){this.set(1,0,0,x.x,0,1,0,x.y,0,0,1,x.z,0,0,0,1);}else {this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1);}return this;}/**
		 * Sets this matrix as a rotational transformation around the X axis by
		 * the given angle.
		 *
		 * @param {number} theta - The rotation in radians.
		 * @return {Matrix4} A reference to this matrix.
		 */makeRotationX(theta){const c=Math.cos(theta),s=Math.sin(theta);this.set(1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1);return this;}/**
		 * Sets this matrix as a rotational transformation around the Y axis by
		 * the given angle.
		 *
		 * @param {number} theta - The rotation in radians.
		 * @return {Matrix4} A reference to this matrix.
		 */makeRotationY(theta){const c=Math.cos(theta),s=Math.sin(theta);this.set(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);return this;}/**
		 * Sets this matrix as a rotational transformation around the Z axis by
		 * the given angle.
		 *
		 * @param {number} theta - The rotation in radians.
		 * @return {Matrix4} A reference to this matrix.
		 */makeRotationZ(theta){const c=Math.cos(theta),s=Math.sin(theta);this.set(c,-s,0,0,s,c,0,0,0,0,1,0,0,0,0,1);return this;}/**
		 * Sets this matrix as a rotational transformation around the given axis by
		 * the given angle.
		 *
		 * This is a somewhat controversial but mathematically sound alternative to
		 * rotating via Quaternions. See the discussion [here](https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199).
		 *
		 * @param {Vector3} axis - The normalized rotation axis.
		 * @param {number} angle - The rotation in radians.
		 * @return {Matrix4} A reference to this matrix.
		 */makeRotationAxis(axis,angle){// Based on http://www.gamedev.net/reference/articles/article1199.asp
	const c=Math.cos(angle);const s=Math.sin(angle);const t=1-c;const x=axis.x,y=axis.y,z=axis.z;const tx=t*x,ty=t*y;this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1);return this;}/**
		 * Sets this matrix as a scale transformation.
		 *
		 * @param {number} x - The amount to scale in the X axis.
		 * @param {number} y - The amount to scale in the Y axis.
		 * @param {number} z - The amount to scale in the Z axis.
		 * @return {Matrix4} A reference to this matrix.
		 */makeScale(x,y,z){this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);return this;}/**
		 * Sets this matrix as a shear transformation.
		 *
		 * @param {number} xy - The amount to shear X by Y.
		 * @param {number} xz - The amount to shear X by Z.
		 * @param {number} yx - The amount to shear Y by X.
		 * @param {number} yz - The amount to shear Y by Z.
		 * @param {number} zx - The amount to shear Z by X.
		 * @param {number} zy - The amount to shear Z by Y.
		 * @return {Matrix4} A reference to this matrix.
		 */makeShear(xy,xz,yx,yz,zx,zy){this.set(1,yx,zx,0,xy,1,zy,0,xz,yz,1,0,0,0,0,1);return this;}/**
		 * Sets this matrix to the transformation composed of the given position,
		 * rotation (Quaternion) and scale.
		 *
		 * @param {Vector3} position - The position vector.
		 * @param {Quaternion} quaternion - The rotation as a Quaternion.
		 * @param {Vector3} scale - The scale vector.
		 * @return {Matrix4} A reference to this matrix.
		 */compose(position,quaternion,scale){const te=this.elements;const x=quaternion._x,y=quaternion._y,z=quaternion._z,w=quaternion._w;const x2=x+x,y2=y+y,z2=z+z;const xx=x*x2,xy=x*y2,xz=x*z2;const yy=y*y2,yz=y*z2,zz=z*z2;const wx=w*x2,wy=w*y2,wz=w*z2;const sx=scale.x,sy=scale.y,sz=scale.z;te[0]=(1-(yy+zz))*sx;te[1]=(xy+wz)*sx;te[2]=(xz-wy)*sx;te[3]=0;te[4]=(xy-wz)*sy;te[5]=(1-(xx+zz))*sy;te[6]=(yz+wx)*sy;te[7]=0;te[8]=(xz+wy)*sz;te[9]=(yz-wx)*sz;te[10]=(1-(xx+yy))*sz;te[11]=0;te[12]=position.x;te[13]=position.y;te[14]=position.z;te[15]=1;return this;}/**
		 * Decomposes this matrix into its position, rotation and scale components
		 * and provides the result in the given objects.
		 *
		 * Note: Not all matrices are decomposable in this way. For example, if an
		 * object has a non-uniformly scaled parent, then the object's world matrix
		 * may not be decomposable, and this method may not be appropriate.
		 *
		 * @param {Vector3} position - The position vector.
		 * @param {Quaternion} quaternion - The rotation as a Quaternion.
		 * @param {Vector3} scale - The scale vector.
		 * @return {Matrix4} A reference to this matrix.
		 */decompose(position,quaternion,scale){const te=this.elements;let sx=_v1$5.set(te[0],te[1],te[2]).length();const sy=_v1$5.set(te[4],te[5],te[6]).length();const sz=_v1$5.set(te[8],te[9],te[10]).length();// if determine is negative, we need to invert one scale
	const det=this.determinant();if(det<0)sx=-sx;position.x=te[12];position.y=te[13];position.z=te[14];// scale the rotation part
	_m1$2$1.copy(this);const invSX=1/sx;const invSY=1/sy;const invSZ=1/sz;_m1$2$1.elements[0]*=invSX;_m1$2$1.elements[1]*=invSX;_m1$2$1.elements[2]*=invSX;_m1$2$1.elements[4]*=invSY;_m1$2$1.elements[5]*=invSY;_m1$2$1.elements[6]*=invSY;_m1$2$1.elements[8]*=invSZ;_m1$2$1.elements[9]*=invSZ;_m1$2$1.elements[10]*=invSZ;quaternion.setFromRotationMatrix(_m1$2$1);scale.x=sx;scale.y=sy;scale.z=sz;return this;}/**
		 * Creates a perspective projection matrix. This is used internally by
		 * {@link PerspectiveCamera#updateProjectionMatrix}.

		 * @param {number} left - Left boundary of the viewing frustum at the near plane.
		 * @param {number} right - Right boundary of the viewing frustum at the near plane.
		 * @param {number} top - Top boundary of the viewing frustum at the near plane.
		 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
		 * @param {number} near - The distance from the camera to the near plane.
		 * @param {number} far - The distance from the camera to the far plane.
		 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
		 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
		 * @return {Matrix4} A reference to this matrix.
		 */makePerspective(left,right,top,bottom,near,far,coordinateSystem=WebGLCoordinateSystem$1,reversedDepth=false){const te=this.elements;const x=2*near/(right-left);const y=2*near/(top-bottom);const a=(right+left)/(right-left);const b=(top+bottom)/(top-bottom);let c,d;if(reversedDepth){c=near/(far-near);d=far*near/(far-near);}else {if(coordinateSystem===WebGLCoordinateSystem$1){c=-(far+near)/(far-near);d=-2*far*near/(far-near);}else if(coordinateSystem===WebGPUCoordinateSystem$1){c=-far/(far-near);d=-far*near/(far-near);}else {throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: '+coordinateSystem);}}te[0]=x;te[4]=0;te[8]=a;te[12]=0;te[1]=0;te[5]=y;te[9]=b;te[13]=0;te[2]=0;te[6]=0;te[10]=c;te[14]=d;te[3]=0;te[7]=0;te[11]=-1;te[15]=0;return this;}/**
		 * Creates a orthographic projection matrix. This is used internally by
		 * {@link OrthographicCamera#updateProjectionMatrix}.

		 * @param {number} left - Left boundary of the viewing frustum at the near plane.
		 * @param {number} right - Right boundary of the viewing frustum at the near plane.
		 * @param {number} top - Top boundary of the viewing frustum at the near plane.
		 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
		 * @param {number} near - The distance from the camera to the near plane.
		 * @param {number} far - The distance from the camera to the far plane.
		 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
		 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
		 * @return {Matrix4} A reference to this matrix.
		 */makeOrthographic(left,right,top,bottom,near,far,coordinateSystem=WebGLCoordinateSystem$1,reversedDepth=false){const te=this.elements;const x=2/(right-left);const y=2/(top-bottom);const a=-(right+left)/(right-left);const b=-(top+bottom)/(top-bottom);let c,d;if(reversedDepth){c=1/(far-near);d=far/(far-near);}else {if(coordinateSystem===WebGLCoordinateSystem$1){c=-2/(far-near);d=-(far+near)/(far-near);}else if(coordinateSystem===WebGPUCoordinateSystem$1){c=-1/(far-near);d=-near/(far-near);}else {throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: '+coordinateSystem);}}te[0]=x;te[4]=0;te[8]=0;te[12]=a;te[1]=0;te[5]=y;te[9]=0;te[13]=b;te[2]=0;te[6]=0;te[10]=c;te[14]=d;te[3]=0;te[7]=0;te[11]=0;te[15]=1;return this;}/**
		 * Returns `true` if this matrix is equal with the given one.
		 *
		 * @param {Matrix4} matrix - The matrix to test for equality.
		 * @return {boolean} Whether this matrix is equal with the given one.
		 */equals(matrix){const te=this.elements;const me=matrix.elements;for(let i=0;i<16;i++){if(te[i]!==me[i])return false;}return true;}/**
		 * Sets the elements of the matrix from the given array.
		 *
		 * @param {Array<number>} array - The matrix elements in column-major order.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Matrix4} A reference to this matrix.
		 */fromArray(array,offset=0){for(let i=0;i<16;i++){this.elements[i]=array[i+offset];}return this;}/**
		 * Writes the elements of this matrix to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The matrix elements in column-major order.
		 */toArray(array=[],offset=0){const te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];array[offset+9]=te[9];array[offset+10]=te[10];array[offset+11]=te[11];array[offset+12]=te[12];array[offset+13]=te[13];array[offset+14]=te[14];array[offset+15]=te[15];return array;}};const _v1$5=/*@__PURE__*/new Vector3$1();const _m1$2$1=/*@__PURE__*/new Matrix4$1();const _zero$1=/*@__PURE__*/new Vector3$1(0,0,0);const _one$1=/*@__PURE__*/new Vector3$1(1,1,1);const _x$1=/*@__PURE__*/new Vector3$1();const _y$1=/*@__PURE__*/new Vector3$1();const _z$1=/*@__PURE__*/new Vector3$1();const _matrix$2=/*@__PURE__*/new Matrix4$1();const _quaternion$3=/*@__PURE__*/new Quaternion$1();/**
	 * A class representing Euler angles.
	 *
	 * Euler angles describe a rotational transformation by rotating an object on
	 * its various axes in specified amounts per axis, and a specified axis
	 * order.
	 *
	 * Iterating through an instance will yield its components (x, y, z,
	 * order) in the corresponding order.
	 *
	 * ```js
	 * const a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );
	 * const b = new THREE.Vector3( 1, 0, 1 );
	 * b.applyEuler(a);
	 * ```
	 */let Euler$1 = class Euler{/**
		 * Constructs a new euler instance.
		 *
		 * @param {number} [x=0] - The angle of the x axis in radians.
		 * @param {number} [y=0] - The angle of the y axis in radians.
		 * @param {number} [z=0] - The angle of the z axis in radians.
		 * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
		 */constructor(x=0,y=0,z=0,order=Euler.DEFAULT_ORDER){/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isEuler=true;this._x=x;this._y=y;this._z=z;this._order=order;}/**
		 * The angle of the x axis in radians.
		 *
		 * @type {number}
		 * @default 0
		 */get x(){return this._x;}set x(value){this._x=value;this._onChangeCallback();}/**
		 * The angle of the y axis in radians.
		 *
		 * @type {number}
		 * @default 0
		 */get y(){return this._y;}set y(value){this._y=value;this._onChangeCallback();}/**
		 * The angle of the z axis in radians.
		 *
		 * @type {number}
		 * @default 0
		 */get z(){return this._z;}set z(value){this._z=value;this._onChangeCallback();}/**
		 * A string representing the order that the rotations are applied.
		 *
		 * @type {string}
		 * @default 'XYZ'
		 */get order(){return this._order;}set order(value){this._order=value;this._onChangeCallback();}/**
		 * Sets the Euler components.
		 *
		 * @param {number} x - The angle of the x axis in radians.
		 * @param {number} y - The angle of the y axis in radians.
		 * @param {number} z - The angle of the z axis in radians.
		 * @param {string} [order] - A string representing the order that the rotations are applied.
		 * @return {Euler} A reference to this Euler instance.
		 */set(x,y,z,order=this._order){this._x=x;this._y=y;this._z=z;this._order=order;this._onChangeCallback();return this;}/**
		 * Returns a new Euler instance with copied values from this instance.
		 *
		 * @return {Euler} A clone of this instance.
		 */clone(){return new this.constructor(this._x,this._y,this._z,this._order);}/**
		 * Copies the values of the given Euler instance to this instance.
		 *
		 * @param {Euler} euler - The Euler instance to copy.
		 * @return {Euler} A reference to this Euler instance.
		 */copy(euler){this._x=euler._x;this._y=euler._y;this._z=euler._z;this._order=euler._order;this._onChangeCallback();return this;}/**
		 * Sets the angles of this Euler instance from a pure rotation matrix.
		 *
		 * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
		 * @param {string} [order] - A string representing the order that the rotations are applied.
		 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
		 * @return {Euler} A reference to this Euler instance.
		 */setFromRotationMatrix(m,order=this._order,update=true){const te=m.elements;const m11=te[0],m12=te[4],m13=te[8];const m21=te[1],m22=te[5],m23=te[9];const m31=te[2],m32=te[6],m33=te[10];switch(order){case 'XYZ':this._y=Math.asin(clamp$1(m13,-1,1));if(Math.abs(m13)<0.9999999){this._x=Math.atan2(-m23,m33);this._z=Math.atan2(-m12,m11);}else {this._x=Math.atan2(m32,m22);this._z=0;}break;case 'YXZ':this._x=Math.asin(-clamp$1(m23,-1,1));if(Math.abs(m23)<0.9999999){this._y=Math.atan2(m13,m33);this._z=Math.atan2(m21,m22);}else {this._y=Math.atan2(-m31,m11);this._z=0;}break;case 'ZXY':this._x=Math.asin(clamp$1(m32,-1,1));if(Math.abs(m32)<0.9999999){this._y=Math.atan2(-m31,m33);this._z=Math.atan2(-m12,m22);}else {this._y=0;this._z=Math.atan2(m21,m11);}break;case 'ZYX':this._y=Math.asin(-clamp$1(m31,-1,1));if(Math.abs(m31)<0.9999999){this._x=Math.atan2(m32,m33);this._z=Math.atan2(m21,m11);}else {this._x=0;this._z=Math.atan2(-m12,m22);}break;case 'YZX':this._z=Math.asin(clamp$1(m21,-1,1));if(Math.abs(m21)<0.9999999){this._x=Math.atan2(-m23,m22);this._y=Math.atan2(-m31,m11);}else {this._x=0;this._y=Math.atan2(m13,m33);}break;case 'XZY':this._z=Math.asin(-clamp$1(m12,-1,1));if(Math.abs(m12)<0.9999999){this._x=Math.atan2(m32,m22);this._y=Math.atan2(m13,m11);}else {this._x=Math.atan2(-m23,m33);this._y=0;}break;default:warn$1('Euler: .setFromRotationMatrix() encountered an unknown order: '+order);}this._order=order;if(update===true)this._onChangeCallback();return this;}/**
		 * Sets the angles of this Euler instance from a normalized quaternion.
		 *
		 * @param {Quaternion} q - A normalized Quaternion.
		 * @param {string} [order] - A string representing the order that the rotations are applied.
		 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
		 * @return {Euler} A reference to this Euler instance.
		 */setFromQuaternion(q,order,update){_matrix$2.makeRotationFromQuaternion(q);return this.setFromRotationMatrix(_matrix$2,order,update);}/**
		 * Sets the angles of this Euler instance from the given vector.
		 *
		 * @param {Vector3} v - The vector.
		 * @param {string} [order] - A string representing the order that the rotations are applied.
		 * @return {Euler} A reference to this Euler instance.
		 */setFromVector3(v,order=this._order){return this.set(v.x,v.y,v.z,order);}/**
		 * Resets the euler angle with a new order by creating a quaternion from this
		 * euler angle and then setting this euler angle with the quaternion and the
		 * new order.
		 *
		 * Warning: This discards revolution information.
		 *
		 * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
		 * @return {Euler} A reference to this Euler instance.
		 */reorder(newOrder){_quaternion$3.setFromEuler(this);return this.setFromQuaternion(_quaternion$3,newOrder);}/**
		 * Returns `true` if this Euler instance is equal with the given one.
		 *
		 * @param {Euler} euler - The Euler instance to test for equality.
		 * @return {boolean} Whether this Euler instance is equal with the given one.
		 */equals(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;}/**
		 * Sets this Euler instance's components to values from the given array. The first three
		 * entries of the array are assign to the x,y and z components. An optional fourth entry
		 * defines the Euler order.
		 *
		 * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
		 * @return {Euler} A reference to this Euler instance.
		 */fromArray(array){this._x=array[0];this._y=array[1];this._z=array[2];if(array[3]!==undefined)this._order=array[3];this._onChangeCallback();return this;}/**
		 * Writes the components of this Euler instance to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number,number,number,string>} The Euler components.
		 */toArray(array=[],offset=0){array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._order;return array;}_onChange(callback){this._onChangeCallback=callback;return this;}_onChangeCallback(){}*[Symbol.iterator](){yield this._x;yield this._y;yield this._z;yield this._order;}};/**
	 * The default Euler angle order.
	 *
	 * @static
	 * @type {string}
	 * @default 'XYZ'
	 */Euler$1.DEFAULT_ORDER='XYZ';/**
	 * A layers object assigns an 3D object to 1 or more of 32
	 * layers numbered `0` to `31` - internally the layers are stored as a
	 * bit mask], and by default all 3D objects are a member of layer `0`.
	 *
	 * This can be used to control visibility - an object must share a layer with
	 * a camera to be visible when that camera's view is
	 * rendered.
	 *
	 * All classes that inherit from {@link Object3D} have an `layers` property which
	 * is an instance of this class.
	 */let Layers$1 = class Layers{/**
		 * Constructs a new layers instance, with membership
		 * initially set to layer `0`.
		 */constructor(){/**
			 * A bit mask storing which of the 32 layers this layers object is currently
			 * a member of.
			 *
			 * @type {number}
			 */this.mask=1|0;}/**
		 * Sets membership to the given layer, and remove membership all other layers.
		 *
		 * @param {number} layer - The layer to set.
		 */set(layer){this.mask=(1<<layer|0)>>>0;}/**
		 * Adds membership of the given layer.
		 *
		 * @param {number} layer - The layer to enable.
		 */enable(layer){this.mask|=1<<layer|0;}/**
		 * Adds membership to all layers.
		 */enableAll(){this.mask=0xffffffff|0;}/**
		 * Toggles the membership of the given layer.
		 *
		 * @param {number} layer - The layer to toggle.
		 */toggle(layer){this.mask^=1<<layer|0;}/**
		 * Removes membership of the given layer.
		 *
		 * @param {number} layer - The layer to enable.
		 */disable(layer){this.mask&=~(1<<layer|0);}/**
		 * Removes the membership from all layers.
		 */disableAll(){this.mask=0;}/**
		 * Returns `true` if this and the given layers object have at least one
		 * layer in common.
		 *
		 * @param {Layers} layers - The layers to test.
		 * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
		 */test(layers){return (this.mask&layers.mask)!==0;}/**
		 * Returns `true` if the given layer is enabled.
		 *
		 * @param {number} layer - The layer to test.
		 * @return {boolean } Whether the given layer is enabled or not.
		 */isEnabled(layer){return (this.mask&(1<<layer|0))!==0;}};let _object3DId$1=0;const _v1$4=/*@__PURE__*/new Vector3$1();const _q1$1=/*@__PURE__*/new Quaternion$1();const _m1$1$2=/*@__PURE__*/new Matrix4$1();const _target$1=/*@__PURE__*/new Vector3$1();const _position$3=/*@__PURE__*/new Vector3$1();const _scale$2=/*@__PURE__*/new Vector3$1();const _quaternion$2$1=/*@__PURE__*/new Quaternion$1();const _xAxis$1=/*@__PURE__*/new Vector3$1(1,0,0);const _yAxis$1=/*@__PURE__*/new Vector3$1(0,1,0);const _zAxis$1=/*@__PURE__*/new Vector3$1(0,0,1);/**
	 * Fires when the object has been added to its parent object.
	 *
	 * @event Object3D#added
	 * @type {Object}
	 */const _addedEvent$1={type:'added'};/**
	 * Fires when the object has been removed from its parent object.
	 *
	 * @event Object3D#removed
	 * @type {Object}
	 */const _removedEvent$1={type:'removed'};/**
	 * Fires when a new child object has been added.
	 *
	 * @event Object3D#childadded
	 * @type {Object}
	 */const _childaddedEvent$1={type:'childadded',child:null};/**
	 * Fires when a child object has been removed.
	 *
	 * @event Object3D#childremoved
	 * @type {Object}
	 */const _childremovedEvent$1={type:'childremoved',child:null};/**
	 * This is the base class for most objects in three.js and provides a set of
	 * properties and methods for manipulating objects in 3D space.
	 *
	 * @augments EventDispatcher
	 */let Object3D$1 = class Object3D extends EventDispatcher$1{/**
		 * Constructs a new 3D object.
		 */constructor(){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isObject3D=true;/**
			 * The ID of the 3D object.
			 *
			 * @name Object3D#id
			 * @type {number}
			 * @readonly
			 */Object.defineProperty(this,'id',{value:_object3DId$1++});/**
			 * The UUID of the 3D object.
			 *
			 * @type {string}
			 * @readonly
			 */this.uuid=generateUUID$1();/**
			 * The name of the 3D object.
			 *
			 * @type {string}
			 */this.name='';/**
			 * The type property is used for detecting the object type
			 * in context of serialization/deserialization.
			 *
			 * @type {string}
			 * @readonly
			 */this.type='Object3D';/**
			 * A reference to the parent object.
			 *
			 * @type {?Object3D}
			 * @default null
			 */this.parent=null;/**
			 * An array holding the child 3D objects of this instance.
			 *
			 * @type {Array<Object3D>}
			 */this.children=[];/**
			 * Defines the `up` direction of the 3D object which influences
			 * the orientation via methods like {@link Object3D#lookAt}.
			 *
			 * The default values for all 3D objects is defined by `Object3D.DEFAULT_UP`.
			 *
			 * @type {Vector3}
			 */this.up=Object3D.DEFAULT_UP.clone();const position=new Vector3$1();const rotation=new Euler$1();const quaternion=new Quaternion$1();const scale=new Vector3$1(1,1,1);function onRotationChange(){quaternion.setFromEuler(rotation,false);}function onQuaternionChange(){rotation.setFromQuaternion(quaternion,undefined,false);}rotation._onChange(onRotationChange);quaternion._onChange(onQuaternionChange);Object.defineProperties(this,{/**
				 * Represents the object's local position.
				 *
				 * @name Object3D#position
				 * @type {Vector3}
				 * @default (0,0,0)
				 */position:{configurable:true,enumerable:true,value:position},/**
				 * Represents the object's local rotation as Euler angles, in radians.
				 *
				 * @name Object3D#rotation
				 * @type {Euler}
				 * @default (0,0,0)
				 */rotation:{configurable:true,enumerable:true,value:rotation},/**
				 * Represents the object's local rotation as Quaternions.
				 *
				 * @name Object3D#quaternion
				 * @type {Quaternion}
				 */quaternion:{configurable:true,enumerable:true,value:quaternion},/**
				 * Represents the object's local scale.
				 *
				 * @name Object3D#scale
				 * @type {Vector3}
				 * @default (1,1,1)
				 */scale:{configurable:true,enumerable:true,value:scale},/**
				 * Represents the object's model-view matrix.
				 *
				 * @name Object3D#modelViewMatrix
				 * @type {Matrix4}
				 */modelViewMatrix:{value:new Matrix4$1()},/**
				 * Represents the object's normal matrix.
				 *
				 * @name Object3D#normalMatrix
				 * @type {Matrix3}
				 */normalMatrix:{value:new Matrix3$1()}});/**
			 * Represents the object's transformation matrix in local space.
			 *
			 * @type {Matrix4}
			 */this.matrix=new Matrix4$1();/**
			 * Represents the object's transformation matrix in world space.
			 * If the 3D object has no parent, then it's identical to the local transformation matrix
			 *
			 * @type {Matrix4}
			 */this.matrixWorld=new Matrix4$1();/**
			 * When set to `true`, the engine automatically computes the local matrix from position,
			 * rotation and scale every frame.
			 *
			 * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_AUTO_UPDATE`.
			 *
			 * @type {boolean}
			 * @default true
			 */this.matrixAutoUpdate=Object3D.DEFAULT_MATRIX_AUTO_UPDATE;/**
			 * When set to `true`, the engine automatically computes the world matrix from the current local
			 * matrix and the object's transformation hierarchy.
			 *
			 * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE`.
			 *
			 * @type {boolean}
			 * @default true
			 */this.matrixWorldAutoUpdate=Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;// checked by the renderer
	/**
			 * When set to `true`, it calculates the world matrix in that frame and resets this property
			 * to `false`.
			 *
			 * @type {boolean}
			 * @default false
			 */this.matrixWorldNeedsUpdate=false;/**
			 * The layer membership of the 3D object. The 3D object is only visible if it has
			 * at least one layer in common with the camera in use. This property can also be
			 * used to filter out unwanted objects in ray-intersection tests when using {@link Raycaster}.
			 *
			 * @type {Layers}
			 */this.layers=new Layers$1();/**
			 * When set to `true`, the 3D object gets rendered.
			 *
			 * @type {boolean}
			 * @default true
			 */this.visible=true;/**
			 * When set to `true`, the 3D object gets rendered into shadow maps.
			 *
			 * @type {boolean}
			 * @default false
			 */this.castShadow=false;/**
			 * When set to `true`, the 3D object is affected by shadows in the scene.
			 *
			 * @type {boolean}
			 * @default false
			 */this.receiveShadow=false;/**
			 * When set to `true`, the 3D object is honored by view frustum culling.
			 *
			 * @type {boolean}
			 * @default true
			 */this.frustumCulled=true;/**
			 * This value allows the default rendering order of scene graph objects to be
			 * overridden although opaque and transparent objects remain sorted independently.
			 * When this property is set for an instance of {@link Group},all descendants
			 * objects will be sorted and rendered together. Sorting is from lowest to highest
			 * render order.
			 *
			 * @type {number}
			 * @default 0
			 */this.renderOrder=0;/**
			 * An array holding the animation clips of the 3D object.
			 *
			 * @type {Array<AnimationClip>}
			 */this.animations=[];/**
			 * Custom depth material to be used when rendering to the depth map. Can only be used
			 * in context of meshes. When shadow-casting with a {@link DirectionalLight} or {@link SpotLight},
			 * if you are modifying vertex positions in the vertex shader you must specify a custom depth
			 * material for proper shadows.
			 *
			 * Only relevant in context of {@link WebGLRenderer}.
			 *
			 * @type {(Material|undefined)}
			 * @default undefined
			 */this.customDepthMaterial=undefined;/**
			 * Same as {@link Object3D#customDepthMaterial}, but used with {@link PointLight}.
			 *
			 * Only relevant in context of {@link WebGLRenderer}.
			 *
			 * @type {(Material|undefined)}
			 * @default undefined
			 */this.customDistanceMaterial=undefined;/**
			 * An object that can be used to store custom data about the 3D object. It
			 * should not hold references to functions as these will not be cloned.
			 *
			 * @type {Object}
			 */this.userData={};}/**
		 * A callback that is executed immediately before a 3D object is rendered to a shadow map.
		 *
		 * @param {Renderer|WebGLRenderer} renderer - The renderer.
		 * @param {Object3D} object - The 3D object.
		 * @param {Camera} camera - The camera that is used to render the scene.
		 * @param {Camera} shadowCamera - The shadow camera.
		 * @param {BufferGeometry} geometry - The 3D object's geometry.
		 * @param {Material} depthMaterial - The depth material.
		 * @param {Object} group - The geometry group data.
		 */onBeforeShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */){}/**
		 * A callback that is executed immediately after a 3D object is rendered to a shadow map.
		 *
		 * @param {Renderer|WebGLRenderer} renderer - The renderer.
		 * @param {Object3D} object - The 3D object.
		 * @param {Camera} camera - The camera that is used to render the scene.
		 * @param {Camera} shadowCamera - The shadow camera.
		 * @param {BufferGeometry} geometry - The 3D object's geometry.
		 * @param {Material} depthMaterial - The depth material.
		 * @param {Object} group - The geometry group data.
		 */onAfterShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */){}/**
		 * A callback that is executed immediately before a 3D object is rendered.
		 *
		 * @param {Renderer|WebGLRenderer} renderer - The renderer.
		 * @param {Object3D} object - The 3D object.
		 * @param {Camera} camera - The camera that is used to render the scene.
		 * @param {BufferGeometry} geometry - The 3D object's geometry.
		 * @param {Material} material - The 3D object's material.
		 * @param {Object} group - The geometry group data.
		 */onBeforeRender(/* renderer, scene, camera, geometry, material, group */){}/**
		 * A callback that is executed immediately after a 3D object is rendered.
		 *
		 * @param {Renderer|WebGLRenderer} renderer - The renderer.
		 * @param {Object3D} object - The 3D object.
		 * @param {Camera} camera - The camera that is used to render the scene.
		 * @param {BufferGeometry} geometry - The 3D object's geometry.
		 * @param {Material} material - The 3D object's material.
		 * @param {Object} group - The geometry group data.
		 */onAfterRender(/* renderer, scene, camera, geometry, material, group */){}/**
		 * Applies the given transformation matrix to the object and updates the object's position,
		 * rotation and scale.
		 *
		 * @param {Matrix4} matrix - The transformation matrix.
		 */applyMatrix4(matrix){if(this.matrixAutoUpdate)this.updateMatrix();this.matrix.premultiply(matrix);this.matrix.decompose(this.position,this.quaternion,this.scale);}/**
		 * Applies a rotation represented by given the quaternion to the 3D object.
		 *
		 * @param {Quaternion} q - The quaternion.
		 * @return {Object3D} A reference to this instance.
		 */applyQuaternion(q){this.quaternion.premultiply(q);return this;}/**
		 * Sets the given rotation represented as an axis/angle couple to the 3D object.
		 *
		 * @param {Vector3} axis - The (normalized) axis vector.
		 * @param {number} angle - The angle in radians.
		 */setRotationFromAxisAngle(axis,angle){// assumes axis is normalized
	this.quaternion.setFromAxisAngle(axis,angle);}/**
		 * Sets the given rotation represented as Euler angles to the 3D object.
		 *
		 * @param {Euler} euler - The Euler angles.
		 */setRotationFromEuler(euler){this.quaternion.setFromEuler(euler,true);}/**
		 * Sets the given rotation represented as rotation matrix to the 3D object.
		 *
		 * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
		 * a pure rotation matrix (i.e, unscaled).
		 */setRotationFromMatrix(m){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	this.quaternion.setFromRotationMatrix(m);}/**
		 * Sets the given rotation represented as a Quaternion to the 3D object.
		 *
		 * @param {Quaternion} q - The Quaternion
		 */setRotationFromQuaternion(q){// assumes q is normalized
	this.quaternion.copy(q);}/**
		 * Rotates the 3D object along an axis in local space.
		 *
		 * @param {Vector3} axis - The (normalized) axis vector.
		 * @param {number} angle - The angle in radians.
		 * @return {Object3D} A reference to this instance.
		 */rotateOnAxis(axis,angle){// rotate object on axis in object space
	// axis is assumed to be normalized
	_q1$1.setFromAxisAngle(axis,angle);this.quaternion.multiply(_q1$1);return this;}/**
		 * Rotates the 3D object along an axis in world space.
		 *
		 * @param {Vector3} axis - The (normalized) axis vector.
		 * @param {number} angle - The angle in radians.
		 * @return {Object3D} A reference to this instance.
		 */rotateOnWorldAxis(axis,angle){// rotate object on axis in world space
	// axis is assumed to be normalized
	// method assumes no rotated parent
	_q1$1.setFromAxisAngle(axis,angle);this.quaternion.premultiply(_q1$1);return this;}/**
		 * Rotates the 3D object around its X axis in local space.
		 *
		 * @param {number} angle - The angle in radians.
		 * @return {Object3D} A reference to this instance.
		 */rotateX(angle){return this.rotateOnAxis(_xAxis$1,angle);}/**
		 * Rotates the 3D object around its Y axis in local space.
		 *
		 * @param {number} angle - The angle in radians.
		 * @return {Object3D} A reference to this instance.
		 */rotateY(angle){return this.rotateOnAxis(_yAxis$1,angle);}/**
		 * Rotates the 3D object around its Z axis in local space.
		 *
		 * @param {number} angle - The angle in radians.
		 * @return {Object3D} A reference to this instance.
		 */rotateZ(angle){return this.rotateOnAxis(_zAxis$1,angle);}/**
		 * Translate the 3D object by a distance along the given axis in local space.
		 *
		 * @param {Vector3} axis - The (normalized) axis vector.
		 * @param {number} distance - The distance in world units.
		 * @return {Object3D} A reference to this instance.
		 */translateOnAxis(axis,distance){// translate object by distance along axis in object space
	// axis is assumed to be normalized
	_v1$4.copy(axis).applyQuaternion(this.quaternion);this.position.add(_v1$4.multiplyScalar(distance));return this;}/**
		 * Translate the 3D object by a distance along its X-axis in local space.
		 *
		 * @param {number} distance - The distance in world units.
		 * @return {Object3D} A reference to this instance.
		 */translateX(distance){return this.translateOnAxis(_xAxis$1,distance);}/**
		 * Translate the 3D object by a distance along its Y-axis in local space.
		 *
		 * @param {number} distance - The distance in world units.
		 * @return {Object3D} A reference to this instance.
		 */translateY(distance){return this.translateOnAxis(_yAxis$1,distance);}/**
		 * Translate the 3D object by a distance along its Z-axis in local space.
		 *
		 * @param {number} distance - The distance in world units.
		 * @return {Object3D} A reference to this instance.
		 */translateZ(distance){return this.translateOnAxis(_zAxis$1,distance);}/**
		 * Converts the given vector from this 3D object's local space to world space.
		 *
		 * @param {Vector3} vector - The vector to convert.
		 * @return {Vector3} The converted vector.
		 */localToWorld(vector){this.updateWorldMatrix(true,false);return vector.applyMatrix4(this.matrixWorld);}/**
		 * Converts the given vector from this 3D object's word space to local space.
		 *
		 * @param {Vector3} vector - The vector to convert.
		 * @return {Vector3} The converted vector.
		 */worldToLocal(vector){this.updateWorldMatrix(true,false);return vector.applyMatrix4(_m1$1$2.copy(this.matrixWorld).invert());}/**
		 * Rotates the object to face a point in world space.
		 *
		 * This method does not support objects having non-uniformly-scaled parent(s).
		 *
		 * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
		 * @param {number} [y] - The y coordinate in world space.
		 * @param {number} [z] - The z coordinate in world space.
		 */lookAt(x,y,z){// This method does not support objects having non-uniformly-scaled parent(s)
	if(x.isVector3){_target$1.copy(x);}else {_target$1.set(x,y,z);}const parent=this.parent;this.updateWorldMatrix(true,false);_position$3.setFromMatrixPosition(this.matrixWorld);if(this.isCamera||this.isLight){_m1$1$2.lookAt(_position$3,_target$1,this.up);}else {_m1$1$2.lookAt(_target$1,_position$3,this.up);}this.quaternion.setFromRotationMatrix(_m1$1$2);if(parent){_m1$1$2.extractRotation(parent.matrixWorld);_q1$1.setFromRotationMatrix(_m1$1$2);this.quaternion.premultiply(_q1$1.invert());}}/**
		 * Adds the given 3D object as a child to this 3D object. An arbitrary number of
		 * objects may be added. Any current parent on an object passed in here will be
		 * removed, since an object can have at most one parent.
		 *
		 * @fires Object3D#added
		 * @fires Object3D#childadded
		 * @param {Object3D} object - The 3D object to add.
		 * @return {Object3D} A reference to this instance.
		 */add(object){if(arguments.length>1){for(let i=0;i<arguments.length;i++){this.add(arguments[i]);}return this;}if(object===this){error$1('Object3D.add: object can\'t be added as a child of itself.',object);return this;}if(object&&object.isObject3D){object.removeFromParent();object.parent=this;this.children.push(object);object.dispatchEvent(_addedEvent$1);_childaddedEvent$1.child=object;this.dispatchEvent(_childaddedEvent$1);_childaddedEvent$1.child=null;}else {error$1('Object3D.add: object not an instance of THREE.Object3D.',object);}return this;}/**
		 * Removes the given 3D object as child from this 3D object.
		 * An arbitrary number of objects may be removed.
		 *
		 * @fires Object3D#removed
		 * @fires Object3D#childremoved
		 * @param {Object3D} object - The 3D object to remove.
		 * @return {Object3D} A reference to this instance.
		 */remove(object){if(arguments.length>1){for(let i=0;i<arguments.length;i++){this.remove(arguments[i]);}return this;}const index=this.children.indexOf(object);if(index!==-1){object.parent=null;this.children.splice(index,1);object.dispatchEvent(_removedEvent$1);_childremovedEvent$1.child=object;this.dispatchEvent(_childremovedEvent$1);_childremovedEvent$1.child=null;}return this;}/**
		 * Removes this 3D object from its current parent.
		 *
		 * @fires Object3D#removed
		 * @fires Object3D#childremoved
		 * @return {Object3D} A reference to this instance.
		 */removeFromParent(){const parent=this.parent;if(parent!==null){parent.remove(this);}return this;}/**
		 * Removes all child objects.
		 *
		 * @fires Object3D#removed
		 * @fires Object3D#childremoved
		 * @return {Object3D} A reference to this instance.
		 */clear(){return this.remove(...this.children);}/**
		 * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
		 * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
		 *
		 * @fires Object3D#added
		 * @fires Object3D#childadded
		 * @param {Object3D} object - The 3D object to attach.
		 * @return {Object3D} A reference to this instance.
		 */attach(object){// adds object as a child of this, while maintaining the object's world transform
	// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
	this.updateWorldMatrix(true,false);_m1$1$2.copy(this.matrixWorld).invert();if(object.parent!==null){object.parent.updateWorldMatrix(true,false);_m1$1$2.multiply(object.parent.matrixWorld);}object.applyMatrix4(_m1$1$2);object.removeFromParent();object.parent=this;this.children.push(object);object.updateWorldMatrix(false,true);object.dispatchEvent(_addedEvent$1);_childaddedEvent$1.child=object;this.dispatchEvent(_childaddedEvent$1);_childaddedEvent$1.child=null;return this;}/**
		 * Searches through the 3D object and its children, starting with the 3D object
		 * itself, and returns the first with a matching ID.
		 *
		 * @param {number} id - The id.
		 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
		 */getObjectById(id){return this.getObjectByProperty('id',id);}/**
		 * Searches through the 3D object and its children, starting with the 3D object
		 * itself, and returns the first with a matching name.
		 *
		 * @param {string} name - The name.
		 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
		 */getObjectByName(name){return this.getObjectByProperty('name',name);}/**
		 * Searches through the 3D object and its children, starting with the 3D object
		 * itself, and returns the first with a matching property value.
		 *
		 * @param {string} name - The name of the property.
		 * @param {any} value - The value.
		 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
		 */getObjectByProperty(name,value){if(this[name]===value)return this;for(let i=0,l=this.children.length;i<l;i++){const child=this.children[i];const object=child.getObjectByProperty(name,value);if(object!==undefined){return object;}}return undefined;}/**
		 * Searches through the 3D object and its children, starting with the 3D object
		 * itself, and returns all 3D objects with a matching property value.
		 *
		 * @param {string} name - The name of the property.
		 * @param {any} value - The value.
		 * @param {Array<Object3D>} result - The method stores the result in this array.
		 * @return {Array<Object3D>} The found 3D objects.
		 */getObjectsByProperty(name,value,result=[]){if(this[name]===value)result.push(this);const children=this.children;for(let i=0,l=children.length;i<l;i++){children[i].getObjectsByProperty(name,value,result);}return result;}/**
		 * Returns a vector representing the position of the 3D object in world space.
		 *
		 * @param {Vector3} target - The target vector the result is stored to.
		 * @return {Vector3} The 3D object's position in world space.
		 */getWorldPosition(target){this.updateWorldMatrix(true,false);return target.setFromMatrixPosition(this.matrixWorld);}/**
		 * Returns a Quaternion representing the position of the 3D object in world space.
		 *
		 * @param {Quaternion} target - The target Quaternion the result is stored to.
		 * @return {Quaternion} The 3D object's rotation in world space.
		 */getWorldQuaternion(target){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_position$3,target,_scale$2);return target;}/**
		 * Returns a vector representing the scale of the 3D object in world space.
		 *
		 * @param {Vector3} target - The target vector the result is stored to.
		 * @return {Vector3} The 3D object's scale in world space.
		 */getWorldScale(target){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_position$3,_quaternion$2$1,target);return target;}/**
		 * Returns a vector representing the ("look") direction of the 3D object in world space.
		 *
		 * @param {Vector3} target - The target vector the result is stored to.
		 * @return {Vector3} The 3D object's direction in world space.
		 */getWorldDirection(target){this.updateWorldMatrix(true,false);const e=this.matrixWorld.elements;return target.set(e[8],e[9],e[10]).normalize();}/**
		 * Abstract method to get intersections between a casted ray and this
		 * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
		 * implement this method in order to use raycasting.
		 *
		 * @abstract
		 * @param {Raycaster} raycaster - The raycaster.
		 * @param {Array<Object>} intersects - An array holding the result of the method.
		 */raycast(/* raycaster, intersects */){}/**
		 * Executes the callback on this 3D object and all descendants.
		 *
		 * Note: Modifying the scene graph inside the callback is discouraged.
		 *
		 * @param {Function} callback - A callback function that allows to process the current 3D object.
		 */traverse(callback){callback(this);const children=this.children;for(let i=0,l=children.length;i<l;i++){children[i].traverse(callback);}}/**
		 * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
		 * Descendants of invisible 3D objects are not traversed.
		 *
		 * Note: Modifying the scene graph inside the callback is discouraged.
		 *
		 * @param {Function} callback - A callback function that allows to process the current 3D object.
		 */traverseVisible(callback){if(this.visible===false)return;callback(this);const children=this.children;for(let i=0,l=children.length;i<l;i++){children[i].traverseVisible(callback);}}/**
		 * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
		 *
		 * Note: Modifying the scene graph inside the callback is discouraged.
		 *
		 * @param {Function} callback - A callback function that allows to process the current 3D object.
		 */traverseAncestors(callback){const parent=this.parent;if(parent!==null){callback(parent);parent.traverseAncestors(callback);}}/**
		 * Updates the transformation matrix in local space by computing it from the current
		 * position, rotation and scale values.
		 */updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=true;}/**
		 * Updates the transformation matrix in world space of this 3D objects and its descendants.
		 *
		 * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
		 * local space. The computation of the local and world matrix can be controlled with the
		 * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
		 * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
		 *
		 * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
		 * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
		 */updateMatrixWorld(force){if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldNeedsUpdate||force){if(this.matrixWorldAutoUpdate===true){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else {this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}}this.matrixWorldNeedsUpdate=false;force=true;}// make sure descendants are updated if required
	const children=this.children;for(let i=0,l=children.length;i<l;i++){const child=children[i];child.updateMatrixWorld(force);}}/**
		 * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
		 * update of ancestor and descendant nodes.
		 *
		 * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
		 * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
		 */updateWorldMatrix(updateParents,updateChildren){const parent=this.parent;if(updateParents===true&&parent!==null){parent.updateWorldMatrix(true,false);}if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldAutoUpdate===true){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else {this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}}// make sure descendants are updated
	if(updateChildren===true){const children=this.children;for(let i=0,l=children.length;i<l;i++){const child=children[i];child.updateWorldMatrix(false,true);}}}/**
		 * Serializes the 3D object into JSON.
		 *
		 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
		 * @return {Object} A JSON object representing the serialized 3D object.
		 * @see {@link ObjectLoader#parse}
		 */toJSON(meta){// meta is a string when called from JSON.stringify
	const isRootObject=meta===undefined||typeof meta==='string';const output={};// meta is a hash used to collect geometries, materials.
	// not providing it implies that this is the root object
	// being serialized.
	if(isRootObject){// initialize meta obj
	meta={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}};output.metadata={version:4.7,type:'Object',generator:'Object3D.toJSON'};}// standard Object3D serialization
	const object={};object.uuid=this.uuid;object.type=this.type;if(this.name!=='')object.name=this.name;if(this.castShadow===true)object.castShadow=true;if(this.receiveShadow===true)object.receiveShadow=true;if(this.visible===false)object.visible=false;if(this.frustumCulled===false)object.frustumCulled=false;if(this.renderOrder!==0)object.renderOrder=this.renderOrder;if(Object.keys(this.userData).length>0)object.userData=this.userData;object.layers=this.layers.mask;object.matrix=this.matrix.toArray();object.up=this.up.toArray();if(this.matrixAutoUpdate===false)object.matrixAutoUpdate=false;// object specific properties
	if(this.isInstancedMesh){object.type='InstancedMesh';object.count=this.count;object.instanceMatrix=this.instanceMatrix.toJSON();if(this.instanceColor!==null)object.instanceColor=this.instanceColor.toJSON();}if(this.isBatchedMesh){object.type='BatchedMesh';object.perObjectFrustumCulled=this.perObjectFrustumCulled;object.sortObjects=this.sortObjects;object.drawRanges=this._drawRanges;object.reservedRanges=this._reservedRanges;object.geometryInfo=this._geometryInfo.map(info=>({...info,boundingBox:info.boundingBox?info.boundingBox.toJSON():undefined,boundingSphere:info.boundingSphere?info.boundingSphere.toJSON():undefined}));object.instanceInfo=this._instanceInfo.map(info=>({...info}));object.availableInstanceIds=this._availableInstanceIds.slice();object.availableGeometryIds=this._availableGeometryIds.slice();object.nextIndexStart=this._nextIndexStart;object.nextVertexStart=this._nextVertexStart;object.geometryCount=this._geometryCount;object.maxInstanceCount=this._maxInstanceCount;object.maxVertexCount=this._maxVertexCount;object.maxIndexCount=this._maxIndexCount;object.geometryInitialized=this._geometryInitialized;object.matricesTexture=this._matricesTexture.toJSON(meta);object.indirectTexture=this._indirectTexture.toJSON(meta);if(this._colorsTexture!==null){object.colorsTexture=this._colorsTexture.toJSON(meta);}if(this.boundingSphere!==null){object.boundingSphere=this.boundingSphere.toJSON();}if(this.boundingBox!==null){object.boundingBox=this.boundingBox.toJSON();}}//
	function serialize(library,element){if(library[element.uuid]===undefined){library[element.uuid]=element.toJSON(meta);}return element.uuid;}if(this.isScene){if(this.background){if(this.background.isColor){object.background=this.background.toJSON();}else if(this.background.isTexture){object.background=this.background.toJSON(meta).uuid;}}if(this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==true){object.environment=this.environment.toJSON(meta).uuid;}}else if(this.isMesh||this.isLine||this.isPoints){object.geometry=serialize(meta.geometries,this.geometry);const parameters=this.geometry.parameters;if(parameters!==undefined&&parameters.shapes!==undefined){const shapes=parameters.shapes;if(Array.isArray(shapes)){for(let i=0,l=shapes.length;i<l;i++){const shape=shapes[i];serialize(meta.shapes,shape);}}else {serialize(meta.shapes,shapes);}}}if(this.isSkinnedMesh){object.bindMode=this.bindMode;object.bindMatrix=this.bindMatrix.toArray();if(this.skeleton!==undefined){serialize(meta.skeletons,this.skeleton);object.skeleton=this.skeleton.uuid;}}if(this.material!==undefined){if(Array.isArray(this.material)){const uuids=[];for(let i=0,l=this.material.length;i<l;i++){uuids.push(serialize(meta.materials,this.material[i]));}object.material=uuids;}else {object.material=serialize(meta.materials,this.material);}}//
	if(this.children.length>0){object.children=[];for(let i=0;i<this.children.length;i++){object.children.push(this.children[i].toJSON(meta).object);}}//
	if(this.animations.length>0){object.animations=[];for(let i=0;i<this.animations.length;i++){const animation=this.animations[i];object.animations.push(serialize(meta.animations,animation));}}if(isRootObject){const geometries=extractFromCache(meta.geometries);const materials=extractFromCache(meta.materials);const textures=extractFromCache(meta.textures);const images=extractFromCache(meta.images);const shapes=extractFromCache(meta.shapes);const skeletons=extractFromCache(meta.skeletons);const animations=extractFromCache(meta.animations);const nodes=extractFromCache(meta.nodes);if(geometries.length>0)output.geometries=geometries;if(materials.length>0)output.materials=materials;if(textures.length>0)output.textures=textures;if(images.length>0)output.images=images;if(shapes.length>0)output.shapes=shapes;if(skeletons.length>0)output.skeletons=skeletons;if(animations.length>0)output.animations=animations;if(nodes.length>0)output.nodes=nodes;}output.object=object;return output;// extract data from the cache hash
	// remove metadata on each item
	// and return as array
	function extractFromCache(cache){const values=[];for(const key in cache){const data=cache[key];delete data.metadata;values.push(data);}return values;}}/**
		 * Returns a new 3D object with copied values from this instance.
		 *
		 * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
		 * @return {Object3D} A clone of this instance.
		 */clone(recursive){return new this.constructor().copy(this,recursive);}/**
		 * Copies the values of the given 3D object to this instance.
		 *
		 * @param {Object3D} source - The 3D object to copy.
		 * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
		 * @return {Object3D} A reference to this instance.
		 */copy(source,recursive=true){this.name=source.name;this.up.copy(source.up);this.position.copy(source.position);this.rotation.order=source.rotation.order;this.quaternion.copy(source.quaternion);this.scale.copy(source.scale);this.matrix.copy(source.matrix);this.matrixWorld.copy(source.matrixWorld);this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrixWorldAutoUpdate=source.matrixWorldAutoUpdate;this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;this.layers.mask=source.layers.mask;this.visible=source.visible;this.castShadow=source.castShadow;this.receiveShadow=source.receiveShadow;this.frustumCulled=source.frustumCulled;this.renderOrder=source.renderOrder;this.animations=source.animations.slice();this.userData=JSON.parse(JSON.stringify(source.userData));if(recursive===true){for(let i=0;i<source.children.length;i++){const child=source.children[i];this.add(child.clone());}}return this;}};/**
	 * The default up direction for objects, also used as the default
	 * position for {@link DirectionalLight} and {@link HemisphereLight}.
	 *
	 * @static
	 * @type {Vector3}
	 * @default (0,1,0)
	 */Object3D$1.DEFAULT_UP=/*@__PURE__*/new Vector3$1(0,1,0);/**
	 * The default setting for {@link Object3D#matrixAutoUpdate} for
	 * newly created 3D objects.
	 *
	 * @static
	 * @type {boolean}
	 * @default true
	 */Object3D$1.DEFAULT_MATRIX_AUTO_UPDATE=true;/**
	 * The default setting for {@link Object3D#matrixWorldAutoUpdate} for
	 * newly created 3D objects.
	 *
	 * @static
	 * @type {boolean}
	 * @default true
	 */Object3D$1.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=true;const _v0$1$1=/*@__PURE__*/new Vector3$1();const _v1$3$1=/*@__PURE__*/new Vector3$1();const _v2$2=/*@__PURE__*/new Vector3$1();const _v3$2=/*@__PURE__*/new Vector3$1();const _vab=/*@__PURE__*/new Vector3$1();const _vac=/*@__PURE__*/new Vector3$1();const _vbc=/*@__PURE__*/new Vector3$1();const _vap=/*@__PURE__*/new Vector3$1();const _vbp=/*@__PURE__*/new Vector3$1();const _vcp=/*@__PURE__*/new Vector3$1();const _v40=/*@__PURE__*/new Vector4();const _v41=/*@__PURE__*/new Vector4();const _v42=/*@__PURE__*/new Vector4();/**
	 * A geometric triangle as defined by three vectors representing its three corners.
	 */class Triangle{/**
		 * Constructs a new triangle.
		 *
		 * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
		 * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
		 * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
		 */constructor(a=new Vector3$1(),b=new Vector3$1(),c=new Vector3$1()){/**
			 * The first corner of the triangle.
			 *
			 * @type {Vector3}
			 */this.a=a;/**
			 * The second corner of the triangle.
			 *
			 * @type {Vector3}
			 */this.b=b;/**
			 * The third corner of the triangle.
			 *
			 * @type {Vector3}
			 */this.c=c;}/**
		 * Computes the normal vector of a triangle.
		 *
		 * @param {Vector3} a - The first corner of the triangle.
		 * @param {Vector3} b - The second corner of the triangle.
		 * @param {Vector3} c - The third corner of the triangle.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The triangle's normal.
		 */static getNormal(a,b,c,target){target.subVectors(c,b);_v0$1$1.subVectors(a,b);target.cross(_v0$1$1);const targetLengthSq=target.lengthSq();if(targetLengthSq>0){return target.multiplyScalar(1/Math.sqrt(targetLengthSq));}return target.set(0,0,0);}/**
		 * Computes a barycentric coordinates from the given vector.
		 * Returns `null` if the triangle is degenerate.
		 *
		 * @param {Vector3} point - A point in 3D space.
		 * @param {Vector3} a - The first corner of the triangle.
		 * @param {Vector3} b - The second corner of the triangle.
		 * @param {Vector3} c - The third corner of the triangle.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The barycentric coordinates for the given point
		 */static getBarycoord(point,a,b,c,target){// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	_v0$1$1.subVectors(c,a);_v1$3$1.subVectors(b,a);_v2$2.subVectors(point,a);const dot00=_v0$1$1.dot(_v0$1$1);const dot01=_v0$1$1.dot(_v1$3$1);const dot02=_v0$1$1.dot(_v2$2);const dot11=_v1$3$1.dot(_v1$3$1);const dot12=_v1$3$1.dot(_v2$2);const denom=dot00*dot11-dot01*dot01;// collinear or singular triangle
	if(denom===0){target.set(0,0,0);return null;}const invDenom=1/denom;const u=(dot11*dot02-dot01*dot12)*invDenom;const v=(dot00*dot12-dot01*dot02)*invDenom;// barycentric coordinates must always sum to 1
	return target.set(1-u-v,v,u);}/**
		 * Returns `true` if the given point, when projected onto the plane of the
		 * triangle, lies within the triangle.
		 *
		 * @param {Vector3} point - The point in 3D space to test.
		 * @param {Vector3} a - The first corner of the triangle.
		 * @param {Vector3} b - The second corner of the triangle.
		 * @param {Vector3} c - The third corner of the triangle.
		 * @return {boolean} Whether the given point, when projected onto the plane of the
		 * triangle, lies within the triangle or not.
		 */static containsPoint(point,a,b,c){// if the triangle is degenerate then we can't contain a point
	if(this.getBarycoord(point,a,b,c,_v3$2)===null){return false;}return _v3$2.x>=0&&_v3$2.y>=0&&_v3$2.x+_v3$2.y<=1;}/**
		 * Computes the value barycentrically interpolated for the given point on the
		 * triangle. Returns `null` if the triangle is degenerate.
		 *
		 * @param {Vector3} point - Position of interpolated point.
		 * @param {Vector3} p1 - The first corner of the triangle.
		 * @param {Vector3} p2 - The second corner of the triangle.
		 * @param {Vector3} p3 - The third corner of the triangle.
		 * @param {Vector3} v1 - Value to interpolate of first vertex.
		 * @param {Vector3} v2 - Value to interpolate of second vertex.
		 * @param {Vector3} v3 - Value to interpolate of third vertex.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The interpolated value.
		 */static getInterpolation(point,p1,p2,p3,v1,v2,v3,target){if(this.getBarycoord(point,p1,p2,p3,_v3$2)===null){target.x=0;target.y=0;if('z'in target)target.z=0;if('w'in target)target.w=0;return null;}target.setScalar(0);target.addScaledVector(v1,_v3$2.x);target.addScaledVector(v2,_v3$2.y);target.addScaledVector(v3,_v3$2.z);return target;}/**
		 * Computes the value barycentrically interpolated for the given attribute and indices.
		 *
		 * @param {BufferAttribute} attr - The attribute to interpolate.
		 * @param {number} i1 - Index of first vertex.
		 * @param {number} i2 - Index of second vertex.
		 * @param {number} i3 - Index of third vertex.
		 * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The interpolated attribute value.
		 */static getInterpolatedAttribute(attr,i1,i2,i3,barycoord,target){_v40.setScalar(0);_v41.setScalar(0);_v42.setScalar(0);_v40.fromBufferAttribute(attr,i1);_v41.fromBufferAttribute(attr,i2);_v42.fromBufferAttribute(attr,i3);target.setScalar(0);target.addScaledVector(_v40,barycoord.x);target.addScaledVector(_v41,barycoord.y);target.addScaledVector(_v42,barycoord.z);return target;}/**
		 * Returns `true` if the triangle is oriented towards the given direction.
		 *
		 * @param {Vector3} a - The first corner of the triangle.
		 * @param {Vector3} b - The second corner of the triangle.
		 * @param {Vector3} c - The third corner of the triangle.
		 * @param {Vector3} direction - The (normalized) direction vector.
		 * @return {boolean} Whether the triangle is oriented towards the given direction or not.
		 */static isFrontFacing(a,b,c,direction){_v0$1$1.subVectors(c,b);_v1$3$1.subVectors(a,b);// strictly front facing
	return _v0$1$1.cross(_v1$3$1).dot(direction)<0?true:false;}/**
		 * Sets the triangle's vertices by copying the given values.
		 *
		 * @param {Vector3} a - The first corner of the triangle.
		 * @param {Vector3} b - The second corner of the triangle.
		 * @param {Vector3} c - The third corner of the triangle.
		 * @return {Triangle} A reference to this triangle.
		 */set(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this;}/**
		 * Sets the triangle's vertices by copying the given array values.
		 *
		 * @param {Array<Vector3>} points - An array with 3D points.
		 * @param {number} i0 - The array index representing the first corner of the triangle.
		 * @param {number} i1 - The array index representing the second corner of the triangle.
		 * @param {number} i2 - The array index representing the third corner of the triangle.
		 * @return {Triangle} A reference to this triangle.
		 */setFromPointsAndIndices(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this;}/**
		 * Sets the triangle's vertices by copying the given attribute values.
		 *
		 * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
		 * @param {number} i0 - The attribute index representing the first corner of the triangle.
		 * @param {number} i1 - The attribute index representing the second corner of the triangle.
		 * @param {number} i2 - The attribute index representing the third corner of the triangle.
		 * @return {Triangle} A reference to this triangle.
		 */setFromAttributeAndIndices(attribute,i0,i1,i2){this.a.fromBufferAttribute(attribute,i0);this.b.fromBufferAttribute(attribute,i1);this.c.fromBufferAttribute(attribute,i2);return this;}/**
		 * Returns a new triangle with copied values from this instance.
		 *
		 * @return {Triangle} A clone of this instance.
		 */clone(){return new this.constructor().copy(this);}/**
		 * Copies the values of the given triangle to this instance.
		 *
		 * @param {Triangle} triangle - The triangle to copy.
		 * @return {Triangle} A reference to this triangle.
		 */copy(triangle){this.a.copy(triangle.a);this.b.copy(triangle.b);this.c.copy(triangle.c);return this;}/**
		 * Computes the area of the triangle.
		 *
		 * @return {number} The triangle's area.
		 */getArea(){_v0$1$1.subVectors(this.c,this.b);_v1$3$1.subVectors(this.a,this.b);return _v0$1$1.cross(_v1$3$1).length()*0.5;}/**
		 * Computes the midpoint of the triangle.
		 *
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The triangle's midpoint.
		 */getMidpoint(target){return target.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);}/**
		 * Computes the normal of the triangle.
		 *
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The triangle's normal.
		 */getNormal(target){return Triangle.getNormal(this.a,this.b,this.c,target);}/**
		 * Computes a plane the triangle lies within.
		 *
		 * @param {Plane} target - The target vector that is used to store the method's result.
		 * @return {Plane} The plane the triangle lies within.
		 */getPlane(target){return target.setFromCoplanarPoints(this.a,this.b,this.c);}/**
		 * Computes a barycentric coordinates from the given vector.
		 * Returns `null` if the triangle is degenerate.
		 *
		 * @param {Vector3} point - A point in 3D space.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The barycentric coordinates for the given point
		 */getBarycoord(point,target){return Triangle.getBarycoord(point,this.a,this.b,this.c,target);}/**
		 * Computes the value barycentrically interpolated for the given point on the
		 * triangle. Returns `null` if the triangle is degenerate.
		 *
		 * @param {Vector3} point - Position of interpolated point.
		 * @param {Vector3} v1 - Value to interpolate of first vertex.
		 * @param {Vector3} v2 - Value to interpolate of second vertex.
		 * @param {Vector3} v3 - Value to interpolate of third vertex.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The interpolated value.
		 */getInterpolation(point,v1,v2,v3,target){return Triangle.getInterpolation(point,this.a,this.b,this.c,v1,v2,v3,target);}/**
		 * Returns `true` if the given point, when projected onto the plane of the
		 * triangle, lies within the triangle.
		 *
		 * @param {Vector3} point - The point in 3D space to test.
		 * @return {boolean} Whether the given point, when projected onto the plane of the
		 * triangle, lies within the triangle or not.
		 */containsPoint(point){return Triangle.containsPoint(point,this.a,this.b,this.c);}/**
		 * Returns `true` if the triangle is oriented towards the given direction.
		 *
		 * @param {Vector3} direction - The (normalized) direction vector.
		 * @return {boolean} Whether the triangle is oriented towards the given direction or not.
		 */isFrontFacing(direction){return Triangle.isFrontFacing(this.a,this.b,this.c,direction);}/**
		 * Returns `true` if this triangle intersects with the given box.
		 *
		 * @param {Box3} box - The box to intersect.
		 * @return {boolean} Whether this triangle intersects with the given box or not.
		 */intersectsBox(box){return box.intersectsTriangle(this);}/**
		 * Returns the closest point on the triangle to the given point.
		 *
		 * @param {Vector3} p - The point to compute the closest point for.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The closest point on the triangle.
		 */closestPointToPoint(p,target){const a=this.a,b=this.b,c=this.c;let v,w;// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
	// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
	// under the accompanying license; see chapter 5.1.5 for detailed explanation.
	// basically, we're distinguishing which of the voronoi regions of the triangle
	// the point lies in with the minimum amount of redundant computation.
	_vab.subVectors(b,a);_vac.subVectors(c,a);_vap.subVectors(p,a);const d1=_vab.dot(_vap);const d2=_vac.dot(_vap);if(d1<=0&&d2<=0){// vertex region of A; barycentric coords (1, 0, 0)
	return target.copy(a);}_vbp.subVectors(p,b);const d3=_vab.dot(_vbp);const d4=_vac.dot(_vbp);if(d3>=0&&d4<=d3){// vertex region of B; barycentric coords (0, 1, 0)
	return target.copy(b);}const vc=d1*d4-d3*d2;if(vc<=0&&d1>=0&&d3<=0){v=d1/(d1-d3);// edge region of AB; barycentric coords (1-v, v, 0)
	return target.copy(a).addScaledVector(_vab,v);}_vcp.subVectors(p,c);const d5=_vab.dot(_vcp);const d6=_vac.dot(_vcp);if(d6>=0&&d5<=d6){// vertex region of C; barycentric coords (0, 0, 1)
	return target.copy(c);}const vb=d5*d2-d1*d6;if(vb<=0&&d2>=0&&d6<=0){w=d2/(d2-d6);// edge region of AC; barycentric coords (1-w, 0, w)
	return target.copy(a).addScaledVector(_vac,w);}const va=d3*d6-d5*d4;if(va<=0&&d4-d3>=0&&d5-d6>=0){_vbc.subVectors(c,b);w=(d4-d3)/(d4-d3+(d5-d6));// edge region of BC; barycentric coords (0, 1-w, w)
	return target.copy(b).addScaledVector(_vbc,w);// edge region of BC
	}// face region
	const denom=1/(va+vb+vc);// u = va * denom
	v=vb*denom;w=vc*denom;return target.copy(a).addScaledVector(_vab,v).addScaledVector(_vac,w);}/**
		 * Returns `true` if this triangle is equal with the given one.
		 *
		 * @param {Triangle} triangle - The triangle to test for equality.
		 * @return {boolean} Whether this triangle is equal with the given one.
		 */equals(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);}}const _colorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'rebeccapurple':0x663399,'red':0xFF0000,'rosybrown':0xBC8F8F,'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};const _hslA={h:0,s:0,l:0};const _hslB={h:0,s:0,l:0};function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*6*(2/3-t);return p;}/**
	 * A Color instance is represented by RGB components in the linear <i>working
	 * color space</i>, which defaults to `LinearSRGBColorSpace`. Inputs
	 * conventionally using `SRGBColorSpace` (such as hexadecimals and CSS
	 * strings) are converted to the working color space automatically.
	 *
	 * ```js
	 * // converted automatically from SRGBColorSpace to LinearSRGBColorSpace
	 * const color = new THREE.Color().setHex( 0x112233 );
	 * ```
	 * Source color spaces may be specified explicitly, to ensure correct conversions.
	 * ```js
	 * // assumed already LinearSRGBColorSpace; no conversion
	 * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5 );
	 *
	 * // converted explicitly from SRGBColorSpace to LinearSRGBColorSpace
	 * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5, SRGBColorSpace );
	 * ```
	 * If THREE.ColorManagement is disabled, no conversions occur. For details,
	 * see <i>Color management</i>. Iterating through a Color instance will yield
	 * its components (r, g, b) in the corresponding order. A Color can be initialised
	 * in any of the following ways:
	 * ```js
	 * //empty constructor - will default white
	 * const color1 = new THREE.Color();
	 *
	 * //Hexadecimal color (recommended)
	 * const color2 = new THREE.Color( 0xff0000 );
	 *
	 * //RGB string
	 * const color3 = new THREE.Color("rgb(255, 0, 0)");
	 * const color4 = new THREE.Color("rgb(100%, 0%, 0%)");
	 *
	 * //X11 color name - all 140 color names are supported.
	 * //Note the lack of CamelCase in the name
	 * const color5 = new THREE.Color( 'skyblue' );
	 * //HSL string
	 * const color6 = new THREE.Color("hsl(0, 100%, 50%)");
	 *
	 * //Separate RGB values between 0 and 1
	 * const color7 = new THREE.Color( 1, 0, 0 );
	 * ```
	 */class Color{/**
		 * Constructs a new color.
		 *
		 * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
		 * and that method is used throughout the rest of the documentation.
		 *
		 * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
		 * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
		 * @param {number} [g] - The green component.
		 * @param {number} [b] - The blue component.
		 */constructor(r,g,b){/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isColor=true;/**
			 * The red component.
			 *
			 * @type {number}
			 * @default 1
			 */this.r=1;/**
			 * The green component.
			 *
			 * @type {number}
			 * @default 1
			 */this.g=1;/**
			 * The blue component.
			 *
			 * @type {number}
			 * @default 1
			 */this.b=1;return this.set(r,g,b);}/**
		 * Sets the colors's components from the given values.
		 *
		 * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
		 * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
		 * @param {number} [g] - The green component.
		 * @param {number} [b] - The blue component.
		 * @return {Color} A reference to this color.
		 */set(r,g,b){if(g===undefined&&b===undefined){// r is THREE.Color, hex or string
	const value=r;if(value&&value.isColor){this.copy(value);}else if(typeof value==='number'){this.setHex(value);}else if(typeof value==='string'){this.setStyle(value);}}else {this.setRGB(r,g,b);}return this;}/**
		 * Sets the colors's components to the given scalar value.
		 *
		 * @param {number} scalar - The scalar value.
		 * @return {Color} A reference to this color.
		 */setScalar(scalar){this.r=scalar;this.g=scalar;this.b=scalar;return this;}/**
		 * Sets this color from a hexadecimal value.
		 *
		 * @param {number} hex - The hexadecimal value.
		 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
		 * @return {Color} A reference to this color.
		 */setHex(hex,colorSpace=SRGBColorSpace){hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;ColorManagement.colorSpaceToWorking(this,colorSpace);return this;}/**
		 * Sets this color from RGB values.
		 *
		 * @param {number} r - Red channel value between `0.0` and `1.0`.
		 * @param {number} g - Green channel value between `0.0` and `1.0`.
		 * @param {number} b - Blue channel value between `0.0` and `1.0`.
		 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
		 * @return {Color} A reference to this color.
		 */setRGB(r,g,b,colorSpace=ColorManagement.workingColorSpace){this.r=r;this.g=g;this.b=b;ColorManagement.colorSpaceToWorking(this,colorSpace);return this;}/**
		 * Sets this color from RGB values.
		 *
		 * @param {number} h - Hue value between `0.0` and `1.0`.
		 * @param {number} s - Saturation value between `0.0` and `1.0`.
		 * @param {number} l - Lightness value between `0.0` and `1.0`.
		 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
		 * @return {Color} A reference to this color.
		 */setHSL(h,s,l,colorSpace=ColorManagement.workingColorSpace){// h,s,l ranges are in 0.0 - 1.0
	h=euclideanModulo(h,1);s=clamp$1(s,0,1);l=clamp$1(l,0,1);if(s===0){this.r=this.g=this.b=l;}else {const p=l<=0.5?l*(1+s):l+s-l*s;const q=2*l-p;this.r=hue2rgb(q,p,h+1/3);this.g=hue2rgb(q,p,h);this.b=hue2rgb(q,p,h-1/3);}ColorManagement.colorSpaceToWorking(this,colorSpace);return this;}/**
		 * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
		 * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
		 * any [X11 color name](https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart) -
		 * all 140 color names are supported).
		 *
		 * @param {string} style - Color as a CSS-style string.
		 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
		 * @return {Color} A reference to this color.
		 */setStyle(style,colorSpace=SRGBColorSpace){function handleAlpha(string){if(string===undefined)return;if(parseFloat(string)<1){warn$1('Color: Alpha component of '+style+' will be ignored.');}}let m;if(m=/^(\w+)\(([^\)]*)\)/.exec(style)){// rgb / hsl
	let color;const name=m[1];const components=m[2];switch(name){case 'rgb':case 'rgba':if(color=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// rgb(255,0,0) rgba(255,0,0,0.5)
	handleAlpha(color[4]);return this.setRGB(Math.min(255,parseInt(color[1],10))/255,Math.min(255,parseInt(color[2],10))/255,Math.min(255,parseInt(color[3],10))/255,colorSpace);}if(color=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
	handleAlpha(color[4]);return this.setRGB(Math.min(100,parseInt(color[1],10))/100,Math.min(100,parseInt(color[2],10))/100,Math.min(100,parseInt(color[3],10))/100,colorSpace);}break;case 'hsl':case 'hsla':if(color=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
	handleAlpha(color[4]);return this.setHSL(parseFloat(color[1])/360,parseFloat(color[2])/100,parseFloat(color[3])/100,colorSpace);}break;default:warn$1('Color: Unknown color model '+style);}}else if(m=/^\#([A-Fa-f\d]+)$/.exec(style)){// hex color
	const hex=m[1];const size=hex.length;if(size===3){// #ff0
	return this.setRGB(parseInt(hex.charAt(0),16)/15,parseInt(hex.charAt(1),16)/15,parseInt(hex.charAt(2),16)/15,colorSpace);}else if(size===6){// #ff0000
	return this.setHex(parseInt(hex,16),colorSpace);}else {warn$1('Color: Invalid hex color '+style);}}else if(style&&style.length>0){return this.setColorName(style,colorSpace);}return this;}/**
		 * Sets this color from a color name. Faster than {@link Color#setStyle} if
		 * you don't need the other CSS-style formats.
		 *
		 * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
		 * ```js
		 * Color.NAMES.aliceblue // returns 0xF0F8FF
		 * ```
		 *
		 * @param {string} style - The color name.
		 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
		 * @return {Color} A reference to this color.
		 */setColorName(style,colorSpace=SRGBColorSpace){// color keywords
	const hex=_colorKeywords[style.toLowerCase()];if(hex!==undefined){// red
	this.setHex(hex,colorSpace);}else {// unknown color
	warn$1('Color: Unknown color '+style);}return this;}/**
		 * Returns a new color with copied values from this instance.
		 *
		 * @return {Color} A clone of this instance.
		 */clone(){return new this.constructor(this.r,this.g,this.b);}/**
		 * Copies the values of the given color to this instance.
		 *
		 * @param {Color} color - The color to copy.
		 * @return {Color} A reference to this color.
		 */copy(color){this.r=color.r;this.g=color.g;this.b=color.b;return this;}/**
		 * Copies the given color into this color, and then converts this color from
		 * `SRGBColorSpace` to `LinearSRGBColorSpace`.
		 *
		 * @param {Color} color - The color to copy/convert.
		 * @return {Color} A reference to this color.
		 */copySRGBToLinear(color){this.r=SRGBToLinear(color.r);this.g=SRGBToLinear(color.g);this.b=SRGBToLinear(color.b);return this;}/**
		 * Copies the given color into this color, and then converts this color from
		 * `LinearSRGBColorSpace` to `SRGBColorSpace`.
		 *
		 * @param {Color} color - The color to copy/convert.
		 * @return {Color} A reference to this color.
		 */copyLinearToSRGB(color){this.r=LinearToSRGB(color.r);this.g=LinearToSRGB(color.g);this.b=LinearToSRGB(color.b);return this;}/**
		 * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
		 *
		 * @return {Color} A reference to this color.
		 */convertSRGBToLinear(){this.copySRGBToLinear(this);return this;}/**
		 * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
		 *
		 * @return {Color} A reference to this color.
		 */convertLinearToSRGB(){this.copyLinearToSRGB(this);return this;}/**
		 * Returns the hexadecimal value of this color.
		 *
		 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
		 * @return {number} The hexadecimal value.
		 */getHex(colorSpace=SRGBColorSpace){ColorManagement.workingToColorSpace(_color.copy(this),colorSpace);return Math.round(clamp$1(_color.r*255,0,255))*65536+Math.round(clamp$1(_color.g*255,0,255))*256+Math.round(clamp$1(_color.b*255,0,255));}/**
		 * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
		 *
		 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
		 * @return {string} The hexadecimal value as a string.
		 */getHexString(colorSpace=SRGBColorSpace){return ('000000'+this.getHex(colorSpace).toString(16)).slice(-6);}/**
		 * Converts the colors RGB values into the HSL format and stores them into the
		 * given target object.
		 *
		 * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
		 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
		 * @return {{h:number,s:number,l:number}} The HSL representation of this color.
		 */getHSL(target,colorSpace=ColorManagement.workingColorSpace){// h,s,l ranges are in 0.0 - 1.0
	ColorManagement.workingToColorSpace(_color.copy(this),colorSpace);const r=_color.r,g=_color.g,b=_color.b;const max=Math.max(r,g,b);const min=Math.min(r,g,b);let hue,saturation;const lightness=(min+max)/2.0;if(min===max){hue=0;saturation=0;}else {const delta=max-min;saturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);switch(max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4;break;}hue/=6;}target.h=hue;target.s=saturation;target.l=lightness;return target;}/**
		 * Returns the RGB values of this color and stores them into the given target object.
		 *
		 * @param {Color} target - The target color that is used to store the method's result.
		 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
		 * @return {Color} The RGB representation of this color.
		 */getRGB(target,colorSpace=ColorManagement.workingColorSpace){ColorManagement.workingToColorSpace(_color.copy(this),colorSpace);target.r=_color.r;target.g=_color.g;target.b=_color.b;return target;}/**
		 * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
		 *
		 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
		 * @return {string} The CSS representation of this color.
		 */getStyle(colorSpace=SRGBColorSpace){ColorManagement.workingToColorSpace(_color.copy(this),colorSpace);const r=_color.r,g=_color.g,b=_color.b;if(colorSpace!==SRGBColorSpace){// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
	return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;}return `rgb(${Math.round(r*255)},${Math.round(g*255)},${Math.round(b*255)})`;}/**
		 * Adds the given HSL values to this color's values.
		 * Internally, this converts the color's RGB values to HSL, adds HSL
		 * and then converts the color back to RGB.
		 *
		 * @param {number} h - Hue value between `0.0` and `1.0`.
		 * @param {number} s - Saturation value between `0.0` and `1.0`.
		 * @param {number} l - Lightness value between `0.0` and `1.0`.
		 * @return {Color} A reference to this color.
		 */offsetHSL(h,s,l){this.getHSL(_hslA);return this.setHSL(_hslA.h+h,_hslA.s+s,_hslA.l+l);}/**
		 * Adds the RGB values of the given color to the RGB values of this color.
		 *
		 * @param {Color} color - The color to add.
		 * @return {Color} A reference to this color.
		 */add(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;return this;}/**
		 * Adds the RGB values of the given colors and stores the result in this instance.
		 *
		 * @param {Color} color1 - The first color.
		 * @param {Color} color2 - The second color.
		 * @return {Color} A reference to this color.
		 */addColors(color1,color2){this.r=color1.r+color2.r;this.g=color1.g+color2.g;this.b=color1.b+color2.b;return this;}/**
		 * Adds the given scalar value to the RGB values of this color.
		 *
		 * @param {number} s - The scalar to add.
		 * @return {Color} A reference to this color.
		 */addScalar(s){this.r+=s;this.g+=s;this.b+=s;return this;}/**
		 * Subtracts the RGB values of the given color from the RGB values of this color.
		 *
		 * @param {Color} color - The color to subtract.
		 * @return {Color} A reference to this color.
		 */sub(color){this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);return this;}/**
		 * Multiplies the RGB values of the given color with the RGB values of this color.
		 *
		 * @param {Color} color - The color to multiply.
		 * @return {Color} A reference to this color.
		 */multiply(color){this.r*=color.r;this.g*=color.g;this.b*=color.b;return this;}/**
		 * Multiplies the given scalar value with the RGB values of this color.
		 *
		 * @param {number} s - The scalar to multiply.
		 * @return {Color} A reference to this color.
		 */multiplyScalar(s){this.r*=s;this.g*=s;this.b*=s;return this;}/**
		 * Linearly interpolates this color's RGB values toward the RGB values of the
		 * given color. The alpha argument can be thought of as the ratio between
		 * the two colors, where `0.0` is this color and `1.0` is the first argument.
		 *
		 * @param {Color} color - The color to converge on.
		 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
		 * @return {Color} A reference to this color.
		 */lerp(color,alpha){this.r+=(color.r-this.r)*alpha;this.g+=(color.g-this.g)*alpha;this.b+=(color.b-this.b)*alpha;return this;}/**
		 * Linearly interpolates between the given colors and stores the result in this instance.
		 * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
		 * is the first and `1.0` is the second color.
		 *
		 * @param {Color} color1 - The first color.
		 * @param {Color} color2 - The second color.
		 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
		 * @return {Color} A reference to this color.
		 */lerpColors(color1,color2,alpha){this.r=color1.r+(color2.r-color1.r)*alpha;this.g=color1.g+(color2.g-color1.g)*alpha;this.b=color1.b+(color2.b-color1.b)*alpha;return this;}/**
		 * Linearly interpolates this color's HSL values toward the HSL values of the
		 * given color. It differs from {@link Color#lerp} by not interpolating straight
		 * from one color to the other, but instead going through all the hues in between
		 * those two colors. The alpha argument can be thought of as the ratio between
		 * the two colors, where 0.0 is this color and 1.0 is the first argument.
		 *
		 * @param {Color} color - The color to converge on.
		 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
		 * @return {Color} A reference to this color.
		 */lerpHSL(color,alpha){this.getHSL(_hslA);color.getHSL(_hslB);const h=lerp(_hslA.h,_hslB.h,alpha);const s=lerp(_hslA.s,_hslB.s,alpha);const l=lerp(_hslA.l,_hslB.l,alpha);this.setHSL(h,s,l);return this;}/**
		 * Sets the color's RGB components from the given 3D vector.
		 *
		 * @param {Vector3} v - The vector to set.
		 * @return {Color} A reference to this color.
		 */setFromVector3(v){this.r=v.x;this.g=v.y;this.b=v.z;return this;}/**
		 * Transforms this color with the given 3x3 matrix.
		 *
		 * @param {Matrix3} m - The matrix.
		 * @return {Color} A reference to this color.
		 */applyMatrix3(m){const r=this.r,g=this.g,b=this.b;const e=m.elements;this.r=e[0]*r+e[3]*g+e[6]*b;this.g=e[1]*r+e[4]*g+e[7]*b;this.b=e[2]*r+e[5]*g+e[8]*b;return this;}/**
		 * Returns `true` if this color is equal with the given one.
		 *
		 * @param {Color} c - The color to test for equality.
		 * @return {boolean} Whether this bounding color is equal with the given one.
		 */equals(c){return c.r===this.r&&c.g===this.g&&c.b===this.b;}/**
		 * Sets this color's RGB components from the given array.
		 *
		 * @param {Array<number>} array - An array holding the RGB values.
		 * @param {number} [offset=0] - The offset into the array.
		 * @return {Color} A reference to this color.
		 */fromArray(array,offset=0){this.r=array[offset];this.g=array[offset+1];this.b=array[offset+2];return this;}/**
		 * Writes the RGB components of this color to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the color components.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The color components.
		 */toArray(array=[],offset=0){array[offset]=this.r;array[offset+1]=this.g;array[offset+2]=this.b;return array;}/**
		 * Sets the components of this color from the given buffer attribute.
		 *
		 * @param {BufferAttribute} attribute - The buffer attribute holding color data.
		 * @param {number} index - The index into the attribute.
		 * @return {Color} A reference to this color.
		 */fromBufferAttribute(attribute,index){this.r=attribute.getX(index);this.g=attribute.getY(index);this.b=attribute.getZ(index);return this;}/**
		 * This methods defines the serialization result of this class. Returns the color
		 * as a hexadecimal value.
		 *
		 * @return {number} The hexadecimal value.
		 */toJSON(){return this.getHex();}*[Symbol.iterator](){yield this.r;yield this.g;yield this.b;}}const _color=/*@__PURE__*/new Color();/**
	 * A dictionary with X11 color names.
	 *
	 * Note that multiple words such as Dark Orange become the string 'darkorange'.
	 *
	 * @static
	 * @type {Object}
	 */Color.NAMES=_colorKeywords;let _materialId=0;/**
	 * Abstract base class for materials.
	 *
	 * Materials define the appearance of renderable 3D objects.
	 *
	 * @abstract
	 * @augments EventDispatcher
	 */class Material extends EventDispatcher$1{/**
		 * Constructs a new material.
		 */constructor(){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isMaterial=true;/**
			 * The ID of the material.
			 *
			 * @name Material#id
			 * @type {number}
			 * @readonly
			 */Object.defineProperty(this,'id',{value:_materialId++});/**
			 * The UUID of the material.
			 *
			 * @type {string}
			 * @readonly
			 */this.uuid=generateUUID$1();/**
			 * The name of the material.
			 *
			 * @type {string}
			 */this.name='';/**
			 * The type property is used for detecting the object type
			 * in context of serialization/deserialization.
			 *
			 * @type {string}
			 * @readonly
			 */this.type='Material';/**
			 * Defines the blending type of the material.
			 *
			 * It must be set to `CustomBlending` if custom blending properties like
			 * {@link Material#blendSrc}, {@link Material#blendDst} or {@link Material#blendEquation}
			 * should have any effect.
			 *
			 * @type {(NoBlending|NormalBlending|AdditiveBlending|SubtractiveBlending|MultiplyBlending|CustomBlending)}
			 * @default NormalBlending
			 */this.blending=NormalBlending;/**
			 * Defines which side of faces will be rendered - front, back or both.
			 *
			 * @type {(FrontSide|BackSide|DoubleSide)}
			 * @default FrontSide
			 */this.side=FrontSide;/**
			 * If set to `true`, vertex colors should be used.
			 *
			 * The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or
			 * four (RGBA) component color buffer attribute is used.
			 *
			 * @type {boolean}
			 * @default false
			 */this.vertexColors=false;/**
			 * Defines how transparent the material is.
			 * A value of `0.0` indicates fully transparent, `1.0` is fully opaque.
			 *
			 * If the {@link Material#transparent} is not set to `true`,
			 * the material will remain fully opaque and this value will only affect its color.
			 *
			 * @type {number}
			 * @default 1
			 */this.opacity=1;/**
			 * Defines whether this material is transparent. This has an effect on
			 * rendering as transparent objects need special treatment and are rendered
			 * after non-transparent objects.
			 *
			 * When set to true, the extent to which the material is transparent is
			 * controlled by {@link Material#opacity}.
			 *
			 * @type {boolean}
			 * @default false
			 */this.transparent=false;/**
			 * Enables alpha hashed transparency, an alternative to {@link Material#transparent} or
			 * {@link Material#alphaTest}. The material will not be rendered if opacity is lower than
			 * a random threshold. Randomization introduces some grain or noise, but approximates alpha
			 * blending without the associated problems of sorting. Using TAA can reduce the resulting noise.
			 *
			 * @type {boolean}
			 * @default false
			 */this.alphaHash=false;/**
			 * Defines the blending source factor.
			 *
			 * @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
			 * @default SrcAlphaFactor
			 */this.blendSrc=SrcAlphaFactor;/**
			 * Defines the blending destination factor.
			 *
			 * @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
			 * @default OneMinusSrcAlphaFactor
			 */this.blendDst=OneMinusSrcAlphaFactor;/**
			 * Defines the blending equation.
			 *
			 * @type {(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
			 * @default AddEquation
			 */this.blendEquation=AddEquation;/**
			 * Defines the blending source alpha factor.
			 *
			 * @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
			 * @default null
			 */this.blendSrcAlpha=null;/**
			 * Defines the blending destination alpha factor.
			 *
			 * @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
			 * @default null
			 */this.blendDstAlpha=null;/**
			 * Defines the blending equation of the alpha channel.
			 *
			 * @type {?(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
			 * @default null
			 */this.blendEquationAlpha=null;/**
			 * Represents the RGB values of the constant blend color.
			 *
			 * This property has only an effect when using custom blending with `ConstantColor` or `OneMinusConstantColor`.
			 *
			 * @type {Color}
			 * @default (0,0,0)
			 */this.blendColor=new Color(0,0,0);/**
			 * Represents the alpha value of the constant blend color.
			 *
			 * This property has only an effect when using custom blending with `ConstantAlpha` or `OneMinusConstantAlpha`.
			 *
			 * @type {number}
			 * @default 0
			 */this.blendAlpha=0;/**
			 * Defines the depth function.
			 *
			 * @type {(NeverDepth|AlwaysDepth|LessDepth|LessEqualDepth|EqualDepth|GreaterEqualDepth|GreaterDepth|NotEqualDepth)}
			 * @default LessEqualDepth
			 */this.depthFunc=LessEqualDepth;/**
			 * Whether to have depth test enabled when rendering this material.
			 * When the depth test is disabled, the depth write will also be implicitly disabled.
			 *
			 * @type {boolean}
			 * @default true
			 */this.depthTest=true;/**
			 * Whether rendering this material has any effect on the depth buffer.
			 *
			 * When drawing 2D overlays it can be useful to disable the depth writing in
			 * order to layer several things together without creating z-index artifacts.
			 *
			 * @type {boolean}
			 * @default true
			 */this.depthWrite=true;/**
			 * The bit mask to use when writing to the stencil buffer.
			 *
			 * @type {number}
			 * @default 0xff
			 */this.stencilWriteMask=0xff;/**
			 * The stencil comparison function to use.
			 *
			 * @type {NeverStencilFunc|LessStencilFunc|EqualStencilFunc|LessEqualStencilFunc|GreaterStencilFunc|NotEqualStencilFunc|GreaterEqualStencilFunc|AlwaysStencilFunc}
			 * @default AlwaysStencilFunc
			 */this.stencilFunc=AlwaysStencilFunc;/**
			 * The value to use when performing stencil comparisons or stencil operations.
			 *
			 * @type {number}
			 * @default 0
			 */this.stencilRef=0;/**
			 * The bit mask to use when comparing against the stencil buffer.
			 *
			 * @type {number}
			 * @default 0xff
			 */this.stencilFuncMask=0xff;/**
			 * Which stencil operation to perform when the comparison function returns `false`.
			 *
			 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
			 * @default KeepStencilOp
			 */this.stencilFail=KeepStencilOp;/**
			 * Which stencil operation to perform when the comparison function returns
			 * `true` but the depth test fails.
			 *
			 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
			 * @default KeepStencilOp
			 */this.stencilZFail=KeepStencilOp;/**
			 * Which stencil operation to perform when the comparison function returns
			 * `true` and the depth test passes.
			 *
			 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
			 * @default KeepStencilOp
			 */this.stencilZPass=KeepStencilOp;/**
			 * Whether stencil operations are performed against the stencil buffer. In
			 * order to perform writes or comparisons against the stencil buffer this
			 * value must be `true`.
			 *
			 * @type {boolean}
			 * @default false
			 */this.stencilWrite=false;/**
			 * User-defined clipping planes specified as THREE.Plane objects in world
			 * space. These planes apply to the objects this material is attached to.
			 * Points in space whose signed distance to the plane is negative are clipped
			 * (not rendered). This requires {@link WebGLRenderer#localClippingEnabled} to
			 * be `true`.
			 *
			 * @type {?Array<Plane>}
			 * @default null
			 */this.clippingPlanes=null;/**
			 * Changes the behavior of clipping planes so that only their intersection is
			 * clipped, rather than their union.
			 *
			 * @type {boolean}
			 * @default false
			 */this.clipIntersection=false;/**
			 * Defines whether to clip shadows according to the clipping planes specified
			 * on this material.
			 *
			 * @type {boolean}
			 * @default false
			 */this.clipShadows=false;/**
			 * Defines which side of faces cast shadows. If `null`, the side casting shadows
			 * is determined as follows:
			 *
			 * - When {@link Material#side} is set to `FrontSide`, the back side cast shadows.
			 * - When {@link Material#side} is set to `BackSide`, the front side cast shadows.
			 * - When {@link Material#side} is set to `DoubleSide`, both sides cast shadows.
			 *
			 * @type {?(FrontSide|BackSide|DoubleSide)}
			 * @default null
			 */this.shadowSide=null;/**
			 * Whether to render the material's color.
			 *
			 * This can be used in conjunction with {@link Object3D#renderOder} to create invisible
			 * objects that occlude other objects.
			 *
			 * @type {boolean}
			 * @default true
			 */this.colorWrite=true;/**
			 * Override the renderer's default precision for this material.
			 *
			 * @type {?('highp'|'mediump'|'lowp')}
			 * @default null
			 */this.precision=null;/**
			 * Whether to use polygon offset or not. When enabled, each fragment's depth value will
			 * be offset after it is interpolated from the depth values of the appropriate vertices.
			 * The offset is added before the depth test is performed and before the value is written
			 * into the depth buffer.
			 *
			 * Can be useful for rendering hidden-line images, for applying decals to surfaces, and for
			 * rendering solids with highlighted edges.
			 *
			 * @type {boolean}
			 * @default false
			 */this.polygonOffset=false;/**
			 * Specifies a scale factor that is used to create a variable depth offset for each polygon.
			 *
			 * @type {number}
			 * @default 0
			 */this.polygonOffsetFactor=0;/**
			 * Is multiplied by an implementation-specific value to create a constant depth offset.
			 *
			 * @type {number}
			 * @default 0
			 */this.polygonOffsetUnits=0;/**
			 * Whether to apply dithering to the color to remove the appearance of banding.
			 *
			 * @type {boolean}
			 * @default false
			 */this.dithering=false;/**
			 * Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts
			 * (meaning when the renderer was created with *antialias* parameter set to `true`). Enabling this
			 * will smooth aliasing on clip plane edges and alphaTest-clipped edges.
			 *
			 * @type {boolean}
			 * @default false
			 */this.alphaToCoverage=false;/**
			 * Whether to premultiply the alpha (transparency) value.
			 *
			 * @type {boolean}
			 * @default false
			 */this.premultipliedAlpha=false;/**
			 * Whether double-sided, transparent objects should be rendered with a single pass or not.
			 *
			 * The engine renders double-sided, transparent objects with two draw calls (back faces first,
			 * then front faces) to mitigate transparency artifacts. There are scenarios however where this
			 * approach produces no quality gains but still doubles draw calls e.g. when rendering flat
			 * vegetation like grass sprites. In these cases, set the `forceSinglePass` flag to `true` to
			 * disable the two pass rendering to avoid performance issues.
			 *
			 * @type {boolean}
			 * @default false
			 */this.forceSinglePass=false;/**
			 * Whether it's possible to override the material with {@link Scene#overrideMaterial} or not.
			 *
			 * @type {boolean}
			 * @default true
			 */this.allowOverride=true;/**
			 * Defines whether 3D objects using this material are visible.
			 *
			 * @type {boolean}
			 * @default true
			 */this.visible=true;/**
			 * Defines whether this material is tone mapped according to the renderer's tone mapping setting.
			 *
			 * It is ignored when rendering to a render target or using post processing or when using
			 * `WebGPURenderer`. In all these cases, all materials are honored by tone mapping.
			 *
			 * @type {boolean}
			 * @default true
			 */this.toneMapped=true;/**
			 * An object that can be used to store custom data about the Material. It
			 * should not hold references to functions as these will not be cloned.
			 *
			 * @type {Object}
			 */this.userData={};/**
			 * This starts at `0` and counts how many times {@link Material#needsUpdate} is set to `true`.
			 *
			 * @type {number}
			 * @readonly
			 * @default 0
			 */this.version=0;this._alphaTest=0;}/**
		 * Sets the alpha value to be used when running an alpha test. The material
		 * will not be rendered if the opacity is lower than this value.
		 *
		 * @type {number}
		 * @readonly
		 * @default 0
		 */get alphaTest(){return this._alphaTest;}set alphaTest(value){if(this._alphaTest>0!==value>0){this.version++;}this._alphaTest=value;}/**
		 * An optional callback that is executed immediately before the material is used to render a 3D object.
		 *
		 * This method can only be used when rendering with {@link WebGLRenderer}.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {Scene} scene - The scene.
		 * @param {Camera} camera - The camera that is used to render the scene.
		 * @param {BufferGeometry} geometry - The 3D object's geometry.
		 * @param {Object3D} object - The 3D object.
		 * @param {Object} group - The geometry group data.
		 */onBeforeRender(/* renderer, scene, camera, geometry, object, group */){}/**
		 * An optional callback that is executed immediately before the shader
		 * program is compiled. This function is called with the shader source code
		 * as a parameter. Useful for the modification of built-in materials.
		 *
		 * This method can only be used when rendering with {@link WebGLRenderer}. The
		 * recommended approach when customizing materials is to use `WebGPURenderer` with the new
		 * Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language).
		 *
		 * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
		 * @param {WebGLRenderer} renderer - A reference to the renderer.
		 */onBeforeCompile(/* shaderobject, renderer */){}/**
		 * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
		 * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
		 * shader or recompile the shader for this material as needed.
		 *
		 * This method can only be used when rendering with {@link WebGLRenderer}.
		 *
		 * @return {string} The custom program cache key.
		 */customProgramCacheKey(){return this.onBeforeCompile.toString();}/**
		 * This method can be used to set default values from parameter objects.
		 * It is a generic implementation so it can be used with different types
		 * of materials.
		 *
		 * @param {Object} [values] - The material values to set.
		 */setValues(values){if(values===undefined)return;for(const key in values){const newValue=values[key];if(newValue===undefined){warn$1(`Material: parameter '${key}' has value of undefined.`);continue;}const currentValue=this[key];if(currentValue===undefined){warn$1(`Material: '${key}' is not a property of THREE.${this.type}.`);continue;}if(currentValue&&currentValue.isColor){currentValue.set(newValue);}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){currentValue.copy(newValue);}else {this[key]=newValue;}}}/**
		 * Serializes the material into JSON.
		 *
		 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
		 * @return {Object} A JSON object representing the serialized material.
		 * @see {@link ObjectLoader#parse}
		 */toJSON(meta){const isRootObject=meta===undefined||typeof meta==='string';if(isRootObject){meta={textures:{},images:{}};}const data={metadata:{version:4.7,type:'Material',generator:'Material.toJSON'}};// standard Material serialization
	data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.color&&this.color.isColor)data.color=this.color.getHex();if(this.roughness!==undefined)data.roughness=this.roughness;if(this.metalness!==undefined)data.metalness=this.metalness;if(this.sheen!==undefined)data.sheen=this.sheen;if(this.sheenColor&&this.sheenColor.isColor)data.sheenColor=this.sheenColor.getHex();if(this.sheenRoughness!==undefined)data.sheenRoughness=this.sheenRoughness;if(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();if(this.emissiveIntensity!==undefined&&this.emissiveIntensity!==1)data.emissiveIntensity=this.emissiveIntensity;if(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();if(this.specularIntensity!==undefined)data.specularIntensity=this.specularIntensity;if(this.specularColor&&this.specularColor.isColor)data.specularColor=this.specularColor.getHex();if(this.shininess!==undefined)data.shininess=this.shininess;if(this.clearcoat!==undefined)data.clearcoat=this.clearcoat;if(this.clearcoatRoughness!==undefined)data.clearcoatRoughness=this.clearcoatRoughness;if(this.clearcoatMap&&this.clearcoatMap.isTexture){data.clearcoatMap=this.clearcoatMap.toJSON(meta).uuid;}if(this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture){data.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(meta).uuid;}if(this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture){data.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(meta).uuid;data.clearcoatNormalScale=this.clearcoatNormalScale.toArray();}if(this.sheenColorMap&&this.sheenColorMap.isTexture){data.sheenColorMap=this.sheenColorMap.toJSON(meta).uuid;}if(this.sheenRoughnessMap&&this.sheenRoughnessMap.isTexture){data.sheenRoughnessMap=this.sheenRoughnessMap.toJSON(meta).uuid;}if(this.dispersion!==undefined)data.dispersion=this.dispersion;if(this.iridescence!==undefined)data.iridescence=this.iridescence;if(this.iridescenceIOR!==undefined)data.iridescenceIOR=this.iridescenceIOR;if(this.iridescenceThicknessRange!==undefined)data.iridescenceThicknessRange=this.iridescenceThicknessRange;if(this.iridescenceMap&&this.iridescenceMap.isTexture){data.iridescenceMap=this.iridescenceMap.toJSON(meta).uuid;}if(this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture){data.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(meta).uuid;}if(this.anisotropy!==undefined)data.anisotropy=this.anisotropy;if(this.anisotropyRotation!==undefined)data.anisotropyRotation=this.anisotropyRotation;if(this.anisotropyMap&&this.anisotropyMap.isTexture){data.anisotropyMap=this.anisotropyMap.toJSON(meta).uuid;}if(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;if(this.matcap&&this.matcap.isTexture)data.matcap=this.matcap.toJSON(meta).uuid;if(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;if(this.lightMap&&this.lightMap.isTexture){data.lightMap=this.lightMap.toJSON(meta).uuid;data.lightMapIntensity=this.lightMapIntensity;}if(this.aoMap&&this.aoMap.isTexture){data.aoMap=this.aoMap.toJSON(meta).uuid;data.aoMapIntensity=this.aoMapIntensity;}if(this.bumpMap&&this.bumpMap.isTexture){data.bumpMap=this.bumpMap.toJSON(meta).uuid;data.bumpScale=this.bumpScale;}if(this.normalMap&&this.normalMap.isTexture){data.normalMap=this.normalMap.toJSON(meta).uuid;data.normalMapType=this.normalMapType;data.normalScale=this.normalScale.toArray();}if(this.displacementMap&&this.displacementMap.isTexture){data.displacementMap=this.displacementMap.toJSON(meta).uuid;data.displacementScale=this.displacementScale;data.displacementBias=this.displacementBias;}if(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;if(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;if(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;if(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;if(this.specularIntensityMap&&this.specularIntensityMap.isTexture)data.specularIntensityMap=this.specularIntensityMap.toJSON(meta).uuid;if(this.specularColorMap&&this.specularColorMap.isTexture)data.specularColorMap=this.specularColorMap.toJSON(meta).uuid;if(this.envMap&&this.envMap.isTexture){data.envMap=this.envMap.toJSON(meta).uuid;if(this.combine!==undefined)data.combine=this.combine;}if(this.envMapRotation!==undefined)data.envMapRotation=this.envMapRotation.toArray();if(this.envMapIntensity!==undefined)data.envMapIntensity=this.envMapIntensity;if(this.reflectivity!==undefined)data.reflectivity=this.reflectivity;if(this.refractionRatio!==undefined)data.refractionRatio=this.refractionRatio;if(this.gradientMap&&this.gradientMap.isTexture){data.gradientMap=this.gradientMap.toJSON(meta).uuid;}if(this.transmission!==undefined)data.transmission=this.transmission;if(this.transmissionMap&&this.transmissionMap.isTexture)data.transmissionMap=this.transmissionMap.toJSON(meta).uuid;if(this.thickness!==undefined)data.thickness=this.thickness;if(this.thicknessMap&&this.thicknessMap.isTexture)data.thicknessMap=this.thicknessMap.toJSON(meta).uuid;if(this.attenuationDistance!==undefined&&this.attenuationDistance!==Infinity)data.attenuationDistance=this.attenuationDistance;if(this.attenuationColor!==undefined)data.attenuationColor=this.attenuationColor.getHex();if(this.size!==undefined)data.size=this.size;if(this.shadowSide!==null)data.shadowSide=this.shadowSide;if(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;if(this.blending!==NormalBlending)data.blending=this.blending;if(this.side!==FrontSide)data.side=this.side;if(this.vertexColors===true)data.vertexColors=true;if(this.opacity<1)data.opacity=this.opacity;if(this.transparent===true)data.transparent=true;if(this.blendSrc!==SrcAlphaFactor)data.blendSrc=this.blendSrc;if(this.blendDst!==OneMinusSrcAlphaFactor)data.blendDst=this.blendDst;if(this.blendEquation!==AddEquation)data.blendEquation=this.blendEquation;if(this.blendSrcAlpha!==null)data.blendSrcAlpha=this.blendSrcAlpha;if(this.blendDstAlpha!==null)data.blendDstAlpha=this.blendDstAlpha;if(this.blendEquationAlpha!==null)data.blendEquationAlpha=this.blendEquationAlpha;if(this.blendColor&&this.blendColor.isColor)data.blendColor=this.blendColor.getHex();if(this.blendAlpha!==0)data.blendAlpha=this.blendAlpha;if(this.depthFunc!==LessEqualDepth)data.depthFunc=this.depthFunc;if(this.depthTest===false)data.depthTest=this.depthTest;if(this.depthWrite===false)data.depthWrite=this.depthWrite;if(this.colorWrite===false)data.colorWrite=this.colorWrite;if(this.stencilWriteMask!==0xff)data.stencilWriteMask=this.stencilWriteMask;if(this.stencilFunc!==AlwaysStencilFunc)data.stencilFunc=this.stencilFunc;if(this.stencilRef!==0)data.stencilRef=this.stencilRef;if(this.stencilFuncMask!==0xff)data.stencilFuncMask=this.stencilFuncMask;if(this.stencilFail!==KeepStencilOp)data.stencilFail=this.stencilFail;if(this.stencilZFail!==KeepStencilOp)data.stencilZFail=this.stencilZFail;if(this.stencilZPass!==KeepStencilOp)data.stencilZPass=this.stencilZPass;if(this.stencilWrite===true)data.stencilWrite=this.stencilWrite;// rotation (SpriteMaterial)
	if(this.rotation!==undefined&&this.rotation!==0)data.rotation=this.rotation;if(this.polygonOffset===true)data.polygonOffset=true;if(this.polygonOffsetFactor!==0)data.polygonOffsetFactor=this.polygonOffsetFactor;if(this.polygonOffsetUnits!==0)data.polygonOffsetUnits=this.polygonOffsetUnits;if(this.linewidth!==undefined&&this.linewidth!==1)data.linewidth=this.linewidth;if(this.dashSize!==undefined)data.dashSize=this.dashSize;if(this.gapSize!==undefined)data.gapSize=this.gapSize;if(this.scale!==undefined)data.scale=this.scale;if(this.dithering===true)data.dithering=true;if(this.alphaTest>0)data.alphaTest=this.alphaTest;if(this.alphaHash===true)data.alphaHash=true;if(this.alphaToCoverage===true)data.alphaToCoverage=true;if(this.premultipliedAlpha===true)data.premultipliedAlpha=true;if(this.forceSinglePass===true)data.forceSinglePass=true;if(this.wireframe===true)data.wireframe=true;if(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;if(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;if(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;if(this.flatShading===true)data.flatShading=true;if(this.visible===false)data.visible=false;if(this.toneMapped===false)data.toneMapped=false;if(this.fog===false)data.fog=false;if(Object.keys(this.userData).length>0)data.userData=this.userData;// TODO: Copied from Object3D.toJSON
	function extractFromCache(cache){const values=[];for(const key in cache){const data=cache[key];delete data.metadata;values.push(data);}return values;}if(isRootObject){const textures=extractFromCache(meta.textures);const images=extractFromCache(meta.images);if(textures.length>0)data.textures=textures;if(images.length>0)data.images=images;}return data;}/**
		 * Returns a new material with copied values from this instance.
		 *
		 * @return {Material} A clone of this instance.
		 */clone(){return new this.constructor().copy(this);}/**
		 * Copies the values of the given material to this instance.
		 *
		 * @param {Material} source - The material to copy.
		 * @return {Material} A reference to this instance.
		 */copy(source){this.name=source.name;this.blending=source.blending;this.side=source.side;this.vertexColors=source.vertexColors;this.opacity=source.opacity;this.transparent=source.transparent;this.blendSrc=source.blendSrc;this.blendDst=source.blendDst;this.blendEquation=source.blendEquation;this.blendSrcAlpha=source.blendSrcAlpha;this.blendDstAlpha=source.blendDstAlpha;this.blendEquationAlpha=source.blendEquationAlpha;this.blendColor.copy(source.blendColor);this.blendAlpha=source.blendAlpha;this.depthFunc=source.depthFunc;this.depthTest=source.depthTest;this.depthWrite=source.depthWrite;this.stencilWriteMask=source.stencilWriteMask;this.stencilFunc=source.stencilFunc;this.stencilRef=source.stencilRef;this.stencilFuncMask=source.stencilFuncMask;this.stencilFail=source.stencilFail;this.stencilZFail=source.stencilZFail;this.stencilZPass=source.stencilZPass;this.stencilWrite=source.stencilWrite;const srcPlanes=source.clippingPlanes;let dstPlanes=null;if(srcPlanes!==null){const n=srcPlanes.length;dstPlanes=new Array(n);for(let i=0;i!==n;++i){dstPlanes[i]=srcPlanes[i].clone();}}this.clippingPlanes=dstPlanes;this.clipIntersection=source.clipIntersection;this.clipShadows=source.clipShadows;this.shadowSide=source.shadowSide;this.colorWrite=source.colorWrite;this.precision=source.precision;this.polygonOffset=source.polygonOffset;this.polygonOffsetFactor=source.polygonOffsetFactor;this.polygonOffsetUnits=source.polygonOffsetUnits;this.dithering=source.dithering;this.alphaTest=source.alphaTest;this.alphaHash=source.alphaHash;this.alphaToCoverage=source.alphaToCoverage;this.premultipliedAlpha=source.premultipliedAlpha;this.forceSinglePass=source.forceSinglePass;this.visible=source.visible;this.toneMapped=source.toneMapped;this.userData=JSON.parse(JSON.stringify(source.userData));return this;}/**
		 * Frees the GPU-related resources allocated by this instance. Call this
		 * method whenever this instance is no longer used in your app.
		 *
		 * @fires Material#dispose
		 */dispose(){/**
			 * Fires when the material has been disposed of.
			 *
			 * @event Material#dispose
			 * @type {Object}
			 */this.dispatchEvent({type:'dispose'});}/**
		 * Setting this property to `true` indicates the engine the material
		 * needs to be recompiled.
		 *
		 * @type {boolean}
		 * @default false
		 * @param {boolean} value
		 */set needsUpdate(value){if(value===true)this.version++;}}/**
	 * A material for drawing geometries in a simple shaded (flat or wireframe) way.
	 *
	 * This material is not affected by lights.
	 *
	 * @augments Material
	 * @demo scenes/material-browser.html#MeshBasicMaterial
	 */class MeshBasicMaterial extends Material{/**
		 * Constructs a new mesh basic material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */constructor(parameters){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isMeshBasicMaterial=true;this.type='MeshBasicMaterial';/**
			 * Color of the material.
			 *
			 * @type {Color}
			 * @default (1,1,1)
			 */this.color=new Color(0xffffff);// diffuse
	/**
			 * The color map. May optionally include an alpha channel, typically combined
			 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
			 * color is modulated by the diffuse `color`.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.map=null;/**
			 * The light map. Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.lightMap=null;/**
			 * Intensity of the baked light.
			 *
			 * @type {number}
			 * @default 1
			 */this.lightMapIntensity=1.0;/**
			 * The red channel of this texture is used as the ambient occlusion map.
			 * Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.aoMap=null;/**
			 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
			 * disables ambient occlusion. Where intensity is `1` and the AO map's
			 * red channel is also `1`, ambient light is fully occluded on a surface.
			 *
			 * @type {number}
			 * @default 1
			 */this.aoMapIntensity=1.0;/**
			 * Specular map used by the material.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.specularMap=null;/**
			 * The alpha map is a grayscale texture that controls the opacity across the
			 * surface (black: fully transparent; white: fully opaque).
			 *
			 * Only the color of the texture is used, ignoring the alpha channel if one
			 * exists. For RGB and RGBA textures, the renderer will use the green channel
			 * when sampling this texture due to the extra bit of precision provided for
			 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
			 * luminance/alpha textures will also still work as expected.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.alphaMap=null;/**
			 * The environment map.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.envMap=null;/**
			 * The rotation of the environment map in radians.
			 *
			 * @type {Euler}
			 * @default (0,0,0)
			 */this.envMapRotation=new Euler$1();/**
			 * How to combine the result of the surface's color with the environment map, if any.
			 *
			 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
			 * blend between the two colors.
			 *
			 * @type {(MultiplyOperation|MixOperation|AddOperation)}
			 * @default MultiplyOperation
			 */this.combine=MultiplyOperation;/**
			 * How much the environment map affects the surface.
			 * The valid range is between `0` (no reflections) and `1` (full reflections).
			 *
			 * @type {number}
			 * @default 1
			 */this.reflectivity=1;/**
			 * The index of refraction (IOR) of air (approximately 1) divided by the
			 * index of refraction of the material. It is used with environment mapping
			 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
			 * The refraction ratio should not exceed `1`.
			 *
			 * @type {number}
			 * @default 0.98
			 */this.refractionRatio=0.98;/**
			 * Renders the geometry as a wireframe.
			 *
			 * @type {boolean}
			 * @default false
			 */this.wireframe=false;/**
			 * Controls the thickness of the wireframe.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {number}
			 * @default 1
			 */this.wireframeLinewidth=1;/**
			 * Defines appearance of wireframe ends.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */this.wireframeLinecap='round';/**
			 * Defines appearance of wireframe joints.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */this.wireframeLinejoin='round';/**
			 * Whether the material is affected by fog or not.
			 *
			 * @type {boolean}
			 * @default true
			 */this.fog=true;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapRotation.copy(source.envMapRotation);this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.fog=source.fog;return this;}}// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
	const _vector$9=/*@__PURE__*/new Vector3$1();const _vector2$1=/*@__PURE__*/new Vector2$1();let _id$2$1=0;/**
	 * This class stores data for an attribute (such as vertex positions, face
	 * indices, normals, colors, UVs, and any custom attributes ) associated with
	 * a geometry, which allows for more efficient passing of data to the GPU.
	 *
	 * When working with vector-like data, the `fromBufferAttribute( attribute, index )`
	 * helper methods on vector and color class might be helpful. E.g. {@link Vector3#fromBufferAttribute}.
	 */let BufferAttribute$1 = class BufferAttribute{/**
		 * Constructs a new buffer attribute.
		 *
		 * @param {TypedArray} array - The array holding the attribute data.
		 * @param {number} itemSize - The item size.
		 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
		 */constructor(array,itemSize,normalized=false){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isBufferAttribute=true;/**
			 * The ID of the buffer attribute.
			 *
			 * @name BufferAttribute#id
			 * @type {number}
			 * @readonly
			 */Object.defineProperty(this,'id',{value:_id$2$1++});/**
			 * The name of the buffer attribute.
			 *
			 * @type {string}
			 */this.name='';/**
			 * The array holding the attribute data. It should have `itemSize * numVertices`
			 * elements, where `numVertices` is the number of vertices in the associated geometry.
			 *
			 * @type {TypedArray}
			 */this.array=array;/**
			 * The number of values of the array that should be associated with a particular vertex.
			 * For instance, if this attribute is storing a 3-component vector (such as a position,
			 * normal, or color), then the value should be `3`.
			 *
			 * @type {number}
			 */this.itemSize=itemSize;/**
			 * Represents the number of items this buffer attribute stores. It is internally computed
			 * by dividing the `array` length by the `itemSize`.
			 *
			 * @type {number}
			 * @readonly
			 */this.count=array!==undefined?array.length/itemSize:0;/**
			 * Applies to integer data only. Indicates how the underlying data in the buffer maps to
			 * the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
			 * and `normalized` is `true`, the values `0 - +65535` in the array data will be mapped to
			 * `0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
			 * to floats unmodified, i.e. `65535` becomes `65535.0f`.
			 *
			 * @type {boolean}
			 */this.normalized=normalized;/**
			 * Defines the intended usage pattern of the data store for optimization purposes.
			 *
			 * Note: After the initial use of a buffer, its usage cannot be changed. Instead,
			 * instantiate a new one and set the desired usage before the next render.
			 *
			 * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
			 * @default StaticDrawUsage
			 */this.usage=StaticDrawUsage$1;/**
			 * This can be used to only update some components of stored vectors (for example, just the
			 * component related to color). Use the `addUpdateRange()` function to add ranges to this array.
			 *
			 * @type {Array<Object>}
			 */this.updateRanges=[];/**
			 * Configures the bound GPU type for use in shaders.
			 *
			 * Note: this only has an effect for integer arrays and is not configurable for float arrays.
			 * For lower precision float types, use `Float16BufferAttribute`.
			 *
			 * @type {(FloatType|IntType)}
			 * @default FloatType
			 */this.gpuType=FloatType$1;/**
			 * A version number, incremented every time the `needsUpdate` is set to `true`.
			 *
			 * @type {number}
			 */this.version=0;}/**
		 * A callback function that is executed after the renderer has transferred the attribute
		 * array data to the GPU.
		 */onUploadCallback(){}/**
		 * Flag to indicate that this attribute has changed and should be re-sent to
		 * the GPU. Set this to `true` when you modify the value of the array.
		 *
		 * @type {number}
		 * @default false
		 * @param {boolean} value
		 */set needsUpdate(value){if(value===true)this.version++;}/**
		 * Sets the usage of this buffer attribute.
		 *
		 * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
		 * @return {BufferAttribute} A reference to this buffer attribute.
		 */setUsage(value){this.usage=value;return this;}/**
		 * Adds a range of data in the data array to be updated on the GPU.
		 *
		 * @param {number} start - Position at which to start update.
		 * @param {number} count - The number of components to update.
		 */addUpdateRange(start,count){this.updateRanges.push({start,count});}/**
		 * Clears the update ranges.
		 */clearUpdateRanges(){this.updateRanges.length=0;}/**
		 * Copies the values of the given buffer attribute to this instance.
		 *
		 * @param {BufferAttribute} source - The buffer attribute to copy.
		 * @return {BufferAttribute} A reference to this instance.
		 */copy(source){this.name=source.name;this.array=new source.array.constructor(source.array);this.itemSize=source.itemSize;this.count=source.count;this.normalized=source.normalized;this.usage=source.usage;this.gpuType=source.gpuType;return this;}/**
		 * Copies a vector from the given buffer attribute to this one. The start
		 * and destination position in the attribute buffers are represented by the
		 * given indices.
		 *
		 * @param {number} index1 - The destination index into this buffer attribute.
		 * @param {BufferAttribute} attribute - The buffer attribute to copy from.
		 * @param {number} index2 - The source index into the given buffer attribute.
		 * @return {BufferAttribute} A reference to this instance.
		 */copyAt(index1,attribute,index2){index1*=this.itemSize;index2*=attribute.itemSize;for(let i=0,l=this.itemSize;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;}/**
		 * Copies the given array data into this buffer attribute.
		 *
		 * @param {(TypedArray|Array)} array - The array to copy.
		 * @return {BufferAttribute} A reference to this instance.
		 */copyArray(array){this.array.set(array);return this;}/**
		 * Applies the given 3x3 matrix to the given attribute. Works with
		 * item size `2` and `3`.
		 *
		 * @param {Matrix3} m - The matrix to apply.
		 * @return {BufferAttribute} A reference to this instance.
		 */applyMatrix3(m){if(this.itemSize===2){for(let i=0,l=this.count;i<l;i++){_vector2$1.fromBufferAttribute(this,i);_vector2$1.applyMatrix3(m);this.setXY(i,_vector2$1.x,_vector2$1.y);}}else if(this.itemSize===3){for(let i=0,l=this.count;i<l;i++){_vector$9.fromBufferAttribute(this,i);_vector$9.applyMatrix3(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}}return this;}/**
		 * Applies the given 4x4 matrix to the given attribute. Only works with
		 * item size `3`.
		 *
		 * @param {Matrix4} m - The matrix to apply.
		 * @return {BufferAttribute} A reference to this instance.
		 */applyMatrix4(m){for(let i=0,l=this.count;i<l;i++){_vector$9.fromBufferAttribute(this,i);_vector$9.applyMatrix4(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}/**
		 * Applies the given 3x3 normal matrix to the given attribute. Only works with
		 * item size `3`.
		 *
		 * @param {Matrix3} m - The normal matrix to apply.
		 * @return {BufferAttribute} A reference to this instance.
		 */applyNormalMatrix(m){for(let i=0,l=this.count;i<l;i++){_vector$9.fromBufferAttribute(this,i);_vector$9.applyNormalMatrix(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}/**
		 * Applies the given 4x4 matrix to the given attribute. Only works with
		 * item size `3` and with direction vectors.
		 *
		 * @param {Matrix4} m - The matrix to apply.
		 * @return {BufferAttribute} A reference to this instance.
		 */transformDirection(m){for(let i=0,l=this.count;i<l;i++){_vector$9.fromBufferAttribute(this,i);_vector$9.transformDirection(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}/**
		 * Sets the given array data in the buffer attribute.
		 *
		 * @param {(TypedArray|Array)} value - The array data to set.
		 * @param {number} [offset=0] - The offset in this buffer attribute's array.
		 * @return {BufferAttribute} A reference to this instance.
		 */set(value,offset=0){// Matching BufferAttribute constructor, do not normalize the array.
	this.array.set(value,offset);return this;}/**
		 * Returns the given component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} component - The component index.
		 * @return {number} The returned value.
		 */getComponent(index,component){let value=this.array[index*this.itemSize+component];if(this.normalized)value=denormalize$1(value,this.array);return value;}/**
		 * Sets the given value to the given component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} component - The component index.
		 * @param {number} value - The value to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */setComponent(index,component,value){if(this.normalized)value=normalize$1(value,this.array);this.array[index*this.itemSize+component]=value;return this;}/**
		 * Returns the x component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @return {number} The x component.
		 */getX(index){let x=this.array[index*this.itemSize];if(this.normalized)x=denormalize$1(x,this.array);return x;}/**
		 * Sets the x component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} x - The value to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */setX(index,x){if(this.normalized)x=normalize$1(x,this.array);this.array[index*this.itemSize]=x;return this;}/**
		 * Returns the y component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @return {number} The y component.
		 */getY(index){let y=this.array[index*this.itemSize+1];if(this.normalized)y=denormalize$1(y,this.array);return y;}/**
		 * Sets the y component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} y - The value to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */setY(index,y){if(this.normalized)y=normalize$1(y,this.array);this.array[index*this.itemSize+1]=y;return this;}/**
		 * Returns the z component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @return {number} The z component.
		 */getZ(index){let z=this.array[index*this.itemSize+2];if(this.normalized)z=denormalize$1(z,this.array);return z;}/**
		 * Sets the z component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} z - The value to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */setZ(index,z){if(this.normalized)z=normalize$1(z,this.array);this.array[index*this.itemSize+2]=z;return this;}/**
		 * Returns the w component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @return {number} The w component.
		 */getW(index){let w=this.array[index*this.itemSize+3];if(this.normalized)w=denormalize$1(w,this.array);return w;}/**
		 * Sets the w component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} w - The value to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */setW(index,w){if(this.normalized)w=normalize$1(w,this.array);this.array[index*this.itemSize+3]=w;return this;}/**
		 * Sets the x and y component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} x - The value for the x component to set.
		 * @param {number} y - The value for the y component to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */setXY(index,x,y){index*=this.itemSize;if(this.normalized){x=normalize$1(x,this.array);y=normalize$1(y,this.array);}this.array[index+0]=x;this.array[index+1]=y;return this;}/**
		 * Sets the x, y and z component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} x - The value for the x component to set.
		 * @param {number} y - The value for the y component to set.
		 * @param {number} z - The value for the z component to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */setXYZ(index,x,y,z){index*=this.itemSize;if(this.normalized){x=normalize$1(x,this.array);y=normalize$1(y,this.array);z=normalize$1(z,this.array);}this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;return this;}/**
		 * Sets the x, y, z and w component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} x - The value for the x component to set.
		 * @param {number} y - The value for the y component to set.
		 * @param {number} z - The value for the z component to set.
		 * @param {number} w - The value for the w component to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */setXYZW(index,x,y,z,w){index*=this.itemSize;if(this.normalized){x=normalize$1(x,this.array);y=normalize$1(y,this.array);z=normalize$1(z,this.array);w=normalize$1(w,this.array);}this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;this.array[index+3]=w;return this;}/**
		 * Sets the given callback function that is executed after the Renderer has transferred
		 * the attribute array data to the GPU. Can be used to perform clean-up operations after
		 * the upload when attribute data are not needed anymore on the CPU side.
		 *
		 * @param {Function} callback - The `onUpload()` callback.
		 * @return {BufferAttribute} A reference to this instance.
		 */onUpload(callback){this.onUploadCallback=callback;return this;}/**
		 * Returns a new buffer attribute with copied values from this instance.
		 *
		 * @return {BufferAttribute} A clone of this instance.
		 */clone(){return new this.constructor(this.array,this.itemSize).copy(this);}/**
		 * Serializes the buffer attribute into JSON.
		 *
		 * @return {Object} A JSON object representing the serialized buffer attribute.
		 */toJSON(){const data={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};if(this.name!=='')data.name=this.name;if(this.usage!==StaticDrawUsage$1)data.usage=this.usage;return data;}};/**
	 * Convenient class that can be used when creating a `UInt16` buffer attribute with
	 * a plain `Array` instance.
	 *
	 * @augments BufferAttribute
	 */let Uint16BufferAttribute$1 = class Uint16BufferAttribute extends BufferAttribute$1{/**
		 * Constructs a new buffer attribute.
		 *
		 * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
		 * @param {number} itemSize - The item size.
		 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
		 */constructor(array,itemSize,normalized){super(new Uint16Array(array),itemSize,normalized);}};/**
	 * Convenient class that can be used when creating a `UInt32` buffer attribute with
	 * a plain `Array` instance.
	 *
	 * @augments BufferAttribute
	 */let Uint32BufferAttribute$1 = class Uint32BufferAttribute extends BufferAttribute$1{/**
		 * Constructs a new buffer attribute.
		 *
		 * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
		 * @param {number} itemSize - The item size.
		 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
		 */constructor(array,itemSize,normalized){super(new Uint32Array(array),itemSize,normalized);}};/**
	 * Convenient class that can be used when creating a `Float32` buffer attribute with
	 * a plain `Array` instance.
	 *
	 * @augments BufferAttribute
	 */let Float32BufferAttribute$1 = class Float32BufferAttribute extends BufferAttribute$1{/**
		 * Constructs a new buffer attribute.
		 *
		 * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
		 * @param {number} itemSize - The item size.
		 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
		 */constructor(array,itemSize,normalized){super(new Float32Array(array),itemSize,normalized);}};let _id$1$1=0;const _m1$4=/*@__PURE__*/new Matrix4$1();const _obj$1=/*@__PURE__*/new Object3D$1();const _offset$1=/*@__PURE__*/new Vector3$1();const _box$2$1=/*@__PURE__*/new Box3$1();const _boxMorphTargets$1=/*@__PURE__*/new Box3$1();const _vector$8=/*@__PURE__*/new Vector3$1();/**
	 * A representation of mesh, line, or point geometry. Includes vertex
	 * positions, face indices, normals, colors, UVs, and custom attributes
	 * within buffers, reducing the cost of passing all this data to the GPU.
	 *
	 * ```js
	 * const geometry = new THREE.BufferGeometry();
	 * // create a simple square shape. We duplicate the top left and bottom right
	 * // vertices because each vertex needs to appear once per triangle.
	 * const vertices = new Float32Array( [
	 * 	-1.0, -1.0,  1.0, // v0
	 * 	 1.0, -1.0,  1.0, // v1
	 * 	 1.0,  1.0,  1.0, // v2
	 *
	 * 	 1.0,  1.0,  1.0, // v3
	 * 	-1.0,  1.0,  1.0, // v4
	 * 	-1.0, -1.0,  1.0  // v5
	 * ] );
	 * // itemSize = 3 because there are 3 values (components) per vertex
	 * geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	 * const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
	 * const mesh = new THREE.Mesh( geometry, material );
	 * ```
	 *
	 * @augments EventDispatcher
	 */let BufferGeometry$1 = class BufferGeometry extends EventDispatcher$1{/**
		 * Constructs a new geometry.
		 */constructor(){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isBufferGeometry=true;/**
			 * The ID of the geometry.
			 *
			 * @name BufferGeometry#id
			 * @type {number}
			 * @readonly
			 */Object.defineProperty(this,'id',{value:_id$1$1++});/**
			 * The UUID of the geometry.
			 *
			 * @type {string}
			 * @readonly
			 */this.uuid=generateUUID$1();/**
			 * The name of the geometry.
			 *
			 * @type {string}
			 */this.name='';this.type='BufferGeometry';/**
			 * Allows for vertices to be re-used across multiple triangles; this is
			 * called using "indexed triangles". Each triangle is associated with the
			 * indices of three vertices. This attribute therefore stores the index of
			 * each vertex for each triangular face. If this attribute is not set, the
			 * renderer assumes that each three contiguous positions represent a single triangle.
			 *
			 * @type {?BufferAttribute}
			 * @default null
			 */this.index=null;/**
			 * A (storage) buffer attribute which was generated with a compute shader and
			 * now defines indirect draw calls.
			 *
			 * Can only be used with {@link WebGPURenderer} and a WebGPU backend.
			 *
			 * @type {?BufferAttribute}
			 * @default null
			 */this.indirect=null;/**
			 * This dictionary has as id the name of the attribute to be set and as value
			 * the buffer attribute to set it to. Rather than accessing this property directly,
			 * use `setAttribute()` and `getAttribute()` to access attributes of this geometry.
			 *
			 * @type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}
			 */this.attributes={};/**
			 * This dictionary holds the morph targets of the geometry.
			 *
			 * Note: Once the geometry has been rendered, the morph attribute data cannot
			 * be changed. You will have to call `dispose()?, and create a new geometry instance.
			 *
			 * @type {Object}
			 */this.morphAttributes={};/**
			 * Used to control the morph target behavior; when set to `true`, the morph
			 * target data is treated as relative offsets, rather than as absolute
			 * positions/normals.
			 *
			 * @type {boolean}
			 * @default false
			 */this.morphTargetsRelative=false;/**
			 * Split the geometry into groups, each of which will be rendered in a
			 * separate draw call. This allows an array of materials to be used with the geometry.
			 *
			 * Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.
			 *
			 * Every vertex and index must belong to exactly one group — groups must not share vertices or
			 * indices, and must not leave vertices or indices unused.
			 *
			 * @type {Array<Object>}
			 */this.groups=[];/**
			 * Bounding box for the geometry which can be calculated with `computeBoundingBox()`.
			 *
			 * @type {?Box3}
			 * @default null
			 */this.boundingBox=null;/**
			 * Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.
			 *
			 * @type {?Sphere}
			 * @default null
			 */this.boundingSphere=null;/**
			 * Determines the part of the geometry to render. This should not be set directly,
			 * instead use `setDrawRange()`.
			 *
			 * @type {{start:number,count:number}}
			 */this.drawRange={start:0,count:Infinity};/**
			 * An object that can be used to store custom data about the geometry.
			 * It should not hold references to functions as these will not be cloned.
			 *
			 * @type {Object}
			 */this.userData={};}/**
		 * Returns the index of this geometry.
		 *
		 * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
		 */getIndex(){return this.index;}/**
		 * Sets the given index to this geometry.
		 *
		 * @param {Array<number>|BufferAttribute} index - The index to set.
		 * @return {BufferGeometry} A reference to this instance.
		 */setIndex(index){if(Array.isArray(index)){this.index=new(arrayNeedsUint32$1(index)?Uint32BufferAttribute$1:Uint16BufferAttribute$1)(index,1);}else {this.index=index;}return this;}/**
		 * Sets the given indirect attribute to this geometry.
		 *
		 * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
		 * @return {BufferGeometry} A reference to this instance.
		 */setIndirect(indirect){this.indirect=indirect;return this;}/**
		 * Returns the indirect attribute of this geometry.
		 *
		 * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
		 */getIndirect(){return this.indirect;}/**
		 * Returns the buffer attribute for the given name.
		 *
		 * @param {string} name - The attribute name.
		 * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
		 * Returns `undefined` if not attribute has been found.
		 */getAttribute(name){return this.attributes[name];}/**
		 * Sets the given attribute for the given name.
		 *
		 * @param {string} name - The attribute name.
		 * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
		 * @return {BufferGeometry} A reference to this instance.
		 */setAttribute(name,attribute){this.attributes[name]=attribute;return this;}/**
		 * Deletes the attribute for the given name.
		 *
		 * @param {string} name - The attribute name to delete.
		 * @return {BufferGeometry} A reference to this instance.
		 */deleteAttribute(name){delete this.attributes[name];return this;}/**
		 * Returns `true` if this geometry has an attribute for the given name.
		 *
		 * @param {string} name - The attribute name.
		 * @return {boolean} Whether this geometry has an attribute for the given name or not.
		 */hasAttribute(name){return this.attributes[name]!==undefined;}/**
		 * Adds a group to this geometry.
		 *
		 * @param {number} start - The first element in this draw call. That is the first
		 * vertex for non-indexed geometry, otherwise the first triangle index.
		 * @param {number} count - Specifies how many vertices (or indices) are part of this group.
		 * @param {number} [materialIndex=0] - The material array index to use.
		 */addGroup(start,count,materialIndex=0){this.groups.push({start:start,count:count,materialIndex:materialIndex});}/**
		 * Clears all groups.
		 */clearGroups(){this.groups=[];}/**
		 * Sets the draw range for this geometry.
		 *
		 * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
		 * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
		 * For indexed BufferGeometry, `count` is the number of indices to render.
		 */setDrawRange(start,count){this.drawRange.start=start;this.drawRange.count=count;}/**
		 * Applies the given 4x4 transformation matrix to the geometry.
		 *
		 * @param {Matrix4} matrix - The matrix to apply.
		 * @return {BufferGeometry} A reference to this instance.
		 */applyMatrix4(matrix){const position=this.attributes.position;if(position!==undefined){position.applyMatrix4(matrix);position.needsUpdate=true;}const normal=this.attributes.normal;if(normal!==undefined){const normalMatrix=new Matrix3$1().getNormalMatrix(matrix);normal.applyNormalMatrix(normalMatrix);normal.needsUpdate=true;}const tangent=this.attributes.tangent;if(tangent!==undefined){tangent.transformDirection(matrix);tangent.needsUpdate=true;}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}return this;}/**
		 * Applies the rotation represented by the Quaternion to the geometry.
		 *
		 * @param {Quaternion} q - The Quaternion to apply.
		 * @return {BufferGeometry} A reference to this instance.
		 */applyQuaternion(q){_m1$4.makeRotationFromQuaternion(q);this.applyMatrix4(_m1$4);return this;}/**
		 * Rotates the geometry about the X axis. This is typically done as a one time
		 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
		 * real-time mesh rotation.
		 *
		 * @param {number} angle - The angle in radians.
		 * @return {BufferGeometry} A reference to this instance.
		 */rotateX(angle){// rotate geometry around world x-axis
	_m1$4.makeRotationX(angle);this.applyMatrix4(_m1$4);return this;}/**
		 * Rotates the geometry about the Y axis. This is typically done as a one time
		 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
		 * real-time mesh rotation.
		 *
		 * @param {number} angle - The angle in radians.
		 * @return {BufferGeometry} A reference to this instance.
		 */rotateY(angle){// rotate geometry around world y-axis
	_m1$4.makeRotationY(angle);this.applyMatrix4(_m1$4);return this;}/**
		 * Rotates the geometry about the Z axis. This is typically done as a one time
		 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
		 * real-time mesh rotation.
		 *
		 * @param {number} angle - The angle in radians.
		 * @return {BufferGeometry} A reference to this instance.
		 */rotateZ(angle){// rotate geometry around world z-axis
	_m1$4.makeRotationZ(angle);this.applyMatrix4(_m1$4);return this;}/**
		 * Translates the geometry. This is typically done as a one time
		 * operation, and not during a loop. Use {@link Object3D#position} for typical
		 * real-time mesh rotation.
		 *
		 * @param {number} x - The x offset.
		 * @param {number} y - The y offset.
		 * @param {number} z - The z offset.
		 * @return {BufferGeometry} A reference to this instance.
		 */translate(x,y,z){// translate geometry
	_m1$4.makeTranslation(x,y,z);this.applyMatrix4(_m1$4);return this;}/**
		 * Scales the geometry. This is typically done as a one time
		 * operation, and not during a loop. Use {@link Object3D#scale} for typical
		 * real-time mesh rotation.
		 *
		 * @param {number} x - The x scale.
		 * @param {number} y - The y scale.
		 * @param {number} z - The z scale.
		 * @return {BufferGeometry} A reference to this instance.
		 */scale(x,y,z){// scale geometry
	_m1$4.makeScale(x,y,z);this.applyMatrix4(_m1$4);return this;}/**
		 * Rotates the geometry to face a point in 3D space. This is typically done as a one time
		 * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
		 * real-time mesh rotation.
		 *
		 * @param {Vector3} vector - The target point.
		 * @return {BufferGeometry} A reference to this instance.
		 */lookAt(vector){_obj$1.lookAt(vector);_obj$1.updateMatrix();this.applyMatrix4(_obj$1.matrix);return this;}/**
		 * Center the geometry based on its bounding box.
		 *
		 * @return {BufferGeometry} A reference to this instance.
		 */center(){this.computeBoundingBox();this.boundingBox.getCenter(_offset$1).negate();this.translate(_offset$1.x,_offset$1.y,_offset$1.z);return this;}/**
		 * Defines a geometry by creating a `position` attribute based on the given array of points. The array
		 * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
		 * set to `0`.
		 *
		 * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
		 * data from the array. The length of the array must match the vertex count.
		 *
		 * @param {Array<Vector2>|Array<Vector3>} points - The points.
		 * @return {BufferGeometry} A reference to this instance.
		 */setFromPoints(points){const positionAttribute=this.getAttribute('position');if(positionAttribute===undefined){const position=[];for(let i=0,l=points.length;i<l;i++){const point=points[i];position.push(point.x,point.y,point.z||0);}this.setAttribute('position',new Float32BufferAttribute$1(position,3));}else {const l=Math.min(points.length,positionAttribute.count);// make sure data do not exceed buffer size
	for(let i=0;i<l;i++){const point=points[i];positionAttribute.setXYZ(i,point.x,point.y,point.z||0);}if(points.length>positionAttribute.count){warn$1('BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.');}positionAttribute.needsUpdate=true;}return this;}/**
		 * Computes the bounding box of the geometry, and updates the `boundingBox` member.
		 * The bounding box is not computed by the engine; it must be computed by your app.
		 * You may need to recompute the bounding box if the geometry vertices are modified.
		 */computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3$1();}const position=this.attributes.position;const morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){error$1('BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.',this);this.boundingBox.set(new Vector3$1(-Infinity,-Infinity,-Infinity),new Vector3$1(+Infinity,+Infinity,+Infinity));return;}if(position!==undefined){this.boundingBox.setFromBufferAttribute(position);// process morph attributes if present
	if(morphAttributesPosition){for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i];_box$2$1.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$8.addVectors(this.boundingBox.min,_box$2$1.min);this.boundingBox.expandByPoint(_vector$8);_vector$8.addVectors(this.boundingBox.max,_box$2$1.max);this.boundingBox.expandByPoint(_vector$8);}else {this.boundingBox.expandByPoint(_box$2$1.min);this.boundingBox.expandByPoint(_box$2$1.max);}}}}else {this.boundingBox.makeEmpty();}if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){error$1('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this);}}/**
		 * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
		 * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
		 * You may need to recompute the bounding sphere if the geometry vertices are modified.
		 */computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere$1();}const position=this.attributes.position;const morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){error$1('BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.',this);this.boundingSphere.set(new Vector3$1(),Infinity);return;}if(position){// first, find the center of the bounding sphere
	const center=this.boundingSphere.center;_box$2$1.setFromBufferAttribute(position);// process morph attributes if present
	if(morphAttributesPosition){for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i];_boxMorphTargets$1.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$8.addVectors(_box$2$1.min,_boxMorphTargets$1.min);_box$2$1.expandByPoint(_vector$8);_vector$8.addVectors(_box$2$1.max,_boxMorphTargets$1.max);_box$2$1.expandByPoint(_vector$8);}else {_box$2$1.expandByPoint(_boxMorphTargets$1.min);_box$2$1.expandByPoint(_boxMorphTargets$1.max);}}}_box$2$1.getCenter(center);// second, try to find a boundingSphere with a radius smaller than the
	// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
	let maxRadiusSq=0;for(let i=0,il=position.count;i<il;i++){_vector$8.fromBufferAttribute(position,i);maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$8));}// process morph attributes if present
	if(morphAttributesPosition){for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i];const morphTargetsRelative=this.morphTargetsRelative;for(let j=0,jl=morphAttribute.count;j<jl;j++){_vector$8.fromBufferAttribute(morphAttribute,j);if(morphTargetsRelative){_offset$1.fromBufferAttribute(position,j);_vector$8.add(_offset$1);}maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$8));}}}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);if(isNaN(this.boundingSphere.radius)){error$1('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this);}}}/**
		 * Calculates and adds a tangent attribute to this geometry.
		 *
		 * The computation is only supported for indexed geometries and if position, normal, and uv attributes
		 * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
		 * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
		 */computeTangents(){const index=this.index;const attributes=this.attributes;// based on http://www.terathon.com/code/tangent.html
	// (per vertex tangents)
	if(index===null||attributes.position===undefined||attributes.normal===undefined||attributes.uv===undefined){error$1('BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');return;}const positionAttribute=attributes.position;const normalAttribute=attributes.normal;const uvAttribute=attributes.uv;if(this.hasAttribute('tangent')===false){this.setAttribute('tangent',new BufferAttribute$1(new Float32Array(4*positionAttribute.count),4));}const tangentAttribute=this.getAttribute('tangent');const tan1=[],tan2=[];for(let i=0;i<positionAttribute.count;i++){tan1[i]=new Vector3$1();tan2[i]=new Vector3$1();}const vA=new Vector3$1(),vB=new Vector3$1(),vC=new Vector3$1(),uvA=new Vector2$1(),uvB=new Vector2$1(),uvC=new Vector2$1(),sdir=new Vector3$1(),tdir=new Vector3$1();function handleTriangle(a,b,c){vA.fromBufferAttribute(positionAttribute,a);vB.fromBufferAttribute(positionAttribute,b);vC.fromBufferAttribute(positionAttribute,c);uvA.fromBufferAttribute(uvAttribute,a);uvB.fromBufferAttribute(uvAttribute,b);uvC.fromBufferAttribute(uvAttribute,c);vB.sub(vA);vC.sub(vA);uvB.sub(uvA);uvC.sub(uvA);const r=1.0/(uvB.x*uvC.y-uvC.x*uvB.y);// silently ignore degenerate uv triangles having coincident or colinear vertices
	if(!isFinite(r))return;sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC,-uvB.y).multiplyScalar(r);tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB,-uvC.x).multiplyScalar(r);tan1[a].add(sdir);tan1[b].add(sdir);tan1[c].add(sdir);tan2[a].add(tdir);tan2[b].add(tdir);tan2[c].add(tdir);}let groups=this.groups;if(groups.length===0){groups=[{start:0,count:index.count}];}for(let i=0,il=groups.length;i<il;++i){const group=groups[i];const start=group.start;const count=group.count;for(let j=start,jl=start+count;j<jl;j+=3){handleTriangle(index.getX(j+0),index.getX(j+1),index.getX(j+2));}}const tmp=new Vector3$1(),tmp2=new Vector3$1();const n=new Vector3$1(),n2=new Vector3$1();function handleVertex(v){n.fromBufferAttribute(normalAttribute,v);n2.copy(n);const t=tan1[v];// Gram-Schmidt orthogonalize
	tmp.copy(t);tmp.sub(n.multiplyScalar(n.dot(t))).normalize();// Calculate handedness
	tmp2.crossVectors(n2,t);const test=tmp2.dot(tan2[v]);const w=test<0.0?-1:1.0;tangentAttribute.setXYZW(v,tmp.x,tmp.y,tmp.z,w);}for(let i=0,il=groups.length;i<il;++i){const group=groups[i];const start=group.start;const count=group.count;for(let j=start,jl=start+count;j<jl;j+=3){handleVertex(index.getX(j+0));handleVertex(index.getX(j+1));handleVertex(index.getX(j+2));}}}/**
		 * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
		 * each vertex normal to be the average of the face normals of the faces that share that vertex.
		 * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
		 * to be the same as the face normal.
		 */computeVertexNormals(){const index=this.index;const positionAttribute=this.getAttribute('position');if(positionAttribute!==undefined){let normalAttribute=this.getAttribute('normal');if(normalAttribute===undefined){normalAttribute=new BufferAttribute$1(new Float32Array(positionAttribute.count*3),3);this.setAttribute('normal',normalAttribute);}else {// reset existing normals to zero
	for(let i=0,il=normalAttribute.count;i<il;i++){normalAttribute.setXYZ(i,0,0,0);}}const pA=new Vector3$1(),pB=new Vector3$1(),pC=new Vector3$1();const nA=new Vector3$1(),nB=new Vector3$1(),nC=new Vector3$1();const cb=new Vector3$1(),ab=new Vector3$1();// indexed elements
	if(index){for(let i=0,il=index.count;i<il;i+=3){const vA=index.getX(i+0);const vB=index.getX(i+1);const vC=index.getX(i+2);pA.fromBufferAttribute(positionAttribute,vA);pB.fromBufferAttribute(positionAttribute,vB);pC.fromBufferAttribute(positionAttribute,vC);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);nA.fromBufferAttribute(normalAttribute,vA);nB.fromBufferAttribute(normalAttribute,vB);nC.fromBufferAttribute(normalAttribute,vC);nA.add(cb);nB.add(cb);nC.add(cb);normalAttribute.setXYZ(vA,nA.x,nA.y,nA.z);normalAttribute.setXYZ(vB,nB.x,nB.y,nB.z);normalAttribute.setXYZ(vC,nC.x,nC.y,nC.z);}}else {// non-indexed elements (unconnected triangle soup)
	for(let i=0,il=positionAttribute.count;i<il;i+=3){pA.fromBufferAttribute(positionAttribute,i+0);pB.fromBufferAttribute(positionAttribute,i+1);pC.fromBufferAttribute(positionAttribute,i+2);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normalAttribute.setXYZ(i+0,cb.x,cb.y,cb.z);normalAttribute.setXYZ(i+1,cb.x,cb.y,cb.z);normalAttribute.setXYZ(i+2,cb.x,cb.y,cb.z);}}this.normalizeNormals();normalAttribute.needsUpdate=true;}}/**
		 * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
		 * correct lighting on the geometry surfaces.
		 */normalizeNormals(){const normals=this.attributes.normal;for(let i=0,il=normals.count;i<il;i++){_vector$8.fromBufferAttribute(normals,i);_vector$8.normalize();normals.setXYZ(i,_vector$8.x,_vector$8.y,_vector$8.z);}}/**
		 * Return a new non-index version of this indexed geometry. If the geometry
		 * is already non-indexed, the method is a NOOP.
		 *
		 * @return {BufferGeometry} The non-indexed version of this indexed geometry.
		 */toNonIndexed(){function convertBufferAttribute(attribute,indices){const array=attribute.array;const itemSize=attribute.itemSize;const normalized=attribute.normalized;const array2=new array.constructor(indices.length*itemSize);let index=0,index2=0;for(let i=0,l=indices.length;i<l;i++){if(attribute.isInterleavedBufferAttribute){index=indices[i]*attribute.data.stride+attribute.offset;}else {index=indices[i]*itemSize;}for(let j=0;j<itemSize;j++){array2[index2++]=array[index++];}}return new BufferAttribute$1(array2,itemSize,normalized);}//
	if(this.index===null){warn$1('BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');return this;}const geometry2=new BufferGeometry();const indices=this.index.array;const attributes=this.attributes;// attributes
	for(const name in attributes){const attribute=attributes[name];const newAttribute=convertBufferAttribute(attribute,indices);geometry2.setAttribute(name,newAttribute);}// morph attributes
	const morphAttributes=this.morphAttributes;for(const name in morphAttributes){const morphArray=[];const morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes
	for(let i=0,il=morphAttribute.length;i<il;i++){const attribute=morphAttribute[i];const newAttribute=convertBufferAttribute(attribute,indices);morphArray.push(newAttribute);}geometry2.morphAttributes[name]=morphArray;}geometry2.morphTargetsRelative=this.morphTargetsRelative;// groups
	const groups=this.groups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i];geometry2.addGroup(group.start,group.count,group.materialIndex);}return geometry2;}/**
		 * Serializes the geometry into JSON.
		 *
		 * @return {Object} A JSON object representing the serialized geometry.
		 */toJSON(){const data={metadata:{version:4.7,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};// standard BufferGeometry serialization
	data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(Object.keys(this.userData).length>0)data.userData=this.userData;if(this.parameters!==undefined){const parameters=this.parameters;for(const key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}// for simplicity the code assumes attributes are not shared across geometries, see #15811
	data.data={attributes:{}};const index=this.index;if(index!==null){data.data.index={type:index.array.constructor.name,array:Array.prototype.slice.call(index.array)};}const attributes=this.attributes;for(const key in attributes){const attribute=attributes[key];data.data.attributes[key]=attribute.toJSON(data.data);}const morphAttributes={};let hasMorphAttributes=false;for(const key in this.morphAttributes){const attributeArray=this.morphAttributes[key];const array=[];for(let i=0,il=attributeArray.length;i<il;i++){const attribute=attributeArray[i];array.push(attribute.toJSON(data.data));}if(array.length>0){morphAttributes[key]=array;hasMorphAttributes=true;}}if(hasMorphAttributes){data.data.morphAttributes=morphAttributes;data.data.morphTargetsRelative=this.morphTargetsRelative;}const groups=this.groups;if(groups.length>0){data.data.groups=JSON.parse(JSON.stringify(groups));}const boundingSphere=this.boundingSphere;if(boundingSphere!==null){data.data.boundingSphere=boundingSphere.toJSON();}return data;}/**
		 * Returns a new geometry with copied values from this instance.
		 *
		 * @return {BufferGeometry} A clone of this instance.
		 */clone(){return new this.constructor().copy(this);}/**
		 * Copies the values of the given geometry to this instance.
		 *
		 * @param {BufferGeometry} source - The geometry to copy.
		 * @return {BufferGeometry} A reference to this instance.
		 */copy(source){// reset
	this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;// used for storing cloned, shared data
	const data={};// name
	this.name=source.name;// index
	const index=source.index;if(index!==null){this.setIndex(index.clone());}// attributes
	const attributes=source.attributes;for(const name in attributes){const attribute=attributes[name];this.setAttribute(name,attribute.clone(data));}// morph attributes
	const morphAttributes=source.morphAttributes;for(const name in morphAttributes){const array=[];const morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes
	for(let i=0,l=morphAttribute.length;i<l;i++){array.push(morphAttribute[i].clone(data));}this.morphAttributes[name]=array;}this.morphTargetsRelative=source.morphTargetsRelative;// groups
	const groups=source.groups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i];this.addGroup(group.start,group.count,group.materialIndex);}// bounding box
	const boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
	const boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// draw range
	this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;// user data
	this.userData=source.userData;return this;}/**
		 * Frees the GPU-related resources allocated by this instance. Call this
		 * method whenever this instance is no longer used in your app.
		 *
		 * @fires BufferGeometry#dispose
		 */dispose(){this.dispatchEvent({type:'dispose'});}};const _inverseMatrix$3=/*@__PURE__*/new Matrix4$1();const _ray$3=/*@__PURE__*/new Ray();const _sphere$6=/*@__PURE__*/new Sphere$1();const _sphereHitAt=/*@__PURE__*/new Vector3$1();const _vA$1=/*@__PURE__*/new Vector3$1();const _vB$1=/*@__PURE__*/new Vector3$1();const _vC$1=/*@__PURE__*/new Vector3$1();const _tempA=/*@__PURE__*/new Vector3$1();const _morphA=/*@__PURE__*/new Vector3$1();const _intersectionPoint=/*@__PURE__*/new Vector3$1();const _intersectionPointWorld=/*@__PURE__*/new Vector3$1();/**
	 * Class representing triangular polygon mesh based objects.
	 *
	 * ```js
	 * const geometry = new THREE.BoxGeometry( 1, 1, 1 );
	 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
	 * const mesh = new THREE.Mesh( geometry, material );
	 * scene.add( mesh );
	 * ```
	 *
	 * @augments Object3D
	 */class Mesh extends Object3D$1{/**
		 * Constructs a new mesh.
		 *
		 * @param {BufferGeometry} [geometry] - The mesh geometry.
		 * @param {Material|Array<Material>} [material] - The mesh material.
		 */constructor(geometry=new BufferGeometry$1(),material=new MeshBasicMaterial()){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isMesh=true;this.type='Mesh';/**
			 * The mesh geometry.
			 *
			 * @type {BufferGeometry}
			 */this.geometry=geometry;/**
			 * The mesh material.
			 *
			 * @type {Material|Array<Material>}
			 * @default MeshBasicMaterial
			 */this.material=material;/**
			 * A dictionary representing the morph targets in the geometry. The key is the
			 * morph targets name, the value its attribute index. This member is `undefined`
			 * by default and only set when morph targets are detected in the geometry.
			 *
			 * @type {Object<String,number>|undefined}
			 * @default undefined
			 */this.morphTargetDictionary=undefined;/**
			 * An array of weights typically in the range `[0,1]` that specify how much of the morph
			 * is applied. This member is `undefined` by default and only set when morph targets are
			 * detected in the geometry.
			 *
			 * @type {Array<number>|undefined}
			 * @default undefined
			 */this.morphTargetInfluences=undefined;/**
			 * The number of instances of this mesh.
			 * Can only be used with {@link WebGPURenderer}.
			 *
			 * @type {number}
			 * @default 1
			 */this.count=1;this.updateMorphTargets();}copy(source,recursive){super.copy(source,recursive);if(source.morphTargetInfluences!==undefined){this.morphTargetInfluences=source.morphTargetInfluences.slice();}if(source.morphTargetDictionary!==undefined){this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary);}this.material=Array.isArray(source.material)?source.material.slice():source.material;this.geometry=source.geometry;return this;}/**
		 * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
		 * to make sure existing morph targets can influence this 3D object.
		 */updateMorphTargets(){const geometry=this.geometry;const morphAttributes=geometry.morphAttributes;const keys=Object.keys(morphAttributes);if(keys.length>0){const morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(let m=0,ml=morphAttribute.length;m<ml;m++){const name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}/**
		 * Returns the local-space position of the vertex at the given index, taking into
		 * account the current animation state of both morph targets and skinning.
		 *
		 * @param {number} index - The vertex index.
		 * @param {Vector3} target - The target object that is used to store the method's result.
		 * @return {Vector3} The vertex position in local space.
		 */getVertexPosition(index,target){const geometry=this.geometry;const position=geometry.attributes.position;const morphPosition=geometry.morphAttributes.position;const morphTargetsRelative=geometry.morphTargetsRelative;target.fromBufferAttribute(position,index);const morphInfluences=this.morphTargetInfluences;if(morphPosition&&morphInfluences){_morphA.set(0,0,0);for(let i=0,il=morphPosition.length;i<il;i++){const influence=morphInfluences[i];const morphAttribute=morphPosition[i];if(influence===0)continue;_tempA.fromBufferAttribute(morphAttribute,index);if(morphTargetsRelative){_morphA.addScaledVector(_tempA,influence);}else {_morphA.addScaledVector(_tempA.sub(target),influence);}}target.add(_morphA);}return target;}/**
		 * Computes intersection points between a casted ray and this line.
		 *
		 * @param {Raycaster} raycaster - The raycaster.
		 * @param {Array<Object>} intersects - The target array that holds the intersection points.
		 */raycast(raycaster,intersects){const geometry=this.geometry;const material=this.material;const matrixWorld=this.matrixWorld;if(material===undefined)return;// test with bounding sphere in world space
	if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$6.copy(geometry.boundingSphere);_sphere$6.applyMatrix4(matrixWorld);// check distance from ray origin to bounding sphere
	_ray$3.copy(raycaster.ray).recast(raycaster.near);if(_sphere$6.containsPoint(_ray$3.origin)===false){if(_ray$3.intersectSphere(_sphere$6,_sphereHitAt)===null)return;if(_ray$3.origin.distanceToSquared(_sphereHitAt)>(raycaster.far-raycaster.near)**2)return;}// convert ray to local space of mesh
	_inverseMatrix$3.copy(matrixWorld).invert();_ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);// test with bounding box in local space
	if(geometry.boundingBox!==null){if(_ray$3.intersectsBox(geometry.boundingBox)===false)return;}// test for intersections with geometry
	this._computeIntersections(raycaster,intersects,_ray$3);}_computeIntersections(raycaster,intersects,rayLocalSpace){let intersection;const geometry=this.geometry;const material=this.material;const index=geometry.index;const position=geometry.attributes.position;const uv=geometry.attributes.uv;const uv1=geometry.attributes.uv1;const normal=geometry.attributes.normal;const groups=geometry.groups;const drawRange=geometry.drawRange;if(index!==null){// indexed buffer geometry
	if(Array.isArray(material)){for(let i=0,il=groups.length;i<il;i++){const group=groups[i];const groupMaterial=material[group.materialIndex];const start=Math.max(group.start,drawRange.start);const end=Math.min(index.count,Math.min(group.start+group.count,drawRange.start+drawRange.count));for(let j=start,jl=end;j<jl;j+=3){const a=index.getX(j);const b=index.getX(j+1);const c=index.getX(j+2);intersection=checkGeometryIntersection(this,groupMaterial,raycaster,rayLocalSpace,uv,uv1,normal,a,b,c);if(intersection){intersection.faceIndex=Math.floor(j/3);// triangle number in indexed buffer semantics
	intersection.face.materialIndex=group.materialIndex;intersects.push(intersection);}}}}else {const start=Math.max(0,drawRange.start);const end=Math.min(index.count,drawRange.start+drawRange.count);for(let i=start,il=end;i<il;i+=3){const a=index.getX(i);const b=index.getX(i+1);const c=index.getX(i+2);intersection=checkGeometryIntersection(this,material,raycaster,rayLocalSpace,uv,uv1,normal,a,b,c);if(intersection){intersection.faceIndex=Math.floor(i/3);// triangle number in indexed buffer semantics
	intersects.push(intersection);}}}}else if(position!==undefined){// non-indexed buffer geometry
	if(Array.isArray(material)){for(let i=0,il=groups.length;i<il;i++){const group=groups[i];const groupMaterial=material[group.materialIndex];const start=Math.max(group.start,drawRange.start);const end=Math.min(position.count,Math.min(group.start+group.count,drawRange.start+drawRange.count));for(let j=start,jl=end;j<jl;j+=3){const a=j;const b=j+1;const c=j+2;intersection=checkGeometryIntersection(this,groupMaterial,raycaster,rayLocalSpace,uv,uv1,normal,a,b,c);if(intersection){intersection.faceIndex=Math.floor(j/3);// triangle number in non-indexed buffer semantics
	intersection.face.materialIndex=group.materialIndex;intersects.push(intersection);}}}}else {const start=Math.max(0,drawRange.start);const end=Math.min(position.count,drawRange.start+drawRange.count);for(let i=start,il=end;i<il;i+=3){const a=i;const b=i+1;const c=i+2;intersection=checkGeometryIntersection(this,material,raycaster,rayLocalSpace,uv,uv1,normal,a,b,c);if(intersection){intersection.faceIndex=Math.floor(i/3);// triangle number in non-indexed buffer semantics
	intersects.push(intersection);}}}}}}function checkIntersection$1(object,material,raycaster,ray,pA,pB,pC,point){let intersect;if(material.side===BackSide){intersect=ray.intersectTriangle(pC,pB,pA,true,point);}else {intersect=ray.intersectTriangle(pA,pB,pC,material.side===FrontSide,point);}if(intersect===null)return null;_intersectionPointWorld.copy(point);_intersectionPointWorld.applyMatrix4(object.matrixWorld);const distance=raycaster.ray.origin.distanceTo(_intersectionPointWorld);if(distance<raycaster.near||distance>raycaster.far)return null;return {distance:distance,point:_intersectionPointWorld.clone(),object:object};}function checkGeometryIntersection(object,material,raycaster,ray,uv,uv1,normal,a,b,c){object.getVertexPosition(a,_vA$1);object.getVertexPosition(b,_vB$1);object.getVertexPosition(c,_vC$1);const intersection=checkIntersection$1(object,material,raycaster,ray,_vA$1,_vB$1,_vC$1,_intersectionPoint);if(intersection){const barycoord=new Vector3$1();Triangle.getBarycoord(_intersectionPoint,_vA$1,_vB$1,_vC$1,barycoord);if(uv){intersection.uv=Triangle.getInterpolatedAttribute(uv,a,b,c,barycoord,new Vector2$1());}if(uv1){intersection.uv1=Triangle.getInterpolatedAttribute(uv1,a,b,c,barycoord,new Vector2$1());}if(normal){intersection.normal=Triangle.getInterpolatedAttribute(normal,a,b,c,barycoord,new Vector3$1());if(intersection.normal.dot(ray.direction)>0){intersection.normal.multiplyScalar(-1);}}const face={a:a,b:b,c:c,normal:new Vector3$1(),materialIndex:0};Triangle.getNormal(_vA$1,_vB$1,_vC$1,face.normal);intersection.face=face;intersection.barycoord=barycoord;}return intersection;}/**
	 * A geometry class for a rectangular cuboid with a given width, height, and depth.
	 * On creation, the cuboid is centred on the origin, with each edge parallel to one
	 * of the axes.
	 *
	 * ```js
	 * const geometry = new THREE.BoxGeometry( 1, 1, 1 );
	 * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
	 * const cube = new THREE.Mesh( geometry, material );
	 * scene.add( cube );
	 * ```
	 *
	 * @augments BufferGeometry
	 * @demo scenes/geometry-browser.html#BoxGeometry
	 */let BoxGeometry$1 = class BoxGeometry extends BufferGeometry$1{/**
		 * Constructs a new box geometry.
		 *
		 * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
		 * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
		 * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
		 * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
		 * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
		 * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
		 */constructor(width=1,height=1,depth=1,widthSegments=1,heightSegments=1,depthSegments=1){super();this.type='BoxGeometry';/**
			 * Holds the constructor parameters that have been
			 * used to generate the geometry. Any modification
			 * after instantiation does not change the geometry.
			 *
			 * @type {Object}
			 */this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};const scope=this;// segments
	widthSegments=Math.floor(widthSegments);heightSegments=Math.floor(heightSegments);depthSegments=Math.floor(depthSegments);// buffers
	const indices=[];const vertices=[];const normals=[];const uvs=[];// helper variables
	let numberOfVertices=0;let groupStart=0;// build each side of the box geometry
	buildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px
	buildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx
	buildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py
	buildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny
	buildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz
	buildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz
	// build geometry
	this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute$1(vertices,3));this.setAttribute('normal',new Float32BufferAttribute$1(normals,3));this.setAttribute('uv',new Float32BufferAttribute$1(uvs,2));function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){const segmentWidth=width/gridX;const segmentHeight=height/gridY;const widthHalf=width/2;const heightHalf=height/2;const depthHalf=depth/2;const gridX1=gridX+1;const gridY1=gridY+1;let vertexCounter=0;let groupCount=0;const vector=new Vector3$1();// generate vertices, normals and uvs
	for(let iy=0;iy<gridY1;iy++){const y=iy*segmentHeight-heightHalf;for(let ix=0;ix<gridX1;ix++){const x=ix*segmentWidth-widthHalf;// set values to correct vector component
	vector[u]=x*udir;vector[v]=y*vdir;vector[w]=depthHalf;// now apply vector to vertex buffer
	vertices.push(vector.x,vector.y,vector.z);// set values to correct vector component
	vector[u]=0;vector[v]=0;vector[w]=depth>0?1:-1;// now apply vector to normal buffer
	normals.push(vector.x,vector.y,vector.z);// uvs
	uvs.push(ix/gridX);uvs.push(1-iy/gridY);// counters
	vertexCounter+=1;}}// indices
	// 1. you need three indices to draw a single face
	// 2. a single segment consists of two faces
	// 3. so we need to generate six (2*3) indices per segment
	for(let iy=0;iy<gridY;iy++){for(let ix=0;ix<gridX;ix++){const a=numberOfVertices+ix+gridX1*iy;const b=numberOfVertices+ix+gridX1*(iy+1);const c=numberOfVertices+(ix+1)+gridX1*(iy+1);const d=numberOfVertices+(ix+1)+gridX1*iy;// faces
	indices.push(a,b,d);indices.push(b,c,d);// increase counter
	groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
	scope.addGroup(groupStart,groupCount,materialIndex);// calculate new start value for groups
	groupStart+=groupCount;// update total number of vertices
	numberOfVertices+=vertexCounter;}}copy(source){super.copy(source);this.parameters=Object.assign({},source.parameters);return this;}/**
		 * Factory method for creating an instance of this class from the given
		 * JSON object.
		 *
		 * @param {Object} data - A JSON object representing the serialized geometry.
		 * @return {BoxGeometry} A new instance.
		 */static fromJSON(data){return new BoxGeometry(data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments);}};/**
	 * Provides utility functions for managing uniforms.
	 *
	 * @module UniformsUtils
	 *//**
	 * Clones the given uniform definitions by performing a deep-copy. That means
	 * if the value of a uniform refers to an object like a Vector3 or Texture,
	 * the cloned uniform will refer to a new object reference.
	 *
	 * @param {Object} src - An object representing uniform definitions.
	 * @return {Object} The cloned uniforms.
	 */function cloneUniforms(src){const dst={};for(const u in src){dst[u]={};for(const p in src[u]){const property=src[u][p];if(property&&(property.isColor||property.isMatrix3||property.isMatrix4||property.isVector2||property.isVector3||property.isVector4||property.isTexture||property.isQuaternion)){if(property.isRenderTargetTexture){warn$1('UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().');dst[u][p]=null;}else {dst[u][p]=property.clone();}}else if(Array.isArray(property)){dst[u][p]=property.slice();}else {dst[u][p]=property;}}}return dst;}/**
	 * Merges the given uniform definitions into a single object. Since the
	 * method internally uses cloneUniforms(), it performs a deep-copy when
	 * producing the merged uniform definitions.
	 *
	 * @param {Array} uniforms - An array of objects containing uniform definitions.
	 * @return {Object} The merged uniforms.
	 */function mergeUniforms(uniforms){const merged={};for(let u=0;u<uniforms.length;u++){const tmp=cloneUniforms(uniforms[u]);for(const p in tmp){merged[p]=tmp[p];}}return merged;}function cloneUniformsGroups(src){const dst=[];for(let u=0;u<src.length;u++){dst.push(src[u].clone());}return dst;}function getUnlitUniformColorSpace(renderer){const currentRenderTarget=renderer.getRenderTarget();if(currentRenderTarget===null){// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
	return renderer.outputColorSpace;}// https://github.com/mrdoob/three.js/issues/27868
	if(currentRenderTarget.isXRRenderTarget===true){return currentRenderTarget.texture.colorSpace;}return ColorManagement.workingColorSpace;}// Legacy
	const UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};var default_vertex="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";var default_fragment="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";/**
	 * A material rendered with custom shaders. A shader is a small program written in GLSL.
	 * that runs on the GPU. You may want to use a custom shader if you need to implement an
	 * effect not included with any of the built-in materials.
	 *
	 * There are the following notes to bear in mind when using a `ShaderMaterial`:
	 *
	 * - `ShaderMaterial` can only be used with {@link WebGLRenderer}.
	 * - Built in attributes and uniforms are passed to the shaders along with your code. If
	 * you don't want that, use {@link RawShaderMaterial} instead.
	 * - You can use the directive `#pragma unroll_loop_start` and `#pragma unroll_loop_end`
	 * in order to unroll a `for` loop in GLSL by the shader preprocessor. The directive has
	 * to be placed right above the loop. The loop formatting has to correspond to a defined standard.
	 *   - The loop has to be [normalized](https://en.wikipedia.org/wiki/Normalized_loop).
	 *   - The loop variable has to be *i*.
	 *   - The value `UNROLLED_LOOP_INDEX` will be replaced with the explicitly
	 * value of *i* for the given iteration and can be used in preprocessor
	 * statements.
	 *
	 * ```js
	 * const material = new THREE.ShaderMaterial( {
	 * 	uniforms: {
	 * 		time: { value: 1.0 },
	 * 		resolution: { value: new THREE.Vector2() }
	 * 	},
	 * 	vertexShader: document.getElementById( 'vertexShader' ).textContent,
	 * 	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
	 * } );
	 * ```
	 *
	 * @augments Material
	 */class ShaderMaterial extends Material{/**
		 * Constructs a new shader material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */constructor(parameters){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isShaderMaterial=true;this.type='ShaderMaterial';/**
			 * Defines custom constants using `#define` directives within the GLSL code
			 * for both the vertex shader and the fragment shader; each key/value pair
			 * yields another directive.
			 * ```js
			 * defines: {
			 * 	FOO: 15,
			 * 	BAR: true
			 * }
			 * ```
			 * Yields the lines:
			 * ```
			 * #define FOO 15
			 * #define BAR true
			 * ```
			 *
			 * @type {Object}
			 */this.defines={};/**
			 * An object of the form:
			 * ```js
			 * {
			 * 	"uniform1": { value: 1.0 },
			 * 	"uniform2": { value: 2 }
			 * }
			 * ```
			 * specifying the uniforms to be passed to the shader code; keys are uniform
			 * names, values are definitions of the form
			 * ```
			 * {
			 * 	value: 1.0
			 * }
			 * ```
			 * where `value` is the value of the uniform. Names must match the name of
			 * the uniform, as defined in the GLSL code. Note that uniforms are refreshed
			 * on every frame, so updating the value of the uniform will immediately
			 * update the value available to the GLSL code.
			 *
			 * @type {Object}
			 */this.uniforms={};/**
			 * An array holding uniforms groups for configuring UBOs.
			 *
			 * @type {Array<UniformsGroup>}
			 */this.uniformsGroups=[];/**
			 * Vertex shader GLSL code. This is the actual code for the shader.
			 *
			 * @type {string}
			 */this.vertexShader=default_vertex;/**
			 * Fragment shader GLSL code. This is the actual code for the shader.
			 *
			 * @type {string}
			 */this.fragmentShader=default_fragment;/**
			 * Controls line thickness or lines.
			 *
			 * WebGL and WebGPU ignore this setting and always render line primitives with a
			 * width of one pixel.
			 *
			 * @type {number}
			 * @default 1
			 */this.linewidth=1;/**
			 * Renders the geometry as a wireframe.
			 *
			 * @type {boolean}
			 * @default false
			 */this.wireframe=false;/**
			 * Controls the thickness of the wireframe.
			 *
			 * WebGL and WebGPU ignore this property and always render
			 * 1 pixel wide lines.
			 *
			 * @type {number}
			 * @default 1
			 */this.wireframeLinewidth=1;/**
			 * Define whether the material color is affected by global fog settings; `true`
			 * to pass fog uniforms to the shader.
			 *
			 * @type {boolean}
			 * @default false
			 */this.fog=false;/**
			 * Defines whether this material uses lighting; `true` to pass uniform data
			 * related to lighting to this shader.
			 *
			 * @type {boolean}
			 * @default false
			 */this.lights=false;/**
			 * Defines whether this material supports clipping; `true` to let the renderer
			 * pass the clippingPlanes uniform.
			 *
			 * @type {boolean}
			 * @default false
			 */this.clipping=false;/**
			 * Overwritten and set to `true` by default.
			 *
			 * @type {boolean}
			 * @default true
			 */this.forceSinglePass=true;/**
			 * This object allows to enable certain WebGL 2 extensions.
			 *
			 * - clipCullDistance: set to `true` to use vertex shader clipping
			 * - multiDraw: set to `true` to use vertex shader multi_draw / enable gl_DrawID
			 *
			 * @type {{clipCullDistance:false,multiDraw:false}}
			 */this.extensions={clipCullDistance:false,// set to use vertex shader clipping
	multiDraw:false// set to use vertex shader multi_draw / enable gl_DrawID
	};/**
			 * When the rendered geometry doesn't include these attributes but the
			 * material does, these default values will be passed to the shaders. This
			 * avoids errors when buffer data is missing.
			 *
			 * - color: [ 1, 1, 1 ]
			 * - uv: [ 0, 0 ]
			 * - uv1: [ 0, 0 ]
			 *
			 * @type {Object}
			 */this.defaultAttributeValues={'color':[1,1,1],'uv':[0,0],'uv1':[0,0]};/**
			 * If set, this calls [gl.bindAttribLocation](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation)
			 * to bind a generic vertex index to an attribute variable.
			 *
			 * @type {string|undefined}
			 * @default undefined
			 */this.index0AttributeName=undefined;/**
			 * Can be used to force a uniform update while changing uniforms in
			 * {@link Object3D#onBeforeRender}.
			 *
			 * @type {boolean}
			 * @default false
			 */this.uniformsNeedUpdate=false;/**
			 * Defines the GLSL version of custom shader code.
			 *
			 * @type {?(GLSL1|GLSL3)}
			 * @default null
			 */this.glslVersion=null;if(parameters!==undefined){this.setValues(parameters);}}copy(source){super.copy(source);this.fragmentShader=source.fragmentShader;this.vertexShader=source.vertexShader;this.uniforms=cloneUniforms(source.uniforms);this.uniformsGroups=cloneUniformsGroups(source.uniformsGroups);this.defines=Object.assign({},source.defines);this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.fog=source.fog;this.lights=source.lights;this.clipping=source.clipping;this.extensions=Object.assign({},source.extensions);this.glslVersion=source.glslVersion;return this;}toJSON(meta){const data=super.toJSON(meta);data.glslVersion=this.glslVersion;data.uniforms={};for(const name in this.uniforms){const uniform=this.uniforms[name];const value=uniform.value;if(value&&value.isTexture){data.uniforms[name]={type:'t',value:value.toJSON(meta).uuid};}else if(value&&value.isColor){data.uniforms[name]={type:'c',value:value.getHex()};}else if(value&&value.isVector2){data.uniforms[name]={type:'v2',value:value.toArray()};}else if(value&&value.isVector3){data.uniforms[name]={type:'v3',value:value.toArray()};}else if(value&&value.isVector4){data.uniforms[name]={type:'v4',value:value.toArray()};}else if(value&&value.isMatrix3){data.uniforms[name]={type:'m3',value:value.toArray()};}else if(value&&value.isMatrix4){data.uniforms[name]={type:'m4',value:value.toArray()};}else {data.uniforms[name]={value:value};// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
	}}if(Object.keys(this.defines).length>0)data.defines=this.defines;data.vertexShader=this.vertexShader;data.fragmentShader=this.fragmentShader;data.lights=this.lights;data.clipping=this.clipping;const extensions={};for(const key in this.extensions){if(this.extensions[key]===true)extensions[key]=true;}if(Object.keys(extensions).length>0)data.extensions=extensions;return data;}}/**
	 * Abstract base class for cameras. This class should always be inherited
	 * when you build a new camera.
	 *
	 * @abstract
	 * @augments Object3D
	 */class Camera extends Object3D$1{/**
		 * Constructs a new camera.
		 */constructor(){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isCamera=true;this.type='Camera';/**
			 * The inverse of the camera's world matrix.
			 *
			 * @type {Matrix4}
			 */this.matrixWorldInverse=new Matrix4$1();/**
			 * The camera's projection matrix.
			 *
			 * @type {Matrix4}
			 */this.projectionMatrix=new Matrix4$1();/**
			 * The inverse of the camera's projection matrix.
			 *
			 * @type {Matrix4}
			 */this.projectionMatrixInverse=new Matrix4$1();/**
			 * The coordinate system in which the camera is used.
			 *
			 * @type {(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
			 */this.coordinateSystem=WebGLCoordinateSystem$1;this._reversedDepth=false;}/**
		 * The flag that indicates whether the camera uses a reversed depth buffer.
		 *
		 * @type {boolean}
		 * @default false
		 */get reversedDepth(){return this._reversedDepth;}copy(source,recursive){super.copy(source,recursive);this.matrixWorldInverse.copy(source.matrixWorldInverse);this.projectionMatrix.copy(source.projectionMatrix);this.projectionMatrixInverse.copy(source.projectionMatrixInverse);this.coordinateSystem=source.coordinateSystem;return this;}/**
		 * Returns a vector representing the ("look") direction of the 3D object in world space.
		 *
		 * This method is overwritten since cameras have a different forward vector compared to other
		 * 3D objects. A camera looks down its local, negative z-axis by default.
		 *
		 * @param {Vector3} target - The target vector the result is stored to.
		 * @return {Vector3} The 3D object's direction in world space.
		 */getWorldDirection(target){return super.getWorldDirection(target).negate();}updateMatrixWorld(force){super.updateMatrixWorld(force);this.matrixWorldInverse.copy(this.matrixWorld).invert();}updateWorldMatrix(updateParents,updateChildren){super.updateWorldMatrix(updateParents,updateChildren);this.matrixWorldInverse.copy(this.matrixWorld).invert();}clone(){return new this.constructor().copy(this);}}const _v3$1=/*@__PURE__*/new Vector3$1();const _minTarget=/*@__PURE__*/new Vector2$1();const _maxTarget=/*@__PURE__*/new Vector2$1();/**
	 * Camera that uses [perspective projection](https://en.wikipedia.org/wiki/Perspective_(graphical)).
	 *
	 * This projection mode is designed to mimic the way the human eye sees. It
	 * is the most common projection mode used for rendering a 3D scene.
	 *
	 * ```js
	 * const camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
	 * scene.add( camera );
	 * ```
	 *
	 * @augments Camera
	 */class PerspectiveCamera extends Camera{/**
		 * Constructs a new perspective camera.
		 *
		 * @param {number} [fov=50] - The vertical field of view.
		 * @param {number} [aspect=1] - The aspect ratio.
		 * @param {number} [near=0.1] - The camera's near plane.
		 * @param {number} [far=2000] - The camera's far plane.
		 */constructor(fov=50,aspect=1,near=0.1,far=2000){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isPerspectiveCamera=true;this.type='PerspectiveCamera';/**
			 * The vertical field of view, from bottom to top of view,
			 * in degrees.
			 *
			 * @type {number}
			 * @default 50
			 */this.fov=fov;/**
			 * The zoom factor of the camera.
			 *
			 * @type {number}
			 * @default 1
			 */this.zoom=1;/**
			 * The camera's near plane. The valid range is greater than `0`
			 * and less than the current value of {@link PerspectiveCamera#far}.
			 *
			 * Note that, unlike for the {@link OrthographicCamera}, `0` is <em>not</em> a
			 * valid value for a perspective camera's near plane.
			 *
			 * @type {number}
			 * @default 0.1
			 */this.near=near;/**
			 * The camera's far plane. Must be greater than the
			 * current value of {@link PerspectiveCamera#near}.
			 *
			 * @type {number}
			 * @default 2000
			 */this.far=far;/**
			 * Object distance used for stereoscopy and depth-of-field effects. This
			 * parameter does not influence the projection matrix unless a
			 * {@link StereoCamera} is being used.
			 *
			 * @type {number}
			 * @default 10
			 */this.focus=10;/**
			 * The aspect ratio, usually the canvas width / canvas height.
			 *
			 * @type {number}
			 * @default 1
			 */this.aspect=aspect;/**
			 * Represents the frustum window specification. This property should not be edited
			 * directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
			 *
			 * @type {?Object}
			 * @default null
			 */this.view=null;/**
			 * Film size used for the larger axis. Default is `35` (millimeters). This
			 * parameter does not influence the projection matrix unless {@link PerspectiveCamera#filmOffset}
			 * is set to a nonzero value.
			 *
			 * @type {number}
			 * @default 35
			 */this.filmGauge=35;/**
			 * Horizontal off-center offset in the same unit as {@link PerspectiveCamera#filmGauge}.
			 *
			 * @type {number}
			 * @default 0
			 */this.filmOffset=0;this.updateProjectionMatrix();}copy(source,recursive){super.copy(source,recursive);this.fov=source.fov;this.zoom=source.zoom;this.near=source.near;this.far=source.far;this.focus=source.focus;this.aspect=source.aspect;this.view=source.view===null?null:Object.assign({},source.view);this.filmGauge=source.filmGauge;this.filmOffset=source.filmOffset;return this;}/**
		 * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
		 */setFocalLength(focalLength){/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */const vExtentSlope=0.5*this.getFilmHeight()/focalLength;this.fov=RAD2DEG*2*Math.atan(vExtentSlope);this.updateProjectionMatrix();}/**
		 * Returns the focal length from the current {@link PerspectiveCamera#fov} and
		 * {@link PerspectiveCamera#filmGauge}.
		 *
		 * @return {number} The computed focal length.
		 */getFocalLength(){const vExtentSlope=Math.tan(DEG2RAD*0.5*this.fov);return 0.5*this.getFilmHeight()/vExtentSlope;}/**
		 * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
		 *
		 * @return {number} The effective FOV.
		 */getEffectiveFOV(){return RAD2DEG*2*Math.atan(Math.tan(DEG2RAD*0.5*this.fov)/this.zoom);}/**
		 * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
		 * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
		 *
		 * @return {number} The film width.
		 */getFilmWidth(){// film not completely covered in portrait format (aspect < 1)
	return this.filmGauge*Math.min(this.aspect,1);}/**
		 * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
		 * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
		 *
		 * @return {number} The film width.
		 */getFilmHeight(){// film not completely covered in landscape format (aspect > 1)
	return this.filmGauge/Math.max(this.aspect,1);}/**
		 * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
		 * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
		 *
		 * @param {number} distance - The viewing distance.
		 * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
		 * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
		 */getViewBounds(distance,minTarget,maxTarget){_v3$1.set(-1,-1,0.5).applyMatrix4(this.projectionMatrixInverse);minTarget.set(_v3$1.x,_v3$1.y).multiplyScalar(-distance/_v3$1.z);_v3$1.set(1,1,0.5).applyMatrix4(this.projectionMatrixInverse);maxTarget.set(_v3$1.x,_v3$1.y).multiplyScalar(-distance/_v3$1.z);}/**
		 * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
		 *
		 * @param {number} distance - The viewing distance.
		 * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
		 * @returns {Vector2} The view size.
		 */getViewSize(distance,target){this.getViewBounds(distance,_minTarget,_maxTarget);return target.subVectors(_maxTarget,_minTarget);}/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *```
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *```
		 * then for each monitor you would call it like this:
		 *```js
		 * const w = 1920;
		 * const h = 1080;
		 * const fullWidth = w * 3;
		 * const fullHeight = h * 2;
		 *
		 * // --A--
		 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 * // --B--
		 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 * // --C--
		 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 * // --D--
		 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 * // --E--
		 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 * // --F--
		 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 * ```
		 *
		 * Note there is no reason monitors have to be the same size or in a grid.
		 *
		 * @param {number} fullWidth - The full width of multiview setup.
		 * @param {number} fullHeight - The full height of multiview setup.
		 * @param {number} x - The horizontal offset of the subcamera.
		 * @param {number} y - The vertical offset of the subcamera.
		 * @param {number} width - The width of subcamera.
		 * @param {number} height - The height of subcamera.
		 */setViewOffset(fullWidth,fullHeight,x,y,width,height){this.aspect=fullWidth/fullHeight;if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();}/**
		 * Removes the view offset from the projection matrix.
		 */clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();}/**
		 * Updates the camera's projection matrix. Must be called after any change of
		 * camera properties.
		 */updateProjectionMatrix(){const near=this.near;let top=near*Math.tan(DEG2RAD*0.5*this.fov)/this.zoom;let height=2*top;let width=this.aspect*height;let left=-0.5*width;const view=this.view;if(this.view!==null&&this.view.enabled){const fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth;top-=view.offsetY*height/fullHeight;width*=view.width/fullWidth;height*=view.height/fullHeight;}const skew=this.filmOffset;if(skew!==0)left+=near*skew/this.getFilmWidth();this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far,this.coordinateSystem,this.reversedDepth);this.projectionMatrixInverse.copy(this.projectionMatrix).invert();}toJSON(meta){const data=super.toJSON(meta);data.object.fov=this.fov;data.object.zoom=this.zoom;data.object.near=this.near;data.object.far=this.far;data.object.focus=this.focus;data.object.aspect=this.aspect;if(this.view!==null)data.object.view=Object.assign({},this.view);data.object.filmGauge=this.filmGauge;data.object.filmOffset=this.filmOffset;return data;}}const fov=-90;// negative fov is not an error
	const aspect=1;/**
	 * A special type of camera that is positioned in 3D space to render its surroundings into a
	 * cube render target. The render target can then be used as an environment map for rendering
	 * realtime reflections in your scene.
	 *
	 * ```js
	 * // Create cube render target
	 * const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256, { generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter } );
	 *
	 * // Create cube camera
	 * const cubeCamera = new THREE.CubeCamera( 1, 100000, cubeRenderTarget );
	 * scene.add( cubeCamera );
	 *
	 * // Create car
	 * const chromeMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, envMap: cubeRenderTarget.texture } );
	 * const car = new THREE.Mesh( carGeometry, chromeMaterial );
	 * scene.add( car );
	 *
	 * // Update the render target cube
	 * car.visible = false;
	 * cubeCamera.position.copy( car.position );
	 * cubeCamera.update( renderer, scene );
	 *
	 * // Render the scene
	 * car.visible = true;
	 * renderer.render( scene, camera );
	 * ```
	 *
	 * @augments Object3D
	 */class CubeCamera extends Object3D$1{/**
		 * Constructs a new cube camera.
		 *
		 * @param {number} near - The camera's near plane.
		 * @param {number} far - The camera's far plane.
		 * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
		 */constructor(near,far,renderTarget){super();this.type='CubeCamera';/**
			 * A reference to the cube render target.
			 *
			 * @type {WebGLCubeRenderTarget}
			 */this.renderTarget=renderTarget;/**
			 * The current active coordinate system.
			 *
			 * @type {?(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
			 * @default null
			 */this.coordinateSystem=null;/**
			 * The current active mipmap level
			 *
			 * @type {number}
			 * @default 0
			 */this.activeMipmapLevel=0;const cameraPX=new PerspectiveCamera(fov,aspect,near,far);cameraPX.layers=this.layers;this.add(cameraPX);const cameraNX=new PerspectiveCamera(fov,aspect,near,far);cameraNX.layers=this.layers;this.add(cameraNX);const cameraPY=new PerspectiveCamera(fov,aspect,near,far);cameraPY.layers=this.layers;this.add(cameraPY);const cameraNY=new PerspectiveCamera(fov,aspect,near,far);cameraNY.layers=this.layers;this.add(cameraNY);const cameraPZ=new PerspectiveCamera(fov,aspect,near,far);cameraPZ.layers=this.layers;this.add(cameraPZ);const cameraNZ=new PerspectiveCamera(fov,aspect,near,far);cameraNZ.layers=this.layers;this.add(cameraNZ);}/**
		 * Must be called when the coordinate system of the cube camera is changed.
		 */updateCoordinateSystem(){const coordinateSystem=this.coordinateSystem;const cameras=this.children.concat();const[cameraPX,cameraNX,cameraPY,cameraNY,cameraPZ,cameraNZ]=cameras;for(const camera of cameras)this.remove(camera);if(coordinateSystem===WebGLCoordinateSystem$1){cameraPX.up.set(0,1,0);cameraPX.lookAt(1,0,0);cameraNX.up.set(0,1,0);cameraNX.lookAt(-1,0,0);cameraPY.up.set(0,0,-1);cameraPY.lookAt(0,1,0);cameraNY.up.set(0,0,1);cameraNY.lookAt(0,-1,0);cameraPZ.up.set(0,1,0);cameraPZ.lookAt(0,0,1);cameraNZ.up.set(0,1,0);cameraNZ.lookAt(0,0,-1);}else if(coordinateSystem===WebGPUCoordinateSystem$1){cameraPX.up.set(0,-1,0);cameraPX.lookAt(-1,0,0);cameraNX.up.set(0,-1,0);cameraNX.lookAt(1,0,0);cameraPY.up.set(0,0,1);cameraPY.lookAt(0,1,0);cameraNY.up.set(0,0,-1);cameraNY.lookAt(0,-1,0);cameraPZ.up.set(0,-1,0);cameraPZ.lookAt(0,0,1);cameraNZ.up.set(0,-1,0);cameraNZ.lookAt(0,0,-1);}else {throw new Error('THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: '+coordinateSystem);}for(const camera of cameras){this.add(camera);camera.updateMatrixWorld();}}/**
		 * Calling this method will render the given scene with the given renderer
		 * into the cube render target of the camera.
		 *
		 * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
		 * @param {Scene} scene - The scene to render.
		 */update(renderer,scene){if(this.parent===null)this.updateMatrixWorld();const{renderTarget,activeMipmapLevel}=this;if(this.coordinateSystem!==renderer.coordinateSystem){this.coordinateSystem=renderer.coordinateSystem;this.updateCoordinateSystem();}const[cameraPX,cameraNX,cameraPY,cameraNY,cameraPZ,cameraNZ]=this.children;const currentRenderTarget=renderer.getRenderTarget();const currentActiveCubeFace=renderer.getActiveCubeFace();const currentActiveMipmapLevel=renderer.getActiveMipmapLevel();const currentXrEnabled=renderer.xr.enabled;renderer.xr.enabled=false;const generateMipmaps=renderTarget.texture.generateMipmaps;renderTarget.texture.generateMipmaps=false;renderer.setRenderTarget(renderTarget,0,activeMipmapLevel);renderer.render(scene,cameraPX);renderer.setRenderTarget(renderTarget,1,activeMipmapLevel);renderer.render(scene,cameraNX);renderer.setRenderTarget(renderTarget,2,activeMipmapLevel);renderer.render(scene,cameraPY);renderer.setRenderTarget(renderTarget,3,activeMipmapLevel);renderer.render(scene,cameraNY);renderer.setRenderTarget(renderTarget,4,activeMipmapLevel);renderer.render(scene,cameraPZ);// mipmaps are generated during the last call of render()
	// at this point, all sides of the cube render target are defined
	renderTarget.texture.generateMipmaps=generateMipmaps;renderer.setRenderTarget(renderTarget,5,activeMipmapLevel);renderer.render(scene,cameraNZ);renderer.setRenderTarget(currentRenderTarget,currentActiveCubeFace,currentActiveMipmapLevel);renderer.xr.enabled=currentXrEnabled;renderTarget.texture.needsPMREMUpdate=true;}}/**
	 * Creates a cube texture made up of six images.
	 *
	 * ```js
	 * const loader = new THREE.CubeTextureLoader();
	 * loader.setPath( 'textures/cube/pisa/' );
	 *
	 * const textureCube = loader.load( [
	 * 	'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'
	 * ] );
	 *
	 * const material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );
	 * ```
	 *
	 * @augments Texture
	 */class CubeTexture extends Texture{/**
		 * Constructs a new cube texture.
		 *
		 * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
		 * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
		 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
		 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
		 * @param {number} [magFilter=LinearFilter] - The mag filter value.
		 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
		 * @param {number} [format=RGBAFormat] - The texture format.
		 * @param {number} [type=UnsignedByteType] - The texture type.
		 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
		 * @param {string} [colorSpace=NoColorSpace] - The color space value.
		 */constructor(images=[],mapping=CubeReflectionMapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,colorSpace){super(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,colorSpace);/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isCubeTexture=true;/**
			 * If set to `true`, the texture is flipped along the vertical axis when
			 * uploaded to the GPU.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */this.flipY=false;}/**
		 * Alias for {@link CubeTexture#image}.
		 *
		 * @type {Array<Image>}
		 */get images(){return this.image;}set images(value){this.image=value;}}/**
	 * A cube render target used in context of {@link WebGLRenderer}.
	 *
	 * @augments WebGLRenderTarget
	 */class WebGLCubeRenderTarget extends WebGLRenderTarget{/**
		 * Constructs a new cube render target.
		 *
		 * @param {number} [size=1] - The size of the render target.
		 * @param {RenderTarget~Options} [options] - The configuration object.
		 */constructor(size=1,options={}){super(size,size,options);/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isWebGLCubeRenderTarget=true;const image={width:size,height:size,depth:1};const images=[image,image,image,image,image,image];/**
			 * Overwritten with a different texture type.
			 *
			 * @type {DataArrayTexture}
			 */this.texture=new CubeTexture(images);this._setTextureOptions(options);// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
	// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
	// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
	// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
	// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
	// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
	this.texture.isRenderTargetTexture=true;}/**
		 * Converts the given equirectangular texture to a cube map.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {Texture} texture - The equirectangular texture.
		 * @return {WebGLCubeRenderTarget} A reference to this cube render target.
		 */fromEquirectangularTexture(renderer,texture){this.texture.type=texture.type;this.texture.colorSpace=texture.colorSpace;this.texture.generateMipmaps=texture.generateMipmaps;this.texture.minFilter=texture.minFilter;this.texture.magFilter=texture.magFilter;const shader={uniforms:{tEquirect:{value:null}},vertexShader:/* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:/* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`};const geometry=new BoxGeometry$1(5,5,5);const material=new ShaderMaterial({name:'CubemapFromEquirect',uniforms:cloneUniforms(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader,side:BackSide,blending:NoBlending});material.uniforms.tEquirect.value=texture;const mesh=new Mesh(geometry,material);const currentMinFilter=texture.minFilter;// Avoid blurred poles
	if(texture.minFilter===LinearMipmapLinearFilter)texture.minFilter=LinearFilter;const camera=new CubeCamera(1,10,this);camera.update(renderer,mesh);texture.minFilter=currentMinFilter;mesh.geometry.dispose();mesh.material.dispose();return this;}/**
		 * Clears this cube render target.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
		 * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
		 * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
		 */clear(renderer,color=true,depth=true,stencil=true){const currentRenderTarget=renderer.getRenderTarget();for(let i=0;i<6;i++){renderer.setRenderTarget(this,i);renderer.clear(color,depth,stencil);}renderer.setRenderTarget(currentRenderTarget);}}/**
	 * This is almost identical to an {@link Object3D}. Its purpose is to
	 * make working with groups of objects syntactically clearer.
	 *
	 * ```js
	 * // Create a group and add the two cubes.
	 * // These cubes can now be rotated / scaled etc as a group.
	 * const group = new THREE.Group();
	 *
	 * group.add( meshA );
	 * group.add( meshB );
	 *
	 * scene.add( group );
	 * ```
	 *
	 * @augments Object3D
	 */class Group extends Object3D$1{constructor(){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isGroup=true;this.type='Group';}}const _moveEvent={type:'move'};/**
	 * Class for representing a XR controller with its
	 * different coordinate systems.
	 *
	 * @private
	 */class WebXRController{/**
		 * Constructs a new XR controller.
		 */constructor(){/**
			 * A group representing the target ray space
			 * of the XR controller.
			 *
			 * @private
			 * @type {?Group}
			 * @default null
			 */this._targetRay=null;/**
			 * A group representing the grip space
			 * of the XR controller.
			 *
			 * @private
			 * @type {?Group}
			 * @default null
			 */this._grip=null;/**
			 * A group representing the hand space
			 * of the XR controller.
			 *
			 * @private
			 * @type {?Group}
			 * @default null
			 */this._hand=null;}/**
		 * Returns a group representing the hand space of the XR controller.
		 *
		 * @return {Group} A group representing the hand space of the XR controller.
		 */getHandSpace(){if(this._hand===null){this._hand=new Group();this._hand.matrixAutoUpdate=false;this._hand.visible=false;this._hand.joints={};this._hand.inputState={pinching:false};}return this._hand;}/**
		 * Returns a group representing the target ray space of the XR controller.
		 *
		 * @return {Group} A group representing the target ray space of the XR controller.
		 */getTargetRaySpace(){if(this._targetRay===null){this._targetRay=new Group();this._targetRay.matrixAutoUpdate=false;this._targetRay.visible=false;this._targetRay.hasLinearVelocity=false;this._targetRay.linearVelocity=new Vector3$1();this._targetRay.hasAngularVelocity=false;this._targetRay.angularVelocity=new Vector3$1();}return this._targetRay;}/**
		 * Returns a group representing the grip space of the XR controller.
		 *
		 * @return {Group} A group representing the grip space of the XR controller.
		 */getGripSpace(){if(this._grip===null){this._grip=new Group();this._grip.matrixAutoUpdate=false;this._grip.visible=false;this._grip.hasLinearVelocity=false;this._grip.linearVelocity=new Vector3$1();this._grip.hasAngularVelocity=false;this._grip.angularVelocity=new Vector3$1();}return this._grip;}/**
		 * Dispatches the given event to the groups representing
		 * the different coordinate spaces of the XR controller.
		 *
		 * @param {Object} event - The event to dispatch.
		 * @return {WebXRController} A reference to this instance.
		 */dispatchEvent(event){if(this._targetRay!==null){this._targetRay.dispatchEvent(event);}if(this._grip!==null){this._grip.dispatchEvent(event);}if(this._hand!==null){this._hand.dispatchEvent(event);}return this;}/**
		 * Connects the controller with the given XR input source.
		 *
		 * @param {XRInputSource} inputSource - The input source.
		 * @return {WebXRController} A reference to this instance.
		 */connect(inputSource){if(inputSource&&inputSource.hand){const hand=this._hand;if(hand){for(const inputjoint of inputSource.hand.values()){// Initialize hand with joints when connected
	this._getHandJoint(hand,inputjoint);}}}this.dispatchEvent({type:'connected',data:inputSource});return this;}/**
		 * Disconnects the controller from the given XR input source.
		 *
		 * @param {XRInputSource} inputSource - The input source.
		 * @return {WebXRController} A reference to this instance.
		 */disconnect(inputSource){this.dispatchEvent({type:'disconnected',data:inputSource});if(this._targetRay!==null){this._targetRay.visible=false;}if(this._grip!==null){this._grip.visible=false;}if(this._hand!==null){this._hand.visible=false;}return this;}/**
		 * Updates the controller with the given input source, XR frame and reference space.
		 * This updates the transformations of the groups that represent the different
		 * coordinate systems of the controller.
		 *
		 * @param {XRInputSource} inputSource - The input source.
		 * @param {XRFrame} frame - The XR frame.
		 * @param {XRReferenceSpace} referenceSpace - The reference space.
		 * @return {WebXRController} A reference to this instance.
		 */update(inputSource,frame,referenceSpace){let inputPose=null;let gripPose=null;let handPose=null;const targetRay=this._targetRay;const grip=this._grip;const hand=this._hand;if(inputSource&&frame.session.visibilityState!=='visible-blurred'){if(hand&&inputSource.hand){handPose=true;for(const inputjoint of inputSource.hand.values()){// Update the joints groups with the XRJoint poses
	const jointPose=frame.getJointPose(inputjoint,referenceSpace);// The transform of this joint will be updated with the joint pose on each frame
	const joint=this._getHandJoint(hand,inputjoint);if(jointPose!==null){joint.matrix.fromArray(jointPose.transform.matrix);joint.matrix.decompose(joint.position,joint.rotation,joint.scale);joint.matrixWorldNeedsUpdate=true;joint.jointRadius=jointPose.radius;}joint.visible=jointPose!==null;}// Custom events
	// Check pinchz
	const indexTip=hand.joints['index-finger-tip'];const thumbTip=hand.joints['thumb-tip'];const distance=indexTip.position.distanceTo(thumbTip.position);const distanceToPinch=0.02;const threshold=0.005;if(hand.inputState.pinching&&distance>distanceToPinch+threshold){hand.inputState.pinching=false;this.dispatchEvent({type:'pinchend',handedness:inputSource.handedness,target:this});}else if(!hand.inputState.pinching&&distance<=distanceToPinch-threshold){hand.inputState.pinching=true;this.dispatchEvent({type:'pinchstart',handedness:inputSource.handedness,target:this});}}else {if(grip!==null&&inputSource.gripSpace){gripPose=frame.getPose(inputSource.gripSpace,referenceSpace);if(gripPose!==null){grip.matrix.fromArray(gripPose.transform.matrix);grip.matrix.decompose(grip.position,grip.rotation,grip.scale);grip.matrixWorldNeedsUpdate=true;if(gripPose.linearVelocity){grip.hasLinearVelocity=true;grip.linearVelocity.copy(gripPose.linearVelocity);}else {grip.hasLinearVelocity=false;}if(gripPose.angularVelocity){grip.hasAngularVelocity=true;grip.angularVelocity.copy(gripPose.angularVelocity);}else {grip.hasAngularVelocity=false;}}}}if(targetRay!==null){inputPose=frame.getPose(inputSource.targetRaySpace,referenceSpace);// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
	if(inputPose===null&&gripPose!==null){inputPose=gripPose;}if(inputPose!==null){targetRay.matrix.fromArray(inputPose.transform.matrix);targetRay.matrix.decompose(targetRay.position,targetRay.rotation,targetRay.scale);targetRay.matrixWorldNeedsUpdate=true;if(inputPose.linearVelocity){targetRay.hasLinearVelocity=true;targetRay.linearVelocity.copy(inputPose.linearVelocity);}else {targetRay.hasLinearVelocity=false;}if(inputPose.angularVelocity){targetRay.hasAngularVelocity=true;targetRay.angularVelocity.copy(inputPose.angularVelocity);}else {targetRay.hasAngularVelocity=false;}this.dispatchEvent(_moveEvent);}}}if(targetRay!==null){targetRay.visible=inputPose!==null;}if(grip!==null){grip.visible=gripPose!==null;}if(hand!==null){hand.visible=handPose!==null;}return this;}/**
		 * Returns a group representing the hand joint for the given input joint.
		 *
		 * @private
		 * @param {Group} hand - The group representing the hand space.
		 * @param {XRJointSpace} inputjoint - The hand joint data.
		 * @return {Group} A group representing the hand joint for the given input joint.
		 */_getHandJoint(hand,inputjoint){if(hand.joints[inputjoint.jointName]===undefined){const joint=new Group();joint.matrixAutoUpdate=false;joint.visible=false;hand.joints[inputjoint.jointName]=joint;hand.add(joint);}return hand.joints[inputjoint.jointName];}}/**
	 * Scenes allow you to set up what is to be rendered and where by three.js.
	 * This is where you place 3D objects like meshes, lines or lights.
	 *
	 * @augments Object3D
	 */class Scene extends Object3D$1{/**
		 * Constructs a new scene.
		 */constructor(){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isScene=true;this.type='Scene';/**
			 * Defines the background of the scene. Valid inputs are:
			 *
			 * - A color for defining a uniform colored background.
			 * - A texture for defining a (flat) textured background.
			 * - Cube textures or equirectangular textures for defining a skybox.
			 *
			 * @type {?(Color|Texture)}
			 * @default null
			 */this.background=null;/**
			 * Sets the environment map for all physical materials in the scene. However,
			 * it's not possible to overwrite an existing texture assigned to the `envMap`
			 * material property.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.environment=null;/**
			 * A fog instance defining the type of fog that affects everything
			 * rendered in the scene.
			 *
			 * @type {?(Fog|FogExp2)}
			 * @default null
			 */this.fog=null;/**
			 * Sets the blurriness of the background. Only influences environment maps
			 * assigned to {@link Scene#background}. Valid input is a float between `0`
			 * and `1`.
			 *
			 * @type {number}
			 * @default 0
			 */this.backgroundBlurriness=0;/**
			 * Attenuates the color of the background. Only applies to background textures.
			 *
			 * @type {number}
			 * @default 1
			 */this.backgroundIntensity=1;/**
			 * The rotation of the background in radians. Only influences environment maps
			 * assigned to {@link Scene#background}.
			 *
			 * @type {Euler}
			 * @default (0,0,0)
			 */this.backgroundRotation=new Euler$1();/**
			 * Attenuates the color of the environment. Only influences environment maps
			 * assigned to {@link Scene#environment}.
			 *
			 * @type {number}
			 * @default 1
			 */this.environmentIntensity=1;/**
			 * The rotation of the environment map in radians. Only influences physical materials
			 * in the scene when {@link Scene#environment} is used.
			 *
			 * @type {Euler}
			 * @default (0,0,0)
			 */this.environmentRotation=new Euler$1();/**
			 * Forces everything in the scene to be rendered with the defined material. It is possible
			 * to exclude materials from override by setting {@link Material#allowOverride} to `false`.
			 *
			 * @type {?Material}
			 * @default null
			 */this.overrideMaterial=null;if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:this}));}}copy(source,recursive){super.copy(source,recursive);if(source.background!==null)this.background=source.background.clone();if(source.environment!==null)this.environment=source.environment.clone();if(source.fog!==null)this.fog=source.fog.clone();this.backgroundBlurriness=source.backgroundBlurriness;this.backgroundIntensity=source.backgroundIntensity;this.backgroundRotation.copy(source.backgroundRotation);this.environmentIntensity=source.environmentIntensity;this.environmentRotation.copy(source.environmentRotation);if(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();this.matrixAutoUpdate=source.matrixAutoUpdate;return this;}toJSON(meta){const data=super.toJSON(meta);if(this.fog!==null)data.object.fog=this.fog.toJSON();if(this.backgroundBlurriness>0)data.object.backgroundBlurriness=this.backgroundBlurriness;if(this.backgroundIntensity!==1)data.object.backgroundIntensity=this.backgroundIntensity;data.object.backgroundRotation=this.backgroundRotation.toArray();if(this.environmentIntensity!==1)data.object.environmentIntensity=this.environmentIntensity;data.object.environmentRotation=this.environmentRotation.toArray();return data;}}/**
	 * Creates a texture directly from raw buffer data.
	 *
	 * The interpretation of the data depends on type and format: If the type is
	 * `UnsignedByteType`, a `Uint8Array` will be useful for addressing the
	 * texel data. If the format is `RGBAFormat`, data needs four values for
	 * one texel; Red, Green, Blue and Alpha (typically the opacity).
	 *
	 * @augments Texture
	 */class DataTexture extends Texture{/**
		 * Constructs a new data texture.
		 *
		 * @param {?TypedArray} [data=null] - The buffer data.
		 * @param {number} [width=1] - The width of the texture.
		 * @param {number} [height=1] - The height of the texture.
		 * @param {number} [format=RGBAFormat] - The texture format.
		 * @param {number} [type=UnsignedByteType] - The texture type.
		 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
		 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
		 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
		 * @param {number} [magFilter=NearestFilter] - The mag filter value.
		 * @param {number} [minFilter=NearestFilter] - The min filter value.
		 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
		 * @param {string} [colorSpace=NoColorSpace] - The color space.
		 */constructor(data=null,width=1,height=1,format,type,mapping,wrapS,wrapT,magFilter=NearestFilter,minFilter=NearestFilter,anisotropy,colorSpace){super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,colorSpace);/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isDataTexture=true;/**
			 * The image definition of a data texture.
			 *
			 * @type {{data:TypedArray,width:number,height:number}}
			 */this.image={data:data,width:width,height:height};/**
			 * Whether to generate mipmaps (if possible) for a texture.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */this.generateMipmaps=false;/**
			 * If set to `true`, the texture is flipped along the vertical axis when
			 * uploaded to the GPU.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */this.flipY=false;/**
			 * Specifies the alignment requirements for the start of each pixel row in memory.
			 *
			 * Overwritten and set to `1` by default.
			 *
			 * @type {boolean}
			 * @default 1
			 */this.unpackAlignment=1;}}const _vector1=/*@__PURE__*/new Vector3$1();const _vector2$2=/*@__PURE__*/new Vector3$1();const _normalMatrix=/*@__PURE__*/new Matrix3$1();/**
	 * A two dimensional surface that extends infinitely in 3D space, represented
	 * in [Hessian normal form](http://mathworld.wolfram.com/HessianNormalForm.html)
	 * by a unit length normal vector and a constant.
	 */class Plane{/**
		 * Constructs a new plane.
		 *
		 * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
		 * @param {number} [constant=0] - The signed distance from the origin to the plane.
		 */constructor(normal=new Vector3$1(1,0,0),constant=0){/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isPlane=true;/**
			 * A unit length vector defining the normal of the plane.
			 *
			 * @type {Vector3}
			 */this.normal=normal;/**
			 * The signed distance from the origin to the plane.
			 *
			 * @type {number}
			 * @default 0
			 */this.constant=constant;}/**
		 * Sets the plane components by copying the given values.
		 *
		 * @param {Vector3} normal - The normal.
		 * @param {number} constant - The constant.
		 * @return {Plane} A reference to this plane.
		 */set(normal,constant){this.normal.copy(normal);this.constant=constant;return this;}/**
		 * Sets the plane components by defining `x`, `y`, `z` as the
		 * plane normal and `w` as the constant.
		 *
		 * @param {number} x - The value for the normal's x component.
		 * @param {number} y - The value for the normal's y component.
		 * @param {number} z - The value for the normal's z component.
		 * @param {number} w - The constant value.
		 * @return {Plane} A reference to this plane.
		 */setComponents(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this;}/**
		 * Sets the plane from the given normal and coplanar point (that is a point
		 * that lies onto the plane).
		 *
		 * @param {Vector3} normal - The normal.
		 * @param {Vector3} point - A coplanar point.
		 * @return {Plane} A reference to this plane.
		 */setFromNormalAndCoplanarPoint(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);return this;}/**
		 * Sets the plane from three coplanar points. The winding order is
		 * assumed to be counter-clockwise, and determines the direction of
		 * the plane normal.
		 *
		 * @param {Vector3} a - The first coplanar point.
		 * @param {Vector3} b - The second coplanar point.
		 * @param {Vector3} c - The third coplanar point.
		 * @return {Plane} A reference to this plane.
		 */setFromCoplanarPoints(a,b,c){const normal=_vector1.subVectors(c,b).cross(_vector2$2.subVectors(a,b)).normalize();// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	this.setFromNormalAndCoplanarPoint(normal,a);return this;}/**
		 * Copies the values of the given plane to this instance.
		 *
		 * @param {Plane} plane - The plane to copy.
		 * @return {Plane} A reference to this plane.
		 */copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this;}/**
		 * Normalizes the plane normal and adjusts the constant accordingly.
		 *
		 * @return {Plane} A reference to this plane.
		 */normalize(){// Note: will lead to a divide by zero if the plane is invalid.
	const inverseNormalLength=1.0/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this;}/**
		 * Negates both the plane normal and the constant.
		 *
		 * @return {Plane} A reference to this plane.
		 */negate(){this.constant*=-1;this.normal.negate();return this;}/**
		 * Returns the signed distance from the given point to this plane.
		 *
		 * @param {Vector3} point - The point to compute the distance for.
		 * @return {number} The signed distance.
		 */distanceToPoint(point){return this.normal.dot(point)+this.constant;}/**
		 * Returns the signed distance from the given sphere to this plane.
		 *
		 * @param {Sphere} sphere - The sphere to compute the distance for.
		 * @return {number} The signed distance.
		 */distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius;}/**
		 * Projects a the given point onto the plane.
		 *
		 * @param {Vector3} point - The point to project.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The projected point on the plane.
		 */projectPoint(point,target){return target.copy(point).addScaledVector(this.normal,-this.distanceToPoint(point));}/**
		 * Returns the intersection point of the passed line and the plane. Returns
		 * `null` if the line does not intersect. Returns the line's starting point if
		 * the line is coplanar with the plane.
		 *
		 * @param {Line3} line - The line to compute the intersection for.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The intersection point.
		 */intersectLine(line,target){const direction=line.delta(_vector1);const denominator=this.normal.dot(direction);if(denominator===0){// line is coplanar, return origin
	if(this.distanceToPoint(line.start)===0){return target.copy(line.start);}// Unsure if this is the correct method to handle this case.
	return null;}const t=-(line.start.dot(this.normal)+this.constant)/denominator;if(t<0||t>1){return null;}return target.copy(line.start).addScaledVector(direction,t);}/**
		 * Returns `true` if the given line segment intersects with (passes through) the plane.
		 *
		 * @param {Line3} line - The line to test.
		 * @return {boolean} Whether the given line segment intersects with the plane or not.
		 */intersectsLine(line){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	const startSign=this.distanceToPoint(line.start);const endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0;}/**
		 * Returns `true` if the given bounding box intersects with the plane.
		 *
		 * @param {Box3} box - The bounding box to test.
		 * @return {boolean} Whether the given bounding box intersects with the plane or not.
		 */intersectsBox(box){return box.intersectsPlane(this);}/**
		 * Returns `true` if the given bounding sphere intersects with the plane.
		 *
		 * @param {Sphere} sphere - The bounding sphere to test.
		 * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
		 */intersectsSphere(sphere){return sphere.intersectsPlane(this);}/**
		 * Returns a coplanar vector to the plane, by calculating the
		 * projection of the normal at the origin onto the plane.
		 *
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The coplanar point.
		 */coplanarPoint(target){return target.copy(this.normal).multiplyScalar(-this.constant);}/**
		 * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
		 *
		 * The optional normal matrix can be pre-computed like so:
		 * ```js
		 * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
		 * ```
		 *
		 * @param {Matrix4} matrix - The transformation matrix.
		 * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
		 * @return {Plane} A reference to this plane.
		 */applyMatrix4(matrix,optionalNormalMatrix){const normalMatrix=optionalNormalMatrix||_normalMatrix.getNormalMatrix(matrix);const referencePoint=this.coplanarPoint(_vector1).applyMatrix4(matrix);const normal=this.normal.applyMatrix3(normalMatrix).normalize();this.constant=-referencePoint.dot(normal);return this;}/**
		 * Translates the plane by the distance defined by the given offset vector.
		 * Note that this only affects the plane constant and will not affect the normal vector.
		 *
		 * @param {Vector3} offset - The offset vector.
		 * @return {Plane} A reference to this plane.
		 */translate(offset){this.constant-=offset.dot(this.normal);return this;}/**
		 * Returns `true` if this plane is equal with the given one.
		 *
		 * @param {Plane} plane - The plane to test for equality.
		 * @return {boolean} Whether this plane is equal with the given one.
		 */equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant;}/**
		 * Returns a new plane with copied values from this instance.
		 *
		 * @return {Plane} A clone of this instance.
		 */clone(){return new this.constructor().copy(this);}}const _sphere$3=/*@__PURE__*/new Sphere$1();const _defaultSpriteCenter=/*@__PURE__*/new Vector2$1(0.5,0.5);const _vector$6=/*@__PURE__*/new Vector3$1();/**
	 * Frustums are used to determine what is inside the camera's field of view.
	 * They help speed up the rendering process - objects which lie outside a camera's
	 * frustum can safely be excluded from rendering.
	 *
	 * This class is mainly intended for use internally by a renderer.
	 */class Frustum{/**
		 * Constructs a new frustum.
		 *
		 * @param {Plane} [p0] - The first plane that encloses the frustum.
		 * @param {Plane} [p1] - The second plane that encloses the frustum.
		 * @param {Plane} [p2] - The third plane that encloses the frustum.
		 * @param {Plane} [p3] - The fourth plane that encloses the frustum.
		 * @param {Plane} [p4] - The fifth plane that encloses the frustum.
		 * @param {Plane} [p5] - The sixth plane that encloses the frustum.
		 */constructor(p0=new Plane(),p1=new Plane(),p2=new Plane(),p3=new Plane(),p4=new Plane(),p5=new Plane()){/**
			 * This array holds the planes that enclose the frustum.
			 *
			 * @type {Array<Plane>}
			 */this.planes=[p0,p1,p2,p3,p4,p5];}/**
		 * Sets the frustum planes by copying the given planes.
		 *
		 * @param {Plane} [p0] - The first plane that encloses the frustum.
		 * @param {Plane} [p1] - The second plane that encloses the frustum.
		 * @param {Plane} [p2] - The third plane that encloses the frustum.
		 * @param {Plane} [p3] - The fourth plane that encloses the frustum.
		 * @param {Plane} [p4] - The fifth plane that encloses the frustum.
		 * @param {Plane} [p5] - The sixth plane that encloses the frustum.
		 * @return {Frustum} A reference to this frustum.
		 */set(p0,p1,p2,p3,p4,p5){const planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this;}/**
		 * Copies the values of the given frustum to this instance.
		 *
		 * @param {Frustum} frustum - The frustum to copy.
		 * @return {Frustum} A reference to this frustum.
		 */copy(frustum){const planes=this.planes;for(let i=0;i<6;i++){planes[i].copy(frustum.planes[i]);}return this;}/**
		 * Sets the frustum planes from the given projection matrix.
		 *
		 * @param {Matrix4} m - The projection matrix.
		 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
		 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
		 * @return {Frustum} A reference to this frustum.
		 */setFromProjectionMatrix(m,coordinateSystem=WebGLCoordinateSystem$1,reversedDepth=false){const planes=this.planes;const me=m.elements;const me0=me[0],me1=me[1],me2=me[2],me3=me[3];const me4=me[4],me5=me[5],me6=me[6],me7=me[7];const me8=me[8],me9=me[9],me10=me[10],me11=me[11];const me12=me[12],me13=me[13],me14=me[14],me15=me[15];planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();if(reversedDepth){planes[4].setComponents(me2,me6,me10,me14).normalize();// far
	planes[5].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();// near
	}else {planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();// far
	if(coordinateSystem===WebGLCoordinateSystem$1){planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();// near
	}else if(coordinateSystem===WebGPUCoordinateSystem$1){planes[5].setComponents(me2,me6,me10,me14).normalize();// near
	}else {throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: '+coordinateSystem);}}return this;}/**
		 * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
		 *
		 * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
		 *
		 * @param {Object3D} object - The 3D object to test.
		 * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
		 */intersectsObject(object){if(object.boundingSphere!==undefined){if(object.boundingSphere===null)object.computeBoundingSphere();_sphere$3.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);}else {const geometry=object.geometry;if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$3.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);}return this.intersectsSphere(_sphere$3);}/**
		 * Returns `true` if the given sprite is intersecting this frustum.
		 *
		 * @param {Sprite} sprite - The sprite to test.
		 * @return {boolean} Whether the sprite is intersecting this frustum or not.
		 */intersectsSprite(sprite){_sphere$3.center.set(0,0,0);const offset=_defaultSpriteCenter.distanceTo(sprite.center);_sphere$3.radius=0.7071067811865476+offset;_sphere$3.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(_sphere$3);}/**
		 * Returns `true` if the given bounding sphere is intersecting this frustum.
		 *
		 * @param {Sphere} sphere - The bounding sphere to test.
		 * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
		 */intersectsSphere(sphere){const planes=this.planes;const center=sphere.center;const negRadius=-sphere.radius;for(let i=0;i<6;i++){const distance=planes[i].distanceToPoint(center);if(distance<negRadius){return false;}}return true;}/**
		 * Returns `true` if the given bounding box is intersecting this frustum.
		 *
		 * @param {Box3} box - The bounding box to test.
		 * @return {boolean} Whether the bounding box is intersecting this frustum or not.
		 */intersectsBox(box){const planes=this.planes;for(let i=0;i<6;i++){const plane=planes[i];// corner at max distance
	_vector$6.x=plane.normal.x>0?box.max.x:box.min.x;_vector$6.y=plane.normal.y>0?box.max.y:box.min.y;_vector$6.z=plane.normal.z>0?box.max.z:box.min.z;if(plane.distanceToPoint(_vector$6)<0){return false;}}return true;}/**
		 * Returns `true` if the given point lies within the frustum.
		 *
		 * @param {Vector3} point - The point to test.
		 * @return {boolean} Whether the point lies within this frustum or not.
		 */containsPoint(point){const planes=this.planes;for(let i=0;i<6;i++){if(planes[i].distanceToPoint(point)<0){return false;}}return true;}/**
		 * Returns a new frustum with copied values from this instance.
		 *
		 * @return {Frustum} A clone of this instance.
		 */clone(){return new this.constructor().copy(this);}}/**
	 * This class can be used to automatically save the depth information of a
	 * rendering into a texture.
	 *
	 * @augments Texture
	 */class DepthTexture extends Texture{/**
		 * Constructs a new depth texture.
		 *
		 * @param {number} width - The width of the texture.
		 * @param {number} height - The height of the texture.
		 * @param {number} [type=UnsignedIntType] - The texture type.
		 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
		 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
		 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
		 * @param {number} [magFilter=LinearFilter] - The mag filter value.
		 * @param {number} [minFilter=LinearFilter] - The min filter value.
		 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
		 * @param {number} [format=DepthFormat] - The texture format.
		 * @param {number} [depth=1] - The depth of the texture.
		 */constructor(width,height,type=UnsignedIntType,mapping,wrapS,wrapT,magFilter=NearestFilter,minFilter=NearestFilter,anisotropy,format=DepthFormat,depth=1){if(format!==DepthFormat&&format!==DepthStencilFormat){throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');}const image={width:width,height:height,depth:depth};super(image,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isDepthTexture=true;/**
			 * If set to `true`, the texture is flipped along the vertical axis when
			 * uploaded to the GPU.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */this.flipY=false;/**
			 * Whether to generate mipmaps (if possible) for a texture.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */this.generateMipmaps=false;/**
			 * Code corresponding to the depth compare function.
			 *
			 * @type {?(NeverCompare|LessCompare|EqualCompare|LessEqualCompare|GreaterCompare|NotEqualCompare|GreaterEqualCompare|AlwaysCompare)}
			 * @default null
			 */this.compareFunction=null;}copy(source){super.copy(source);this.source=new Source(Object.assign({},source.image));// see #30540
	this.compareFunction=source.compareFunction;return this;}toJSON(meta){const data=super.toJSON(meta);if(this.compareFunction!==null)data.compareFunction=this.compareFunction;return data;}}/**
	 * Represents a texture created externally with the same renderer context.
	 *
	 * This may be a texture from a protected media stream, device camera feed,
	 * or other data feeds like a depth sensor.
	 *
	 * Note that this class is only supported in {@link WebGLRenderer}, and in
	 * the {@link WebGPURenderer} WebGPU backend.
	 *
	 * @augments Texture
	 */class ExternalTexture extends Texture{/**
		 * Creates a new raw texture.
		 *
		 * @param {?(WebGLTexture|GPUTexture)} [sourceTexture=null] - The external texture.
		 */constructor(sourceTexture=null){super();/**
			 * The external source texture.
			 *
			 * @type {?(WebGLTexture|GPUTexture)}
			 * @default null
			 */this.sourceTexture=sourceTexture;/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isExternalTexture=true;}copy(source){super.copy(source);this.sourceTexture=source.sourceTexture;return this;}}/**
	 * A geometry class for representing a plane.
	 *
	 * ```js
	 * const geometry = new THREE.PlaneGeometry( 1, 1 );
	 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
	 * const plane = new THREE.Mesh( geometry, material );
	 * scene.add( plane );
	 * ```
	 *
	 * @augments BufferGeometry
	 * @demo scenes/geometry-browser.html#PlaneGeometry
	 */class PlaneGeometry extends BufferGeometry$1{/**
		 * Constructs a new plane geometry.
		 *
		 * @param {number} [width=1] - The width along the X axis.
		 * @param {number} [height=1] - The height along the Y axis
		 * @param {number} [widthSegments=1] - The number of segments along the X axis.
		 * @param {number} [heightSegments=1] - The number of segments along the Y axis.
		 */constructor(width=1,height=1,widthSegments=1,heightSegments=1){super();this.type='PlaneGeometry';/**
			 * Holds the constructor parameters that have been
			 * used to generate the geometry. Any modification
			 * after instantiation does not change the geometry.
			 *
			 * @type {Object}
			 */this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};const width_half=width/2;const height_half=height/2;const gridX=Math.floor(widthSegments);const gridY=Math.floor(heightSegments);const gridX1=gridX+1;const gridY1=gridY+1;const segment_width=width/gridX;const segment_height=height/gridY;//
	const indices=[];const vertices=[];const normals=[];const uvs=[];for(let iy=0;iy<gridY1;iy++){const y=iy*segment_height-height_half;for(let ix=0;ix<gridX1;ix++){const x=ix*segment_width-width_half;vertices.push(x,-y,0);normals.push(0,0,1);uvs.push(ix/gridX);uvs.push(1-iy/gridY);}}for(let iy=0;iy<gridY;iy++){for(let ix=0;ix<gridX;ix++){const a=ix+gridX1*iy;const b=ix+gridX1*(iy+1);const c=ix+1+gridX1*(iy+1);const d=ix+1+gridX1*iy;indices.push(a,b,d);indices.push(b,c,d);}}this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute$1(vertices,3));this.setAttribute('normal',new Float32BufferAttribute$1(normals,3));this.setAttribute('uv',new Float32BufferAttribute$1(uvs,2));}copy(source){super.copy(source);this.parameters=Object.assign({},source.parameters);return this;}/**
		 * Factory method for creating an instance of this class from the given
		 * JSON object.
		 *
		 * @param {Object} data - A JSON object representing the serialized geometry.
		 * @return {PlaneGeometry} A new instance.
		 */static fromJSON(data){return new PlaneGeometry(data.width,data.height,data.widthSegments,data.heightSegments);}}/**
	 * A material for shiny surfaces with specular highlights.
	 *
	 * The material uses a non-physically based [Blinn-Phong](https://en.wikipedia.org/wiki/Blinn-Phong_shading_model)
	 * model for calculating reflectance. Unlike the Lambertian model used in the
	 * {@link MeshLambertMaterial} this can simulate shiny surfaces with specular
	 * highlights (such as varnished wood). `MeshPhongMaterial` uses per-fragment shading.
	 *
	 * Performance will generally be greater when using this material over the
	 * {@link MeshStandardMaterial} or {@link MeshPhysicalMaterial}, at the cost of
	 * some graphical accuracy.
	 *
	 * @augments Material
	 * @demo scenes/material-browser.html#MeshPhongMaterial
	 */class MeshPhongMaterial extends Material{/**
		 * Constructs a new mesh phong material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */constructor(parameters){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isMeshPhongMaterial=true;this.type='MeshPhongMaterial';/**
			 * Color of the material.
			 *
			 * @type {Color}
			 * @default (1,1,1)
			 */this.color=new Color(0xffffff);// diffuse
	/**
			 * Specular color of the material. The default color is set to `0x111111` (very dark grey)
			 *
			 * This defines how shiny the material is and the color of its shine.
			 *
			 * @type {Color}
			 */this.specular=new Color(0x111111);/**
			 * How shiny the specular highlight is; a higher value gives a sharper highlight.
			 *
			 * @type {number}
			 * @default 30
			 */this.shininess=30;/**
			 * The color map. May optionally include an alpha channel, typically combined
			 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
			 * color is modulated by the diffuse `color`.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.map=null;/**
			 * The light map. Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.lightMap=null;/**
			 * Intensity of the baked light.
			 *
			 * @type {number}
			 * @default 1
			 */this.lightMapIntensity=1.0;/**
			 * The red channel of this texture is used as the ambient occlusion map.
			 * Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.aoMap=null;/**
			 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
			 * disables ambient occlusion. Where intensity is `1` and the AO map's
			 * red channel is also `1`, ambient light is fully occluded on a surface.
			 *
			 * @type {number}
			 * @default 1
			 */this.aoMapIntensity=1.0;/**
			 * Emissive (light) color of the material, essentially a solid color
			 * unaffected by other lighting.
			 *
			 * @type {Color}
			 * @default (0,0,0)
			 */this.emissive=new Color(0x000000);/**
			 * Intensity of the emissive light. Modulates the emissive color.
			 *
			 * @type {number}
			 * @default 1
			 */this.emissiveIntensity=1.0;/**
			 * Set emissive (glow) map. The emissive map color is modulated by the
			 * emissive color and the emissive intensity. If you have an emissive map,
			 * be sure to set the emissive color to something other than black.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.emissiveMap=null;/**
			 * The texture to create a bump map. The black and white values map to the
			 * perceived depth in relation to the lights. Bump doesn't actually affect
			 * the geometry of the object, only the lighting. If a normal map is defined
			 * this will be ignored.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.bumpMap=null;/**
			 * How much the bump map affects the material. Typical range is `[0,1]`.
			 *
			 * @type {number}
			 * @default 1
			 */this.bumpScale=1;/**
			 * The texture to create a normal map. The RGB values affect the surface
			 * normal for each pixel fragment and change the way the color is lit. Normal
			 * maps do not change the actual shape of the surface, only the lighting. In
			 * case the material has a normal map authored using the left handed
			 * convention, the `y` component of `normalScale` should be negated to compensate
			 * for the different handedness.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.normalMap=null;/**
			 * The type of normal map.
			 *
			 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
			 * @default TangentSpaceNormalMap
			 */this.normalMapType=TangentSpaceNormalMap;/**
			 * How much the normal map affects the material. Typical value range is `[0,1]`.
			 *
			 * @type {Vector2}
			 * @default (1,1)
			 */this.normalScale=new Vector2$1(1,1);/**
			 * The displacement map affects the position of the mesh's vertices. Unlike
			 * other maps which only affect the light and shade of the material the
			 * displaced vertices can cast shadows, block other objects, and otherwise
			 * act as real geometry. The displacement texture is an image where the value
			 * of each pixel (white being the highest) is mapped against, and
			 * repositions, the vertices of the mesh.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.displacementMap=null;/**
			 * How much the displacement map affects the mesh (where black is no
			 * displacement, and white is maximum displacement). Without a displacement
			 * map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */this.displacementScale=1;/**
			 * The offset of the displacement map's values on the mesh's vertices.
			 * The bias is added to the scaled sample of the displacement map.
			 * Without a displacement map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */this.displacementBias=0;/**
			 * The specular map value affects both how much the specular surface
			 * highlight contributes and how much of the environment map affects the
			 * surface.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.specularMap=null;/**
			 * The alpha map is a grayscale texture that controls the opacity across the
			 * surface (black: fully transparent; white: fully opaque).
			 *
			 * Only the color of the texture is used, ignoring the alpha channel if one
			 * exists. For RGB and RGBA textures, the renderer will use the green channel
			 * when sampling this texture due to the extra bit of precision provided for
			 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
			 * luminance/alpha textures will also still work as expected.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.alphaMap=null;/**
			 * The environment map.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.envMap=null;/**
			 * The rotation of the environment map in radians.
			 *
			 * @type {Euler}
			 * @default (0,0,0)
			 */this.envMapRotation=new Euler$1();/**
			 * How to combine the result of the surface's color with the environment map, if any.
			 *
			 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
			 * blend between the two colors.
			 *
			 * @type {(MultiplyOperation|MixOperation|AddOperation)}
			 * @default MultiplyOperation
			 */this.combine=MultiplyOperation;/**
			 * How much the environment map affects the surface.
			 * The valid range is between `0` (no reflections) and `1` (full reflections).
			 *
			 * @type {number}
			 * @default 1
			 */this.reflectivity=1;/**
			 * The index of refraction (IOR) of air (approximately 1) divided by the
			 * index of refraction of the material. It is used with environment mapping
			 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
			 * The refraction ratio should not exceed `1`.
			 *
			 * @type {number}
			 * @default 0.98
			 */this.refractionRatio=0.98;/**
			 * Renders the geometry as a wireframe.
			 *
			 * @type {boolean}
			 * @default false
			 */this.wireframe=false;/**
			 * Controls the thickness of the wireframe.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {number}
			 * @default 1
			 */this.wireframeLinewidth=1;/**
			 * Defines appearance of wireframe ends.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */this.wireframeLinecap='round';/**
			 * Defines appearance of wireframe joints.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */this.wireframeLinejoin='round';/**
			 * Whether the material is rendered with flat shading or not.
			 *
			 * @type {boolean}
			 * @default false
			 */this.flatShading=false;/**
			 * Whether the material is affected by fog or not.
			 *
			 * @type {boolean}
			 * @default true
			 */this.fog=true;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.specular.copy(source.specular);this.shininess=source.shininess;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapRotation.copy(source.envMapRotation);this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;this.fog=source.fog;return this;}}/**
	 * A material for non-shiny surfaces, without specular highlights.
	 *
	 * The material uses a non-physically based [Lambertian](https://en.wikipedia.org/wiki/Lambertian_reflectance)
	 * model for calculating reflectance. This can simulate some surfaces (such
	 * as untreated wood or stone) well, but cannot simulate shiny surfaces with
	 * specular highlights (such as varnished wood). `MeshLambertMaterial` uses per-fragment
	 * shading.
	 *
	 * Due to the simplicity of the reflectance and illumination models,
	 * performance will be greater when using this material over the
	 * {@link MeshPhongMaterial}, {@link MeshStandardMaterial} or
	 * {@link MeshPhysicalMaterial}, at the cost of some graphical accuracy.
	 *
	 * @augments Material
	 * @demo scenes/material-browser.html#MeshLambertMaterial
	 */class MeshLambertMaterial extends Material{/**
		 * Constructs a new mesh lambert material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */constructor(parameters){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isMeshLambertMaterial=true;this.type='MeshLambertMaterial';/**
			 * Color of the material.
			 *
			 * @type {Color}
			 * @default (1,1,1)
			 */this.color=new Color(0xffffff);// diffuse
	/**
			 * The color map. May optionally include an alpha channel, typically combined
			 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
			 * color is modulated by the diffuse `color`.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.map=null;/**
			 * The light map. Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.lightMap=null;/**
			 * Intensity of the baked light.
			 *
			 * @type {number}
			 * @default 1
			 */this.lightMapIntensity=1.0;/**
			 * The red channel of this texture is used as the ambient occlusion map.
			 * Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.aoMap=null;/**
			 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
			 * disables ambient occlusion. Where intensity is `1` and the AO map's
			 * red channel is also `1`, ambient light is fully occluded on a surface.
			 *
			 * @type {number}
			 * @default 1
			 */this.aoMapIntensity=1.0;/**
			 * Emissive (light) color of the material, essentially a solid color
			 * unaffected by other lighting.
			 *
			 * @type {Color}
			 * @default (0,0,0)
			 */this.emissive=new Color(0x000000);/**
			 * Intensity of the emissive light. Modulates the emissive color.
			 *
			 * @type {number}
			 * @default 1
			 */this.emissiveIntensity=1.0;/**
			 * Set emissive (glow) map. The emissive map color is modulated by the
			 * emissive color and the emissive intensity. If you have an emissive map,
			 * be sure to set the emissive color to something other than black.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.emissiveMap=null;/**
			 * The texture to create a bump map. The black and white values map to the
			 * perceived depth in relation to the lights. Bump doesn't actually affect
			 * the geometry of the object, only the lighting. If a normal map is defined
			 * this will be ignored.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.bumpMap=null;/**
			 * How much the bump map affects the material. Typical range is `[0,1]`.
			 *
			 * @type {number}
			 * @default 1
			 */this.bumpScale=1;/**
			 * The texture to create a normal map. The RGB values affect the surface
			 * normal for each pixel fragment and change the way the color is lit. Normal
			 * maps do not change the actual shape of the surface, only the lighting. In
			 * case the material has a normal map authored using the left handed
			 * convention, the `y` component of `normalScale` should be negated to compensate
			 * for the different handedness.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.normalMap=null;/**
			 * The type of normal map.
			 *
			 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
			 * @default TangentSpaceNormalMap
			 */this.normalMapType=TangentSpaceNormalMap;/**
			 * How much the normal map affects the material. Typical value range is `[0,1]`.
			 *
			 * @type {Vector2}
			 * @default (1,1)
			 */this.normalScale=new Vector2$1(1,1);/**
			 * The displacement map affects the position of the mesh's vertices. Unlike
			 * other maps which only affect the light and shade of the material the
			 * displaced vertices can cast shadows, block other objects, and otherwise
			 * act as real geometry. The displacement texture is an image where the value
			 * of each pixel (white being the highest) is mapped against, and
			 * repositions, the vertices of the mesh.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.displacementMap=null;/**
			 * How much the displacement map affects the mesh (where black is no
			 * displacement, and white is maximum displacement). Without a displacement
			 * map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */this.displacementScale=1;/**
			 * The offset of the displacement map's values on the mesh's vertices.
			 * The bias is added to the scaled sample of the displacement map.
			 * Without a displacement map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */this.displacementBias=0;/**
			 * Specular map used by the material.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.specularMap=null;/**
			 * The alpha map is a grayscale texture that controls the opacity across the
			 * surface (black: fully transparent; white: fully opaque).
			 *
			 * Only the color of the texture is used, ignoring the alpha channel if one
			 * exists. For RGB and RGBA textures, the renderer will use the green channel
			 * when sampling this texture due to the extra bit of precision provided for
			 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
			 * luminance/alpha textures will also still work as expected.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.alphaMap=null;/**
			 * The environment map.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.envMap=null;/**
			 * The rotation of the environment map in radians.
			 *
			 * @type {Euler}
			 * @default (0,0,0)
			 */this.envMapRotation=new Euler$1();/**
			 * How to combine the result of the surface's color with the environment map, if any.
			 *
			 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
			 * blend between the two colors.
			 *
			 * @type {(MultiplyOperation|MixOperation|AddOperation)}
			 * @default MultiplyOperation
			 */this.combine=MultiplyOperation;/**
			 * How much the environment map affects the surface.
			 * The valid range is between `0` (no reflections) and `1` (full reflections).
			 *
			 * @type {number}
			 * @default 1
			 */this.reflectivity=1;/**
			 * The index of refraction (IOR) of air (approximately 1) divided by the
			 * index of refraction of the material. It is used with environment mapping
			 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
			 * The refraction ratio should not exceed `1`.
			 *
			 * @type {number}
			 * @default 0.98
			 */this.refractionRatio=0.98;/**
			 * Renders the geometry as a wireframe.
			 *
			 * @type {boolean}
			 * @default false
			 */this.wireframe=false;/**
			 * Controls the thickness of the wireframe.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {number}
			 * @default 1
			 */this.wireframeLinewidth=1;/**
			 * Defines appearance of wireframe ends.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */this.wireframeLinecap='round';/**
			 * Defines appearance of wireframe joints.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */this.wireframeLinejoin='round';/**
			 * Whether the material is rendered with flat shading or not.
			 *
			 * @type {boolean}
			 * @default false
			 */this.flatShading=false;/**
			 * Whether the material is affected by fog or not.
			 *
			 * @type {boolean}
			 * @default true
			 */this.fog=true;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapRotation.copy(source.envMapRotation);this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;this.fog=source.fog;return this;}}/**
	 * A material for drawing geometry by depth. Depth is based off of the camera
	 * near and far plane. White is nearest, black is farthest.
	 *
	 * @augments Material
	 * @demo scenes/material-browser.html#MeshDepthMaterial
	 */class MeshDepthMaterial extends Material{/**
		 * Constructs a new mesh depth material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */constructor(parameters){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isMeshDepthMaterial=true;this.type='MeshDepthMaterial';/**
			 * Type for depth packing.
			 *
			 * @type {(BasicDepthPacking|RGBADepthPacking|RGBDepthPacking|RGDepthPacking)}
			 * @default BasicDepthPacking
			 */this.depthPacking=BasicDepthPacking;/**
			 * The color map. May optionally include an alpha channel, typically combined
			 * with {@link Material#transparent} or {@link Material#alphaTest}.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.map=null;/**
			 * The alpha map is a grayscale texture that controls the opacity across the
			 * surface (black: fully transparent; white: fully opaque).
			 *
			 * Only the color of the texture is used, ignoring the alpha channel if one
			 * exists. For RGB and RGBA textures, the renderer will use the green channel
			 * when sampling this texture due to the extra bit of precision provided for
			 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
			 * luminance/alpha textures will also still work as expected.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.alphaMap=null;/**
			 * The displacement map affects the position of the mesh's vertices. Unlike
			 * other maps which only affect the light and shade of the material the
			 * displaced vertices can cast shadows, block other objects, and otherwise
			 * act as real geometry. The displacement texture is an image where the value
			 * of each pixel (white being the highest) is mapped against, and
			 * repositions, the vertices of the mesh.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.displacementMap=null;/**
			 * How much the displacement map affects the mesh (where black is no
			 * displacement, and white is maximum displacement). Without a displacement
			 * map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */this.displacementScale=1;/**
			 * The offset of the displacement map's values on the mesh's vertices.
			 * The bias is added to the scaled sample of the displacement map.
			 * Without a displacement map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */this.displacementBias=0;/**
			 * Renders the geometry as a wireframe.
			 *
			 * @type {boolean}
			 * @default false
			 */this.wireframe=false;/**
			 * Controls the thickness of the wireframe.
			 *
			 * WebGL and WebGPU ignore this property and always render
			 * 1 pixel wide lines.
			 *
			 * @type {number}
			 * @default 1
			 */this.wireframeLinewidth=1;this.setValues(parameters);}copy(source){super.copy(source);this.depthPacking=source.depthPacking;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;return this;}}/**
	 * A material used internally for implementing shadow mapping with
	 * point lights.
	 *
	 * Can also be used to customize the shadow casting of an object by assigning
	 * an instance of `MeshDistanceMaterial` to {@link Object3D#customDistanceMaterial}.
	 * The following examples demonstrates this approach in order to ensure
	 * transparent parts of objects do not cast shadows.
	 *
	 * @augments Material
	 */class MeshDistanceMaterial extends Material{/**
		 * Constructs a new mesh distance material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */constructor(parameters){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isMeshDistanceMaterial=true;this.type='MeshDistanceMaterial';/**
			 * The color map. May optionally include an alpha channel, typically combined
			 * with {@link Material#transparent} or {@link Material#alphaTest}.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.map=null;/**
			 * The alpha map is a grayscale texture that controls the opacity across the
			 * surface (black: fully transparent; white: fully opaque).
			 *
			 * Only the color of the texture is used, ignoring the alpha channel if one
			 * exists. For RGB and RGBA textures, the renderer will use the green channel
			 * when sampling this texture due to the extra bit of precision provided for
			 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
			 * luminance/alpha textures will also still work as expected.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.alphaMap=null;/**
			 * The displacement map affects the position of the mesh's vertices. Unlike
			 * other maps which only affect the light and shade of the material the
			 * displaced vertices can cast shadows, block other objects, and otherwise
			 * act as real geometry. The displacement texture is an image where the value
			 * of each pixel (white being the highest) is mapped against, and
			 * repositions, the vertices of the mesh.
			 *
			 * @type {?Texture}
			 * @default null
			 */this.displacementMap=null;/**
			 * How much the displacement map affects the mesh (where black is no
			 * displacement, and white is maximum displacement). Without a displacement
			 * map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */this.displacementScale=1;/**
			 * The offset of the displacement map's values on the mesh's vertices.
			 * The bias is added to the scaled sample of the displacement map.
			 * Without a displacement map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */this.displacementBias=0;this.setValues(parameters);}copy(source){super.copy(source);this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;return this;}}/**
	 * Abstract base class for lights - all other light types inherit the
	 * properties and methods described here.
	 *
	 * @abstract
	 * @augments Object3D
	 */class Light extends Object3D$1{/**
		 * Constructs a new light.
		 *
		 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
		 * @param {number} [intensity=1] - The light's strength/intensity.
		 */constructor(color,intensity=1){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isLight=true;this.type='Light';/**
			 * The light's color.
			 *
			 * @type {Color}
			 */this.color=new Color(color);/**
			 * The light's intensity.
			 *
			 * @type {number}
			 * @default 1
			 */this.intensity=intensity;}/**
		 * Frees the GPU-related resources allocated by this instance. Call this
		 * method whenever this instance is no longer used in your app.
		 */dispose(){// Empty here in base class; some subclasses override.
	}copy(source,recursive){super.copy(source,recursive);this.color.copy(source.color);this.intensity=source.intensity;return this;}toJSON(meta){const data=super.toJSON(meta);data.object.color=this.color.getHex();data.object.intensity=this.intensity;if(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();if(this.distance!==undefined)data.object.distance=this.distance;if(this.angle!==undefined)data.object.angle=this.angle;if(this.decay!==undefined)data.object.decay=this.decay;if(this.penumbra!==undefined)data.object.penumbra=this.penumbra;if(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();if(this.target!==undefined)data.object.target=this.target.uuid;return data;}}const _projScreenMatrix$1=/*@__PURE__*/new Matrix4$1();const _lightPositionWorld$1=/*@__PURE__*/new Vector3$1();const _lookTarget$1=/*@__PURE__*/new Vector3$1();/**
	 * Abstract base class for light shadow classes. These classes
	 * represent the shadow configuration for different light types.
	 *
	 * @abstract
	 */class LightShadow{/**
		 * Constructs a new light shadow.
		 *
		 * @param {Camera} camera - The light's view of the world.
		 */constructor(camera){/**
			 * The light's view of the world.
			 *
			 * @type {Camera}
			 */this.camera=camera;/**
			 * The intensity of the shadow. The default is `1`.
			 * Valid values are in the range `[0, 1]`.
			 *
			 * @type {number}
			 * @default 1
			 */this.intensity=1;/**
			 * Shadow map bias, how much to add or subtract from the normalized depth
			 * when deciding whether a surface is in shadow.
			 *
			 * The default is `0`. Very tiny adjustments here (in the order of `0.0001`)
			 * may help reduce artifacts in shadows.
			 *
			 * @type {number}
			 * @default 0
			 */this.bias=0;/**
			 * Defines how much the position used to query the shadow map is offset along
			 * the object normal. The default is `0`. Increasing this value can be used to
			 * reduce shadow acne especially in large scenes where light shines onto
			 * geometry at a shallow angle. The cost is that shadows may appear distorted.
			 *
			 * @type {number}
			 * @default 0
			 */this.normalBias=0;/**
			 * Setting this to values greater than 1 will blur the edges of the shadow.
			 * High values will cause unwanted banding effects in the shadows - a greater
			 * map size will allow for a higher value to be used here before these effects
			 * become visible.
			 *
			 * The property has no effect when the shadow map type is `PCFSoftShadowMap` and
			 * and it is recommended to increase softness by decreasing the shadow map size instead.
			 *
			 * The property has no effect when the shadow map type is `BasicShadowMap`.
			 *
			 * @type {number}
			 * @default 1
			 */this.radius=1;/**
			 * The amount of samples to use when blurring a VSM shadow map.
			 *
			 * @type {number}
			 * @default 8
			 */this.blurSamples=8;/**
			 * Defines the width and height of the shadow map. Higher values give better quality
			 * shadows at the cost of computation time. Values must be powers of two.
			 *
			 * @type {Vector2}
			 * @default (512,512)
			 */this.mapSize=new Vector2$1(512,512);/**
			 * The type of shadow texture. The default is `UnsignedByteType`.
			 *
			 * @type {number}
			 * @default UnsignedByteType
			 */this.mapType=UnsignedByteType;/**
			 * The depth map generated using the internal camera; a location beyond a
			 * pixel's depth is in shadow. Computed internally during rendering.
			 *
			 * @type {?RenderTarget}
			 * @default null
			 */this.map=null;/**
			 * The distribution map generated using the internal camera; an occlusion is
			 * calculated based on the distribution of depths. Computed internally during
			 * rendering.
			 *
			 * @type {?RenderTarget}
			 * @default null
			 */this.mapPass=null;/**
			 * Model to shadow camera space, to compute location and depth in shadow map.
			 * This is computed internally during rendering.
			 *
			 * @type {Matrix4}
			 */this.matrix=new Matrix4$1();/**
			 * Enables automatic updates of the light's shadow. If you do not require dynamic
			 * lighting / shadows, you may set this to `false`.
			 *
			 * @type {boolean}
			 * @default true
			 */this.autoUpdate=true;/**
			 * When set to `true`, shadow maps will be updated in the next `render` call.
			 * If you have set {@link LightShadow#autoUpdate} to `false`, you will need to
			 * set this property to `true` and then make a render call to update the light's shadow.
			 *
			 * @type {boolean}
			 * @default false
			 */this.needsUpdate=false;this._frustum=new Frustum();this._frameExtents=new Vector2$1(1,1);this._viewportCount=1;this._viewports=[new Vector4(0,0,1,1)];}/**
		 * Used internally by the renderer to get the number of viewports that need
		 * to be rendered for this shadow.
		 *
		 * @return {number} The viewport count.
		 */getViewportCount(){return this._viewportCount;}/**
		 * Gets the shadow cameras frustum. Used internally by the renderer to cull objects.
		 *
		 * @return {Frustum} The shadow camera frustum.
		 */getFrustum(){return this._frustum;}/**
		 * Update the matrices for the camera and shadow, used internally by the renderer.
		 *
		 * @param {Light} light - The light for which the shadow is being rendered.
		 */updateMatrices(light){const shadowCamera=this.camera;const shadowMatrix=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);shadowCamera.position.copy(_lightPositionWorld$1);_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);shadowCamera.lookAt(_lookTarget$1);shadowCamera.updateMatrixWorld();_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(_projScreenMatrix$1,shadowCamera.coordinateSystem,shadowCamera.reversedDepth);if(shadowCamera.reversedDepth){shadowMatrix.set(0.5,0.0,0.0,0.5,0.0,0.5,0.0,0.5,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0);}else {shadowMatrix.set(0.5,0.0,0.0,0.5,0.0,0.5,0.0,0.5,0.0,0.0,0.5,0.5,0.0,0.0,0.0,1.0);}shadowMatrix.multiply(_projScreenMatrix$1);}/**
		 * Returns a viewport definition for the given viewport index.
		 *
		 * @param {number} viewportIndex - The viewport index.
		 * @return {Vector4} The viewport.
		 */getViewport(viewportIndex){return this._viewports[viewportIndex];}/**
		 * Returns the frame extends.
		 *
		 * @return {Vector2} The frame extends.
		 */getFrameExtents(){return this._frameExtents;}/**
		 * Frees the GPU-related resources allocated by this instance. Call this
		 * method whenever this instance is no longer used in your app.
		 */dispose(){if(this.map){this.map.dispose();}if(this.mapPass){this.mapPass.dispose();}}/**
		 * Copies the values of the given light shadow instance to this instance.
		 *
		 * @param {LightShadow} source - The light shadow to copy.
		 * @return {LightShadow} A reference to this light shadow instance.
		 */copy(source){this.camera=source.camera.clone();this.intensity=source.intensity;this.bias=source.bias;this.radius=source.radius;this.autoUpdate=source.autoUpdate;this.needsUpdate=source.needsUpdate;this.normalBias=source.normalBias;this.blurSamples=source.blurSamples;this.mapSize.copy(source.mapSize);return this;}/**
		 * Returns a new light shadow instance with copied values from this instance.
		 *
		 * @return {LightShadow} A clone of this instance.
		 */clone(){return new this.constructor().copy(this);}/**
		 * Serializes the light shadow into JSON.
		 *
		 * @return {Object} A JSON object representing the serialized light shadow.
		 * @see {@link ObjectLoader#parse}
		 */toJSON(){const object={};if(this.intensity!==1)object.intensity=this.intensity;if(this.bias!==0)object.bias=this.bias;if(this.normalBias!==0)object.normalBias=this.normalBias;if(this.radius!==1)object.radius=this.radius;if(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();object.camera=this.camera.toJSON(false).object;delete object.camera.matrix;return object;}}/**
	 * Camera that uses [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection).
	 *
	 * In this projection mode, an object's size in the rendered image stays
	 * constant regardless of its distance from the camera. This can be useful
	 * for rendering 2D scenes and UI elements, amongst other things.
	 *
	 * ```js
	 * const camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
	 * scene.add( camera );
	 * ```
	 *
	 * @augments Camera
	 */class OrthographicCamera extends Camera{/**
		 * Constructs a new orthographic camera.
		 *
		 * @param {number} [left=-1] - The left plane of the camera's frustum.
		 * @param {number} [right=1] - The right plane of the camera's frustum.
		 * @param {number} [top=1] - The top plane of the camera's frustum.
		 * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
		 * @param {number} [near=0.1] - The camera's near plane.
		 * @param {number} [far=2000] - The camera's far plane.
		 */constructor(left=-1,right=1,top=1,bottom=-1,near=0.1,far=2000){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isOrthographicCamera=true;this.type='OrthographicCamera';/**
			 * The zoom factor of the camera.
			 *
			 * @type {number}
			 * @default 1
			 */this.zoom=1;/**
			 * Represents the frustum window specification. This property should not be edited
			 * directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
			 *
			 * @type {?Object}
			 * @default null
			 */this.view=null;/**
			 * The left plane of the camera's frustum.
			 *
			 * @type {number}
			 * @default -1
			 */this.left=left;/**
			 * The right plane of the camera's frustum.
			 *
			 * @type {number}
			 * @default 1
			 */this.right=right;/**
			 * The top plane of the camera's frustum.
			 *
			 * @type {number}
			 * @default 1
			 */this.top=top;/**
			 * The bottom plane of the camera's frustum.
			 *
			 * @type {number}
			 * @default -1
			 */this.bottom=bottom;/**
			 * The camera's near plane. The valid range is greater than `0`
			 * and less than the current value of {@link OrthographicCamera#far}.
			 *
			 * Note that, unlike for the {@link PerspectiveCamera}, `0` is a
			 * valid value for an orthographic camera's near plane.
			 *
			 * @type {number}
			 * @default 0.1
			 */this.near=near;/**
			 * The camera's far plane. Must be greater than the
			 * current value of {@link OrthographicCamera#near}.
			 *
			 * @type {number}
			 * @default 2000
			 */this.far=far;this.updateProjectionMatrix();}copy(source,recursive){super.copy(source,recursive);this.left=source.left;this.right=source.right;this.top=source.top;this.bottom=source.bottom;this.near=source.near;this.far=source.far;this.zoom=source.zoom;this.view=source.view===null?null:Object.assign({},source.view);return this;}/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * @param {number} fullWidth - The full width of multiview setup.
		 * @param {number} fullHeight - The full height of multiview setup.
		 * @param {number} x - The horizontal offset of the subcamera.
		 * @param {number} y - The vertical offset of the subcamera.
		 * @param {number} width - The width of subcamera.
		 * @param {number} height - The height of subcamera.
		 * @see {@link PerspectiveCamera#setViewOffset}
		 */setViewOffset(fullWidth,fullHeight,x,y,width,height){if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();}/**
		 * Removes the view offset from the projection matrix.
		 */clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();}/**
		 * Updates the camera's projection matrix. Must be called after any change of
		 * camera properties.
		 */updateProjectionMatrix(){const dx=(this.right-this.left)/(2*this.zoom);const dy=(this.top-this.bottom)/(2*this.zoom);const cx=(this.right+this.left)/2;const cy=(this.top+this.bottom)/2;let left=cx-dx;let right=cx+dx;let top=cy+dy;let bottom=cy-dy;if(this.view!==null&&this.view.enabled){const scaleW=(this.right-this.left)/this.view.fullWidth/this.zoom;const scaleH=(this.top-this.bottom)/this.view.fullHeight/this.zoom;left+=scaleW*this.view.offsetX;right=left+scaleW*this.view.width;top-=scaleH*this.view.offsetY;bottom=top-scaleH*this.view.height;}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far,this.coordinateSystem,this.reversedDepth);this.projectionMatrixInverse.copy(this.projectionMatrix).invert();}toJSON(meta){const data=super.toJSON(meta);data.object.zoom=this.zoom;data.object.left=this.left;data.object.right=this.right;data.object.top=this.top;data.object.bottom=this.bottom;data.object.near=this.near;data.object.far=this.far;if(this.view!==null)data.object.view=Object.assign({},this.view);return data;}}/**
	 * Represents the shadow configuration of directional lights.
	 *
	 * @augments LightShadow
	 */class DirectionalLightShadow extends LightShadow{/**
		 * Constructs a new directional light shadow.
		 */constructor(){super(new OrthographicCamera(-5,5,5,-5,0.5,500));/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isDirectionalLightShadow=true;}}/**
	 * A light that gets emitted in a specific direction. This light will behave
	 * as though it is infinitely far away and the rays produced from it are all
	 * parallel. The common use case for this is to simulate daylight; the sun is
	 * far enough away that its position can be considered to be infinite, and
	 * all light rays coming from it are parallel.
	 *
	 * A common point of confusion for directional lights is that setting the
	 * rotation has no effect. This is because three.js's DirectionalLight is the
	 * equivalent to what is often called a 'Target Direct Light' in other
	 * applications.
	 *
	 * This means that its direction is calculated as pointing from the light's
	 * {@link Object3D#position} to the {@link DirectionalLight#target} position
	 * (as opposed to a 'Free Direct Light' that just has a rotation
	 * component).
	 *
	 * This light can cast shadows - see the {@link DirectionalLightShadow} for details.
	 *
	 * ```js
	 * // White directional light at half intensity shining from the top.
	 * const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
	 * scene.add( directionalLight );
	 * ```
	 *
	 * @augments Light
	 */class DirectionalLight extends Light{/**
		 * Constructs a new directional light.
		 *
		 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
		 * @param {number} [intensity=1] - The light's strength/intensity.
		 */constructor(color,intensity){super(color,intensity);/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isDirectionalLight=true;this.type='DirectionalLight';this.position.copy(Object3D$1.DEFAULT_UP);this.updateMatrix();/**
			 * The directional light points from its position to the
			 * target's position.
			 *
			 * For the target's position to be changed to anything other
			 * than the default, it must be added to the scene.
			 *
			 * It is also possible to set the target to be another 3D object
			 * in the scene. The light will now track the target object.
			 *
			 * @type {Object3D}
			 */this.target=new Object3D$1();/**
			 * This property holds the light's shadow configuration.
			 *
			 * @type {DirectionalLightShadow}
			 */this.shadow=new DirectionalLightShadow();}dispose(){this.shadow.dispose();}copy(source){super.copy(source);this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}}/**
	 * This light globally illuminates all objects in the scene equally.
	 *
	 * It cannot be used to cast shadows as it does not have a direction.
	 *
	 * ```js
	 * const light = new THREE.AmbientLight( 0x404040 ); // soft white light
	 * scene.add( light );
	 * ```
	 *
	 * @augments Light
	 */class AmbientLight extends Light{/**
		 * Constructs a new ambient light.
		 *
		 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
		 * @param {number} [intensity=1] - The light's strength/intensity.
		 */constructor(color,intensity){super(color,intensity);/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isAmbientLight=true;this.type='AmbientLight';}}/**
	 * This type of camera can be used in order to efficiently render a scene with a
	 * predefined set of cameras. This is an important performance aspect for
	 * rendering VR scenes.
	 *
	 * An instance of `ArrayCamera` always has an array of sub cameras. It's mandatory
	 * to define for each sub camera the `viewport` property which determines the
	 * part of the viewport that is rendered with this camera.
	 *
	 * @augments PerspectiveCamera
	 */class ArrayCamera extends PerspectiveCamera{/**
		 * Constructs a new array camera.
		 *
		 * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
		 */constructor(array=[]){super();/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isArrayCamera=true;/**
			 * Whether this camera is used with multiview rendering or not.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default false
			 */this.isMultiViewCamera=false;/**
			 * An array of perspective sub cameras.
			 *
			 * @type {Array<PerspectiveCamera>}
			 */this.cameras=array;}}const _matrix$1=/*@__PURE__*/new Matrix4$1();/**
	 * This class is designed to assist with raycasting. Raycasting is used for
	 * mouse picking (working out what objects in the 3d space the mouse is over)
	 * amongst other things.
	 */class Raycaster{/**
		 * Constructs a new raycaster.
		 *
		 * @param {Vector3} origin - The origin vector where the ray casts from.
		 * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.
		 * @param {number} [near=0] - All results returned are further away than near. Near can't be negative.
		 * @param {number} [far=Infinity] - All results returned are closer than far. Far can't be lower than near.
		 */constructor(origin,direction,near=0,far=Infinity){/**
			 * The ray used for raycasting.
			 *
			 * @type {Ray}
			 */this.ray=new Ray(origin,direction);/**
			 * All results returned are further away than near. Near can't be negative.
			 *
			 * @type {number}
			 * @default 0
			 */this.near=near;/**
			 * All results returned are further away than near. Near can't be negative.
			 *
			 * @type {number}
			 * @default Infinity
			 */this.far=far;/**
			 * The camera to use when raycasting against view-dependent objects such as
			 * billboarded objects like sprites. This field can be set manually or
			 * is set when calling `setFromCamera()`.
			 *
			 * @type {?Camera}
			 * @default null
			 */this.camera=null;/**
			 * Allows to selectively ignore 3D objects when performing intersection tests.
			 * The following code example ensures that only 3D objects on layer `1` will be
			 * honored by raycaster.
			 * ```js
			 * raycaster.layers.set( 1 );
			 * object.layers.enable( 1 );
			 * ```
			 *
			 * @type {Layers}
			 */this.layers=new Layers$1();/**
			 * A parameter object that configures the raycasting. It has the structure:
			 *
			 * ```
			 * {
			 * 	Mesh: {},
			 * 	Line: { threshold: 1 },
			 * 	LOD: {},
			 * 	Points: { threshold: 1 },
			 * 	Sprite: {}
			 * }
			 * ```
			 * Where `threshold` is the precision of the raycaster when intersecting objects, in world units.
			 *
			 * @type {Object}
			 */this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}};}/**
		 * Updates the ray with a new origin and direction by copying the values from the arguments.
		 *
		 * @param {Vector3} origin - The origin vector where the ray casts from.
		 * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.
		 */set(origin,direction){// direction is assumed to be normalized (for accurate distance calculations)
	this.ray.set(origin,direction);}/**
		 * Uses the given coordinates and camera to compute a new origin and direction for the internal ray.
		 *
		 * @param {Vector2} coords - 2D coordinates of the mouse, in normalized device coordinates (NDC).
		 * X and Y components should be between `-1` and `1`.
		 * @param {Camera} camera - The camera from which the ray should originate.
		 */setFromCamera(coords,camera){if(camera.isPerspectiveCamera){this.ray.origin.setFromMatrixPosition(camera.matrixWorld);this.ray.direction.set(coords.x,coords.y,0.5).unproject(camera).sub(this.ray.origin).normalize();this.camera=camera;}else if(camera.isOrthographicCamera){this.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera);// set origin in plane of camera
	this.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld);this.camera=camera;}else {error$1('Raycaster: Unsupported camera type: '+camera.type);}}/**
		 * Uses the given WebXR controller to compute a new origin and direction for the internal ray.
		 *
		 * @param {WebXRController} controller - The controller to copy the position and direction from.
		 * @return {Raycaster} A reference to this raycaster.
		 */setFromXRController(controller){_matrix$1.identity().extractRotation(controller.matrixWorld);this.ray.origin.setFromMatrixPosition(controller.matrixWorld);this.ray.direction.set(0,0,-1).applyMatrix4(_matrix$1);return this;}/**
		 * The intersection point of a raycaster intersection test.
		 * @typedef {Object} Raycaster~Intersection
		 * @property {number} distance - The distance from the ray's origin to the intersection point.
		 * @property {number} distanceToRay -  Some 3D objects e.g. {@link Points} provide the distance of the
		 * intersection to the nearest point on the ray. For other objects it will be `undefined`.
		 * @property {Vector3} point - The intersection point, in world coordinates.
		 * @property {Object} face - The face that has been intersected.
		 * @property {number} faceIndex - The face index.
		 * @property {Object3D} object - The 3D object that has been intersected.
		 * @property {Vector2} uv - U,V coordinates at point of intersection.
		 * @property {Vector2} uv1 - Second set of U,V coordinates at point of intersection.
		 * @property {Vector3} uv1 - Interpolated normal vector at point of intersection.
		 * @property {number} instanceId - The index number of the instance where the ray
		 * intersects the {@link InstancedMesh}.
		 *//**
		 * Checks all intersection between the ray and the object with or without the
		 * descendants. Intersections are returned sorted by distance, closest first.
		 *
		 * `Raycaster` delegates to the `raycast()` method of the passed 3D object, when
		 * evaluating whether the ray intersects the object or not. This allows meshes to respond
		 * differently to ray casting than lines or points.
		 *
		 * Note that for meshes, faces must be pointed towards the origin of the ray in order
		 * to be detected; intersections of the ray passing through the back of a face will not
		 * be detected. To raycast against both faces of an object, you'll want to set  {@link Material#side}
		 * to `THREE.DoubleSide`.
		 *
		 * @param {Object3D} object - The 3D object to check for intersection with the ray.
		 * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.
		 * Otherwise it only checks intersection with the object.
		 * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.
		 * @return {Array<Raycaster~Intersection>} An array holding the intersection points.
		 */intersectObject(object,recursive=true,intersects=[]){intersect(object,this,intersects,recursive);intersects.sort(ascSort);return intersects;}/**
		 * Checks all intersection between the ray and the objects with or without
		 * the descendants. Intersections are returned sorted by distance, closest first.
		 *
		 * @param {Array<Object3D>} objects - The 3D objects to check for intersection with the ray.
		 * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.
		 * Otherwise it only checks intersection with the object.
		 * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.
		 * @return {Array<Raycaster~Intersection>} An array holding the intersection points.
		 */intersectObjects(objects,recursive=true,intersects=[]){for(let i=0,l=objects.length;i<l;i++){intersect(objects[i],this,intersects,recursive);}intersects.sort(ascSort);return intersects;}}function ascSort(a,b){return a.distance-b.distance;}function intersect(object,raycaster,intersects,recursive){let propagate=true;if(object.layers.test(raycaster.layers)){const result=object.raycast(raycaster,intersects);if(result===false)propagate=false;}if(propagate===true&&recursive===true){const children=object.children;for(let i=0,l=children.length;i<l;i++){intersect(children[i],raycaster,intersects,true);}}}/**
	 * This class can be used to represent points in 3D space as
	 * [Spherical coordinates](https://en.wikipedia.org/wiki/Spherical_coordinate_system).
	 */class Spherical{/**
		 * Constructs a new spherical.
		 *
		 * @param {number} [radius=1] - The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
		 * @param {number} [phi=0] - The polar angle in radians from the y (up) axis.
		 * @param {number} [theta=0] - The equator/azimuthal angle in radians around the y (up) axis.
		 */constructor(radius=1,phi=0,theta=0){/**
			 * The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
			 *
			 * @type {number}
			 * @default 1
			 */this.radius=radius;/**
			 * The polar angle in radians from the y (up) axis.
			 *
			 * @type {number}
			 * @default 0
			 */this.phi=phi;/**
			 * The equator/azimuthal angle in radians around the y (up) axis.
			 *
			 * @type {number}
			 * @default 0
			 */this.theta=theta;}/**
		 * Sets the spherical components by copying the given values.
		 *
		 * @param {number} radius - The radius.
		 * @param {number} phi - The polar angle.
		 * @param {number} theta - The azimuthal angle.
		 * @return {Spherical} A reference to this spherical.
		 */set(radius,phi,theta){this.radius=radius;this.phi=phi;this.theta=theta;return this;}/**
		 * Copies the values of the given spherical to this instance.
		 *
		 * @param {Spherical} other - The spherical to copy.
		 * @return {Spherical} A reference to this spherical.
		 */copy(other){this.radius=other.radius;this.phi=other.phi;this.theta=other.theta;return this;}/**
		 * Restricts the polar angle [page:.phi phi] to be between `0.000001` and pi -
		 * `0.000001`.
		 *
		 * @return {Spherical} A reference to this spherical.
		 */makeSafe(){const EPS=0.000001;this.phi=clamp$1(this.phi,EPS,Math.PI-EPS);return this;}/**
		 * Sets the spherical components from the given vector which is assumed to hold
		 * Cartesian coordinates.
		 *
		 * @param {Vector3} v - The vector to set.
		 * @return {Spherical} A reference to this spherical.
		 */setFromVector3(v){return this.setFromCartesianCoords(v.x,v.y,v.z);}/**
		 * Sets the spherical components from the given Cartesian coordinates.
		 *
		 * @param {number} x - The x value.
		 * @param {number} y - The y value.
		 * @param {number} z - The z value.
		 * @return {Spherical} A reference to this spherical.
		 */setFromCartesianCoords(x,y,z){this.radius=Math.sqrt(x*x+y*y+z*z);if(this.radius===0){this.theta=0;this.phi=0;}else {this.theta=Math.atan2(x,z);this.phi=Math.acos(clamp$1(y/this.radius,-1,1));}return this;}/**
		 * Returns a new spherical with copied values from this instance.
		 *
		 * @return {Spherical} A clone of this instance.
		 */clone(){return new this.constructor().copy(this);}}/**
	 * Abstract base class for controls.
	 *
	 * @abstract
	 * @augments EventDispatcher
	 */class Controls extends EventDispatcher$1{/**
		 * Constructs a new controls instance.
		 *
		 * @param {Object3D} object - The object that is managed by the controls.
		 * @param {?HTMLElement} domElement - The HTML element used for event listeners.
		 */constructor(object,domElement=null){super();/**
			 * The object that is managed by the controls.
			 *
			 * @type {Object3D}
			 */this.object=object;/**
			 * The HTML element used for event listeners.
			 *
			 * @type {?HTMLElement}
			 * @default null
			 */this.domElement=domElement;/**
			 * Whether the controls responds to user input or not.
			 *
			 * @type {boolean}
			 * @default true
			 */this.enabled=true;/**
			 * The internal state of the controls.
			 *
			 * @type {number}
			 * @default -1
			 */this.state=-1;/**
			 * This object defines the keyboard input of the controls.
			 *
			 * @type {Object}
			 */this.keys={};/**
			 * This object defines what type of actions are assigned to the available mouse buttons.
			 * It depends on the control implementation what kind of mouse buttons and actions are supported.
			 *
			 * @type {{LEFT: ?number, MIDDLE: ?number, RIGHT: ?number}}
			 */this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null};/**
			 * This object defines what type of actions are assigned to what kind of touch interaction.
			 * It depends on the control implementation what kind of touch interaction and actions are supported.
			 *
			 * @type {{ONE: ?number, TWO: ?number}}
			 */this.touches={ONE:null,TWO:null};}/**
		 * Connects the controls to the DOM. This method has so called "side effects" since
		 * it adds the module's event listeners to the DOM.
		 *
		 * @param {HTMLElement} element - The DOM element to connect to.
		 */connect(element){if(element===undefined){warn$1('Controls: connect() now requires an element.');// @deprecated, the warning can be removed with r185
	return;}if(this.domElement!==null)this.disconnect();this.domElement=element;}/**
		 * Disconnects the controls from the DOM.
		 */disconnect(){}/**
		 * Call this method if you no longer want use to the controls. It frees all internal
		 * resources and removes all event listeners.
		 */dispose(){}/**
		 * Controls should implement this method if they have to update their internal state
		 * per simulation step.
		 *
		 * @param {number} [delta] - The time delta in seconds.
		 */update(/* delta */){}}/**
	 * Determines how many bytes must be used to represent the texture.
	 *
	 * @param {number} width - The width of the texture.
	 * @param {number} height - The height of the texture.
	 * @param {number} format - The texture's format.
	 * @param {number} type - The texture's type.
	 * @return {number} The byte length.
	 */function getByteLength(width,height,format,type){const typeByteLength=getTextureTypeByteLength(type);switch(format){// https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
	case AlphaFormat:return width*height;case RedFormat:return width*height/typeByteLength.components*typeByteLength.byteLength;case RedIntegerFormat:return width*height/typeByteLength.components*typeByteLength.byteLength;case RGFormat:return width*height*2/typeByteLength.components*typeByteLength.byteLength;case RGIntegerFormat:return width*height*2/typeByteLength.components*typeByteLength.byteLength;case RGBFormat:return width*height*3/typeByteLength.components*typeByteLength.byteLength;case RGBAFormat:return width*height*4/typeByteLength.components*typeByteLength.byteLength;case RGBAIntegerFormat:return width*height*4/typeByteLength.components*typeByteLength.byteLength;// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
	case RGB_S3TC_DXT1_Format:case RGBA_S3TC_DXT1_Format:return Math.floor((width+3)/4)*Math.floor((height+3)/4)*8;case RGBA_S3TC_DXT3_Format:case RGBA_S3TC_DXT5_Format:return Math.floor((width+3)/4)*Math.floor((height+3)/4)*16;// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
	case RGB_PVRTC_2BPPV1_Format:case RGBA_PVRTC_2BPPV1_Format:return Math.max(width,16)*Math.max(height,8)/4;case RGB_PVRTC_4BPPV1_Format:case RGBA_PVRTC_4BPPV1_Format:return Math.max(width,8)*Math.max(height,8)/2;// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
	case RGB_ETC1_Format:case RGB_ETC2_Format:return Math.floor((width+3)/4)*Math.floor((height+3)/4)*8;case RGBA_ETC2_EAC_Format:return Math.floor((width+3)/4)*Math.floor((height+3)/4)*16;// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
	case RGBA_ASTC_4x4_Format:return Math.floor((width+3)/4)*Math.floor((height+3)/4)*16;case RGBA_ASTC_5x4_Format:return Math.floor((width+4)/5)*Math.floor((height+3)/4)*16;case RGBA_ASTC_5x5_Format:return Math.floor((width+4)/5)*Math.floor((height+4)/5)*16;case RGBA_ASTC_6x5_Format:return Math.floor((width+5)/6)*Math.floor((height+4)/5)*16;case RGBA_ASTC_6x6_Format:return Math.floor((width+5)/6)*Math.floor((height+5)/6)*16;case RGBA_ASTC_8x5_Format:return Math.floor((width+7)/8)*Math.floor((height+4)/5)*16;case RGBA_ASTC_8x6_Format:return Math.floor((width+7)/8)*Math.floor((height+5)/6)*16;case RGBA_ASTC_8x8_Format:return Math.floor((width+7)/8)*Math.floor((height+7)/8)*16;case RGBA_ASTC_10x5_Format:return Math.floor((width+9)/10)*Math.floor((height+4)/5)*16;case RGBA_ASTC_10x6_Format:return Math.floor((width+9)/10)*Math.floor((height+5)/6)*16;case RGBA_ASTC_10x8_Format:return Math.floor((width+9)/10)*Math.floor((height+7)/8)*16;case RGBA_ASTC_10x10_Format:return Math.floor((width+9)/10)*Math.floor((height+9)/10)*16;case RGBA_ASTC_12x10_Format:return Math.floor((width+11)/12)*Math.floor((height+9)/10)*16;case RGBA_ASTC_12x12_Format:return Math.floor((width+11)/12)*Math.floor((height+11)/12)*16;// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
	case RGBA_BPTC_Format:case RGB_BPTC_SIGNED_Format:case RGB_BPTC_UNSIGNED_Format:return Math.ceil(width/4)*Math.ceil(height/4)*16;// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
	case RED_RGTC1_Format:case SIGNED_RED_RGTC1_Format:return Math.ceil(width/4)*Math.ceil(height/4)*8;case RED_GREEN_RGTC2_Format:case SIGNED_RED_GREEN_RGTC2_Format:return Math.ceil(width/4)*Math.ceil(height/4)*16;}throw new Error(`Unable to determine texture byte length for ${format} format.`);}function getTextureTypeByteLength(type){switch(type){case UnsignedByteType:case ByteType:return {byteLength:1,components:1};case UnsignedShortType:case ShortType:case HalfFloatType:return {byteLength:2,components:1};case UnsignedShort4444Type:case UnsignedShort5551Type:return {byteLength:2,components:4};case UnsignedIntType:case IntType:case FloatType$1:return {byteLength:4,components:1};case UnsignedInt5999Type:case UnsignedInt101111Type:return {byteLength:4,components:3};}throw new Error(`Unknown texture type ${type}.`);}if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register',{detail:{revision:REVISION}}));}if(typeof window!=='undefined'){if(window.__THREE__){warn$1('WARNING: Multiple instances of Three.js being imported.');}else {window.__THREE__=REVISION;}}

	function WebGLAnimation(){let context=null;let isAnimating=false;let animationLoop=null;let requestId=null;function onAnimationFrame(time,frame){animationLoop(time,frame);requestId=context.requestAnimationFrame(onAnimationFrame);}return {start:function(){if(isAnimating===true)return;if(animationLoop===null)return;requestId=context.requestAnimationFrame(onAnimationFrame);isAnimating=true;},stop:function(){context.cancelAnimationFrame(requestId);isAnimating=false;},setAnimationLoop:function(callback){animationLoop=callback;},setContext:function(value){context=value;}};}function WebGLAttributes(gl){const buffers=new WeakMap();function createBuffer(attribute,bufferType){const array=attribute.array;const usage=attribute.usage;const size=array.byteLength;const buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer);gl.bufferData(bufferType,array,usage);attribute.onUploadCallback();let type;if(array instanceof Float32Array){type=gl.FLOAT;}else if(typeof Float16Array!=='undefined'&&array instanceof Float16Array){type=gl.HALF_FLOAT;}else if(array instanceof Uint16Array){if(attribute.isFloat16BufferAttribute){type=gl.HALF_FLOAT;}else {type=gl.UNSIGNED_SHORT;}}else if(array instanceof Int16Array){type=gl.SHORT;}else if(array instanceof Uint32Array){type=gl.UNSIGNED_INT;}else if(array instanceof Int32Array){type=gl.INT;}else if(array instanceof Int8Array){type=gl.BYTE;}else if(array instanceof Uint8Array){type=gl.UNSIGNED_BYTE;}else if(array instanceof Uint8ClampedArray){type=gl.UNSIGNED_BYTE;}else {throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: '+array);}return {buffer:buffer,type:type,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version,size:size};}function updateBuffer(buffer,attribute,bufferType){const array=attribute.array;const updateRanges=attribute.updateRanges;gl.bindBuffer(bufferType,buffer);if(updateRanges.length===0){// Not using update ranges
	gl.bufferSubData(bufferType,0,array);}else {// Before applying update ranges, we merge any adjacent / overlapping
	// ranges to reduce load on `gl.bufferSubData`. Empirically, this has led
	// to performance improvements for applications which make heavy use of
	// update ranges. Likely due to GPU command overhead.
	//
	// Note that to reduce garbage collection between frames, we merge the
	// update ranges in-place. This is safe because this method will clear the
	// update ranges once updated.
	updateRanges.sort((a,b)=>a.start-b.start);// To merge the update ranges in-place, we work from left to right in the
	// existing updateRanges array, merging ranges. This may result in a final
	// array which is smaller than the original. This index tracks the last
	// index representing a merged range, any data after this index can be
	// trimmed once the merge algorithm is completed.
	let mergeIndex=0;for(let i=1;i<updateRanges.length;i++){const previousRange=updateRanges[mergeIndex];const range=updateRanges[i];// We add one here to merge adjacent ranges. This is safe because ranges
	// operate over positive integers.
	if(range.start<=previousRange.start+previousRange.count+1){previousRange.count=Math.max(previousRange.count,range.start+range.count-previousRange.start);}else {++mergeIndex;updateRanges[mergeIndex]=range;}}// Trim the array to only contain the merged ranges.
	updateRanges.length=mergeIndex+1;for(let i=0,l=updateRanges.length;i<l;i++){const range=updateRanges[i];gl.bufferSubData(bufferType,range.start*array.BYTES_PER_ELEMENT,array,range.start,range.count);}attribute.clearUpdateRanges();}attribute.onUploadCallback();}//
	function get(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;return buffers.get(attribute);}function remove(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;const data=buffers.get(attribute);if(data){gl.deleteBuffer(data.buffer);buffers.delete(attribute);}}function update(attribute,bufferType){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;if(attribute.isGLBufferAttribute){const cached=buffers.get(attribute);if(!cached||cached.version<attribute.version){buffers.set(attribute,{buffer:attribute.buffer,type:attribute.type,bytesPerElement:attribute.elementSize,version:attribute.version});}return;}const data=buffers.get(attribute);if(data===undefined){buffers.set(attribute,createBuffer(attribute,bufferType));}else if(data.version<attribute.version){if(data.size!==attribute.array.byteLength){throw new Error('THREE.WebGLAttributes: The size of the buffer attribute\'s array buffer does not match the original size. Resizing buffer attributes is not supported.');}updateBuffer(data.buffer,attribute,bufferType);data.version=attribute.version;}}return {get:get,remove:remove,update:update};}var alphahash_fragment="#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";var alphahash_pars_fragment="#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif";var alphamap_fragment="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";var alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var alphatest_fragment="#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif";var alphatest_pars_fragment="#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";var aomap_fragment="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";var aomap_pars_fragment="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";var batching_pars_vertex="#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif";var batching_vertex="#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";var begin_vertex="vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif";var beginnormal_vertex="vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";var bsdfs="float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated";var iridescence_fragment="#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";var bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";var clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif";var clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";var clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";var clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";var color_fragment="#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";var color_pars_fragment="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";var color_pars_vertex="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif";var color_vertex="#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif";var common="#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";var cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";var defaultnormal_vertex="vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";var displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";var displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";var emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";var emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";var colorspace_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );";var colorspace_pars_fragment="vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";var envmap_fragment="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";var envmap_common_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n#endif";var envmap_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";var envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";var envmap_vertex="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";var fog_vertex="#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";var fog_pars_vertex="#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";var fog_fragment="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";var fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";var gradientmap_pars_fragment="#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";var lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";var lights_lambert_fragment="LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";var lights_lambert_pars_fragment="varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";var lights_pars_begin="uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";var envmap_physical_pars_fragment="#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif";var lights_toon_fragment="ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";var lights_toon_pars_fragment="varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";var lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";var lights_phong_pars_fragment="varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";var lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";var lights_physical_pars_fragment="uniform sampler2D dfgLUT;\nstruct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 uv = vec2( roughness, dotNV );\n\treturn texture2D( dfgLUT, uv ).rg;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nvec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 dfgV = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNV * dotNV), 0.0, dotNV), material.roughness );\n\tvec2 dfgL = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNL * dotNL), 0.0, dotNL), material.roughness );\n\tvec3 FssEss_V = material.specularColor * dfgV.x + material.specularF90 * dfgV.y;\n\tvec3 FssEss_L = material.specularColor * dfgL.x + material.specularF90 * dfgL.y;\n\tfloat Ess_V = dfgV.x + dfgV.y;\n\tfloat Ess_L = dfgL.x + dfgL.y;\n\tfloat Ems_V = 1.0 - Ess_V;\n\tfloat Ems_L = 1.0 - Ess_L;\n\tvec3 Favg = material.specularColor + ( 1.0 - material.specularColor ) * 0.047619;\n\tvec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg * Favg + EPSILON );\n\tfloat compensationFactor = Ems_V * Ems_L;\n\tvec3 multiScatter = Fms * compensationFactor;\n\treturn singleScatter + multiScatter;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";var lights_fragment_begin="\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";var lights_fragment_maps="#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";var lights_fragment_end="#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";var logdepthbuf_fragment="#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";var logdepthbuf_pars_fragment="#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";var logdepthbuf_pars_vertex="#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";var logdepthbuf_vertex="#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";var map_fragment="#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";var map_pars_fragment="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";var map_particle_fragment="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";var map_particle_pars_fragment="#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";var metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";var morphinstance_vertex="#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif";var morphcolor_vertex="#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";var morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";var morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif";var morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";var normal_fragment_begin="float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;";var normal_fragment_maps="#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";var normal_pars_fragment="#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";var normal_pars_vertex="#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";var normal_vertex="#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";var normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif";var clearcoat_normal_fragment_begin="#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif";var clearcoat_normal_fragment_maps="#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";var clearcoat_pars_fragment="#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif";var iridescence_pars_fragment="#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";var opaque_fragment="#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";var packing="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}";var premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";var project_vertex="vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";var dithering_fragment="#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";var dithering_pars_fragment="#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";var roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";var roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";var shadowmap_pars_fragment="#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\tfloat depth = unpackRGBAToDepth( texture2D( depths, uv ) );\n\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\treturn step( depth, compare );\n\t\t#else\n\t\t\treturn step( compare, depth );\n\t\t#endif\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow( sampler2D shadow, vec2 uv, float compare ) {\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\tfloat hard_shadow = step( distribution.x, compare );\n\t\t#else\n\t\t\tfloat hard_shadow = step( compare, distribution.x );\n\t\t#endif\n\t\tif ( hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif";var shadowmap_pars_vertex="#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";var shadowmap_vertex="#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";var shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";var skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";var skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif";var skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";var skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";var specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";var specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";var tonemapping_fragment="#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";var tonemapping_pars_fragment="#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";var transmission_fragment="#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";var transmission_pars_fragment="#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t#else\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif";var uv_pars_fragment="#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";var uv_pars_vertex="#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";var uv_vertex="#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";var worldpos_vertex="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";const vertex$h="varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";const fragment$h="uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";const vertex$g="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";const fragment$g="#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";const vertex$f="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";const fragment$f="uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";const vertex$e="#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";const fragment$e="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\tfloat fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];\n\t#else\n\t\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;\n\t#endif\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}";const vertex$d="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";const fragment$d="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";const vertex$c="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";const fragment$c="uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";const vertex$b="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";const fragment$b="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";const vertex$a="#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";const fragment$a="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const vertex$9="#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";const fragment$9="#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const vertex$8="#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";const fragment$8="#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const vertex$7="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";const fragment$7="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";const vertex$6="#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";const fragment$6="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const vertex$5="#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";const fragment$5="#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const vertex$4="#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";const fragment$4="#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const vertex$3="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";const fragment$3="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";const vertex$2="#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";const fragment$2="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";const vertex$1="uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";const fragment$1="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";const ShaderChunk={alphahash_fragment:alphahash_fragment,alphahash_pars_fragment:alphahash_pars_fragment,alphamap_fragment:alphamap_fragment,alphamap_pars_fragment:alphamap_pars_fragment,alphatest_fragment:alphatest_fragment,alphatest_pars_fragment:alphatest_pars_fragment,aomap_fragment:aomap_fragment,aomap_pars_fragment:aomap_pars_fragment,batching_pars_vertex:batching_pars_vertex,batching_vertex:batching_vertex,begin_vertex:begin_vertex,beginnormal_vertex:beginnormal_vertex,bsdfs:bsdfs,iridescence_fragment:iridescence_fragment,bumpmap_pars_fragment:bumpmap_pars_fragment,clipping_planes_fragment:clipping_planes_fragment,clipping_planes_pars_fragment:clipping_planes_pars_fragment,clipping_planes_pars_vertex:clipping_planes_pars_vertex,clipping_planes_vertex:clipping_planes_vertex,color_fragment:color_fragment,color_pars_fragment:color_pars_fragment,color_pars_vertex:color_pars_vertex,color_vertex:color_vertex,common:common,cube_uv_reflection_fragment:cube_uv_reflection_fragment,defaultnormal_vertex:defaultnormal_vertex,displacementmap_pars_vertex:displacementmap_pars_vertex,displacementmap_vertex:displacementmap_vertex,emissivemap_fragment:emissivemap_fragment,emissivemap_pars_fragment:emissivemap_pars_fragment,colorspace_fragment:colorspace_fragment,colorspace_pars_fragment:colorspace_pars_fragment,envmap_fragment:envmap_fragment,envmap_common_pars_fragment:envmap_common_pars_fragment,envmap_pars_fragment:envmap_pars_fragment,envmap_pars_vertex:envmap_pars_vertex,envmap_physical_pars_fragment:envmap_physical_pars_fragment,envmap_vertex:envmap_vertex,fog_vertex:fog_vertex,fog_pars_vertex:fog_pars_vertex,fog_fragment:fog_fragment,fog_pars_fragment:fog_pars_fragment,gradientmap_pars_fragment:gradientmap_pars_fragment,lightmap_pars_fragment:lightmap_pars_fragment,lights_lambert_fragment:lights_lambert_fragment,lights_lambert_pars_fragment:lights_lambert_pars_fragment,lights_pars_begin:lights_pars_begin,lights_toon_fragment:lights_toon_fragment,lights_toon_pars_fragment:lights_toon_pars_fragment,lights_phong_fragment:lights_phong_fragment,lights_phong_pars_fragment:lights_phong_pars_fragment,lights_physical_fragment:lights_physical_fragment,lights_physical_pars_fragment:lights_physical_pars_fragment,lights_fragment_begin:lights_fragment_begin,lights_fragment_maps:lights_fragment_maps,lights_fragment_end:lights_fragment_end,logdepthbuf_fragment:logdepthbuf_fragment,logdepthbuf_pars_fragment:logdepthbuf_pars_fragment,logdepthbuf_pars_vertex:logdepthbuf_pars_vertex,logdepthbuf_vertex:logdepthbuf_vertex,map_fragment:map_fragment,map_pars_fragment:map_pars_fragment,map_particle_fragment:map_particle_fragment,map_particle_pars_fragment:map_particle_pars_fragment,metalnessmap_fragment:metalnessmap_fragment,metalnessmap_pars_fragment:metalnessmap_pars_fragment,morphinstance_vertex:morphinstance_vertex,morphcolor_vertex:morphcolor_vertex,morphnormal_vertex:morphnormal_vertex,morphtarget_pars_vertex:morphtarget_pars_vertex,morphtarget_vertex:morphtarget_vertex,normal_fragment_begin:normal_fragment_begin,normal_fragment_maps:normal_fragment_maps,normal_pars_fragment:normal_pars_fragment,normal_pars_vertex:normal_pars_vertex,normal_vertex:normal_vertex,normalmap_pars_fragment:normalmap_pars_fragment,clearcoat_normal_fragment_begin:clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps:clearcoat_normal_fragment_maps,clearcoat_pars_fragment:clearcoat_pars_fragment,iridescence_pars_fragment:iridescence_pars_fragment,opaque_fragment:opaque_fragment,packing:packing,premultiplied_alpha_fragment:premultiplied_alpha_fragment,project_vertex:project_vertex,dithering_fragment:dithering_fragment,dithering_pars_fragment:dithering_pars_fragment,roughnessmap_fragment:roughnessmap_fragment,roughnessmap_pars_fragment:roughnessmap_pars_fragment,shadowmap_pars_fragment:shadowmap_pars_fragment,shadowmap_pars_vertex:shadowmap_pars_vertex,shadowmap_vertex:shadowmap_vertex,shadowmask_pars_fragment:shadowmask_pars_fragment,skinbase_vertex:skinbase_vertex,skinning_pars_vertex:skinning_pars_vertex,skinning_vertex:skinning_vertex,skinnormal_vertex:skinnormal_vertex,specularmap_fragment:specularmap_fragment,specularmap_pars_fragment:specularmap_pars_fragment,tonemapping_fragment:tonemapping_fragment,tonemapping_pars_fragment:tonemapping_pars_fragment,transmission_fragment:transmission_fragment,transmission_pars_fragment:transmission_pars_fragment,uv_pars_fragment:uv_pars_fragment,uv_pars_vertex:uv_pars_vertex,uv_vertex:uv_vertex,worldpos_vertex:worldpos_vertex,background_vert:vertex$h,background_frag:fragment$h,backgroundCube_vert:vertex$g,backgroundCube_frag:fragment$g,cube_vert:vertex$f,cube_frag:fragment$f,depth_vert:vertex$e,depth_frag:fragment$e,distanceRGBA_vert:vertex$d,distanceRGBA_frag:fragment$d,equirect_vert:vertex$c,equirect_frag:fragment$c,linedashed_vert:vertex$b,linedashed_frag:fragment$b,meshbasic_vert:vertex$a,meshbasic_frag:fragment$a,meshlambert_vert:vertex$9,meshlambert_frag:fragment$9,meshmatcap_vert:vertex$8,meshmatcap_frag:fragment$8,meshnormal_vert:vertex$7,meshnormal_frag:fragment$7,meshphong_vert:vertex$6,meshphong_frag:fragment$6,meshphysical_vert:vertex$5,meshphysical_frag:fragment$5,meshtoon_vert:vertex$4,meshtoon_frag:fragment$4,points_vert:vertex$3,points_frag:fragment$3,shadow_vert:vertex$2,shadow_frag:fragment$2,sprite_vert:vertex$1,sprite_frag:fragment$1};// Uniforms library for shared webgl shaders
	const UniformsLib={common:{diffuse:{value:/*@__PURE__*/new Color(0xffffff)},opacity:{value:1.0},map:{value:null},mapTransform:{value:/*@__PURE__*/new Matrix3$1()},alphaMap:{value:null},alphaMapTransform:{value:/*@__PURE__*/new Matrix3$1()},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:/*@__PURE__*/new Matrix3$1()}},envmap:{envMap:{value:null},envMapRotation:{value:/*@__PURE__*/new Matrix3$1()},flipEnvMap:{value:-1},reflectivity:{value:1.0},// basic, lambert, phong
	ior:{value:1.5},// physical
	refractionRatio:{value:0.98},// basic, lambert, phong
	dfgLUT:{value:null}// DFG LUT for physically-based rendering
	},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:/*@__PURE__*/new Matrix3$1()}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:/*@__PURE__*/new Matrix3$1()}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:/*@__PURE__*/new Matrix3$1()},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:/*@__PURE__*/new Matrix3$1()},normalScale:{value:/*@__PURE__*/new Vector2$1(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:/*@__PURE__*/new Matrix3$1()},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:/*@__PURE__*/new Matrix3$1()}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:/*@__PURE__*/new Matrix3$1()}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:/*@__PURE__*/new Matrix3$1()}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:/*@__PURE__*/new Color(0xffffff)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
	rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:/*@__PURE__*/new Color(0xffffff)},opacity:{value:1.0},size:{value:1.0},scale:{value:1.0},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:/*@__PURE__*/new Matrix3$1()},alphaTest:{value:0},uvTransform:{value:/*@__PURE__*/new Matrix3$1()}},sprite:{diffuse:{value:/*@__PURE__*/new Color(0xffffff)},opacity:{value:1.0},center:{value:/*@__PURE__*/new Vector2$1(0.5,0.5)},rotation:{value:0.0},map:{value:null},mapTransform:{value:/*@__PURE__*/new Matrix3$1()},alphaMap:{value:null},alphaMapTransform:{value:/*@__PURE__*/new Matrix3$1()},alphaTest:{value:0}}};const ShaderLib={basic:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:/*@__PURE__*/new Color(0x000000)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:/*@__PURE__*/new Color(0x000000)},specular:{value:/*@__PURE__*/new Color(0x111111)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:/*@__PURE__*/new Color(0x000000)},roughness:{value:1.0},metalness:{value:0.0},envMapIntensity:{value:1}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:/*@__PURE__*/new Color(0x000000)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.meshnormal_vert,fragmentShader:ShaderChunk.meshnormal_frag},sprite:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:/*@__PURE__*/new Matrix3$1()},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:/*@__PURE__*/new Matrix3$1()}},vertexShader:ShaderChunk.backgroundCube_vert,fragmentShader:ShaderChunk.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1.0}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:/*@__PURE__*/new Vector3$1()},nearDistance:{value:1},farDistance:{value:1000}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:/*@__PURE__*/new Color(0x00000)},opacity:{value:1.0}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:/*@__PURE__*/mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:/*@__PURE__*/new Matrix3$1()},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:/*@__PURE__*/new Matrix3$1()},clearcoatNormalScale:{value:/*@__PURE__*/new Vector2$1(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:/*@__PURE__*/new Matrix3$1()},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:/*@__PURE__*/new Matrix3$1()},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:/*@__PURE__*/new Matrix3$1()},sheen:{value:0},sheenColor:{value:/*@__PURE__*/new Color(0x000000)},sheenColorMap:{value:null},sheenColorMapTransform:{value:/*@__PURE__*/new Matrix3$1()},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:/*@__PURE__*/new Matrix3$1()},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:/*@__PURE__*/new Matrix3$1()},transmissionSamplerSize:{value:/*@__PURE__*/new Vector2$1()},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:/*@__PURE__*/new Matrix3$1()},attenuationDistance:{value:0},attenuationColor:{value:/*@__PURE__*/new Color(0x000000)},specularColor:{value:/*@__PURE__*/new Color(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:/*@__PURE__*/new Matrix3$1()},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:/*@__PURE__*/new Matrix3$1()},anisotropyVector:{value:/*@__PURE__*/new Vector2$1()},anisotropyMap:{value:null},anisotropyMapTransform:{value:/*@__PURE__*/new Matrix3$1()}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};const _rgb={r:0,b:0,g:0};const _e1$1=/*@__PURE__*/new Euler$1();const _m1$1$1=/*@__PURE__*/new Matrix4$1();function WebGLBackground(renderer,cubemaps,cubeuvmaps,state,objects,alpha,premultipliedAlpha){const clearColor=new Color(0x000000);let clearAlpha=alpha===true?0:1;let planeMesh;let boxMesh;let currentBackground=null;let currentBackgroundVersion=0;let currentTonemapping=null;function getBackground(scene){let background=scene.isScene===true?scene.background:null;if(background&&background.isTexture){const usePMREM=scene.backgroundBlurriness>0;// use PMREM if the user wants to blur the background
	background=(usePMREM?cubeuvmaps:cubemaps).get(background);}return background;}function render(scene){let forceClear=false;const background=getBackground(scene);if(background===null){setClear(clearColor,clearAlpha);}else if(background&&background.isColor){setClear(background,1);forceClear=true;}const environmentBlendMode=renderer.xr.getEnvironmentBlendMode();if(environmentBlendMode==='additive'){state.buffers.color.setClear(0,0,0,1,premultipliedAlpha);}else if(environmentBlendMode==='alpha-blend'){state.buffers.color.setClear(0,0,0,0,premultipliedAlpha);}if(renderer.autoClear||forceClear){// buffers might not be writable which is required to ensure a correct clear
	state.buffers.depth.setTest(true);state.buffers.depth.setMask(true);state.buffers.color.setMask(true);renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil);}}function addToRenderList(renderList,scene){const background=getBackground(scene);if(background&&(background.isCubeTexture||background.mapping===CubeUVReflectionMapping)){if(boxMesh===undefined){boxMesh=new Mesh(new BoxGeometry$1(1,1,1),new ShaderMaterial({name:'BackgroundCubeMaterial',uniforms:cloneUniforms(ShaderLib.backgroundCube.uniforms),vertexShader:ShaderLib.backgroundCube.vertexShader,fragmentShader:ShaderLib.backgroundCube.fragmentShader,side:BackSide,depthTest:false,depthWrite:false,fog:false,allowOverride:false}));boxMesh.geometry.deleteAttribute('normal');boxMesh.geometry.deleteAttribute('uv');boxMesh.onBeforeRender=function(renderer,scene,camera){this.matrixWorld.copyPosition(camera.matrixWorld);};// add "envMap" material property so the renderer can evaluate it like for built-in materials
	Object.defineProperty(boxMesh.material,'envMap',{get:function(){return this.uniforms.envMap.value;}});objects.update(boxMesh);}_e1$1.copy(scene.backgroundRotation);// accommodate left-handed frame
	_e1$1.x*=-1;_e1$1.y*=-1;_e1$1.z*=-1;if(background.isCubeTexture&&background.isRenderTargetTexture===false){// environment maps which are not cube render targets or PMREMs follow a different convention
	_e1$1.y*=-1;_e1$1.z*=-1;}boxMesh.material.uniforms.envMap.value=background;boxMesh.material.uniforms.flipEnvMap.value=background.isCubeTexture&&background.isRenderTargetTexture===false?-1:1;boxMesh.material.uniforms.backgroundBlurriness.value=scene.backgroundBlurriness;boxMesh.material.uniforms.backgroundIntensity.value=scene.backgroundIntensity;boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1$1.makeRotationFromEuler(_e1$1));boxMesh.material.toneMapped=ColorManagement.getTransfer(background.colorSpace)!==SRGBTransfer;if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping){boxMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=background.version;currentTonemapping=renderer.toneMapping;}boxMesh.layers.enableAll();// push to the pre-sorted opaque render list
	renderList.unshift(boxMesh,boxMesh.geometry,boxMesh.material,0,0,null);}else if(background&&background.isTexture){if(planeMesh===undefined){planeMesh=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:'BackgroundMaterial',uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:false,depthWrite:false,fog:false,allowOverride:false}));planeMesh.geometry.deleteAttribute('normal');// add "map" material property so the renderer can evaluate it like for built-in materials
	Object.defineProperty(planeMesh.material,'map',{get:function(){return this.uniforms.t2D.value;}});objects.update(planeMesh);}planeMesh.material.uniforms.t2D.value=background;planeMesh.material.uniforms.backgroundIntensity.value=scene.backgroundIntensity;planeMesh.material.toneMapped=ColorManagement.getTransfer(background.colorSpace)!==SRGBTransfer;if(background.matrixAutoUpdate===true){background.updateMatrix();}planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping){planeMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=background.version;currentTonemapping=renderer.toneMapping;}planeMesh.layers.enableAll();// push to the pre-sorted opaque render list
	renderList.unshift(planeMesh,planeMesh.geometry,planeMesh.material,0,0,null);}}function setClear(color,alpha){color.getRGB(_rgb,getUnlitUniformColorSpace(renderer));state.buffers.color.setClear(_rgb.r,_rgb.g,_rgb.b,alpha,premultipliedAlpha);}function dispose(){if(boxMesh!==undefined){boxMesh.geometry.dispose();boxMesh.material.dispose();boxMesh=undefined;}if(planeMesh!==undefined){planeMesh.geometry.dispose();planeMesh.material.dispose();planeMesh=undefined;}}return {getClearColor:function(){return clearColor;},setClearColor:function(color,alpha=1){clearColor.set(color);clearAlpha=alpha;setClear(clearColor,clearAlpha);},getClearAlpha:function(){return clearAlpha;},setClearAlpha:function(alpha){clearAlpha=alpha;setClear(clearColor,clearAlpha);},render:render,addToRenderList:addToRenderList,dispose:dispose};}function WebGLBindingStates(gl,attributes){const maxVertexAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);const bindingStates={};const defaultState=createBindingState(null);let currentState=defaultState;let forceUpdate=false;function setup(object,material,program,geometry,index){let updateBuffers=false;const state=getBindingState(geometry,program,material);if(currentState!==state){currentState=state;bindVertexArrayObject(currentState.object);}updateBuffers=needsUpdate(object,geometry,program,index);if(updateBuffers)saveCache(object,geometry,program,index);if(index!==null){attributes.update(index,gl.ELEMENT_ARRAY_BUFFER);}if(updateBuffers||forceUpdate){forceUpdate=false;setupVertexAttributes(object,material,program,geometry);if(index!==null){gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,attributes.get(index).buffer);}}}function createVertexArrayObject(){return gl.createVertexArray();}function bindVertexArrayObject(vao){return gl.bindVertexArray(vao);}function deleteVertexArrayObject(vao){return gl.deleteVertexArray(vao);}function getBindingState(geometry,program,material){const wireframe=material.wireframe===true;let programMap=bindingStates[geometry.id];if(programMap===undefined){programMap={};bindingStates[geometry.id]=programMap;}let stateMap=programMap[program.id];if(stateMap===undefined){stateMap={};programMap[program.id]=stateMap;}let state=stateMap[wireframe];if(state===undefined){state=createBindingState(createVertexArrayObject());stateMap[wireframe]=state;}return state;}function createBindingState(vao){const newAttributes=[];const enabledAttributes=[];const attributeDivisors=[];for(let i=0;i<maxVertexAttributes;i++){newAttributes[i]=0;enabledAttributes[i]=0;attributeDivisors[i]=0;}return {// for backward compatibility on non-VAO support browser
	geometry:null,program:null,wireframe:false,newAttributes:newAttributes,enabledAttributes:enabledAttributes,attributeDivisors:attributeDivisors,object:vao,attributes:{},index:null};}function needsUpdate(object,geometry,program,index){const cachedAttributes=currentState.attributes;const geometryAttributes=geometry.attributes;let attributesNum=0;const programAttributes=program.getAttributes();for(const name in programAttributes){const programAttribute=programAttributes[name];if(programAttribute.location>=0){const cachedAttribute=cachedAttributes[name];let geometryAttribute=geometryAttributes[name];if(geometryAttribute===undefined){if(name==='instanceMatrix'&&object.instanceMatrix)geometryAttribute=object.instanceMatrix;if(name==='instanceColor'&&object.instanceColor)geometryAttribute=object.instanceColor;}if(cachedAttribute===undefined)return true;if(cachedAttribute.attribute!==geometryAttribute)return true;if(geometryAttribute&&cachedAttribute.data!==geometryAttribute.data)return true;attributesNum++;}}if(currentState.attributesNum!==attributesNum)return true;if(currentState.index!==index)return true;return false;}function saveCache(object,geometry,program,index){const cache={};const attributes=geometry.attributes;let attributesNum=0;const programAttributes=program.getAttributes();for(const name in programAttributes){const programAttribute=programAttributes[name];if(programAttribute.location>=0){let attribute=attributes[name];if(attribute===undefined){if(name==='instanceMatrix'&&object.instanceMatrix)attribute=object.instanceMatrix;if(name==='instanceColor'&&object.instanceColor)attribute=object.instanceColor;}const data={};data.attribute=attribute;if(attribute&&attribute.data){data.data=attribute.data;}cache[name]=data;attributesNum++;}}currentState.attributes=cache;currentState.attributesNum=attributesNum;currentState.index=index;}function initAttributes(){const newAttributes=currentState.newAttributes;for(let i=0,il=newAttributes.length;i<il;i++){newAttributes[i]=0;}}function enableAttribute(attribute){enableAttributeAndDivisor(attribute,0);}function enableAttributeAndDivisor(attribute,meshPerAttribute){const newAttributes=currentState.newAttributes;const enabledAttributes=currentState.enabledAttributes;const attributeDivisors=currentState.attributeDivisors;newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==meshPerAttribute){gl.vertexAttribDivisor(attribute,meshPerAttribute);attributeDivisors[attribute]=meshPerAttribute;}}function disableUnusedAttributes(){const newAttributes=currentState.newAttributes;const enabledAttributes=currentState.enabledAttributes;for(let i=0,il=enabledAttributes.length;i<il;i++){if(enabledAttributes[i]!==newAttributes[i]){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}}function vertexAttribPointer(index,size,type,normalized,stride,offset,integer){if(integer===true){gl.vertexAttribIPointer(index,size,type,stride,offset);}else {gl.vertexAttribPointer(index,size,type,normalized,stride,offset);}}function setupVertexAttributes(object,material,program,geometry){initAttributes();const geometryAttributes=geometry.attributes;const programAttributes=program.getAttributes();const materialDefaultAttributeValues=material.defaultAttributeValues;for(const name in programAttributes){const programAttribute=programAttributes[name];if(programAttribute.location>=0){let geometryAttribute=geometryAttributes[name];if(geometryAttribute===undefined){if(name==='instanceMatrix'&&object.instanceMatrix)geometryAttribute=object.instanceMatrix;if(name==='instanceColor'&&object.instanceColor)geometryAttribute=object.instanceColor;}if(geometryAttribute!==undefined){const normalized=geometryAttribute.normalized;const size=geometryAttribute.itemSize;const attribute=attributes.get(geometryAttribute);// TODO Attribute may not be available on context restore
	if(attribute===undefined)continue;const buffer=attribute.buffer;const type=attribute.type;const bytesPerElement=attribute.bytesPerElement;// check for integer attributes
	const integer=type===gl.INT||type===gl.UNSIGNED_INT||geometryAttribute.gpuType===IntType;if(geometryAttribute.isInterleavedBufferAttribute){const data=geometryAttribute.data;const stride=data.stride;const offset=geometryAttribute.offset;if(data.isInstancedInterleavedBuffer){for(let i=0;i<programAttribute.locationSize;i++){enableAttributeAndDivisor(programAttribute.location+i,data.meshPerAttribute);}if(object.isInstancedMesh!==true&&geometry._maxInstanceCount===undefined){geometry._maxInstanceCount=data.meshPerAttribute*data.count;}}else {for(let i=0;i<programAttribute.locationSize;i++){enableAttribute(programAttribute.location+i);}}gl.bindBuffer(gl.ARRAY_BUFFER,buffer);for(let i=0;i<programAttribute.locationSize;i++){vertexAttribPointer(programAttribute.location+i,size/programAttribute.locationSize,type,normalized,stride*bytesPerElement,(offset+size/programAttribute.locationSize*i)*bytesPerElement,integer);}}else {if(geometryAttribute.isInstancedBufferAttribute){for(let i=0;i<programAttribute.locationSize;i++){enableAttributeAndDivisor(programAttribute.location+i,geometryAttribute.meshPerAttribute);}if(object.isInstancedMesh!==true&&geometry._maxInstanceCount===undefined){geometry._maxInstanceCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;}}else {for(let i=0;i<programAttribute.locationSize;i++){enableAttribute(programAttribute.location+i);}}gl.bindBuffer(gl.ARRAY_BUFFER,buffer);for(let i=0;i<programAttribute.locationSize;i++){vertexAttribPointer(programAttribute.location+i,size/programAttribute.locationSize,type,normalized,size*bytesPerElement,size/programAttribute.locationSize*i*bytesPerElement,integer);}}}else if(materialDefaultAttributeValues!==undefined){const value=materialDefaultAttributeValues[name];if(value!==undefined){switch(value.length){case 2:gl.vertexAttrib2fv(programAttribute.location,value);break;case 3:gl.vertexAttrib3fv(programAttribute.location,value);break;case 4:gl.vertexAttrib4fv(programAttribute.location,value);break;default:gl.vertexAttrib1fv(programAttribute.location,value);}}}}}disableUnusedAttributes();}function dispose(){reset();for(const geometryId in bindingStates){const programMap=bindingStates[geometryId];for(const programId in programMap){const stateMap=programMap[programId];for(const wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[programId];}delete bindingStates[geometryId];}}function releaseStatesOfGeometry(geometry){if(bindingStates[geometry.id]===undefined)return;const programMap=bindingStates[geometry.id];for(const programId in programMap){const stateMap=programMap[programId];for(const wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[programId];}delete bindingStates[geometry.id];}function releaseStatesOfProgram(program){for(const geometryId in bindingStates){const programMap=bindingStates[geometryId];if(programMap[program.id]===undefined)continue;const stateMap=programMap[program.id];for(const wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[program.id];}}function reset(){resetDefaultState();forceUpdate=true;if(currentState===defaultState)return;currentState=defaultState;bindVertexArrayObject(currentState.object);}// for backward-compatibility
	function resetDefaultState(){defaultState.geometry=null;defaultState.program=null;defaultState.wireframe=false;}return {setup:setup,reset:reset,resetDefaultState:resetDefaultState,dispose:dispose,releaseStatesOfGeometry:releaseStatesOfGeometry,releaseStatesOfProgram:releaseStatesOfProgram,initAttributes:initAttributes,enableAttribute:enableAttribute,disableUnusedAttributes:disableUnusedAttributes};}function WebGLBufferRenderer(gl,extensions,info){let mode;function setMode(value){mode=value;}function render(start,count){gl.drawArrays(mode,start,count);info.update(count,mode,1);}function renderInstances(start,count,primcount){if(primcount===0)return;gl.drawArraysInstanced(mode,start,count,primcount);info.update(count,mode,primcount);}function renderMultiDraw(starts,counts,drawCount){if(drawCount===0)return;const extension=extensions.get('WEBGL_multi_draw');extension.multiDrawArraysWEBGL(mode,starts,0,counts,0,drawCount);let elementCount=0;for(let i=0;i<drawCount;i++){elementCount+=counts[i];}info.update(elementCount,mode,1);}function renderMultiDrawInstances(starts,counts,drawCount,primcount){if(drawCount===0)return;const extension=extensions.get('WEBGL_multi_draw');if(extension===null){for(let i=0;i<starts.length;i++){renderInstances(starts[i],counts[i],primcount[i]);}}else {extension.multiDrawArraysInstancedWEBGL(mode,starts,0,counts,0,primcount,0,drawCount);let elementCount=0;for(let i=0;i<drawCount;i++){elementCount+=counts[i]*primcount[i];}info.update(elementCount,mode,1);}}//
	this.setMode=setMode;this.render=render;this.renderInstances=renderInstances;this.renderMultiDraw=renderMultiDraw;this.renderMultiDrawInstances=renderMultiDrawInstances;}function WebGLCapabilities(gl,extensions,parameters,utils){let maxAnisotropy;function getMaxAnisotropy(){if(maxAnisotropy!==undefined)return maxAnisotropy;if(extensions.has('EXT_texture_filter_anisotropic')===true){const extension=extensions.get('EXT_texture_filter_anisotropic');maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);}else {maxAnisotropy=0;}return maxAnisotropy;}function textureFormatReadable(textureFormat){if(textureFormat!==RGBAFormat&&utils.convert(textureFormat)!==gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)){return false;}return true;}function textureTypeReadable(textureType){const halfFloatSupportedByExt=textureType===HalfFloatType&&(extensions.has('EXT_color_buffer_half_float')||extensions.has('EXT_color_buffer_float'));if(textureType!==UnsignedByteType&&utils.convert(textureType)!==gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE)&&// Edge and Chrome Mac < 52 (#9513)
	textureType!==FloatType$1&&!halfFloatSupportedByExt){return false;}return true;}function getMaxPrecision(precision){if(precision==='highp'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.HIGH_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision>0){return 'highp';}precision='mediump';}if(precision==='mediump'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.MEDIUM_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT).precision>0){return 'mediump';}}return 'lowp';}let precision=parameters.precision!==undefined?parameters.precision:'highp';const maxPrecision=getMaxPrecision(precision);if(maxPrecision!==precision){warn$1('WebGLRenderer:',precision,'not supported, using',maxPrecision,'instead.');precision=maxPrecision;}const logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true;const reversedDepthBuffer=parameters.reversedDepthBuffer===true&&extensions.has('EXT_clip_control');const maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);const maxVertexTextures=gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);const maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE);const maxCubemapSize=gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);const maxAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);const maxVertexUniforms=gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);const maxVaryings=gl.getParameter(gl.MAX_VARYING_VECTORS);const maxFragmentUniforms=gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);const vertexTextures=maxVertexTextures>0;const maxSamples=gl.getParameter(gl.MAX_SAMPLES);return {isWebGL2:true,// keeping this for backwards compatibility
	getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,textureFormatReadable:textureFormatReadable,textureTypeReadable:textureTypeReadable,precision:precision,logarithmicDepthBuffer:logarithmicDepthBuffer,reversedDepthBuffer:reversedDepthBuffer,maxTextures:maxTextures,maxVertexTextures:maxVertexTextures,maxTextureSize:maxTextureSize,maxCubemapSize:maxCubemapSize,maxAttributes:maxAttributes,maxVertexUniforms:maxVertexUniforms,maxVaryings:maxVaryings,maxFragmentUniforms:maxFragmentUniforms,vertexTextures:vertexTextures,maxSamples:maxSamples};}function WebGLClipping(properties){const scope=this;let globalState=null,numGlobalPlanes=0,localClippingEnabled=false,renderingShadows=false;const plane=new Plane(),viewNormalMatrix=new Matrix3$1(),uniform={value:null,needsUpdate:false};this.uniform=uniform;this.numPlanes=0;this.numIntersection=0;this.init=function(planes,enableLocalClipping){const enabled=planes.length!==0||enableLocalClipping||// enable state of previous frame - the clipping code has to
	// run another frame in order to reset the state:
	numGlobalPlanes!==0||localClippingEnabled;localClippingEnabled=enableLocalClipping;numGlobalPlanes=planes.length;return enabled;};this.beginShadows=function(){renderingShadows=true;projectPlanes(null);};this.endShadows=function(){renderingShadows=false;};this.setGlobalState=function(planes,camera){globalState=projectPlanes(planes,camera,0);};this.setState=function(material,camera,useCache){const planes=material.clippingPlanes,clipIntersection=material.clipIntersection,clipShadows=material.clipShadows;const materialProperties=properties.get(material);if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows){// there's no local clipping
	if(renderingShadows){// there's no global clipping
	projectPlanes(null);}else {resetGlobalState();}}else {const nGlobal=renderingShadows?0:numGlobalPlanes,lGlobal=nGlobal*4;let dstArray=materialProperties.clippingState||null;uniform.value=dstArray;// ensure unique state
	dstArray=projectPlanes(planes,camera,lGlobal,useCache);for(let i=0;i!==lGlobal;++i){dstArray[i]=globalState[i];}materialProperties.clippingState=dstArray;this.numIntersection=clipIntersection?this.numPlanes:0;this.numPlanes+=nGlobal;}};function resetGlobalState(){if(uniform.value!==globalState){uniform.value=globalState;uniform.needsUpdate=numGlobalPlanes>0;}scope.numPlanes=numGlobalPlanes;scope.numIntersection=0;}function projectPlanes(planes,camera,dstOffset,skipTransform){const nPlanes=planes!==null?planes.length:0;let dstArray=null;if(nPlanes!==0){dstArray=uniform.value;if(skipTransform!==true||dstArray===null){const flatSize=dstOffset+nPlanes*4,viewMatrix=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(viewMatrix);if(dstArray===null||dstArray.length<flatSize){dstArray=new Float32Array(flatSize);}for(let i=0,i4=dstOffset;i!==nPlanes;++i,i4+=4){plane.copy(planes[i]).applyMatrix4(viewMatrix,viewNormalMatrix);plane.normal.toArray(dstArray,i4);dstArray[i4+3]=plane.constant;}}uniform.value=dstArray;uniform.needsUpdate=true;}scope.numPlanes=nPlanes;scope.numIntersection=0;return dstArray;}}function WebGLCubeMaps(renderer){let cubemaps=new WeakMap();function mapTextureMapping(texture,mapping){if(mapping===EquirectangularReflectionMapping){texture.mapping=CubeReflectionMapping;}else if(mapping===EquirectangularRefractionMapping){texture.mapping=CubeRefractionMapping;}return texture;}function get(texture){if(texture&&texture.isTexture){const mapping=texture.mapping;if(mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping){if(cubemaps.has(texture)){const cubemap=cubemaps.get(texture).texture;return mapTextureMapping(cubemap,texture.mapping);}else {const image=texture.image;if(image&&image.height>0){const renderTarget=new WebGLCubeRenderTarget(image.height);renderTarget.fromEquirectangularTexture(renderer,texture);cubemaps.set(texture,renderTarget);texture.addEventListener('dispose',onTextureDispose);return mapTextureMapping(renderTarget.texture,texture.mapping);}else {// image not yet ready. try the conversion next frame
	return null;}}}}return texture;}function onTextureDispose(event){const texture=event.target;texture.removeEventListener('dispose',onTextureDispose);const cubemap=cubemaps.get(texture);if(cubemap!==undefined){cubemaps.delete(texture);cubemap.dispose();}}function dispose(){cubemaps=new WeakMap();}return {get:get,dispose:dispose};}const LOD_MIN=4;// The standard deviations (radians) associated with the extra mips.
	// Used for scene blur in fromScene() method.
	const EXTRA_LOD_SIGMA=[0.125,0.215,0.35,0.446,0.526,0.582];// The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.
	// Used for scene blur in fromScene() method.
	const MAX_SAMPLES=20;// GGX VNDF importance sampling configuration
	const GGX_SAMPLES=512;const _flatCamera=/*@__PURE__*/new OrthographicCamera();const _clearColor=/*@__PURE__*/new Color();let _oldTarget=null;let _oldActiveCubeFace=0;let _oldActiveMipmapLevel=0;let _oldXrEnabled=false;const _origin=/*@__PURE__*/new Vector3$1();/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * The prefiltering uses GGX VNDF (Visible Normal Distribution Function)
	 * importance sampling based on "Sampling the GGX Distribution of Visible Normals"
	 * (Heitz, 2018) to generate environment maps that accurately match the GGX BRDF
	 * used in material rendering for physically-based image-based lighting.
	 */class PMREMGenerator{/**
		 * Constructs a new PMREM generator.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 */constructor(renderer){this._renderer=renderer;this._pingPongRenderTarget=null;this._lodMax=0;this._cubeSize=0;this._sizeLods=[];this._sigmas=[];this._lodMeshes=[];this._backgroundBox=null;this._cubemapMaterial=null;this._equirectMaterial=null;this._blurMaterial=null;this._ggxMaterial=null;}/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety.
		 *
		 * @param {Scene} scene - The scene to be captured.
		 * @param {number} [sigma=0] - The blur radius in radians.
		 * @param {number} [near=0.1] - The near plane distance.
		 * @param {number} [far=100] - The far plane distance.
		 * @param {Object} [options={}] - The configuration options.
		 * @param {number} [options.size=256] - The texture size of the PMREM.
		 * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
		 * @return {WebGLRenderTarget} The resulting PMREM.
		 */fromScene(scene,sigma=0,near=0.1,far=100,options={}){const{size=256,position=_origin}=options;_oldTarget=this._renderer.getRenderTarget();_oldActiveCubeFace=this._renderer.getActiveCubeFace();_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel();_oldXrEnabled=this._renderer.xr.enabled;this._renderer.xr.enabled=false;this._setSize(size);const cubeUVRenderTarget=this._allocateTargets();cubeUVRenderTarget.depthBuffer=true;this._sceneToCubeUV(scene,near,far,cubeUVRenderTarget,position);if(sigma>0){this._blur(cubeUVRenderTarget,0,0,sigma);}this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;}/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * or HDR. The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 *
		 * @param {Texture} equirectangular - The equirectangular texture to be converted.
		 * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
		 * @return {WebGLRenderTarget} The resulting PMREM.
		 */fromEquirectangular(equirectangular,renderTarget=null){return this._fromTexture(equirectangular,renderTarget);}/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * or HDR. The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 *
		 * @param {Texture} cubemap - The cubemap texture to be converted.
		 * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
		 * @return {WebGLRenderTarget} The resulting PMREM.
		 */fromCubemap(cubemap,renderTarget=null){return this._fromTexture(cubemap,renderTarget);}/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */compileCubemapShader(){if(this._cubemapMaterial===null){this._cubemapMaterial=_getCubemapMaterial();this._compileMaterial(this._cubemapMaterial);}}/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */compileEquirectangularShader(){if(this._equirectMaterial===null){this._equirectMaterial=_getEquirectMaterial();this._compileMaterial(this._equirectMaterial);}}/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */dispose(){this._dispose();if(this._cubemapMaterial!==null)this._cubemapMaterial.dispose();if(this._equirectMaterial!==null)this._equirectMaterial.dispose();if(this._backgroundBox!==null){this._backgroundBox.geometry.dispose();this._backgroundBox.material.dispose();}}// private interface
	_setSize(cubeSize){this._lodMax=Math.floor(Math.log2(cubeSize));this._cubeSize=Math.pow(2,this._lodMax);}_dispose(){if(this._blurMaterial!==null)this._blurMaterial.dispose();if(this._ggxMaterial!==null)this._ggxMaterial.dispose();if(this._pingPongRenderTarget!==null)this._pingPongRenderTarget.dispose();for(let i=0;i<this._lodMeshes.length;i++){this._lodMeshes[i].geometry.dispose();}}_cleanup(outputTarget){this._renderer.setRenderTarget(_oldTarget,_oldActiveCubeFace,_oldActiveMipmapLevel);this._renderer.xr.enabled=_oldXrEnabled;outputTarget.scissorTest=false;_setViewport(outputTarget,0,0,outputTarget.width,outputTarget.height);}_fromTexture(texture,renderTarget){if(texture.mapping===CubeReflectionMapping||texture.mapping===CubeRefractionMapping){this._setSize(texture.image.length===0?16:texture.image[0].width||texture.image[0].image.width);}else {// Equirectangular
	this._setSize(texture.image.width/4);}_oldTarget=this._renderer.getRenderTarget();_oldActiveCubeFace=this._renderer.getActiveCubeFace();_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel();_oldXrEnabled=this._renderer.xr.enabled;this._renderer.xr.enabled=false;const cubeUVRenderTarget=renderTarget||this._allocateTargets();this._textureToCubeUV(texture,cubeUVRenderTarget);this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;}_allocateTargets(){const width=3*Math.max(this._cubeSize,16*7);const height=4*this._cubeSize;const params={magFilter:LinearFilter,minFilter:LinearFilter,generateMipmaps:false,type:HalfFloatType,format:RGBAFormat,colorSpace:LinearSRGBColorSpace,depthBuffer:false};const cubeUVRenderTarget=_createRenderTarget(width,height,params);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==width||this._pingPongRenderTarget.height!==height){if(this._pingPongRenderTarget!==null){this._dispose();}this._pingPongRenderTarget=_createRenderTarget(width,height,params);const{_lodMax}=this;({lodMeshes:this._lodMeshes,sizeLods:this._sizeLods,sigmas:this._sigmas}=_createPlanes(_lodMax));this._blurMaterial=_getBlurShader(_lodMax,width,height);}return cubeUVRenderTarget;}_compileMaterial(material){const mesh=new Mesh(new BufferGeometry$1(),material);this._renderer.compile(mesh,_flatCamera);}_sceneToCubeUV(scene,near,far,cubeUVRenderTarget,position){const fov=90;const aspect=1;const cubeCamera=new PerspectiveCamera(fov,aspect,near,far);const upSign=[1,-1,1,1,1,1];const forwardSign=[1,1,1,-1,-1,-1];const renderer=this._renderer;const originalAutoClear=renderer.autoClear;const toneMapping=renderer.toneMapping;renderer.getClearColor(_clearColor);renderer.toneMapping=NoToneMapping;renderer.autoClear=false;// https://github.com/mrdoob/three.js/issues/31413#issuecomment-3095966812
	const reversedDepthBuffer=renderer.state.buffers.depth.getReversed();if(reversedDepthBuffer){renderer.setRenderTarget(cubeUVRenderTarget);renderer.clearDepth();renderer.setRenderTarget(null);}if(this._backgroundBox===null){this._backgroundBox=new Mesh(new BoxGeometry$1(),new MeshBasicMaterial({name:'PMREM.Background',side:BackSide,depthWrite:false,depthTest:false}));}const backgroundBox=this._backgroundBox;const backgroundMaterial=backgroundBox.material;let useSolidColor=false;const background=scene.background;if(background){if(background.isColor){backgroundMaterial.color.copy(background);scene.background=null;useSolidColor=true;}}else {backgroundMaterial.color.copy(_clearColor);useSolidColor=true;}for(let i=0;i<6;i++){const col=i%3;if(col===0){cubeCamera.up.set(0,upSign[i],0);cubeCamera.position.set(position.x,position.y,position.z);cubeCamera.lookAt(position.x+forwardSign[i],position.y,position.z);}else if(col===1){cubeCamera.up.set(0,0,upSign[i]);cubeCamera.position.set(position.x,position.y,position.z);cubeCamera.lookAt(position.x,position.y+forwardSign[i],position.z);}else {cubeCamera.up.set(0,upSign[i],0);cubeCamera.position.set(position.x,position.y,position.z);cubeCamera.lookAt(position.x,position.y,position.z+forwardSign[i]);}const size=this._cubeSize;_setViewport(cubeUVRenderTarget,col*size,i>2?size:0,size,size);renderer.setRenderTarget(cubeUVRenderTarget);if(useSolidColor){renderer.render(backgroundBox,cubeCamera);}renderer.render(scene,cubeCamera);}renderer.toneMapping=toneMapping;renderer.autoClear=originalAutoClear;scene.background=background;}_textureToCubeUV(texture,cubeUVRenderTarget){const renderer=this._renderer;const isCubeTexture=texture.mapping===CubeReflectionMapping||texture.mapping===CubeRefractionMapping;if(isCubeTexture){if(this._cubemapMaterial===null){this._cubemapMaterial=_getCubemapMaterial();}this._cubemapMaterial.uniforms.flipEnvMap.value=texture.isRenderTargetTexture===false?-1:1;}else {if(this._equirectMaterial===null){this._equirectMaterial=_getEquirectMaterial();}}const material=isCubeTexture?this._cubemapMaterial:this._equirectMaterial;const mesh=this._lodMeshes[0];mesh.material=material;const uniforms=material.uniforms;uniforms['envMap'].value=texture;const size=this._cubeSize;_setViewport(cubeUVRenderTarget,0,0,3*size,2*size);renderer.setRenderTarget(cubeUVRenderTarget);renderer.render(mesh,_flatCamera);}_applyPMREM(cubeUVRenderTarget){const renderer=this._renderer;const autoClear=renderer.autoClear;renderer.autoClear=false;const n=this._lodMeshes.length;// Use GGX VNDF importance sampling
	for(let i=1;i<n;i++){this._applyGGXFilter(cubeUVRenderTarget,i-1,i);}renderer.autoClear=autoClear;}/**
		 * Applies GGX VNDF importance sampling filter to generate a prefiltered environment map.
		 * Uses Monte Carlo integration with VNDF importance sampling to accurately represent the
		 * GGX BRDF for physically-based rendering. Reads from the previous LOD level and
		 * applies incremental roughness filtering to avoid over-blurring.
		 *
		 * @private
		 * @param {WebGLRenderTarget} cubeUVRenderTarget
		 * @param {number} lodIn - Source LOD level to read from
		 * @param {number} lodOut - Target LOD level to write to
		 */_applyGGXFilter(cubeUVRenderTarget,lodIn,lodOut){const renderer=this._renderer;const pingPongRenderTarget=this._pingPongRenderTarget;if(this._ggxMaterial===null){const width=3*Math.max(this._cubeSize,16);const height=4*this._cubeSize;this._ggxMaterial=_getGGXShader(this._lodMax,width,height);}const ggxMaterial=this._ggxMaterial;const ggxMesh=this._lodMeshes[lodOut];ggxMesh.material=ggxMaterial;const ggxUniforms=ggxMaterial.uniforms;// Calculate incremental roughness between LOD levels
	const targetRoughness=lodOut/(this._lodMeshes.length-1);const sourceRoughness=lodIn/(this._lodMeshes.length-1);const incrementalRoughness=Math.sqrt(targetRoughness*targetRoughness-sourceRoughness*sourceRoughness);// Apply blur strength mapping for better quality across the roughness range
	const blurStrength=0.05+targetRoughness*0.95;const adjustedRoughness=incrementalRoughness*blurStrength;// Calculate viewport position based on output LOD level
	const{_lodMax}=this;const outputSize=this._sizeLods[lodOut];const x=3*outputSize*(lodOut>_lodMax-LOD_MIN?lodOut-_lodMax+LOD_MIN:0);const y=4*(this._cubeSize-outputSize);// Read from previous LOD with incremental roughness
	ggxUniforms['envMap'].value=cubeUVRenderTarget.texture;ggxUniforms['roughness'].value=adjustedRoughness;ggxUniforms['mipInt'].value=_lodMax-lodIn;// Sample from input LOD
	_setViewport(pingPongRenderTarget,x,y,3*outputSize,2*outputSize);renderer.setRenderTarget(pingPongRenderTarget);renderer.render(ggxMesh,_flatCamera);// Copy from pingPong back to cubeUV (simple direct copy)
	ggxUniforms['envMap'].value=pingPongRenderTarget.texture;ggxUniforms['roughness'].value=0.0;// Direct copy
	ggxUniforms['mipInt'].value=_lodMax-lodOut;// Read from the level we just wrote
	_setViewport(cubeUVRenderTarget,x,y,3*outputSize,2*outputSize);renderer.setRenderTarget(cubeUVRenderTarget);renderer.render(ggxMesh,_flatCamera);}/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 *
		 * Used for initial scene blur in fromScene() method when sigma > 0.
		 *
		 * @private
		 * @param {WebGLRenderTarget} cubeUVRenderTarget
		 * @param {number} lodIn
		 * @param {number} lodOut
		 * @param {number} sigma
		 * @param {Vector3} [poleAxis]
		 */_blur(cubeUVRenderTarget,lodIn,lodOut,sigma,poleAxis){const pingPongRenderTarget=this._pingPongRenderTarget;this._halfBlur(cubeUVRenderTarget,pingPongRenderTarget,lodIn,lodOut,sigma,'latitudinal',poleAxis);this._halfBlur(pingPongRenderTarget,cubeUVRenderTarget,lodOut,lodOut,sigma,'longitudinal',poleAxis);}_halfBlur(targetIn,targetOut,lodIn,lodOut,sigmaRadians,direction,poleAxis){const renderer=this._renderer;const blurMaterial=this._blurMaterial;if(direction!=='latitudinal'&&direction!=='longitudinal'){error$1('blur direction must be either latitudinal or longitudinal!');}// Number of standard deviations at which to cut off the discrete approximation.
	const STANDARD_DEVIATIONS=3;const blurMesh=this._lodMeshes[lodOut];blurMesh.material=blurMaterial;const blurUniforms=blurMaterial.uniforms;const pixels=this._sizeLods[lodIn]-1;const radiansPerPixel=isFinite(sigmaRadians)?Math.PI/(2*pixels):2*Math.PI/(2*MAX_SAMPLES-1);const sigmaPixels=sigmaRadians/radiansPerPixel;const samples=isFinite(sigmaRadians)?1+Math.floor(STANDARD_DEVIATIONS*sigmaPixels):MAX_SAMPLES;if(samples>MAX_SAMPLES){warn$1(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);}const weights=[];let sum=0;for(let i=0;i<MAX_SAMPLES;++i){const x=i/sigmaPixels;const weight=Math.exp(-x*x/2);weights.push(weight);if(i===0){sum+=weight;}else if(i<samples){sum+=2*weight;}}for(let i=0;i<weights.length;i++){weights[i]=weights[i]/sum;}blurUniforms['envMap'].value=targetIn.texture;blurUniforms['samples'].value=samples;blurUniforms['weights'].value=weights;blurUniforms['latitudinal'].value=direction==='latitudinal';if(poleAxis){blurUniforms['poleAxis'].value=poleAxis;}const{_lodMax}=this;blurUniforms['dTheta'].value=radiansPerPixel;blurUniforms['mipInt'].value=_lodMax-lodIn;const outputSize=this._sizeLods[lodOut];const x=3*outputSize*(lodOut>_lodMax-LOD_MIN?lodOut-_lodMax+LOD_MIN:0);const y=4*(this._cubeSize-outputSize);_setViewport(targetOut,x,y,3*outputSize,2*outputSize);renderer.setRenderTarget(targetOut);renderer.render(blurMesh,_flatCamera);}}function _createPlanes(lodMax){const sizeLods=[];const sigmas=[];const lodMeshes=[];let lod=lodMax;const totalLods=lodMax-LOD_MIN+1+EXTRA_LOD_SIGMA.length;for(let i=0;i<totalLods;i++){const sizeLod=Math.pow(2,lod);sizeLods.push(sizeLod);let sigma=1.0/sizeLod;if(i>lodMax-LOD_MIN){sigma=EXTRA_LOD_SIGMA[i-lodMax+LOD_MIN-1];}else if(i===0){sigma=0;}sigmas.push(sigma);const texelSize=1.0/(sizeLod-2);const min=-texelSize;const max=1+texelSize;const uv1=[min,min,max,min,max,max,min,min,max,max,min,max];const cubeFaces=6;const vertices=6;const positionSize=3;const uvSize=2;const faceIndexSize=1;const position=new Float32Array(positionSize*vertices*cubeFaces);const uv=new Float32Array(uvSize*vertices*cubeFaces);const faceIndex=new Float32Array(faceIndexSize*vertices*cubeFaces);for(let face=0;face<cubeFaces;face++){const x=face%3*2/3-1;const y=face>2?0:-1;const coordinates=[x,y,0,x+2/3,y,0,x+2/3,y+1,0,x,y,0,x+2/3,y+1,0,x,y+1,0];position.set(coordinates,positionSize*vertices*face);uv.set(uv1,uvSize*vertices*face);const fill=[face,face,face,face,face,face];faceIndex.set(fill,faceIndexSize*vertices*face);}const planes=new BufferGeometry$1();planes.setAttribute('position',new BufferAttribute$1(position,positionSize));planes.setAttribute('uv',new BufferAttribute$1(uv,uvSize));planes.setAttribute('faceIndex',new BufferAttribute$1(faceIndex,faceIndexSize));lodMeshes.push(new Mesh(planes,null));if(lod>LOD_MIN){lod--;}}return {lodMeshes,sizeLods,sigmas};}function _createRenderTarget(width,height,params){const cubeUVRenderTarget=new WebGLRenderTarget(width,height,params);cubeUVRenderTarget.texture.mapping=CubeUVReflectionMapping;cubeUVRenderTarget.texture.name='PMREM.cubeUv';cubeUVRenderTarget.scissorTest=true;return cubeUVRenderTarget;}function _setViewport(target,x,y,width,height){target.viewport.set(x,y,width,height);target.scissor.set(x,y,width,height);}function _getGGXShader(lodMax,width,height){const shaderMaterial=new ShaderMaterial({name:'PMREMGGXConvolution',defines:{'GGX_SAMPLES':GGX_SAMPLES,'CUBEUV_TEXEL_WIDTH':1.0/width,'CUBEUV_TEXEL_HEIGHT':1.0/height,'CUBEUV_MAX_MIP':`${lodMax}.0`},uniforms:{'envMap':{value:null},'roughness':{value:0.0},'mipInt':{value:0}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 3.2: Transform view direction to hemisphere configuration
				vec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));

				// Section 4.1: Orthonormal basis
				float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
				vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(Vh, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + Vh.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`,blending:NoBlending,depthTest:false,depthWrite:false});return shaderMaterial;}function _getBlurShader(lodMax,width,height){const weights=new Float32Array(MAX_SAMPLES);const poleAxis=new Vector3$1(0,1,0);const shaderMaterial=new ShaderMaterial({name:'SphericalGaussianBlur',defines:{'n':MAX_SAMPLES,'CUBEUV_TEXEL_WIDTH':1.0/width,'CUBEUV_TEXEL_HEIGHT':1.0/height,'CUBEUV_MAX_MIP':`${lodMax}.0`},uniforms:{'envMap':{value:null},'samples':{value:1},'weights':{value:weights},'latitudinal':{value:false},'dTheta':{value:0},'mipInt':{value:0},'poleAxis':{value:poleAxis}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:NoBlending,depthTest:false,depthWrite:false});return shaderMaterial;}function _getEquirectMaterial(){return new ShaderMaterial({name:'EquirectangularToCubeUV',uniforms:{'envMap':{value:null}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:NoBlending,depthTest:false,depthWrite:false});}function _getCubemapMaterial(){return new ShaderMaterial({name:'CubemapToCubeUV',uniforms:{'envMap':{value:null},'flipEnvMap':{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:NoBlending,depthTest:false,depthWrite:false});}function _getCommonVertexShader(){return/* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;}function WebGLCubeUVMaps(renderer){let cubeUVmaps=new WeakMap();let pmremGenerator=null;function get(texture){if(texture&&texture.isTexture){const mapping=texture.mapping;const isEquirectMap=mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping;const isCubeMap=mapping===CubeReflectionMapping||mapping===CubeRefractionMapping;// equirect/cube map to cubeUV conversion
	if(isEquirectMap||isCubeMap){let renderTarget=cubeUVmaps.get(texture);const currentPMREMVersion=renderTarget!==undefined?renderTarget.texture.pmremVersion:0;if(texture.isRenderTargetTexture&&texture.pmremVersion!==currentPMREMVersion){if(pmremGenerator===null)pmremGenerator=new PMREMGenerator(renderer);renderTarget=isEquirectMap?pmremGenerator.fromEquirectangular(texture,renderTarget):pmremGenerator.fromCubemap(texture,renderTarget);renderTarget.texture.pmremVersion=texture.pmremVersion;cubeUVmaps.set(texture,renderTarget);return renderTarget.texture;}else {if(renderTarget!==undefined){return renderTarget.texture;}else {const image=texture.image;if(isEquirectMap&&image&&image.height>0||isCubeMap&&image&&isCubeTextureComplete(image)){if(pmremGenerator===null)pmremGenerator=new PMREMGenerator(renderer);renderTarget=isEquirectMap?pmremGenerator.fromEquirectangular(texture):pmremGenerator.fromCubemap(texture);renderTarget.texture.pmremVersion=texture.pmremVersion;cubeUVmaps.set(texture,renderTarget);texture.addEventListener('dispose',onTextureDispose);return renderTarget.texture;}else {// image not yet ready. try the conversion next frame
	return null;}}}}}return texture;}function isCubeTextureComplete(image){let count=0;const length=6;for(let i=0;i<length;i++){if(image[i]!==undefined)count++;}return count===length;}function onTextureDispose(event){const texture=event.target;texture.removeEventListener('dispose',onTextureDispose);const cubemapUV=cubeUVmaps.get(texture);if(cubemapUV!==undefined){cubeUVmaps.delete(texture);cubemapUV.dispose();}}function dispose(){cubeUVmaps=new WeakMap();if(pmremGenerator!==null){pmremGenerator.dispose();pmremGenerator=null;}}return {get:get,dispose:dispose};}function WebGLExtensions(gl){const extensions={};function getExtension(name){if(extensions[name]!==undefined){return extensions[name];}const extension=gl.getExtension(name);extensions[name]=extension;return extension;}return {has:function(name){return getExtension(name)!==null;},init:function(){getExtension('EXT_color_buffer_float');getExtension('WEBGL_clip_cull_distance');getExtension('OES_texture_float_linear');getExtension('EXT_color_buffer_half_float');getExtension('WEBGL_multisampled_render_to_texture');getExtension('WEBGL_render_shared_exponent');},get:function(name){const extension=getExtension(name);if(extension===null){warnOnce('WebGLRenderer: '+name+' extension not supported.');}return extension;}};}function WebGLGeometries(gl,attributes,info,bindingStates){const geometries={};const wireframeAttributes=new WeakMap();function onGeometryDispose(event){const geometry=event.target;if(geometry.index!==null){attributes.remove(geometry.index);}for(const name in geometry.attributes){attributes.remove(geometry.attributes[name]);}geometry.removeEventListener('dispose',onGeometryDispose);delete geometries[geometry.id];const attribute=wireframeAttributes.get(geometry);if(attribute){attributes.remove(attribute);wireframeAttributes.delete(geometry);}bindingStates.releaseStatesOfGeometry(geometry);if(geometry.isInstancedBufferGeometry===true){delete geometry._maxInstanceCount;}//
	info.memory.geometries--;}function get(object,geometry){if(geometries[geometry.id]===true)return geometry;geometry.addEventListener('dispose',onGeometryDispose);geometries[geometry.id]=true;info.memory.geometries++;return geometry;}function update(geometry){const geometryAttributes=geometry.attributes;// Updating index buffer in VAO now. See WebGLBindingStates.
	for(const name in geometryAttributes){attributes.update(geometryAttributes[name],gl.ARRAY_BUFFER);}}function updateWireframeAttribute(geometry){const indices=[];const geometryIndex=geometry.index;const geometryPosition=geometry.attributes.position;let version=0;if(geometryIndex!==null){const array=geometryIndex.array;version=geometryIndex.version;for(let i=0,l=array.length;i<l;i+=3){const a=array[i+0];const b=array[i+1];const c=array[i+2];indices.push(a,b,b,c,c,a);}}else if(geometryPosition!==undefined){const array=geometryPosition.array;version=geometryPosition.version;for(let i=0,l=array.length/3-1;i<l;i+=3){const a=i+0;const b=i+1;const c=i+2;indices.push(a,b,b,c,c,a);}}else {return;}const attribute=new(arrayNeedsUint32$1(indices)?Uint32BufferAttribute$1:Uint16BufferAttribute$1)(indices,1);attribute.version=version;// Updating index buffer in VAO now. See WebGLBindingStates
	//
	const previousAttribute=wireframeAttributes.get(geometry);if(previousAttribute)attributes.remove(previousAttribute);//
	wireframeAttributes.set(geometry,attribute);}function getWireframeAttribute(geometry){const currentAttribute=wireframeAttributes.get(geometry);if(currentAttribute){const geometryIndex=geometry.index;if(geometryIndex!==null){// if the attribute is obsolete, create a new one
	if(currentAttribute.version<geometryIndex.version){updateWireframeAttribute(geometry);}}}else {updateWireframeAttribute(geometry);}return wireframeAttributes.get(geometry);}return {get:get,update:update,getWireframeAttribute:getWireframeAttribute};}function WebGLIndexedBufferRenderer(gl,extensions,info){let mode;function setMode(value){mode=value;}let type,bytesPerElement;function setIndex(value){type=value.type;bytesPerElement=value.bytesPerElement;}function render(start,count){gl.drawElements(mode,count,type,start*bytesPerElement);info.update(count,mode,1);}function renderInstances(start,count,primcount){if(primcount===0)return;gl.drawElementsInstanced(mode,count,type,start*bytesPerElement,primcount);info.update(count,mode,primcount);}function renderMultiDraw(starts,counts,drawCount){if(drawCount===0)return;const extension=extensions.get('WEBGL_multi_draw');extension.multiDrawElementsWEBGL(mode,counts,0,type,starts,0,drawCount);let elementCount=0;for(let i=0;i<drawCount;i++){elementCount+=counts[i];}info.update(elementCount,mode,1);}function renderMultiDrawInstances(starts,counts,drawCount,primcount){if(drawCount===0)return;const extension=extensions.get('WEBGL_multi_draw');if(extension===null){for(let i=0;i<starts.length;i++){renderInstances(starts[i]/bytesPerElement,counts[i],primcount[i]);}}else {extension.multiDrawElementsInstancedWEBGL(mode,counts,0,type,starts,0,primcount,0,drawCount);let elementCount=0;for(let i=0;i<drawCount;i++){elementCount+=counts[i]*primcount[i];}info.update(elementCount,mode,1);}}//
	this.setMode=setMode;this.setIndex=setIndex;this.render=render;this.renderInstances=renderInstances;this.renderMultiDraw=renderMultiDraw;this.renderMultiDrawInstances=renderMultiDrawInstances;}function WebGLInfo(gl){const memory={geometries:0,textures:0};const render={frame:0,calls:0,triangles:0,points:0,lines:0};function update(count,mode,instanceCount){render.calls++;switch(mode){case gl.TRIANGLES:render.triangles+=instanceCount*(count/3);break;case gl.LINES:render.lines+=instanceCount*(count/2);break;case gl.LINE_STRIP:render.lines+=instanceCount*(count-1);break;case gl.LINE_LOOP:render.lines+=instanceCount*count;break;case gl.POINTS:render.points+=instanceCount*count;break;default:error$1('WebGLInfo: Unknown draw mode:',mode);break;}}function reset(){render.calls=0;render.triangles=0;render.points=0;render.lines=0;}return {memory:memory,render:render,programs:null,autoReset:true,reset:reset,update:update};}function WebGLMorphtargets(gl,capabilities,textures){const morphTextures=new WeakMap();const morph=new Vector4();function update(object,geometry,program){const objectInfluences=object.morphTargetInfluences;// the following encodes morph targets into an array of data textures. Each layer represents a single morph target.
	const morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color;const morphTargetsCount=morphAttribute!==undefined?morphAttribute.length:0;let entry=morphTextures.get(geometry);if(entry===undefined||entry.count!==morphTargetsCount){if(entry!==undefined)entry.texture.dispose();const hasMorphPosition=geometry.morphAttributes.position!==undefined;const hasMorphNormals=geometry.morphAttributes.normal!==undefined;const hasMorphColors=geometry.morphAttributes.color!==undefined;const morphTargets=geometry.morphAttributes.position||[];const morphNormals=geometry.morphAttributes.normal||[];const morphColors=geometry.morphAttributes.color||[];let vertexDataCount=0;if(hasMorphPosition===true)vertexDataCount=1;if(hasMorphNormals===true)vertexDataCount=2;if(hasMorphColors===true)vertexDataCount=3;let width=geometry.attributes.position.count*vertexDataCount;let height=1;if(width>capabilities.maxTextureSize){height=Math.ceil(width/capabilities.maxTextureSize);width=capabilities.maxTextureSize;}const buffer=new Float32Array(width*height*4*morphTargetsCount);const texture=new DataArrayTexture(buffer,width,height,morphTargetsCount);texture.type=FloatType$1;texture.needsUpdate=true;// fill buffer
	const vertexDataStride=vertexDataCount*4;for(let i=0;i<morphTargetsCount;i++){const morphTarget=morphTargets[i];const morphNormal=morphNormals[i];const morphColor=morphColors[i];const offset=width*height*4*i;for(let j=0;j<morphTarget.count;j++){const stride=j*vertexDataStride;if(hasMorphPosition===true){morph.fromBufferAttribute(morphTarget,j);buffer[offset+stride+0]=morph.x;buffer[offset+stride+1]=morph.y;buffer[offset+stride+2]=morph.z;buffer[offset+stride+3]=0;}if(hasMorphNormals===true){morph.fromBufferAttribute(morphNormal,j);buffer[offset+stride+4]=morph.x;buffer[offset+stride+5]=morph.y;buffer[offset+stride+6]=morph.z;buffer[offset+stride+7]=0;}if(hasMorphColors===true){morph.fromBufferAttribute(morphColor,j);buffer[offset+stride+8]=morph.x;buffer[offset+stride+9]=morph.y;buffer[offset+stride+10]=morph.z;buffer[offset+stride+11]=morphColor.itemSize===4?morph.w:1;}}}entry={count:morphTargetsCount,texture:texture,size:new Vector2$1(width,height)};morphTextures.set(geometry,entry);function disposeTexture(){texture.dispose();morphTextures.delete(geometry);geometry.removeEventListener('dispose',disposeTexture);}geometry.addEventListener('dispose',disposeTexture);}//
	if(object.isInstancedMesh===true&&object.morphTexture!==null){program.getUniforms().setValue(gl,'morphTexture',object.morphTexture,textures);}else {let morphInfluencesSum=0;for(let i=0;i<objectInfluences.length;i++){morphInfluencesSum+=objectInfluences[i];}const morphBaseInfluence=geometry.morphTargetsRelative?1:1-morphInfluencesSum;program.getUniforms().setValue(gl,'morphTargetBaseInfluence',morphBaseInfluence);program.getUniforms().setValue(gl,'morphTargetInfluences',objectInfluences);}program.getUniforms().setValue(gl,'morphTargetsTexture',entry.texture,textures);program.getUniforms().setValue(gl,'morphTargetsTextureSize',entry.size);}return {update:update};}function WebGLObjects(gl,geometries,attributes,info){let updateMap=new WeakMap();function update(object){const frame=info.render.frame;const geometry=object.geometry;const buffergeometry=geometries.get(object,geometry);// Update once per frame
	if(updateMap.get(buffergeometry)!==frame){geometries.update(buffergeometry);updateMap.set(buffergeometry,frame);}if(object.isInstancedMesh){if(object.hasEventListener('dispose',onInstancedMeshDispose)===false){object.addEventListener('dispose',onInstancedMeshDispose);}if(updateMap.get(object)!==frame){attributes.update(object.instanceMatrix,gl.ARRAY_BUFFER);if(object.instanceColor!==null){attributes.update(object.instanceColor,gl.ARRAY_BUFFER);}updateMap.set(object,frame);}}if(object.isSkinnedMesh){const skeleton=object.skeleton;if(updateMap.get(skeleton)!==frame){skeleton.update();updateMap.set(skeleton,frame);}}return buffergeometry;}function dispose(){updateMap=new WeakMap();}function onInstancedMeshDispose(event){const instancedMesh=event.target;instancedMesh.removeEventListener('dispose',onInstancedMeshDispose);attributes.remove(instancedMesh.instanceMatrix);if(instancedMesh.instanceColor!==null)attributes.remove(instancedMesh.instanceColor);}return {update:update,dispose:dispose};}/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */const emptyTexture=/*@__PURE__*/new Texture();const emptyShadowTexture=/*@__PURE__*/new DepthTexture(1,1);const emptyArrayTexture=/*@__PURE__*/new DataArrayTexture();const empty3dTexture=/*@__PURE__*/new Data3DTexture();const emptyCubeTexture=/*@__PURE__*/new CubeTexture();// --- Utilities ---
	// Array Caches (provide typed arrays for temporary by size)
	const arrayCacheF32=[];const arrayCacheI32=[];// Float32Array caches used for uploading Matrix uniforms
	const mat4array=new Float32Array(16);const mat3array=new Float32Array(9);const mat2array=new Float32Array(4);// Flattening for arrays of vectors and matrices
	function flatten(array,nBlocks,blockSize){const firstElem=array[0];if(firstElem<=0||firstElem>0)return array;// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983
	const n=nBlocks*blockSize;let r=arrayCacheF32[n];if(r===undefined){r=new Float32Array(n);arrayCacheF32[n]=r;}if(nBlocks!==0){firstElem.toArray(r,0);for(let i=1,offset=0;i!==nBlocks;++i){offset+=blockSize;array[i].toArray(r,offset);}}return r;}function arraysEqual(a,b){if(a.length!==b.length)return false;for(let i=0,l=a.length;i<l;i++){if(a[i]!==b[i])return false;}return true;}function copyArray(a,b){for(let i=0,l=b.length;i<l;i++){a[i]=b[i];}}// Texture unit allocation
	function allocTexUnits(textures,n){let r=arrayCacheI32[n];if(r===undefined){r=new Int32Array(n);arrayCacheI32[n]=r;}for(let i=0;i!==n;++i){r[i]=textures.allocateTextureUnit();}return r;}// --- Setters ---
	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.
	// Single scalar
	function setValueV1f(gl,v){const cache=this.cache;if(cache[0]===v)return;gl.uniform1f(this.addr,v);cache[0]=v;}// Single float vector (from flat array or THREE.VectorN)
	function setValueV2f(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y){gl.uniform2f(this.addr,v.x,v.y);cache[0]=v.x;cache[1]=v.y;}}else {if(arraysEqual(cache,v))return;gl.uniform2fv(this.addr,v);copyArray(cache,v);}}function setValueV3f(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z){gl.uniform3f(this.addr,v.x,v.y,v.z);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;}}else if(v.r!==undefined){if(cache[0]!==v.r||cache[1]!==v.g||cache[2]!==v.b){gl.uniform3f(this.addr,v.r,v.g,v.b);cache[0]=v.r;cache[1]=v.g;cache[2]=v.b;}}else {if(arraysEqual(cache,v))return;gl.uniform3fv(this.addr,v);copyArray(cache,v);}}function setValueV4f(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w){gl.uniform4f(this.addr,v.x,v.y,v.z,v.w);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;cache[3]=v.w;}}else {if(arraysEqual(cache,v))return;gl.uniform4fv(this.addr,v);copyArray(cache,v);}}// Single matrix (from flat array or THREE.MatrixN)
	function setValueM2(gl,v){const cache=this.cache;const elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix2fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat2array.set(elements);gl.uniformMatrix2fv(this.addr,false,mat2array);copyArray(cache,elements);}}function setValueM3(gl,v){const cache=this.cache;const elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix3fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat3array.set(elements);gl.uniformMatrix3fv(this.addr,false,mat3array);copyArray(cache,elements);}}function setValueM4(gl,v){const cache=this.cache;const elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix4fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat4array.set(elements);gl.uniformMatrix4fv(this.addr,false,mat4array);copyArray(cache,elements);}}// Single integer / boolean
	function setValueV1i(gl,v){const cache=this.cache;if(cache[0]===v)return;gl.uniform1i(this.addr,v);cache[0]=v;}// Single integer / boolean vector (from flat array or THREE.VectorN)
	function setValueV2i(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y){gl.uniform2i(this.addr,v.x,v.y);cache[0]=v.x;cache[1]=v.y;}}else {if(arraysEqual(cache,v))return;gl.uniform2iv(this.addr,v);copyArray(cache,v);}}function setValueV3i(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z){gl.uniform3i(this.addr,v.x,v.y,v.z);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;}}else {if(arraysEqual(cache,v))return;gl.uniform3iv(this.addr,v);copyArray(cache,v);}}function setValueV4i(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w){gl.uniform4i(this.addr,v.x,v.y,v.z,v.w);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;cache[3]=v.w;}}else {if(arraysEqual(cache,v))return;gl.uniform4iv(this.addr,v);copyArray(cache,v);}}// Single unsigned integer
	function setValueV1ui(gl,v){const cache=this.cache;if(cache[0]===v)return;gl.uniform1ui(this.addr,v);cache[0]=v;}// Single unsigned integer vector (from flat array or THREE.VectorN)
	function setValueV2ui(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y){gl.uniform2ui(this.addr,v.x,v.y);cache[0]=v.x;cache[1]=v.y;}}else {if(arraysEqual(cache,v))return;gl.uniform2uiv(this.addr,v);copyArray(cache,v);}}function setValueV3ui(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z){gl.uniform3ui(this.addr,v.x,v.y,v.z);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;}}else {if(arraysEqual(cache,v))return;gl.uniform3uiv(this.addr,v);copyArray(cache,v);}}function setValueV4ui(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w){gl.uniform4ui(this.addr,v.x,v.y,v.z,v.w);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;cache[3]=v.w;}}else {if(arraysEqual(cache,v))return;gl.uniform4uiv(this.addr,v);copyArray(cache,v);}}// Single texture (2D / Cube)
	function setValueT1(gl,v,textures){const cache=this.cache;const unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}let emptyTexture2D;if(this.type===gl.SAMPLER_2D_SHADOW){emptyShadowTexture.compareFunction=LessEqualCompare;// #28670
	emptyTexture2D=emptyShadowTexture;}else {emptyTexture2D=emptyTexture;}textures.setTexture2D(v||emptyTexture2D,unit);}function setValueT3D1(gl,v,textures){const cache=this.cache;const unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture3D(v||empty3dTexture,unit);}function setValueT6(gl,v,textures){const cache=this.cache;const unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTextureCube(v||emptyCubeTexture,unit);}function setValueT2DArray1(gl,v,textures){const cache=this.cache;const unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture2DArray(v||emptyArrayTexture,unit);}// Helper to pick the right setter for the singular case
	function getSingularSetter(type){switch(type){case 0x1406:return setValueV1f;// FLOAT
	case 0x8b50:return setValueV2f;// _VEC2
	case 0x8b51:return setValueV3f;// _VEC3
	case 0x8b52:return setValueV4f;// _VEC4
	case 0x8b5a:return setValueM2;// _MAT2
	case 0x8b5b:return setValueM3;// _MAT3
	case 0x8b5c:return setValueM4;// _MAT4
	case 0x1404:case 0x8b56:return setValueV1i;// INT, BOOL
	case 0x8b53:case 0x8b57:return setValueV2i;// _VEC2
	case 0x8b54:case 0x8b58:return setValueV3i;// _VEC3
	case 0x8b55:case 0x8b59:return setValueV4i;// _VEC4
	case 0x1405:return setValueV1ui;// UINT
	case 0x8dc6:return setValueV2ui;// _VEC2
	case 0x8dc7:return setValueV3ui;// _VEC3
	case 0x8dc8:return setValueV4ui;// _VEC4
	case 0x8b5e:// SAMPLER_2D
	case 0x8d66:// SAMPLER_EXTERNAL_OES
	case 0x8dca:// INT_SAMPLER_2D
	case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
	case 0x8b62:// SAMPLER_2D_SHADOW
	return setValueT1;case 0x8b5f:// SAMPLER_3D
	case 0x8dcb:// INT_SAMPLER_3D
	case 0x8dd3:// UNSIGNED_INT_SAMPLER_3D
	return setValueT3D1;case 0x8b60:// SAMPLER_CUBE
	case 0x8dcc:// INT_SAMPLER_CUBE
	case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
	case 0x8dc5:// SAMPLER_CUBE_SHADOW
	return setValueT6;case 0x8dc1:// SAMPLER_2D_ARRAY
	case 0x8dcf:// INT_SAMPLER_2D_ARRAY
	case 0x8dd7:// UNSIGNED_INT_SAMPLER_2D_ARRAY
	case 0x8dc4:// SAMPLER_2D_ARRAY_SHADOW
	return setValueT2DArray1;}}// Array of scalars
	function setValueV1fArray(gl,v){gl.uniform1fv(this.addr,v);}// Array of vectors (from flat array or array of THREE.VectorN)
	function setValueV2fArray(gl,v){const data=flatten(v,this.size,2);gl.uniform2fv(this.addr,data);}function setValueV3fArray(gl,v){const data=flatten(v,this.size,3);gl.uniform3fv(this.addr,data);}function setValueV4fArray(gl,v){const data=flatten(v,this.size,4);gl.uniform4fv(this.addr,data);}// Array of matrices (from flat array or array of THREE.MatrixN)
	function setValueM2Array(gl,v){const data=flatten(v,this.size,4);gl.uniformMatrix2fv(this.addr,false,data);}function setValueM3Array(gl,v){const data=flatten(v,this.size,9);gl.uniformMatrix3fv(this.addr,false,data);}function setValueM4Array(gl,v){const data=flatten(v,this.size,16);gl.uniformMatrix4fv(this.addr,false,data);}// Array of integer / boolean
	function setValueV1iArray(gl,v){gl.uniform1iv(this.addr,v);}// Array of integer / boolean vectors (from flat array)
	function setValueV2iArray(gl,v){gl.uniform2iv(this.addr,v);}function setValueV3iArray(gl,v){gl.uniform3iv(this.addr,v);}function setValueV4iArray(gl,v){gl.uniform4iv(this.addr,v);}// Array of unsigned integer
	function setValueV1uiArray(gl,v){gl.uniform1uiv(this.addr,v);}// Array of unsigned integer vectors (from flat array)
	function setValueV2uiArray(gl,v){gl.uniform2uiv(this.addr,v);}function setValueV3uiArray(gl,v){gl.uniform3uiv(this.addr,v);}function setValueV4uiArray(gl,v){gl.uniform4uiv(this.addr,v);}// Array of textures (2D / 3D / Cube / 2DArray)
	function setValueT1Array(gl,v,textures){const cache=this.cache;const n=v.length;const units=allocTexUnits(textures,n);if(!arraysEqual(cache,units)){gl.uniform1iv(this.addr,units);copyArray(cache,units);}for(let i=0;i!==n;++i){textures.setTexture2D(v[i]||emptyTexture,units[i]);}}function setValueT3DArray(gl,v,textures){const cache=this.cache;const n=v.length;const units=allocTexUnits(textures,n);if(!arraysEqual(cache,units)){gl.uniform1iv(this.addr,units);copyArray(cache,units);}for(let i=0;i!==n;++i){textures.setTexture3D(v[i]||empty3dTexture,units[i]);}}function setValueT6Array(gl,v,textures){const cache=this.cache;const n=v.length;const units=allocTexUnits(textures,n);if(!arraysEqual(cache,units)){gl.uniform1iv(this.addr,units);copyArray(cache,units);}for(let i=0;i!==n;++i){textures.setTextureCube(v[i]||emptyCubeTexture,units[i]);}}function setValueT2DArrayArray(gl,v,textures){const cache=this.cache;const n=v.length;const units=allocTexUnits(textures,n);if(!arraysEqual(cache,units)){gl.uniform1iv(this.addr,units);copyArray(cache,units);}for(let i=0;i!==n;++i){textures.setTexture2DArray(v[i]||emptyArrayTexture,units[i]);}}// Helper to pick the right setter for a pure (bottom-level) array
	function getPureArraySetter(type){switch(type){case 0x1406:return setValueV1fArray;// FLOAT
	case 0x8b50:return setValueV2fArray;// _VEC2
	case 0x8b51:return setValueV3fArray;// _VEC3
	case 0x8b52:return setValueV4fArray;// _VEC4
	case 0x8b5a:return setValueM2Array;// _MAT2
	case 0x8b5b:return setValueM3Array;// _MAT3
	case 0x8b5c:return setValueM4Array;// _MAT4
	case 0x1404:case 0x8b56:return setValueV1iArray;// INT, BOOL
	case 0x8b53:case 0x8b57:return setValueV2iArray;// _VEC2
	case 0x8b54:case 0x8b58:return setValueV3iArray;// _VEC3
	case 0x8b55:case 0x8b59:return setValueV4iArray;// _VEC4
	case 0x1405:return setValueV1uiArray;// UINT
	case 0x8dc6:return setValueV2uiArray;// _VEC2
	case 0x8dc7:return setValueV3uiArray;// _VEC3
	case 0x8dc8:return setValueV4uiArray;// _VEC4
	case 0x8b5e:// SAMPLER_2D
	case 0x8d66:// SAMPLER_EXTERNAL_OES
	case 0x8dca:// INT_SAMPLER_2D
	case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
	case 0x8b62:// SAMPLER_2D_SHADOW
	return setValueT1Array;case 0x8b5f:// SAMPLER_3D
	case 0x8dcb:// INT_SAMPLER_3D
	case 0x8dd3:// UNSIGNED_INT_SAMPLER_3D
	return setValueT3DArray;case 0x8b60:// SAMPLER_CUBE
	case 0x8dcc:// INT_SAMPLER_CUBE
	case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
	case 0x8dc5:// SAMPLER_CUBE_SHADOW
	return setValueT6Array;case 0x8dc1:// SAMPLER_2D_ARRAY
	case 0x8dcf:// INT_SAMPLER_2D_ARRAY
	case 0x8dd7:// UNSIGNED_INT_SAMPLER_2D_ARRAY
	case 0x8dc4:// SAMPLER_2D_ARRAY_SHADOW
	return setValueT2DArrayArray;}}// --- Uniform Classes ---
	class SingleUniform{constructor(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=[];this.type=activeInfo.type;this.setValue=getSingularSetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
	}}class PureArrayUniform{constructor(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=[];this.type=activeInfo.type;this.size=activeInfo.size;this.setValue=getPureArraySetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
	}}class StructuredUniform{constructor(id){this.id=id;this.seq=[];this.map={};}setValue(gl,value,textures){const seq=this.seq;for(let i=0,n=seq.length;i!==n;++i){const u=seq[i];u.setValue(gl,value[u.id],textures);}}}// --- Top-level ---
	// Parser - builds up the property tree from the path strings
	const RePathPart=/(\w+)(\])?(\[|\.)?/g;// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.
	function addUniform(container,uniformObject){container.seq.push(uniformObject);container.map[uniformObject.id]=uniformObject;}function parseUniform(activeInfo,addr,container){const path=activeInfo.name,pathLength=path.length;// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex=0;while(true){const match=RePathPart.exec(path),matchEnd=RePathPart.lastIndex;let id=match[1];const idIsIndex=match[2]===']',subscript=match[3];if(idIsIndex)id=id|0;// convert to integer
	if(subscript===undefined||subscript==='['&&matchEnd+2===pathLength){// bare name or "pure" bottom-level array "[0]" suffix
	addUniform(container,subscript===undefined?new SingleUniform(id,activeInfo,addr):new PureArrayUniform(id,activeInfo,addr));break;}else {// step into inner node / create it in case it doesn't exist
	const map=container.map;let next=map[id];if(next===undefined){next=new StructuredUniform(id);addUniform(container,next);}container=next;}}}// Root Container
	class WebGLUniforms{constructor(gl,program){this.seq=[];this.map={};const n=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const info=gl.getActiveUniform(program,i),addr=gl.getUniformLocation(program,info.name);parseUniform(info,addr,this);}}setValue(gl,name,value,textures){const u=this.map[name];if(u!==undefined)u.setValue(gl,value,textures);}setOptional(gl,object,name){const v=object[name];if(v!==undefined)this.setValue(gl,name,v);}static upload(gl,seq,values,textures){for(let i=0,n=seq.length;i!==n;++i){const u=seq[i],v=values[u.id];if(v.needsUpdate!==false){// note: always updating when .needsUpdate is undefined
	u.setValue(gl,v.value,textures);}}}static seqWithValue(seq,values){const r=[];for(let i=0,n=seq.length;i!==n;++i){const u=seq[i];if(u.id in values)r.push(u);}return r;}}function WebGLShader(gl,type,string){const shader=gl.createShader(type);gl.shaderSource(shader,string);gl.compileShader(shader);return shader;}// From https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/
	const COMPLETION_STATUS_KHR=0x91B1;let programIdCount=0;function handleSource(string,errorLine){const lines=string.split('\n');const lines2=[];const from=Math.max(errorLine-6,0);const to=Math.min(errorLine+6,lines.length);for(let i=from;i<to;i++){const line=i+1;lines2.push(`${line===errorLine?'>':' '} ${line}: ${lines[i]}`);}return lines2.join('\n');}const _m0=/*@__PURE__*/new Matrix3$1();function getEncodingComponents(colorSpace){ColorManagement._getMatrix(_m0,ColorManagement.workingColorSpace,colorSpace);const encodingMatrix=`mat3( ${_m0.elements.map(v=>v.toFixed(4))} )`;switch(ColorManagement.getTransfer(colorSpace)){case LinearTransfer:return [encodingMatrix,'LinearTransferOETF'];case SRGBTransfer:return [encodingMatrix,'sRGBTransferOETF'];default:warn$1('WebGLProgram: Unsupported color space: ',colorSpace);return [encodingMatrix,'LinearTransferOETF'];}}function getShaderErrors(gl,shader,type){const status=gl.getShaderParameter(shader,gl.COMPILE_STATUS);const shaderInfoLog=gl.getShaderInfoLog(shader)||'';const errors=shaderInfoLog.trim();if(status&&errors==='')return '';const errorMatches=/ERROR: 0:(\d+)/.exec(errors);if(errorMatches){// --enable-privileged-webgl-extension
	// log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
	const errorLine=parseInt(errorMatches[1]);return type.toUpperCase()+'\n\n'+errors+'\n\n'+handleSource(gl.getShaderSource(shader),errorLine);}else {return errors;}}function getTexelEncodingFunction(functionName,colorSpace){const components=getEncodingComponents(colorSpace);return [`vec4 ${functionName}( vec4 value ) {`,`	return ${components[1]}( vec4( value.rgb * ${components[0]}, value.a ) );`,'}'].join('\n');}function getToneMappingFunction(functionName,toneMapping){let toneMappingName;switch(toneMapping){case LinearToneMapping:toneMappingName='Linear';break;case ReinhardToneMapping:toneMappingName='Reinhard';break;case CineonToneMapping:toneMappingName='Cineon';break;case ACESFilmicToneMapping:toneMappingName='ACESFilmic';break;case AgXToneMapping:toneMappingName='AgX';break;case NeutralToneMapping:toneMappingName='Neutral';break;case CustomToneMapping:toneMappingName='Custom';break;default:warn$1('WebGLProgram: Unsupported toneMapping:',toneMapping);toneMappingName='Linear';}return 'vec3 '+functionName+'( vec3 color ) { return '+toneMappingName+'ToneMapping( color ); }';}const _v0$1=/*@__PURE__*/new Vector3$1();function getLuminanceFunction(){ColorManagement.getLuminanceCoefficients(_v0$1);const r=_v0$1.x.toFixed(4);const g=_v0$1.y.toFixed(4);const b=_v0$1.z.toFixed(4);return ['float luminance( const in vec3 rgb ) {',`	const vec3 weights = vec3( ${r}, ${g}, ${b} );`,'	return dot( weights, rgb );','}'].join('\n');}function generateVertexExtensions(parameters){const chunks=[parameters.extensionClipCullDistance?'#extension GL_ANGLE_clip_cull_distance : require':'',parameters.extensionMultiDraw?'#extension GL_ANGLE_multi_draw : require':''];return chunks.filter(filterEmptyLine).join('\n');}function generateDefines(defines){const chunks=[];for(const name in defines){const value=defines[name];if(value===false)continue;chunks.push('#define '+name+' '+value);}return chunks.join('\n');}function fetchAttributeLocations(gl,program){const attributes={};const n=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);for(let i=0;i<n;i++){const info=gl.getActiveAttrib(program,i);const name=info.name;let locationSize=1;if(info.type===gl.FLOAT_MAT2)locationSize=2;if(info.type===gl.FLOAT_MAT3)locationSize=3;if(info.type===gl.FLOAT_MAT4)locationSize=4;// log( 'WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
	attributes[name]={type:info.type,location:gl.getAttribLocation(program,name),locationSize:locationSize};}return attributes;}function filterEmptyLine(string){return string!=='';}function replaceLightNums(string,parameters){const numSpotLightCoords=parameters.numSpotLightShadows+parameters.numSpotLightMaps-parameters.numSpotLightShadowsWithMaps;return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,parameters.numPointLightShadows);}function replaceClippingPlaneNums(string,parameters){return string.replace(/NUM_CLIPPING_PLANES/g,parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,parameters.numClippingPlanes-parameters.numClipIntersection);}// Resolve Includes
	const includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(string){return string.replace(includePattern,includeReplacer);}const shaderChunkMap=new Map();function includeReplacer(match,include){let string=ShaderChunk[include];if(string===undefined){const newInclude=shaderChunkMap.get(include);if(newInclude!==undefined){string=ShaderChunk[newInclude];warn$1('WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',include,newInclude);}else {throw new Error('Can not resolve #include <'+include+'>');}}return resolveIncludes(string);}// Unroll Loops
	const unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(string){return string.replace(unrollLoopPattern,loopReplacer);}function loopReplacer(match,start,end,snippet){let string='';for(let i=parseInt(start);i<parseInt(end);i++){string+=snippet.replace(/\[\s*i\s*\]/g,'[ '+i+' ]').replace(/UNROLLED_LOOP_INDEX/g,i);}return string;}//
	function generatePrecision(parameters){let precisionstring=`precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;if(parameters.precision==='highp'){precisionstring+='\n#define HIGH_PRECISION';}else if(parameters.precision==='mediump'){precisionstring+='\n#define MEDIUM_PRECISION';}else if(parameters.precision==='lowp'){precisionstring+='\n#define LOW_PRECISION';}return precisionstring;}function generateShadowMapTypeDefine(parameters){let shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';if(parameters.shadowMapType===PCFShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF';}else if(parameters.shadowMapType===PCFSoftShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';}else if(parameters.shadowMapType===VSMShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_VSM';}return shadowMapTypeDefine;}function generateEnvMapTypeDefine(parameters){let envMapTypeDefine='ENVMAP_TYPE_CUBE';if(parameters.envMap){switch(parameters.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE';break;case CubeUVReflectionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE_UV';break;}}return envMapTypeDefine;}function generateEnvMapModeDefine(parameters){let envMapModeDefine='ENVMAP_MODE_REFLECTION';if(parameters.envMap){switch(parameters.envMapMode){case CubeRefractionMapping:envMapModeDefine='ENVMAP_MODE_REFRACTION';break;}}return envMapModeDefine;}function generateEnvMapBlendingDefine(parameters){let envMapBlendingDefine='ENVMAP_BLENDING_NONE';if(parameters.envMap){switch(parameters.combine){case MultiplyOperation:envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';break;case MixOperation:envMapBlendingDefine='ENVMAP_BLENDING_MIX';break;case AddOperation:envMapBlendingDefine='ENVMAP_BLENDING_ADD';break;}}return envMapBlendingDefine;}function generateCubeUVSize(parameters){const imageHeight=parameters.envMapCubeUVHeight;if(imageHeight===null)return null;const maxMip=Math.log2(imageHeight)-2;const texelHeight=1.0/imageHeight;const texelWidth=1.0/(3*Math.max(Math.pow(2,maxMip),7*16));return {texelWidth,texelHeight,maxMip};}function WebGLProgram(renderer,cacheKey,parameters,bindingStates){// TODO Send this event to Three.js DevTools
	// log( 'WebGLProgram', cacheKey );
	const gl=renderer.getContext();const defines=parameters.defines;let vertexShader=parameters.vertexShader;let fragmentShader=parameters.fragmentShader;const shadowMapTypeDefine=generateShadowMapTypeDefine(parameters);const envMapTypeDefine=generateEnvMapTypeDefine(parameters);const envMapModeDefine=generateEnvMapModeDefine(parameters);const envMapBlendingDefine=generateEnvMapBlendingDefine(parameters);const envMapCubeUVSize=generateCubeUVSize(parameters);const customVertexExtensions=generateVertexExtensions(parameters);const customDefines=generateDefines(defines);const program=gl.createProgram();let prefixVertex,prefixFragment;let versionString=parameters.glslVersion?'#version '+parameters.glslVersion+'\n':'';if(parameters.isRawShaderMaterial){prefixVertex=['#define SHADER_TYPE '+parameters.shaderType,'#define SHADER_NAME '+parameters.shaderName,customDefines].filter(filterEmptyLine).join('\n');if(prefixVertex.length>0){prefixVertex+='\n';}prefixFragment=['#define SHADER_TYPE '+parameters.shaderType,'#define SHADER_NAME '+parameters.shaderName,customDefines].filter(filterEmptyLine).join('\n');if(prefixFragment.length>0){prefixFragment+='\n';}}else {prefixVertex=[generatePrecision(parameters),'#define SHADER_TYPE '+parameters.shaderType,'#define SHADER_NAME '+parameters.shaderName,customDefines,parameters.extensionClipCullDistance?'#define USE_CLIP_DISTANCE':'',parameters.batching?'#define USE_BATCHING':'',parameters.batchingColor?'#define USE_BATCHING_COLOR':'',parameters.instancing?'#define USE_INSTANCING':'',parameters.instancingColor?'#define USE_INSTANCING_COLOR':'',parameters.instancingMorph?'#define USE_INSTANCING_MORPH':'',parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMapObjectSpace?'#define USE_NORMALMAP_OBJECTSPACE':'',parameters.normalMapTangentSpace?'#define USE_NORMALMAP_TANGENTSPACE':'',parameters.displacementMap?'#define USE_DISPLACEMENTMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.anisotropy?'#define USE_ANISOTROPY':'',parameters.anisotropyMap?'#define USE_ANISOTROPYMAP':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.iridescenceMap?'#define USE_IRIDESCENCEMAP':'',parameters.iridescenceThicknessMap?'#define USE_IRIDESCENCE_THICKNESSMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.specularColorMap?'#define USE_SPECULAR_COLORMAP':'',parameters.specularIntensityMap?'#define USE_SPECULAR_INTENSITYMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.alphaHash?'#define USE_ALPHAHASH':'',parameters.transmission?'#define USE_TRANSMISSION':'',parameters.transmissionMap?'#define USE_TRANSMISSIONMAP':'',parameters.thicknessMap?'#define USE_THICKNESSMAP':'',parameters.sheenColorMap?'#define USE_SHEEN_COLORMAP':'',parameters.sheenRoughnessMap?'#define USE_SHEEN_ROUGHNESSMAP':'',//
	parameters.mapUv?'#define MAP_UV '+parameters.mapUv:'',parameters.alphaMapUv?'#define ALPHAMAP_UV '+parameters.alphaMapUv:'',parameters.lightMapUv?'#define LIGHTMAP_UV '+parameters.lightMapUv:'',parameters.aoMapUv?'#define AOMAP_UV '+parameters.aoMapUv:'',parameters.emissiveMapUv?'#define EMISSIVEMAP_UV '+parameters.emissiveMapUv:'',parameters.bumpMapUv?'#define BUMPMAP_UV '+parameters.bumpMapUv:'',parameters.normalMapUv?'#define NORMALMAP_UV '+parameters.normalMapUv:'',parameters.displacementMapUv?'#define DISPLACEMENTMAP_UV '+parameters.displacementMapUv:'',parameters.metalnessMapUv?'#define METALNESSMAP_UV '+parameters.metalnessMapUv:'',parameters.roughnessMapUv?'#define ROUGHNESSMAP_UV '+parameters.roughnessMapUv:'',parameters.anisotropyMapUv?'#define ANISOTROPYMAP_UV '+parameters.anisotropyMapUv:'',parameters.clearcoatMapUv?'#define CLEARCOATMAP_UV '+parameters.clearcoatMapUv:'',parameters.clearcoatNormalMapUv?'#define CLEARCOAT_NORMALMAP_UV '+parameters.clearcoatNormalMapUv:'',parameters.clearcoatRoughnessMapUv?'#define CLEARCOAT_ROUGHNESSMAP_UV '+parameters.clearcoatRoughnessMapUv:'',parameters.iridescenceMapUv?'#define IRIDESCENCEMAP_UV '+parameters.iridescenceMapUv:'',parameters.iridescenceThicknessMapUv?'#define IRIDESCENCE_THICKNESSMAP_UV '+parameters.iridescenceThicknessMapUv:'',parameters.sheenColorMapUv?'#define SHEEN_COLORMAP_UV '+parameters.sheenColorMapUv:'',parameters.sheenRoughnessMapUv?'#define SHEEN_ROUGHNESSMAP_UV '+parameters.sheenRoughnessMapUv:'',parameters.specularMapUv?'#define SPECULARMAP_UV '+parameters.specularMapUv:'',parameters.specularColorMapUv?'#define SPECULAR_COLORMAP_UV '+parameters.specularColorMapUv:'',parameters.specularIntensityMapUv?'#define SPECULAR_INTENSITYMAP_UV '+parameters.specularIntensityMapUv:'',parameters.transmissionMapUv?'#define TRANSMISSIONMAP_UV '+parameters.transmissionMapUv:'',parameters.thicknessMapUv?'#define THICKNESSMAP_UV '+parameters.thicknessMapUv:'',//
	parameters.vertexTangents&&parameters.flatShading===false?'#define USE_TANGENT':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.vertexAlphas?'#define USE_COLOR_ALPHA':'',parameters.vertexUv1s?'#define USE_UV1':'',parameters.vertexUv2s?'#define USE_UV2':'',parameters.vertexUv3s?'#define USE_UV3':'',parameters.pointsUvs?'#define USE_POINTS_UV':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.skinning?'#define USE_SKINNING':'',parameters.morphTargets?'#define USE_MORPHTARGETS':'',parameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',parameters.morphColors?'#define USE_MORPHCOLORS':'',parameters.morphTargetsCount>0?'#define MORPHTARGETS_TEXTURE_STRIDE '+parameters.morphTextureStride:'',parameters.morphTargetsCount>0?'#define MORPHTARGETS_COUNT '+parameters.morphTargetsCount:'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',parameters.numLightProbes>0?'#define USE_LIGHT_PROBES':'',parameters.logarithmicDepthBuffer?'#define USE_LOGARITHMIC_DEPTH_BUFFER':'',parameters.reversedDepthBuffer?'#define USE_REVERSED_DEPTH_BUFFER':'','uniform mat4 modelMatrix;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform mat4 viewMatrix;','uniform mat3 normalMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;','#ifdef USE_INSTANCING','	attribute mat4 instanceMatrix;','#endif','#ifdef USE_INSTANCING_COLOR','	attribute vec3 instanceColor;','#endif','#ifdef USE_INSTANCING_MORPH','	uniform sampler2D morphTexture;','#endif','attribute vec3 position;','attribute vec3 normal;','attribute vec2 uv;','#ifdef USE_UV1','	attribute vec2 uv1;','#endif','#ifdef USE_UV2','	attribute vec2 uv2;','#endif','#ifdef USE_UV3','	attribute vec2 uv3;','#endif','#ifdef USE_TANGENT','	attribute vec4 tangent;','#endif','#if defined( USE_COLOR_ALPHA )','	attribute vec4 color;','#elif defined( USE_COLOR )','	attribute vec3 color;','#endif','#ifdef USE_SKINNING','	attribute vec4 skinIndex;','	attribute vec4 skinWeight;','#endif','\n'].filter(filterEmptyLine).join('\n');prefixFragment=[generatePrecision(parameters),'#define SHADER_TYPE '+parameters.shaderType,'#define SHADER_NAME '+parameters.shaderName,customDefines,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.alphaToCoverage?'#define ALPHA_TO_COVERAGE':'',parameters.map?'#define USE_MAP':'',parameters.matcap?'#define USE_MATCAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapTypeDefine:'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.envMap?'#define '+envMapBlendingDefine:'',envMapCubeUVSize?'#define CUBEUV_TEXEL_WIDTH '+envMapCubeUVSize.texelWidth:'',envMapCubeUVSize?'#define CUBEUV_TEXEL_HEIGHT '+envMapCubeUVSize.texelHeight:'',envMapCubeUVSize?'#define CUBEUV_MAX_MIP '+envMapCubeUVSize.maxMip+'.0':'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMapObjectSpace?'#define USE_NORMALMAP_OBJECTSPACE':'',parameters.normalMapTangentSpace?'#define USE_NORMALMAP_TANGENTSPACE':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.anisotropy?'#define USE_ANISOTROPY':'',parameters.anisotropyMap?'#define USE_ANISOTROPYMAP':'',parameters.clearcoat?'#define USE_CLEARCOAT':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.dispersion?'#define USE_DISPERSION':'',parameters.iridescence?'#define USE_IRIDESCENCE':'',parameters.iridescenceMap?'#define USE_IRIDESCENCEMAP':'',parameters.iridescenceThicknessMap?'#define USE_IRIDESCENCE_THICKNESSMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.specularColorMap?'#define USE_SPECULAR_COLORMAP':'',parameters.specularIntensityMap?'#define USE_SPECULAR_INTENSITYMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.alphaTest?'#define USE_ALPHATEST':'',parameters.alphaHash?'#define USE_ALPHAHASH':'',parameters.sheen?'#define USE_SHEEN':'',parameters.sheenColorMap?'#define USE_SHEEN_COLORMAP':'',parameters.sheenRoughnessMap?'#define USE_SHEEN_ROUGHNESSMAP':'',parameters.transmission?'#define USE_TRANSMISSION':'',parameters.transmissionMap?'#define USE_TRANSMISSIONMAP':'',parameters.thicknessMap?'#define USE_THICKNESSMAP':'',parameters.vertexTangents&&parameters.flatShading===false?'#define USE_TANGENT':'',parameters.vertexColors||parameters.instancingColor||parameters.batchingColor?'#define USE_COLOR':'',parameters.vertexAlphas?'#define USE_COLOR_ALPHA':'',parameters.vertexUv1s?'#define USE_UV1':'',parameters.vertexUv2s?'#define USE_UV2':'',parameters.vertexUv3s?'#define USE_UV3':'',parameters.pointsUvs?'#define USE_POINTS_UV':'',parameters.gradientMap?'#define USE_GRADIENTMAP':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.premultipliedAlpha?'#define PREMULTIPLIED_ALPHA':'',parameters.numLightProbes>0?'#define USE_LIGHT_PROBES':'',parameters.decodeVideoTexture?'#define DECODE_VIDEO_TEXTURE':'',parameters.decodeVideoTextureEmissive?'#define DECODE_VIDEO_TEXTURE_EMISSIVE':'',parameters.logarithmicDepthBuffer?'#define USE_LOGARITHMIC_DEPTH_BUFFER':'',parameters.reversedDepthBuffer?'#define USE_REVERSED_DEPTH_BUFFER':'','uniform mat4 viewMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;',parameters.toneMapping!==NoToneMapping?'#define TONE_MAPPING':'',parameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below
	parameters.toneMapping!==NoToneMapping?getToneMappingFunction('toneMapping',parameters.toneMapping):'',parameters.dithering?'#define DITHERING':'',parameters.opaque?'#define OPAQUE':'',ShaderChunk['colorspace_pars_fragment'],// this code is required here because it is used by the various encoding/decoding function defined below
	getTexelEncodingFunction('linearToOutputTexel',parameters.outputColorSpace),getLuminanceFunction(),parameters.useDepthPacking?'#define DEPTH_PACKING '+parameters.depthPacking:'','\n'].filter(filterEmptyLine).join('\n');}vertexShader=resolveIncludes(vertexShader);vertexShader=replaceLightNums(vertexShader,parameters);vertexShader=replaceClippingPlaneNums(vertexShader,parameters);fragmentShader=resolveIncludes(fragmentShader);fragmentShader=replaceLightNums(fragmentShader,parameters);fragmentShader=replaceClippingPlaneNums(fragmentShader,parameters);vertexShader=unrollLoops(vertexShader);fragmentShader=unrollLoops(fragmentShader);if(parameters.isRawShaderMaterial!==true){// GLSL 3.0 conversion for built-in materials and ShaderMaterial
	versionString='#version 300 es\n';prefixVertex=[customVertexExtensions,'#define attribute in','#define varying out','#define texture2D texture'].join('\n')+'\n'+prefixVertex;prefixFragment=['#define varying in',parameters.glslVersion===GLSL3?'':'layout(location = 0) out highp vec4 pc_fragColor;',parameters.glslVersion===GLSL3?'':'#define gl_FragColor pc_fragColor','#define gl_FragDepthEXT gl_FragDepth','#define texture2D texture','#define textureCube texture','#define texture2DProj textureProj','#define texture2DLodEXT textureLod','#define texture2DProjLodEXT textureProjLod','#define textureCubeLodEXT textureLod','#define texture2DGradEXT textureGrad','#define texture2DProjGradEXT textureProjGrad','#define textureCubeGradEXT textureGrad'].join('\n')+'\n'+prefixFragment;}const vertexGlsl=versionString+prefixVertex+vertexShader;const fragmentGlsl=versionString+prefixFragment+fragmentShader;// log( '*VERTEX*', vertexGlsl );
	// log( '*FRAGMENT*', fragmentGlsl );
	const glVertexShader=WebGLShader(gl,gl.VERTEX_SHADER,vertexGlsl);const glFragmentShader=WebGLShader(gl,gl.FRAGMENT_SHADER,fragmentGlsl);gl.attachShader(program,glVertexShader);gl.attachShader(program,glFragmentShader);// Force a particular attribute to index 0.
	if(parameters.index0AttributeName!==undefined){gl.bindAttribLocation(program,0,parameters.index0AttributeName);}else if(parameters.morphTargets===true){// programs with morphTargets displace position out of attribute 0
	gl.bindAttribLocation(program,0,'position');}gl.linkProgram(program);function onFirstUse(self){// check for link errors
	if(renderer.debug.checkShaderErrors){const programInfoLog=gl.getProgramInfoLog(program)||'';const vertexShaderInfoLog=gl.getShaderInfoLog(glVertexShader)||'';const fragmentShaderInfoLog=gl.getShaderInfoLog(glFragmentShader)||'';const programLog=programInfoLog.trim();const vertexLog=vertexShaderInfoLog.trim();const fragmentLog=fragmentShaderInfoLog.trim();let runnable=true;let haveDiagnostics=true;if(gl.getProgramParameter(program,gl.LINK_STATUS)===false){runnable=false;if(typeof renderer.debug.onShaderError==='function'){renderer.debug.onShaderError(gl,program,glVertexShader,glFragmentShader);}else {// default error reporting
	const vertexErrors=getShaderErrors(gl,glVertexShader,'vertex');const fragmentErrors=getShaderErrors(gl,glFragmentShader,'fragment');error$1('THREE.WebGLProgram: Shader Error '+gl.getError()+' - '+'VALIDATE_STATUS '+gl.getProgramParameter(program,gl.VALIDATE_STATUS)+'\n\n'+'Material Name: '+self.name+'\n'+'Material Type: '+self.type+'\n\n'+'Program Info Log: '+programLog+'\n'+vertexErrors+'\n'+fragmentErrors);}}else if(programLog!==''){warn$1('WebGLProgram: Program Info Log:',programLog);}else if(vertexLog===''||fragmentLog===''){haveDiagnostics=false;}if(haveDiagnostics){self.diagnostics={runnable:runnable,programLog:programLog,vertexShader:{log:vertexLog,prefix:prefixVertex},fragmentShader:{log:fragmentLog,prefix:prefixFragment}};}}// Clean up
	// Crashes in iOS9 and iOS10. #18402
	// gl.detachShader( program, glVertexShader );
	// gl.detachShader( program, glFragmentShader );
	gl.deleteShader(glVertexShader);gl.deleteShader(glFragmentShader);cachedUniforms=new WebGLUniforms(gl,program);cachedAttributes=fetchAttributeLocations(gl,program);}// set up caching for uniform locations
	let cachedUniforms;this.getUniforms=function(){if(cachedUniforms===undefined){// Populates cachedUniforms and cachedAttributes
	onFirstUse(this);}return cachedUniforms;};// set up caching for attribute locations
	let cachedAttributes;this.getAttributes=function(){if(cachedAttributes===undefined){// Populates cachedAttributes and cachedUniforms
	onFirstUse(this);}return cachedAttributes;};// indicate when the program is ready to be used. if the KHR_parallel_shader_compile extension isn't supported,
	// flag the program as ready immediately. It may cause a stall when it's first used.
	let programReady=parameters.rendererExtensionParallelShaderCompile===false;this.isReady=function(){if(programReady===false){programReady=gl.getProgramParameter(program,COMPLETION_STATUS_KHR);}return programReady;};// free resource
	this.destroy=function(){bindingStates.releaseStatesOfProgram(this);gl.deleteProgram(program);this.program=undefined;};//
	this.type=parameters.shaderType;this.name=parameters.shaderName;this.id=programIdCount++;this.cacheKey=cacheKey;this.usedTimes=1;this.program=program;this.vertexShader=glVertexShader;this.fragmentShader=glFragmentShader;return this;}let _id$2=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map();this.materialCache=new Map();}update(material){const vertexShader=material.vertexShader;const fragmentShader=material.fragmentShader;const vertexShaderStage=this._getShaderStage(vertexShader);const fragmentShaderStage=this._getShaderStage(fragmentShader);const materialShaders=this._getShaderCacheForMaterial(material);if(materialShaders.has(vertexShaderStage)===false){materialShaders.add(vertexShaderStage);vertexShaderStage.usedTimes++;}if(materialShaders.has(fragmentShaderStage)===false){materialShaders.add(fragmentShaderStage);fragmentShaderStage.usedTimes++;}return this;}remove(material){const materialShaders=this.materialCache.get(material);for(const shaderStage of materialShaders){shaderStage.usedTimes--;if(shaderStage.usedTimes===0)this.shaderCache.delete(shaderStage.code);}this.materialCache.delete(material);return this;}getVertexShaderID(material){return this._getShaderStage(material.vertexShader).id;}getFragmentShaderID(material){return this._getShaderStage(material.fragmentShader).id;}dispose(){this.shaderCache.clear();this.materialCache.clear();}_getShaderCacheForMaterial(material){const cache=this.materialCache;let set=cache.get(material);if(set===undefined){set=new Set();cache.set(material,set);}return set;}_getShaderStage(code){const cache=this.shaderCache;let stage=cache.get(code);if(stage===undefined){stage=new WebGLShaderStage(code);cache.set(code,stage);}return stage;}}class WebGLShaderStage{constructor(code){this.id=_id$2++;this.code=code;this.usedTimes=0;}}function WebGLPrograms(renderer,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping){const _programLayers=new Layers$1();const _customShaders=new WebGLShaderCache();const _activeChannels=new Set();const programs=[];const logarithmicDepthBuffer=capabilities.logarithmicDepthBuffer;const SUPPORTS_VERTEX_TEXTURES=capabilities.vertexTextures;let precision=capabilities.precision;const shaderIDs={MeshDepthMaterial:'depth',MeshDistanceMaterial:'distanceRGBA',MeshNormalMaterial:'normal',MeshBasicMaterial:'basic',MeshLambertMaterial:'lambert',MeshPhongMaterial:'phong',MeshToonMaterial:'toon',MeshStandardMaterial:'physical',MeshPhysicalMaterial:'physical',MeshMatcapMaterial:'matcap',LineBasicMaterial:'basic',LineDashedMaterial:'dashed',PointsMaterial:'points',ShadowMaterial:'shadow',SpriteMaterial:'sprite'};function getChannel(value){_activeChannels.add(value);if(value===0)return 'uv';return `uv${value}`;}function getParameters(material,lights,shadows,scene,object){const fog=scene.fog;const geometry=object.geometry;const environment=material.isMeshStandardMaterial?scene.environment:null;const envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment);const envMapCubeUVHeight=!!envMap&&envMap.mapping===CubeUVReflectionMapping?envMap.image.height:null;const shaderID=shaderIDs[material.type];// heuristics to create shader parameters according to lights in the scene
	// (not to blow over maxLights budget)
	if(material.precision!==null){precision=capabilities.getMaxPrecision(material.precision);if(precision!==material.precision){warn$1('WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');}}//
	const morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color;const morphTargetsCount=morphAttribute!==undefined?morphAttribute.length:0;let morphTextureStride=0;if(geometry.morphAttributes.position!==undefined)morphTextureStride=1;if(geometry.morphAttributes.normal!==undefined)morphTextureStride=2;if(geometry.morphAttributes.color!==undefined)morphTextureStride=3;//
	let vertexShader,fragmentShader;let customVertexShaderID,customFragmentShaderID;if(shaderID){const shader=ShaderLib[shaderID];vertexShader=shader.vertexShader;fragmentShader=shader.fragmentShader;}else {vertexShader=material.vertexShader;fragmentShader=material.fragmentShader;_customShaders.update(material);customVertexShaderID=_customShaders.getVertexShaderID(material);customFragmentShaderID=_customShaders.getFragmentShaderID(material);}const currentRenderTarget=renderer.getRenderTarget();const reversedDepthBuffer=renderer.state.buffers.depth.getReversed();const IS_INSTANCEDMESH=object.isInstancedMesh===true;const IS_BATCHEDMESH=object.isBatchedMesh===true;const HAS_MAP=!!material.map;const HAS_MATCAP=!!material.matcap;const HAS_ENVMAP=!!envMap;const HAS_AOMAP=!!material.aoMap;const HAS_LIGHTMAP=!!material.lightMap;const HAS_BUMPMAP=!!material.bumpMap;const HAS_NORMALMAP=!!material.normalMap;const HAS_DISPLACEMENTMAP=!!material.displacementMap;const HAS_EMISSIVEMAP=!!material.emissiveMap;const HAS_METALNESSMAP=!!material.metalnessMap;const HAS_ROUGHNESSMAP=!!material.roughnessMap;const HAS_ANISOTROPY=material.anisotropy>0;const HAS_CLEARCOAT=material.clearcoat>0;const HAS_DISPERSION=material.dispersion>0;const HAS_IRIDESCENCE=material.iridescence>0;const HAS_SHEEN=material.sheen>0;const HAS_TRANSMISSION=material.transmission>0;const HAS_ANISOTROPYMAP=HAS_ANISOTROPY&&!!material.anisotropyMap;const HAS_CLEARCOATMAP=HAS_CLEARCOAT&&!!material.clearcoatMap;const HAS_CLEARCOAT_NORMALMAP=HAS_CLEARCOAT&&!!material.clearcoatNormalMap;const HAS_CLEARCOAT_ROUGHNESSMAP=HAS_CLEARCOAT&&!!material.clearcoatRoughnessMap;const HAS_IRIDESCENCEMAP=HAS_IRIDESCENCE&&!!material.iridescenceMap;const HAS_IRIDESCENCE_THICKNESSMAP=HAS_IRIDESCENCE&&!!material.iridescenceThicknessMap;const HAS_SHEEN_COLORMAP=HAS_SHEEN&&!!material.sheenColorMap;const HAS_SHEEN_ROUGHNESSMAP=HAS_SHEEN&&!!material.sheenRoughnessMap;const HAS_SPECULARMAP=!!material.specularMap;const HAS_SPECULAR_COLORMAP=!!material.specularColorMap;const HAS_SPECULAR_INTENSITYMAP=!!material.specularIntensityMap;const HAS_TRANSMISSIONMAP=HAS_TRANSMISSION&&!!material.transmissionMap;const HAS_THICKNESSMAP=HAS_TRANSMISSION&&!!material.thicknessMap;const HAS_GRADIENTMAP=!!material.gradientMap;const HAS_ALPHAMAP=!!material.alphaMap;const HAS_ALPHATEST=material.alphaTest>0;const HAS_ALPHAHASH=!!material.alphaHash;const HAS_EXTENSIONS=!!material.extensions;let toneMapping=NoToneMapping;if(material.toneMapped){if(currentRenderTarget===null||currentRenderTarget.isXRRenderTarget===true){toneMapping=renderer.toneMapping;}}const parameters={shaderID:shaderID,shaderType:material.type,shaderName:material.name,vertexShader:vertexShader,fragmentShader:fragmentShader,defines:material.defines,customVertexShaderID:customVertexShaderID,customFragmentShaderID:customFragmentShaderID,isRawShaderMaterial:material.isRawShaderMaterial===true,glslVersion:material.glslVersion,precision:precision,batching:IS_BATCHEDMESH,batchingColor:IS_BATCHEDMESH&&object._colorsTexture!==null,instancing:IS_INSTANCEDMESH,instancingColor:IS_INSTANCEDMESH&&object.instanceColor!==null,instancingMorph:IS_INSTANCEDMESH&&object.morphTexture!==null,supportsVertexTextures:SUPPORTS_VERTEX_TEXTURES,outputColorSpace:currentRenderTarget===null?renderer.outputColorSpace:currentRenderTarget.isXRRenderTarget===true?currentRenderTarget.texture.colorSpace:LinearSRGBColorSpace,alphaToCoverage:!!material.alphaToCoverage,map:HAS_MAP,matcap:HAS_MATCAP,envMap:HAS_ENVMAP,envMapMode:HAS_ENVMAP&&envMap.mapping,envMapCubeUVHeight:envMapCubeUVHeight,aoMap:HAS_AOMAP,lightMap:HAS_LIGHTMAP,bumpMap:HAS_BUMPMAP,normalMap:HAS_NORMALMAP,displacementMap:SUPPORTS_VERTEX_TEXTURES&&HAS_DISPLACEMENTMAP,emissiveMap:HAS_EMISSIVEMAP,normalMapObjectSpace:HAS_NORMALMAP&&material.normalMapType===ObjectSpaceNormalMap,normalMapTangentSpace:HAS_NORMALMAP&&material.normalMapType===TangentSpaceNormalMap,metalnessMap:HAS_METALNESSMAP,roughnessMap:HAS_ROUGHNESSMAP,anisotropy:HAS_ANISOTROPY,anisotropyMap:HAS_ANISOTROPYMAP,clearcoat:HAS_CLEARCOAT,clearcoatMap:HAS_CLEARCOATMAP,clearcoatNormalMap:HAS_CLEARCOAT_NORMALMAP,clearcoatRoughnessMap:HAS_CLEARCOAT_ROUGHNESSMAP,dispersion:HAS_DISPERSION,iridescence:HAS_IRIDESCENCE,iridescenceMap:HAS_IRIDESCENCEMAP,iridescenceThicknessMap:HAS_IRIDESCENCE_THICKNESSMAP,sheen:HAS_SHEEN,sheenColorMap:HAS_SHEEN_COLORMAP,sheenRoughnessMap:HAS_SHEEN_ROUGHNESSMAP,specularMap:HAS_SPECULARMAP,specularColorMap:HAS_SPECULAR_COLORMAP,specularIntensityMap:HAS_SPECULAR_INTENSITYMAP,transmission:HAS_TRANSMISSION,transmissionMap:HAS_TRANSMISSIONMAP,thicknessMap:HAS_THICKNESSMAP,gradientMap:HAS_GRADIENTMAP,opaque:material.transparent===false&&material.blending===NormalBlending&&material.alphaToCoverage===false,alphaMap:HAS_ALPHAMAP,alphaTest:HAS_ALPHATEST,alphaHash:HAS_ALPHAHASH,combine:material.combine,//
	mapUv:HAS_MAP&&getChannel(material.map.channel),aoMapUv:HAS_AOMAP&&getChannel(material.aoMap.channel),lightMapUv:HAS_LIGHTMAP&&getChannel(material.lightMap.channel),bumpMapUv:HAS_BUMPMAP&&getChannel(material.bumpMap.channel),normalMapUv:HAS_NORMALMAP&&getChannel(material.normalMap.channel),displacementMapUv:HAS_DISPLACEMENTMAP&&getChannel(material.displacementMap.channel),emissiveMapUv:HAS_EMISSIVEMAP&&getChannel(material.emissiveMap.channel),metalnessMapUv:HAS_METALNESSMAP&&getChannel(material.metalnessMap.channel),roughnessMapUv:HAS_ROUGHNESSMAP&&getChannel(material.roughnessMap.channel),anisotropyMapUv:HAS_ANISOTROPYMAP&&getChannel(material.anisotropyMap.channel),clearcoatMapUv:HAS_CLEARCOATMAP&&getChannel(material.clearcoatMap.channel),clearcoatNormalMapUv:HAS_CLEARCOAT_NORMALMAP&&getChannel(material.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:HAS_CLEARCOAT_ROUGHNESSMAP&&getChannel(material.clearcoatRoughnessMap.channel),iridescenceMapUv:HAS_IRIDESCENCEMAP&&getChannel(material.iridescenceMap.channel),iridescenceThicknessMapUv:HAS_IRIDESCENCE_THICKNESSMAP&&getChannel(material.iridescenceThicknessMap.channel),sheenColorMapUv:HAS_SHEEN_COLORMAP&&getChannel(material.sheenColorMap.channel),sheenRoughnessMapUv:HAS_SHEEN_ROUGHNESSMAP&&getChannel(material.sheenRoughnessMap.channel),specularMapUv:HAS_SPECULARMAP&&getChannel(material.specularMap.channel),specularColorMapUv:HAS_SPECULAR_COLORMAP&&getChannel(material.specularColorMap.channel),specularIntensityMapUv:HAS_SPECULAR_INTENSITYMAP&&getChannel(material.specularIntensityMap.channel),transmissionMapUv:HAS_TRANSMISSIONMAP&&getChannel(material.transmissionMap.channel),thicknessMapUv:HAS_THICKNESSMAP&&getChannel(material.thicknessMap.channel),alphaMapUv:HAS_ALPHAMAP&&getChannel(material.alphaMap.channel),//
	vertexTangents:!!geometry.attributes.tangent&&(HAS_NORMALMAP||HAS_ANISOTROPY),vertexColors:material.vertexColors,vertexAlphas:material.vertexColors===true&&!!geometry.attributes.color&&geometry.attributes.color.itemSize===4,pointsUvs:object.isPoints===true&&!!geometry.attributes.uv&&(HAS_MAP||HAS_ALPHAMAP),fog:!!fog,useFog:material.fog===true,fogExp2:!!fog&&fog.isFogExp2,flatShading:material.flatShading===true&&material.wireframe===false,sizeAttenuation:material.sizeAttenuation===true,logarithmicDepthBuffer:logarithmicDepthBuffer,reversedDepthBuffer:reversedDepthBuffer,skinning:object.isSkinnedMesh===true,morphTargets:geometry.morphAttributes.position!==undefined,morphNormals:geometry.morphAttributes.normal!==undefined,morphColors:geometry.morphAttributes.color!==undefined,morphTargetsCount:morphTargetsCount,morphTextureStride:morphTextureStride,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numSpotLightMaps:lights.spotLightMap.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numDirLightShadows:lights.directionalShadowMap.length,numPointLightShadows:lights.pointShadowMap.length,numSpotLightShadows:lights.spotShadowMap.length,numSpotLightShadowsWithMaps:lights.numSpotLightShadowsWithMaps,numLightProbes:lights.numLightProbes,numClippingPlanes:clipping.numPlanes,numClipIntersection:clipping.numIntersection,dithering:material.dithering,shadowMapEnabled:renderer.shadowMap.enabled&&shadows.length>0,shadowMapType:renderer.shadowMap.type,toneMapping:toneMapping,decodeVideoTexture:HAS_MAP&&material.map.isVideoTexture===true&&ColorManagement.getTransfer(material.map.colorSpace)===SRGBTransfer,decodeVideoTextureEmissive:HAS_EMISSIVEMAP&&material.emissiveMap.isVideoTexture===true&&ColorManagement.getTransfer(material.emissiveMap.colorSpace)===SRGBTransfer,premultipliedAlpha:material.premultipliedAlpha,doubleSided:material.side===DoubleSide,flipSided:material.side===BackSide,useDepthPacking:material.depthPacking>=0,depthPacking:material.depthPacking||0,index0AttributeName:material.index0AttributeName,extensionClipCullDistance:HAS_EXTENSIONS&&material.extensions.clipCullDistance===true&&extensions.has('WEBGL_clip_cull_distance'),extensionMultiDraw:(HAS_EXTENSIONS&&material.extensions.multiDraw===true||IS_BATCHEDMESH)&&extensions.has('WEBGL_multi_draw'),rendererExtensionParallelShaderCompile:extensions.has('KHR_parallel_shader_compile'),customProgramCacheKey:material.customProgramCacheKey()};// the usage of getChannel() determines the active texture channels for this shader
	parameters.vertexUv1s=_activeChannels.has(1);parameters.vertexUv2s=_activeChannels.has(2);parameters.vertexUv3s=_activeChannels.has(3);_activeChannels.clear();return parameters;}function getProgramCacheKey(parameters){const array=[];if(parameters.shaderID){array.push(parameters.shaderID);}else {array.push(parameters.customVertexShaderID);array.push(parameters.customFragmentShaderID);}if(parameters.defines!==undefined){for(const name in parameters.defines){array.push(name);array.push(parameters.defines[name]);}}if(parameters.isRawShaderMaterial===false){getProgramCacheKeyParameters(array,parameters);getProgramCacheKeyBooleans(array,parameters);array.push(renderer.outputColorSpace);}array.push(parameters.customProgramCacheKey);return array.join();}function getProgramCacheKeyParameters(array,parameters){array.push(parameters.precision);array.push(parameters.outputColorSpace);array.push(parameters.envMapMode);array.push(parameters.envMapCubeUVHeight);array.push(parameters.mapUv);array.push(parameters.alphaMapUv);array.push(parameters.lightMapUv);array.push(parameters.aoMapUv);array.push(parameters.bumpMapUv);array.push(parameters.normalMapUv);array.push(parameters.displacementMapUv);array.push(parameters.emissiveMapUv);array.push(parameters.metalnessMapUv);array.push(parameters.roughnessMapUv);array.push(parameters.anisotropyMapUv);array.push(parameters.clearcoatMapUv);array.push(parameters.clearcoatNormalMapUv);array.push(parameters.clearcoatRoughnessMapUv);array.push(parameters.iridescenceMapUv);array.push(parameters.iridescenceThicknessMapUv);array.push(parameters.sheenColorMapUv);array.push(parameters.sheenRoughnessMapUv);array.push(parameters.specularMapUv);array.push(parameters.specularColorMapUv);array.push(parameters.specularIntensityMapUv);array.push(parameters.transmissionMapUv);array.push(parameters.thicknessMapUv);array.push(parameters.combine);array.push(parameters.fogExp2);array.push(parameters.sizeAttenuation);array.push(parameters.morphTargetsCount);array.push(parameters.morphAttributeCount);array.push(parameters.numDirLights);array.push(parameters.numPointLights);array.push(parameters.numSpotLights);array.push(parameters.numSpotLightMaps);array.push(parameters.numHemiLights);array.push(parameters.numRectAreaLights);array.push(parameters.numDirLightShadows);array.push(parameters.numPointLightShadows);array.push(parameters.numSpotLightShadows);array.push(parameters.numSpotLightShadowsWithMaps);array.push(parameters.numLightProbes);array.push(parameters.shadowMapType);array.push(parameters.toneMapping);array.push(parameters.numClippingPlanes);array.push(parameters.numClipIntersection);array.push(parameters.depthPacking);}function getProgramCacheKeyBooleans(array,parameters){_programLayers.disableAll();if(parameters.supportsVertexTextures)_programLayers.enable(0);if(parameters.instancing)_programLayers.enable(1);if(parameters.instancingColor)_programLayers.enable(2);if(parameters.instancingMorph)_programLayers.enable(3);if(parameters.matcap)_programLayers.enable(4);if(parameters.envMap)_programLayers.enable(5);if(parameters.normalMapObjectSpace)_programLayers.enable(6);if(parameters.normalMapTangentSpace)_programLayers.enable(7);if(parameters.clearcoat)_programLayers.enable(8);if(parameters.iridescence)_programLayers.enable(9);if(parameters.alphaTest)_programLayers.enable(10);if(parameters.vertexColors)_programLayers.enable(11);if(parameters.vertexAlphas)_programLayers.enable(12);if(parameters.vertexUv1s)_programLayers.enable(13);if(parameters.vertexUv2s)_programLayers.enable(14);if(parameters.vertexUv3s)_programLayers.enable(15);if(parameters.vertexTangents)_programLayers.enable(16);if(parameters.anisotropy)_programLayers.enable(17);if(parameters.alphaHash)_programLayers.enable(18);if(parameters.batching)_programLayers.enable(19);if(parameters.dispersion)_programLayers.enable(20);if(parameters.batchingColor)_programLayers.enable(21);if(parameters.gradientMap)_programLayers.enable(22);array.push(_programLayers.mask);_programLayers.disableAll();if(parameters.fog)_programLayers.enable(0);if(parameters.useFog)_programLayers.enable(1);if(parameters.flatShading)_programLayers.enable(2);if(parameters.logarithmicDepthBuffer)_programLayers.enable(3);if(parameters.reversedDepthBuffer)_programLayers.enable(4);if(parameters.skinning)_programLayers.enable(5);if(parameters.morphTargets)_programLayers.enable(6);if(parameters.morphNormals)_programLayers.enable(7);if(parameters.morphColors)_programLayers.enable(8);if(parameters.premultipliedAlpha)_programLayers.enable(9);if(parameters.shadowMapEnabled)_programLayers.enable(10);if(parameters.doubleSided)_programLayers.enable(11);if(parameters.flipSided)_programLayers.enable(12);if(parameters.useDepthPacking)_programLayers.enable(13);if(parameters.dithering)_programLayers.enable(14);if(parameters.transmission)_programLayers.enable(15);if(parameters.sheen)_programLayers.enable(16);if(parameters.opaque)_programLayers.enable(17);if(parameters.pointsUvs)_programLayers.enable(18);if(parameters.decodeVideoTexture)_programLayers.enable(19);if(parameters.decodeVideoTextureEmissive)_programLayers.enable(20);if(parameters.alphaToCoverage)_programLayers.enable(21);array.push(_programLayers.mask);}function getUniforms(material){const shaderID=shaderIDs[material.type];let uniforms;if(shaderID){const shader=ShaderLib[shaderID];uniforms=UniformsUtils.clone(shader.uniforms);}else {uniforms=material.uniforms;}return uniforms;}function acquireProgram(parameters,cacheKey){let program;// Check if code has been already compiled
	for(let p=0,pl=programs.length;p<pl;p++){const preexistingProgram=programs[p];if(preexistingProgram.cacheKey===cacheKey){program=preexistingProgram;++program.usedTimes;break;}}if(program===undefined){program=new WebGLProgram(renderer,cacheKey,parameters,bindingStates);programs.push(program);}return program;}function releaseProgram(program){if(--program.usedTimes===0){// Remove from unordered set
	const i=programs.indexOf(program);programs[i]=programs[programs.length-1];programs.pop();// Free WebGL resources
	program.destroy();}}function releaseShaderCache(material){_customShaders.remove(material);}function dispose(){_customShaders.dispose();}return {getParameters:getParameters,getProgramCacheKey:getProgramCacheKey,getUniforms:getUniforms,acquireProgram:acquireProgram,releaseProgram:releaseProgram,releaseShaderCache:releaseShaderCache,// Exposed for resource monitoring & error feedback via renderer.info:
	programs:programs,dispose:dispose};}function WebGLProperties(){let properties=new WeakMap();function has(object){return properties.has(object);}function get(object){let map=properties.get(object);if(map===undefined){map={};properties.set(object,map);}return map;}function remove(object){properties.delete(object);}function update(object,key,value){properties.get(object)[key]=value;}function dispose(){properties=new WeakMap();}return {has:has,get:get,remove:remove,update:update,dispose:dispose};}function painterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.material.id!==b.material.id){return a.material.id-b.material.id;}else if(a.z!==b.z){return a.z-b.z;}else {return a.id-b.id;}}function reversePainterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.z!==b.z){return b.z-a.z;}else {return a.id-b.id;}}function WebGLRenderList(){const renderItems=[];let renderItemsIndex=0;const opaque=[];const transmissive=[];const transparent=[];function init(){renderItemsIndex=0;opaque.length=0;transmissive.length=0;transparent.length=0;}function getNextRenderItem(object,geometry,material,groupOrder,z,group){let renderItem=renderItems[renderItemsIndex];if(renderItem===undefined){renderItem={id:object.id,object:object,geometry:geometry,material:material,groupOrder:groupOrder,renderOrder:object.renderOrder,z:z,group:group};renderItems[renderItemsIndex]=renderItem;}else {renderItem.id=object.id;renderItem.object=object;renderItem.geometry=geometry;renderItem.material=material;renderItem.groupOrder=groupOrder;renderItem.renderOrder=object.renderOrder;renderItem.z=z;renderItem.group=group;}renderItemsIndex++;return renderItem;}function push(object,geometry,material,groupOrder,z,group){const renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);if(material.transmission>0.0){transmissive.push(renderItem);}else if(material.transparent===true){transparent.push(renderItem);}else {opaque.push(renderItem);}}function unshift(object,geometry,material,groupOrder,z,group){const renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);if(material.transmission>0.0){transmissive.unshift(renderItem);}else if(material.transparent===true){transparent.unshift(renderItem);}else {opaque.unshift(renderItem);}}function sort(customOpaqueSort,customTransparentSort){if(opaque.length>1)opaque.sort(customOpaqueSort||painterSortStable);if(transmissive.length>1)transmissive.sort(customTransparentSort||reversePainterSortStable);if(transparent.length>1)transparent.sort(customTransparentSort||reversePainterSortStable);}function finish(){// Clear references from inactive renderItems in the list
	for(let i=renderItemsIndex,il=renderItems.length;i<il;i++){const renderItem=renderItems[i];if(renderItem.id===null)break;renderItem.id=null;renderItem.object=null;renderItem.geometry=null;renderItem.material=null;renderItem.group=null;}}return {opaque:opaque,transmissive:transmissive,transparent:transparent,init:init,push:push,unshift:unshift,finish:finish,sort:sort};}function WebGLRenderLists(){let lists=new WeakMap();function get(scene,renderCallDepth){const listArray=lists.get(scene);let list;if(listArray===undefined){list=new WebGLRenderList();lists.set(scene,[list]);}else {if(renderCallDepth>=listArray.length){list=new WebGLRenderList();listArray.push(list);}else {list=listArray[renderCallDepth];}}return list;}function dispose(){lists=new WeakMap();}return {get:get,dispose:dispose};}function UniformsCache(){const lights={};return {get:function(light){if(lights[light.id]!==undefined){return lights[light.id];}let uniforms;switch(light.type){case 'DirectionalLight':uniforms={direction:new Vector3$1(),color:new Color()};break;case 'SpotLight':uniforms={position:new Vector3$1(),direction:new Vector3$1(),color:new Color(),distance:0,coneCos:0,penumbraCos:0,decay:0};break;case 'PointLight':uniforms={position:new Vector3$1(),color:new Color(),distance:0,decay:0};break;case 'HemisphereLight':uniforms={direction:new Vector3$1(),skyColor:new Color(),groundColor:new Color()};break;case 'RectAreaLight':uniforms={color:new Color(),position:new Vector3$1(),halfWidth:new Vector3$1(),halfHeight:new Vector3$1()};break;}lights[light.id]=uniforms;return uniforms;}};}function ShadowUniformsCache(){const lights={};return {get:function(light){if(lights[light.id]!==undefined){return lights[light.id];}let uniforms;switch(light.type){case 'DirectionalLight':uniforms={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2$1()};break;case 'SpotLight':uniforms={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2$1()};break;case 'PointLight':uniforms={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2$1(),shadowCameraNear:1,shadowCameraFar:1000};break;// TODO (abelnation): set RectAreaLight shadow uniforms
	}lights[light.id]=uniforms;return uniforms;}};}let nextVersion=0;function shadowCastingAndTexturingLightsFirst(lightA,lightB){return (lightB.castShadow?2:0)-(lightA.castShadow?2:0)+(lightB.map?1:0)-(lightA.map?1:0);}function WebGLLights(extensions){const cache=new UniformsCache();const shadowCache=ShadowUniformsCache();const state={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let i=0;i<9;i++)state.probe.push(new Vector3$1());const vector3=new Vector3$1();const matrix4=new Matrix4$1();const matrix42=new Matrix4$1();function setup(lights){let r=0,g=0,b=0;for(let i=0;i<9;i++)state.probe[i].set(0,0,0);let directionalLength=0;let pointLength=0;let spotLength=0;let rectAreaLength=0;let hemiLength=0;let numDirectionalShadows=0;let numPointShadows=0;let numSpotShadows=0;let numSpotMaps=0;let numSpotShadowsWithMaps=0;let numLightProbes=0;// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
	lights.sort(shadowCastingAndTexturingLightsFirst);for(let i=0,l=lights.length;i<l;i++){const light=lights[i];const color=light.color;const intensity=light.intensity;const distance=light.distance;const shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight){r+=color.r*intensity;g+=color.g*intensity;b+=color.b*intensity;}else if(light.isLightProbe){for(let j=0;j<9;j++){state.probe[j].addScaledVector(light.sh.coefficients[j],intensity);}numLightProbes++;}else if(light.isDirectionalLight){const uniforms=cache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity);if(light.castShadow){const shadow=light.shadow;const shadowUniforms=shadowCache.get(light);shadowUniforms.shadowIntensity=shadow.intensity;shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowNormalBias=shadow.normalBias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;state.directionalShadow[directionalLength]=shadowUniforms;state.directionalShadowMap[directionalLength]=shadowMap;state.directionalShadowMatrix[directionalLength]=light.shadow.matrix;numDirectionalShadows++;}state.directional[directionalLength]=uniforms;directionalLength++;}else if(light.isSpotLight){const uniforms=cache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.color.copy(color).multiplyScalar(intensity);uniforms.distance=distance;uniforms.coneCos=Math.cos(light.angle);uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));uniforms.decay=light.decay;state.spot[spotLength]=uniforms;const shadow=light.shadow;if(light.map){state.spotLightMap[numSpotMaps]=light.map;numSpotMaps++;// make sure the lightMatrix is up to date
	// TODO : do it if required only
	shadow.updateMatrices(light);if(light.castShadow)numSpotShadowsWithMaps++;}state.spotLightMatrix[spotLength]=shadow.matrix;if(light.castShadow){const shadowUniforms=shadowCache.get(light);shadowUniforms.shadowIntensity=shadow.intensity;shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowNormalBias=shadow.normalBias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;state.spotShadow[spotLength]=shadowUniforms;state.spotShadowMap[spotLength]=shadowMap;numSpotShadows++;}spotLength++;}else if(light.isRectAreaLight){const uniforms=cache.get(light);uniforms.color.copy(color).multiplyScalar(intensity);uniforms.halfWidth.set(light.width*0.5,0.0,0.0);uniforms.halfHeight.set(0.0,light.height*0.5,0.0);state.rectArea[rectAreaLength]=uniforms;rectAreaLength++;}else if(light.isPointLight){const uniforms=cache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.distance=light.distance;uniforms.decay=light.decay;if(light.castShadow){const shadow=light.shadow;const shadowUniforms=shadowCache.get(light);shadowUniforms.shadowIntensity=shadow.intensity;shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowNormalBias=shadow.normalBias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;shadowUniforms.shadowCameraNear=shadow.camera.near;shadowUniforms.shadowCameraFar=shadow.camera.far;state.pointShadow[pointLength]=shadowUniforms;state.pointShadowMap[pointLength]=shadowMap;state.pointShadowMatrix[pointLength]=light.shadow.matrix;numPointShadows++;}state.point[pointLength]=uniforms;pointLength++;}else if(light.isHemisphereLight){const uniforms=cache.get(light);uniforms.skyColor.copy(light.color).multiplyScalar(intensity);uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);state.hemi[hemiLength]=uniforms;hemiLength++;}}if(rectAreaLength>0){if(extensions.has('OES_texture_float_linear')===true){state.rectAreaLTC1=UniformsLib.LTC_FLOAT_1;state.rectAreaLTC2=UniformsLib.LTC_FLOAT_2;}else {state.rectAreaLTC1=UniformsLib.LTC_HALF_1;state.rectAreaLTC2=UniformsLib.LTC_HALF_2;}}state.ambient[0]=r;state.ambient[1]=g;state.ambient[2]=b;const hash=state.hash;if(hash.directionalLength!==directionalLength||hash.pointLength!==pointLength||hash.spotLength!==spotLength||hash.rectAreaLength!==rectAreaLength||hash.hemiLength!==hemiLength||hash.numDirectionalShadows!==numDirectionalShadows||hash.numPointShadows!==numPointShadows||hash.numSpotShadows!==numSpotShadows||hash.numSpotMaps!==numSpotMaps||hash.numLightProbes!==numLightProbes){state.directional.length=directionalLength;state.spot.length=spotLength;state.rectArea.length=rectAreaLength;state.point.length=pointLength;state.hemi.length=hemiLength;state.directionalShadow.length=numDirectionalShadows;state.directionalShadowMap.length=numDirectionalShadows;state.pointShadow.length=numPointShadows;state.pointShadowMap.length=numPointShadows;state.spotShadow.length=numSpotShadows;state.spotShadowMap.length=numSpotShadows;state.directionalShadowMatrix.length=numDirectionalShadows;state.pointShadowMatrix.length=numPointShadows;state.spotLightMatrix.length=numSpotShadows+numSpotMaps-numSpotShadowsWithMaps;state.spotLightMap.length=numSpotMaps;state.numSpotLightShadowsWithMaps=numSpotShadowsWithMaps;state.numLightProbes=numLightProbes;hash.directionalLength=directionalLength;hash.pointLength=pointLength;hash.spotLength=spotLength;hash.rectAreaLength=rectAreaLength;hash.hemiLength=hemiLength;hash.numDirectionalShadows=numDirectionalShadows;hash.numPointShadows=numPointShadows;hash.numSpotShadows=numSpotShadows;hash.numSpotMaps=numSpotMaps;hash.numLightProbes=numLightProbes;state.version=nextVersion++;}}function setupView(lights,camera){let directionalLength=0;let pointLength=0;let spotLength=0;let rectAreaLength=0;let hemiLength=0;const viewMatrix=camera.matrixWorldInverse;for(let i=0,l=lights.length;i<l;i++){const light=lights[i];if(light.isDirectionalLight){const uniforms=state.directional[directionalLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);directionalLength++;}else if(light.isSpotLight){const uniforms=state.spot[spotLength];uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);spotLength++;}else if(light.isRectAreaLight){const uniforms=state.rectArea[rectAreaLength];uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);// extract local rotation of light to derive width/height half vectors
	matrix42.identity();matrix4.copy(light.matrixWorld);matrix4.premultiply(viewMatrix);matrix42.extractRotation(matrix4);uniforms.halfWidth.set(light.width*0.5,0.0,0.0);uniforms.halfHeight.set(0.0,light.height*0.5,0.0);uniforms.halfWidth.applyMatrix4(matrix42);uniforms.halfHeight.applyMatrix4(matrix42);rectAreaLength++;}else if(light.isPointLight){const uniforms=state.point[pointLength];uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);pointLength++;}else if(light.isHemisphereLight){const uniforms=state.hemi[hemiLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld);uniforms.direction.transformDirection(viewMatrix);hemiLength++;}}}return {setup:setup,setupView:setupView,state:state};}function WebGLRenderState(extensions){const lights=new WebGLLights(extensions);const lightsArray=[];const shadowsArray=[];function init(camera){state.camera=camera;lightsArray.length=0;shadowsArray.length=0;}function pushLight(light){lightsArray.push(light);}function pushShadow(shadowLight){shadowsArray.push(shadowLight);}function setupLights(){lights.setup(lightsArray);}function setupLightsView(camera){lights.setupView(lightsArray,camera);}const state={lightsArray:lightsArray,shadowsArray:shadowsArray,camera:null,lights:lights,transmissionRenderTarget:{}};return {init:init,state:state,setupLights:setupLights,setupLightsView:setupLightsView,pushLight:pushLight,pushShadow:pushShadow};}function WebGLRenderStates(extensions){let renderStates=new WeakMap();function get(scene,renderCallDepth=0){const renderStateArray=renderStates.get(scene);let renderState;if(renderStateArray===undefined){renderState=new WebGLRenderState(extensions);renderStates.set(scene,[renderState]);}else {if(renderCallDepth>=renderStateArray.length){renderState=new WebGLRenderState(extensions);renderStateArray.push(renderState);}else {renderState=renderStateArray[renderCallDepth];}}return renderState;}function dispose(){renderStates=new WeakMap();}return {get:get,dispose:dispose};}const vertex="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";const fragment="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";function WebGLShadowMap(renderer,objects,capabilities){let _frustum=new Frustum();const _shadowMapSize=new Vector2$1(),_viewportSize=new Vector2$1(),_viewport=new Vector4(),_depthMaterial=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),_distanceMaterial=new MeshDistanceMaterial(),_materialCache={},_maxTextureSize=capabilities.maxTextureSize;const shadowSide={[FrontSide]:BackSide,[BackSide]:FrontSide,[DoubleSide]:DoubleSide};const shadowMaterialVertical=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2$1()},radius:{value:4.0}},vertexShader:vertex,fragmentShader:fragment});const shadowMaterialHorizontal=shadowMaterialVertical.clone();shadowMaterialHorizontal.defines.HORIZONTAL_PASS=1;const fullScreenTri=new BufferGeometry$1();fullScreenTri.setAttribute('position',new BufferAttribute$1(new Float32Array([-1,-1,0.5,3,-1,0.5,-1,3,0.5]),3));const fullScreenMesh=new Mesh(fullScreenTri,shadowMaterialVertical);const scope=this;this.enabled=false;this.autoUpdate=true;this.needsUpdate=false;this.type=PCFShadowMap;let _previousType=this.type;this.render=function(lights,scene,camera){if(scope.enabled===false)return;if(scope.autoUpdate===false&&scope.needsUpdate===false)return;if(lights.length===0)return;const currentRenderTarget=renderer.getRenderTarget();const activeCubeFace=renderer.getActiveCubeFace();const activeMipmapLevel=renderer.getActiveMipmapLevel();const _state=renderer.state;// Set GL state for depth map.
	_state.setBlending(NoBlending);if(_state.buffers.depth.getReversed()===true){_state.buffers.color.setClear(0,0,0,0);}else {_state.buffers.color.setClear(1,1,1,1);}_state.buffers.depth.setTest(true);_state.setScissorTest(false);// check for shadow map type changes
	const toVSM=_previousType!==VSMShadowMap&&this.type===VSMShadowMap;const fromVSM=_previousType===VSMShadowMap&&this.type!==VSMShadowMap;// render depth map
	for(let i=0,il=lights.length;i<il;i++){const light=lights[i];const shadow=light.shadow;if(shadow===undefined){warn$1('WebGLShadowMap:',light,'has no shadow.');continue;}if(shadow.autoUpdate===false&&shadow.needsUpdate===false)continue;_shadowMapSize.copy(shadow.mapSize);const shadowFrameExtents=shadow.getFrameExtents();_shadowMapSize.multiply(shadowFrameExtents);_viewportSize.copy(shadow.mapSize);if(_shadowMapSize.x>_maxTextureSize||_shadowMapSize.y>_maxTextureSize){if(_shadowMapSize.x>_maxTextureSize){_viewportSize.x=Math.floor(_maxTextureSize/shadowFrameExtents.x);_shadowMapSize.x=_viewportSize.x*shadowFrameExtents.x;shadow.mapSize.x=_viewportSize.x;}if(_shadowMapSize.y>_maxTextureSize){_viewportSize.y=Math.floor(_maxTextureSize/shadowFrameExtents.y);_shadowMapSize.y=_viewportSize.y*shadowFrameExtents.y;shadow.mapSize.y=_viewportSize.y;}}if(shadow.map===null||toVSM===true||fromVSM===true){const pars=this.type!==VSMShadowMap?{minFilter:NearestFilter,magFilter:NearestFilter}:{};if(shadow.map!==null){shadow.map.dispose();}shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.map.texture.name=light.name+'.shadowMap';shadow.camera.updateProjectionMatrix();}renderer.setRenderTarget(shadow.map);renderer.clear();const viewportCount=shadow.getViewportCount();for(let vp=0;vp<viewportCount;vp++){const viewport=shadow.getViewport(vp);_viewport.set(_viewportSize.x*viewport.x,_viewportSize.y*viewport.y,_viewportSize.x*viewport.z,_viewportSize.y*viewport.w);_state.viewport(_viewport);shadow.updateMatrices(light,vp);_frustum=shadow.getFrustum();renderObject(scene,camera,shadow.camera,light,this.type);}// do blur pass for VSM
	if(shadow.isPointLightShadow!==true&&this.type===VSMShadowMap){VSMPass(shadow,camera);}shadow.needsUpdate=false;}_previousType=this.type;scope.needsUpdate=false;renderer.setRenderTarget(currentRenderTarget,activeCubeFace,activeMipmapLevel);};function VSMPass(shadow,camera){const geometry=objects.update(fullScreenMesh);if(shadowMaterialVertical.defines.VSM_SAMPLES!==shadow.blurSamples){shadowMaterialVertical.defines.VSM_SAMPLES=shadow.blurSamples;shadowMaterialHorizontal.defines.VSM_SAMPLES=shadow.blurSamples;shadowMaterialVertical.needsUpdate=true;shadowMaterialHorizontal.needsUpdate=true;}if(shadow.mapPass===null){shadow.mapPass=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y);}// vertical pass
	shadowMaterialVertical.uniforms.shadow_pass.value=shadow.map.texture;shadowMaterialVertical.uniforms.resolution.value=shadow.mapSize;shadowMaterialVertical.uniforms.radius.value=shadow.radius;renderer.setRenderTarget(shadow.mapPass);renderer.clear();renderer.renderBufferDirect(camera,null,geometry,shadowMaterialVertical,fullScreenMesh,null);// horizontal pass
	shadowMaterialHorizontal.uniforms.shadow_pass.value=shadow.mapPass.texture;shadowMaterialHorizontal.uniforms.resolution.value=shadow.mapSize;shadowMaterialHorizontal.uniforms.radius.value=shadow.radius;renderer.setRenderTarget(shadow.map);renderer.clear();renderer.renderBufferDirect(camera,null,geometry,shadowMaterialHorizontal,fullScreenMesh,null);}function getDepthMaterial(object,material,light,type){let result=null;const customMaterial=light.isPointLight===true?object.customDistanceMaterial:object.customDepthMaterial;if(customMaterial!==undefined){result=customMaterial;}else {result=light.isPointLight===true?_distanceMaterial:_depthMaterial;if(renderer.localClippingEnabled&&material.clipShadows===true&&Array.isArray(material.clippingPlanes)&&material.clippingPlanes.length!==0||material.displacementMap&&material.displacementScale!==0||material.alphaMap&&material.alphaTest>0||material.map&&material.alphaTest>0||material.alphaToCoverage===true){// in this case we need a unique material instance reflecting the
	// appropriate state
	const keyA=result.uuid,keyB=material.uuid;let materialsForVariant=_materialCache[keyA];if(materialsForVariant===undefined){materialsForVariant={};_materialCache[keyA]=materialsForVariant;}let cachedMaterial=materialsForVariant[keyB];if(cachedMaterial===undefined){cachedMaterial=result.clone();materialsForVariant[keyB]=cachedMaterial;material.addEventListener('dispose',onMaterialDispose);}result=cachedMaterial;}}result.visible=material.visible;result.wireframe=material.wireframe;if(type===VSMShadowMap){result.side=material.shadowSide!==null?material.shadowSide:material.side;}else {result.side=material.shadowSide!==null?material.shadowSide:shadowSide[material.side];}result.alphaMap=material.alphaMap;result.alphaTest=material.alphaToCoverage===true?0.5:material.alphaTest;// approximate alphaToCoverage by using a fixed alphaTest value
	result.map=material.map;result.clipShadows=material.clipShadows;result.clippingPlanes=material.clippingPlanes;result.clipIntersection=material.clipIntersection;result.displacementMap=material.displacementMap;result.displacementScale=material.displacementScale;result.displacementBias=material.displacementBias;result.wireframeLinewidth=material.wireframeLinewidth;result.linewidth=material.linewidth;if(light.isPointLight===true&&result.isMeshDistanceMaterial===true){const materialProperties=renderer.properties.get(result);materialProperties.light=light;}return result;}function renderObject(object,camera,shadowCamera,light,type){if(object.visible===false)return;const visible=object.layers.test(camera.layers);if(visible&&(object.isMesh||object.isLine||object.isPoints)){if((object.castShadow||object.receiveShadow&&type===VSMShadowMap)&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);const geometry=objects.update(object);const material=object.material;if(Array.isArray(material)){const groups=geometry.groups;for(let k=0,kl=groups.length;k<kl;k++){const group=groups[k];const groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){const depthMaterial=getDepthMaterial(object,groupMaterial,light,type);object.onBeforeShadow(renderer,object,camera,shadowCamera,geometry,depthMaterial,group);renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);object.onAfterShadow(renderer,object,camera,shadowCamera,geometry,depthMaterial,group);}}}else if(material.visible){const depthMaterial=getDepthMaterial(object,material,light,type);object.onBeforeShadow(renderer,object,camera,shadowCamera,geometry,depthMaterial,null);renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,null);object.onAfterShadow(renderer,object,camera,shadowCamera,geometry,depthMaterial,null);}}}const children=object.children;for(let i=0,l=children.length;i<l;i++){renderObject(children[i],camera,shadowCamera,light,type);}}function onMaterialDispose(event){const material=event.target;material.removeEventListener('dispose',onMaterialDispose);// make sure to remove the unique distance/depth materials used for shadow map rendering
	for(const id in _materialCache){const cache=_materialCache[id];const uuid=event.target.uuid;if(uuid in cache){const shadowMaterial=cache[uuid];shadowMaterial.dispose();delete cache[uuid];}}}}const reversedFuncs={[NeverDepth]:AlwaysDepth,[LessDepth]:GreaterDepth,[EqualDepth]:NotEqualDepth,[LessEqualDepth]:GreaterEqualDepth,[AlwaysDepth]:NeverDepth,[GreaterDepth]:LessDepth,[NotEqualDepth]:EqualDepth,[GreaterEqualDepth]:LessEqualDepth};function WebGLState(gl,extensions){function ColorBuffer(){let locked=false;const color=new Vector4();let currentColorMask=null;const currentColorClear=new Vector4(0,0,0,0);return {setMask:function(colorMask){if(currentColorMask!==colorMask&&!locked){gl.colorMask(colorMask,colorMask,colorMask,colorMask);currentColorMask=colorMask;}},setLocked:function(lock){locked=lock;},setClear:function(r,g,b,a,premultipliedAlpha){if(premultipliedAlpha===true){r*=a;g*=a;b*=a;}color.set(r,g,b,a);if(currentColorClear.equals(color)===false){gl.clearColor(r,g,b,a);currentColorClear.copy(color);}},reset:function(){locked=false;currentColorMask=null;currentColorClear.set(-1,0,0,0);// set to invalid state
	}};}function DepthBuffer(){let locked=false;let currentReversed=false;let currentDepthMask=null;let currentDepthFunc=null;let currentDepthClear=null;return {setReversed:function(reversed){if(currentReversed!==reversed){const ext=extensions.get('EXT_clip_control');if(reversed){ext.clipControlEXT(ext.LOWER_LEFT_EXT,ext.ZERO_TO_ONE_EXT);}else {ext.clipControlEXT(ext.LOWER_LEFT_EXT,ext.NEGATIVE_ONE_TO_ONE_EXT);}currentReversed=reversed;const oldDepth=currentDepthClear;currentDepthClear=null;this.setClear(oldDepth);}},getReversed:function(){return currentReversed;},setTest:function(depthTest){if(depthTest){enable(gl.DEPTH_TEST);}else {disable(gl.DEPTH_TEST);}},setMask:function(depthMask){if(currentDepthMask!==depthMask&&!locked){gl.depthMask(depthMask);currentDepthMask=depthMask;}},setFunc:function(depthFunc){if(currentReversed)depthFunc=reversedFuncs[depthFunc];if(currentDepthFunc!==depthFunc){switch(depthFunc){case NeverDepth:gl.depthFunc(gl.NEVER);break;case AlwaysDepth:gl.depthFunc(gl.ALWAYS);break;case LessDepth:gl.depthFunc(gl.LESS);break;case LessEqualDepth:gl.depthFunc(gl.LEQUAL);break;case EqualDepth:gl.depthFunc(gl.EQUAL);break;case GreaterEqualDepth:gl.depthFunc(gl.GEQUAL);break;case GreaterDepth:gl.depthFunc(gl.GREATER);break;case NotEqualDepth:gl.depthFunc(gl.NOTEQUAL);break;default:gl.depthFunc(gl.LEQUAL);}currentDepthFunc=depthFunc;}},setLocked:function(lock){locked=lock;},setClear:function(depth){if(currentDepthClear!==depth){if(currentReversed){depth=1-depth;}gl.clearDepth(depth);currentDepthClear=depth;}},reset:function(){locked=false;currentDepthMask=null;currentDepthFunc=null;currentDepthClear=null;currentReversed=false;}};}function StencilBuffer(){let locked=false;let currentStencilMask=null;let currentStencilFunc=null;let currentStencilRef=null;let currentStencilFuncMask=null;let currentStencilFail=null;let currentStencilZFail=null;let currentStencilZPass=null;let currentStencilClear=null;return {setTest:function(stencilTest){if(!locked){if(stencilTest){enable(gl.STENCIL_TEST);}else {disable(gl.STENCIL_TEST);}}},setMask:function(stencilMask){if(currentStencilMask!==stencilMask&&!locked){gl.stencilMask(stencilMask);currentStencilMask=stencilMask;}},setFunc:function(stencilFunc,stencilRef,stencilMask){if(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask){gl.stencilFunc(stencilFunc,stencilRef,stencilMask);currentStencilFunc=stencilFunc;currentStencilRef=stencilRef;currentStencilFuncMask=stencilMask;}},setOp:function(stencilFail,stencilZFail,stencilZPass){if(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||currentStencilZPass!==stencilZPass){gl.stencilOp(stencilFail,stencilZFail,stencilZPass);currentStencilFail=stencilFail;currentStencilZFail=stencilZFail;currentStencilZPass=stencilZPass;}},setLocked:function(lock){locked=lock;},setClear:function(stencil){if(currentStencilClear!==stencil){gl.clearStencil(stencil);currentStencilClear=stencil;}},reset:function(){locked=false;currentStencilMask=null;currentStencilFunc=null;currentStencilRef=null;currentStencilFuncMask=null;currentStencilFail=null;currentStencilZFail=null;currentStencilZPass=null;currentStencilClear=null;}};}//
	const colorBuffer=new ColorBuffer();const depthBuffer=new DepthBuffer();const stencilBuffer=new StencilBuffer();const uboBindings=new WeakMap();const uboProgramMap=new WeakMap();let enabledCapabilities={};let currentBoundFramebuffers={};let currentDrawbuffers=new WeakMap();let defaultDrawbuffers=[];let currentProgram=null;let currentBlendingEnabled=false;let currentBlending=null;let currentBlendEquation=null;let currentBlendSrc=null;let currentBlendDst=null;let currentBlendEquationAlpha=null;let currentBlendSrcAlpha=null;let currentBlendDstAlpha=null;let currentBlendColor=new Color(0,0,0);let currentBlendAlpha=0;let currentPremultipledAlpha=false;let currentFlipSided=null;let currentCullFace=null;let currentLineWidth=null;let currentPolygonOffsetFactor=null;let currentPolygonOffsetUnits=null;const maxTextures=gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let lineWidthAvailable=false;let version=0;const glVersion=gl.getParameter(gl.VERSION);if(glVersion.indexOf('WebGL')!==-1){version=parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);lineWidthAvailable=version>=1.0;}else if(glVersion.indexOf('OpenGL ES')!==-1){version=parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);lineWidthAvailable=version>=2.0;}let currentTextureSlot=null;let currentBoundTextures={};const scissorParam=gl.getParameter(gl.SCISSOR_BOX);const viewportParam=gl.getParameter(gl.VIEWPORT);const currentScissor=new Vector4().fromArray(scissorParam);const currentViewport=new Vector4().fromArray(viewportParam);function createTexture(type,target,count,dimensions){const data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.
	const texture=gl.createTexture();gl.bindTexture(type,texture);gl.texParameteri(type,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(type,gl.TEXTURE_MAG_FILTER,gl.NEAREST);for(let i=0;i<count;i++){if(type===gl.TEXTURE_3D||type===gl.TEXTURE_2D_ARRAY){gl.texImage3D(target,0,gl.RGBA,1,1,dimensions,0,gl.RGBA,gl.UNSIGNED_BYTE,data);}else {gl.texImage2D(target+i,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,data);}}return texture;}const emptyTextures={};emptyTextures[gl.TEXTURE_2D]=createTexture(gl.TEXTURE_2D,gl.TEXTURE_2D,1);emptyTextures[gl.TEXTURE_CUBE_MAP]=createTexture(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_CUBE_MAP_POSITIVE_X,6);emptyTextures[gl.TEXTURE_2D_ARRAY]=createTexture(gl.TEXTURE_2D_ARRAY,gl.TEXTURE_2D_ARRAY,1,1);emptyTextures[gl.TEXTURE_3D]=createTexture(gl.TEXTURE_3D,gl.TEXTURE_3D,1,1);// init
	colorBuffer.setClear(0,0,0,1);depthBuffer.setClear(1);stencilBuffer.setClear(0);enable(gl.DEPTH_TEST);depthBuffer.setFunc(LessEqualDepth);setFlipSided(false);setCullFace(CullFaceBack);enable(gl.CULL_FACE);setBlending(NoBlending);//
	function enable(id){if(enabledCapabilities[id]!==true){gl.enable(id);enabledCapabilities[id]=true;}}function disable(id){if(enabledCapabilities[id]!==false){gl.disable(id);enabledCapabilities[id]=false;}}function bindFramebuffer(target,framebuffer){if(currentBoundFramebuffers[target]!==framebuffer){gl.bindFramebuffer(target,framebuffer);currentBoundFramebuffers[target]=framebuffer;// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER
	if(target===gl.DRAW_FRAMEBUFFER){currentBoundFramebuffers[gl.FRAMEBUFFER]=framebuffer;}if(target===gl.FRAMEBUFFER){currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER]=framebuffer;}return true;}return false;}function drawBuffers(renderTarget,framebuffer){let drawBuffers=defaultDrawbuffers;let needsUpdate=false;if(renderTarget){drawBuffers=currentDrawbuffers.get(framebuffer);if(drawBuffers===undefined){drawBuffers=[];currentDrawbuffers.set(framebuffer,drawBuffers);}const textures=renderTarget.textures;if(drawBuffers.length!==textures.length||drawBuffers[0]!==gl.COLOR_ATTACHMENT0){for(let i=0,il=textures.length;i<il;i++){drawBuffers[i]=gl.COLOR_ATTACHMENT0+i;}drawBuffers.length=textures.length;needsUpdate=true;}}else {if(drawBuffers[0]!==gl.BACK){drawBuffers[0]=gl.BACK;needsUpdate=true;}}if(needsUpdate){gl.drawBuffers(drawBuffers);}}function useProgram(program){if(currentProgram!==program){gl.useProgram(program);currentProgram=program;return true;}return false;}const equationToGL={[AddEquation]:gl.FUNC_ADD,[SubtractEquation]:gl.FUNC_SUBTRACT,[ReverseSubtractEquation]:gl.FUNC_REVERSE_SUBTRACT};equationToGL[MinEquation]=gl.MIN;equationToGL[MaxEquation]=gl.MAX;const factorToGL={[ZeroFactor]:gl.ZERO,[OneFactor]:gl.ONE,[SrcColorFactor]:gl.SRC_COLOR,[SrcAlphaFactor]:gl.SRC_ALPHA,[SrcAlphaSaturateFactor]:gl.SRC_ALPHA_SATURATE,[DstColorFactor]:gl.DST_COLOR,[DstAlphaFactor]:gl.DST_ALPHA,[OneMinusSrcColorFactor]:gl.ONE_MINUS_SRC_COLOR,[OneMinusSrcAlphaFactor]:gl.ONE_MINUS_SRC_ALPHA,[OneMinusDstColorFactor]:gl.ONE_MINUS_DST_COLOR,[OneMinusDstAlphaFactor]:gl.ONE_MINUS_DST_ALPHA,[ConstantColorFactor]:gl.CONSTANT_COLOR,[OneMinusConstantColorFactor]:gl.ONE_MINUS_CONSTANT_COLOR,[ConstantAlphaFactor]:gl.CONSTANT_ALPHA,[OneMinusConstantAlphaFactor]:gl.ONE_MINUS_CONSTANT_ALPHA};function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,blendColor,blendAlpha,premultipliedAlpha){if(blending===NoBlending){if(currentBlendingEnabled===true){disable(gl.BLEND);currentBlendingEnabled=false;}return;}if(currentBlendingEnabled===false){enable(gl.BLEND);currentBlendingEnabled=true;}if(blending!==CustomBlending){if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){if(currentBlendEquation!==AddEquation||currentBlendEquationAlpha!==AddEquation){gl.blendEquation(gl.FUNC_ADD);currentBlendEquation=AddEquation;currentBlendEquationAlpha=AddEquation;}if(premultipliedAlpha){switch(blending){case NormalBlending:gl.blendFuncSeparate(gl.ONE,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:gl.blendFunc(gl.ONE,gl.ONE);break;case SubtractiveBlending:gl.blendFuncSeparate(gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ZERO,gl.ONE);break;case MultiplyBlending:gl.blendFuncSeparate(gl.DST_COLOR,gl.ONE_MINUS_SRC_ALPHA,gl.ZERO,gl.ONE);break;default:error$1('WebGLState: Invalid blending: ',blending);break;}}else {switch(blending){case NormalBlending:gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE,gl.ONE,gl.ONE);break;case SubtractiveBlending:error$1('WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true');break;case MultiplyBlending:error$1('WebGLState: MultiplyBlending requires material.premultipliedAlpha = true');break;default:error$1('WebGLState: Invalid blending: ',blending);break;}}currentBlendSrc=null;currentBlendDst=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;currentBlendColor.set(0,0,0);currentBlendAlpha=0;currentBlending=blending;currentPremultipledAlpha=premultipliedAlpha;}return;}// custom blending
	blendEquationAlpha=blendEquationAlpha||blendEquation;blendSrcAlpha=blendSrcAlpha||blendSrc;blendDstAlpha=blendDstAlpha||blendDst;if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){gl.blendEquationSeparate(equationToGL[blendEquation],equationToGL[blendEquationAlpha]);currentBlendEquation=blendEquation;currentBlendEquationAlpha=blendEquationAlpha;}if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){gl.blendFuncSeparate(factorToGL[blendSrc],factorToGL[blendDst],factorToGL[blendSrcAlpha],factorToGL[blendDstAlpha]);currentBlendSrc=blendSrc;currentBlendDst=blendDst;currentBlendSrcAlpha=blendSrcAlpha;currentBlendDstAlpha=blendDstAlpha;}if(blendColor.equals(currentBlendColor)===false||blendAlpha!==currentBlendAlpha){gl.blendColor(blendColor.r,blendColor.g,blendColor.b,blendAlpha);currentBlendColor.copy(blendColor);currentBlendAlpha=blendAlpha;}currentBlending=blending;currentPremultipledAlpha=false;}function setMaterial(material,frontFaceCW){material.side===DoubleSide?disable(gl.CULL_FACE):enable(gl.CULL_FACE);let flipSided=material.side===BackSide;if(frontFaceCW)flipSided=!flipSided;setFlipSided(flipSided);material.blending===NormalBlending&&material.transparent===false?setBlending(NoBlending):setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.blendColor,material.blendAlpha,material.premultipliedAlpha);depthBuffer.setFunc(material.depthFunc);depthBuffer.setTest(material.depthTest);depthBuffer.setMask(material.depthWrite);colorBuffer.setMask(material.colorWrite);const stencilWrite=material.stencilWrite;stencilBuffer.setTest(stencilWrite);if(stencilWrite){stencilBuffer.setMask(material.stencilWriteMask);stencilBuffer.setFunc(material.stencilFunc,material.stencilRef,material.stencilFuncMask);stencilBuffer.setOp(material.stencilFail,material.stencilZFail,material.stencilZPass);}setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);material.alphaToCoverage===true?enable(gl.SAMPLE_ALPHA_TO_COVERAGE):disable(gl.SAMPLE_ALPHA_TO_COVERAGE);}//
	function setFlipSided(flipSided){if(currentFlipSided!==flipSided){if(flipSided){gl.frontFace(gl.CW);}else {gl.frontFace(gl.CCW);}currentFlipSided=flipSided;}}function setCullFace(cullFace){if(cullFace!==CullFaceNone){enable(gl.CULL_FACE);if(cullFace!==currentCullFace){if(cullFace===CullFaceBack){gl.cullFace(gl.BACK);}else if(cullFace===CullFaceFront){gl.cullFace(gl.FRONT);}else {gl.cullFace(gl.FRONT_AND_BACK);}}}else {disable(gl.CULL_FACE);}currentCullFace=cullFace;}function setLineWidth(width){if(width!==currentLineWidth){if(lineWidthAvailable)gl.lineWidth(width);currentLineWidth=width;}}function setPolygonOffset(polygonOffset,factor,units){if(polygonOffset){enable(gl.POLYGON_OFFSET_FILL);if(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){gl.polygonOffset(factor,units);currentPolygonOffsetFactor=factor;currentPolygonOffsetUnits=units;}}else {disable(gl.POLYGON_OFFSET_FILL);}}function setScissorTest(scissorTest){if(scissorTest){enable(gl.SCISSOR_TEST);}else {disable(gl.SCISSOR_TEST);}}// texture
	function activeTexture(webglSlot){if(webglSlot===undefined)webglSlot=gl.TEXTURE0+maxTextures-1;if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}}function bindTexture(webglType,webglTexture,webglSlot){if(webglSlot===undefined){if(currentTextureSlot===null){webglSlot=gl.TEXTURE0+maxTextures-1;}else {webglSlot=currentTextureSlot;}}let boundTexture=currentBoundTextures[webglSlot];if(boundTexture===undefined){boundTexture={type:undefined,texture:undefined};currentBoundTextures[webglSlot]=boundTexture;}if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);boundTexture.type=webglType;boundTexture.texture=webglTexture;}}function unbindTexture(){const boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture!==undefined&&boundTexture.type!==undefined){gl.bindTexture(boundTexture.type,null);boundTexture.type=undefined;boundTexture.texture=undefined;}}function compressedTexImage2D(){try{gl.compressedTexImage2D(...arguments);}catch(error){error('WebGLState:',error);}}function compressedTexImage3D(){try{gl.compressedTexImage3D(...arguments);}catch(error){error('WebGLState:',error);}}function texSubImage2D(){try{gl.texSubImage2D(...arguments);}catch(error){error('WebGLState:',error);}}function texSubImage3D(){try{gl.texSubImage3D(...arguments);}catch(error){error('WebGLState:',error);}}function compressedTexSubImage2D(){try{gl.compressedTexSubImage2D(...arguments);}catch(error){error('WebGLState:',error);}}function compressedTexSubImage3D(){try{gl.compressedTexSubImage3D(...arguments);}catch(error){error('WebGLState:',error);}}function texStorage2D(){try{gl.texStorage2D(...arguments);}catch(error){error('WebGLState:',error);}}function texStorage3D(){try{gl.texStorage3D(...arguments);}catch(error){error('WebGLState:',error);}}function texImage2D(){try{gl.texImage2D(...arguments);}catch(error){error('WebGLState:',error);}}function texImage3D(){try{gl.texImage3D(...arguments);}catch(error){error('WebGLState:',error);}}//
	function scissor(scissor){if(currentScissor.equals(scissor)===false){gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);currentScissor.copy(scissor);}}function viewport(viewport){if(currentViewport.equals(viewport)===false){gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);currentViewport.copy(viewport);}}function updateUBOMapping(uniformsGroup,program){let mapping=uboProgramMap.get(program);if(mapping===undefined){mapping=new WeakMap();uboProgramMap.set(program,mapping);}let blockIndex=mapping.get(uniformsGroup);if(blockIndex===undefined){blockIndex=gl.getUniformBlockIndex(program,uniformsGroup.name);mapping.set(uniformsGroup,blockIndex);}}function uniformBlockBinding(uniformsGroup,program){const mapping=uboProgramMap.get(program);const blockIndex=mapping.get(uniformsGroup);if(uboBindings.get(program)!==blockIndex){// bind shader specific block index to global block point
	gl.uniformBlockBinding(program,blockIndex,uniformsGroup.__bindingPointIndex);uboBindings.set(program,blockIndex);}}//
	function reset(){// reset state
	gl.disable(gl.BLEND);gl.disable(gl.CULL_FACE);gl.disable(gl.DEPTH_TEST);gl.disable(gl.POLYGON_OFFSET_FILL);gl.disable(gl.SCISSOR_TEST);gl.disable(gl.STENCIL_TEST);gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ONE,gl.ZERO);gl.blendFuncSeparate(gl.ONE,gl.ZERO,gl.ONE,gl.ZERO);gl.blendColor(0,0,0,0);gl.colorMask(true,true,true,true);gl.clearColor(0,0,0,0);gl.depthMask(true);gl.depthFunc(gl.LESS);depthBuffer.setReversed(false);gl.clearDepth(1);gl.stencilMask(0xffffffff);gl.stencilFunc(gl.ALWAYS,0,0xffffffff);gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);gl.clearStencil(0);gl.cullFace(gl.BACK);gl.frontFace(gl.CCW);gl.polygonOffset(0,0);gl.activeTexture(gl.TEXTURE0);gl.bindFramebuffer(gl.FRAMEBUFFER,null);gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER,null);gl.bindFramebuffer(gl.READ_FRAMEBUFFER,null);gl.useProgram(null);gl.lineWidth(1);gl.scissor(0,0,gl.canvas.width,gl.canvas.height);gl.viewport(0,0,gl.canvas.width,gl.canvas.height);// reset internals
	enabledCapabilities={};currentTextureSlot=null;currentBoundTextures={};currentBoundFramebuffers={};currentDrawbuffers=new WeakMap();defaultDrawbuffers=[];currentProgram=null;currentBlendingEnabled=false;currentBlending=null;currentBlendEquation=null;currentBlendSrc=null;currentBlendDst=null;currentBlendEquationAlpha=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;currentBlendColor=new Color(0,0,0);currentBlendAlpha=0;currentPremultipledAlpha=false;currentFlipSided=null;currentCullFace=null;currentLineWidth=null;currentPolygonOffsetFactor=null;currentPolygonOffsetUnits=null;currentScissor.set(0,0,gl.canvas.width,gl.canvas.height);currentViewport.set(0,0,gl.canvas.width,gl.canvas.height);colorBuffer.reset();depthBuffer.reset();stencilBuffer.reset();}return {buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},enable:enable,disable:disable,bindFramebuffer:bindFramebuffer,drawBuffers:drawBuffers,useProgram:useProgram,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,unbindTexture:unbindTexture,compressedTexImage2D:compressedTexImage2D,compressedTexImage3D:compressedTexImage3D,texImage2D:texImage2D,texImage3D:texImage3D,updateUBOMapping:updateUBOMapping,uniformBlockBinding:uniformBlockBinding,texStorage2D:texStorage2D,texStorage3D:texStorage3D,texSubImage2D:texSubImage2D,texSubImage3D:texSubImage3D,compressedTexSubImage2D:compressedTexSubImage2D,compressedTexSubImage3D:compressedTexSubImage3D,scissor:scissor,viewport:viewport,reset:reset};}function WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info){const multisampledRTTExt=extensions.has('WEBGL_multisampled_render_to_texture')?extensions.get('WEBGL_multisampled_render_to_texture'):null;const supportsInvalidateFramebuffer=typeof navigator==='undefined'?false:/OculusBrowser/g.test(navigator.userAgent);const _imageDimensions=new Vector2$1();const _videoTextures=new WeakMap();let _canvas;const _sources=new WeakMap();// maps WebglTexture objects to instances of Source
	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
	let useOffscreenCanvas=false;try{useOffscreenCanvas=typeof OffscreenCanvas!=='undefined'// eslint-disable-next-line compat/compat
	&&new OffscreenCanvas(1,1).getContext('2d')!==null;}catch(err){// Ignore any errors
	}function createCanvas(width,height){// Use OffscreenCanvas when available. Specially needed in web workers
	return useOffscreenCanvas?// eslint-disable-next-line compat/compat
	new OffscreenCanvas(width,height):createElementNS('canvas');}function resizeImage(image,needsNewCanvas,maxSize){let scale=1;const dimensions=getDimensions(image);// handle case if texture exceeds max size
	if(dimensions.width>maxSize||dimensions.height>maxSize){scale=maxSize/Math.max(dimensions.width,dimensions.height);}// only perform resize if necessary
	if(scale<1){// only perform resize for certain image types
	if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap||typeof VideoFrame!=='undefined'&&image instanceof VideoFrame){const width=Math.floor(scale*dimensions.width);const height=Math.floor(scale*dimensions.height);if(_canvas===undefined)_canvas=createCanvas(width,height);// cube textures can't reuse the same canvas
	const canvas=needsNewCanvas?createCanvas(width,height):_canvas;canvas.width=width;canvas.height=height;const context=canvas.getContext('2d');context.drawImage(image,0,0,width,height);warn$1('WebGLRenderer: Texture has been resized from ('+dimensions.width+'x'+dimensions.height+') to ('+width+'x'+height+').');return canvas;}else {if('data'in image){warn$1('WebGLRenderer: Image in DataTexture is too big ('+dimensions.width+'x'+dimensions.height+').');}return image;}}return image;}function textureNeedsGenerateMipmaps(texture){return texture.generateMipmaps;}function generateMipmap(target){_gl.generateMipmap(target);}function getTargetType(texture){if(texture.isWebGLCubeRenderTarget)return _gl.TEXTURE_CUBE_MAP;if(texture.isWebGL3DRenderTarget)return _gl.TEXTURE_3D;if(texture.isWebGLArrayRenderTarget||texture.isCompressedArrayTexture)return _gl.TEXTURE_2D_ARRAY;return _gl.TEXTURE_2D;}function getInternalFormat(internalFormatName,glFormat,glType,colorSpace,forceLinearTransfer=false){if(internalFormatName!==null){if(_gl[internalFormatName]!==undefined)return _gl[internalFormatName];warn$1('WebGLRenderer: Attempt to use non-existing WebGL internal format \''+internalFormatName+'\'');}let internalFormat=glFormat;if(glFormat===_gl.RED){if(glType===_gl.FLOAT)internalFormat=_gl.R32F;if(glType===_gl.HALF_FLOAT)internalFormat=_gl.R16F;if(glType===_gl.UNSIGNED_BYTE)internalFormat=_gl.R8;}if(glFormat===_gl.RED_INTEGER){if(glType===_gl.UNSIGNED_BYTE)internalFormat=_gl.R8UI;if(glType===_gl.UNSIGNED_SHORT)internalFormat=_gl.R16UI;if(glType===_gl.UNSIGNED_INT)internalFormat=_gl.R32UI;if(glType===_gl.BYTE)internalFormat=_gl.R8I;if(glType===_gl.SHORT)internalFormat=_gl.R16I;if(glType===_gl.INT)internalFormat=_gl.R32I;}if(glFormat===_gl.RG){if(glType===_gl.FLOAT)internalFormat=_gl.RG32F;if(glType===_gl.HALF_FLOAT)internalFormat=_gl.RG16F;if(glType===_gl.UNSIGNED_BYTE)internalFormat=_gl.RG8;}if(glFormat===_gl.RG_INTEGER){if(glType===_gl.UNSIGNED_BYTE)internalFormat=_gl.RG8UI;if(glType===_gl.UNSIGNED_SHORT)internalFormat=_gl.RG16UI;if(glType===_gl.UNSIGNED_INT)internalFormat=_gl.RG32UI;if(glType===_gl.BYTE)internalFormat=_gl.RG8I;if(glType===_gl.SHORT)internalFormat=_gl.RG16I;if(glType===_gl.INT)internalFormat=_gl.RG32I;}if(glFormat===_gl.RGB_INTEGER){if(glType===_gl.UNSIGNED_BYTE)internalFormat=_gl.RGB8UI;if(glType===_gl.UNSIGNED_SHORT)internalFormat=_gl.RGB16UI;if(glType===_gl.UNSIGNED_INT)internalFormat=_gl.RGB32UI;if(glType===_gl.BYTE)internalFormat=_gl.RGB8I;if(glType===_gl.SHORT)internalFormat=_gl.RGB16I;if(glType===_gl.INT)internalFormat=_gl.RGB32I;}if(glFormat===_gl.RGBA_INTEGER){if(glType===_gl.UNSIGNED_BYTE)internalFormat=_gl.RGBA8UI;if(glType===_gl.UNSIGNED_SHORT)internalFormat=_gl.RGBA16UI;if(glType===_gl.UNSIGNED_INT)internalFormat=_gl.RGBA32UI;if(glType===_gl.BYTE)internalFormat=_gl.RGBA8I;if(glType===_gl.SHORT)internalFormat=_gl.RGBA16I;if(glType===_gl.INT)internalFormat=_gl.RGBA32I;}if(glFormat===_gl.RGB){if(glType===_gl.UNSIGNED_INT_5_9_9_9_REV)internalFormat=_gl.RGB9_E5;if(glType===_gl.UNSIGNED_INT_10F_11F_11F_REV)internalFormat=_gl.R11F_G11F_B10F;}if(glFormat===_gl.RGBA){const transfer=forceLinearTransfer?LinearTransfer:ColorManagement.getTransfer(colorSpace);if(glType===_gl.FLOAT)internalFormat=_gl.RGBA32F;if(glType===_gl.HALF_FLOAT)internalFormat=_gl.RGBA16F;if(glType===_gl.UNSIGNED_BYTE)internalFormat=transfer===SRGBTransfer?_gl.SRGB8_ALPHA8:_gl.RGBA8;if(glType===_gl.UNSIGNED_SHORT_4_4_4_4)internalFormat=_gl.RGBA4;if(glType===_gl.UNSIGNED_SHORT_5_5_5_1)internalFormat=_gl.RGB5_A1;}if(internalFormat===_gl.R16F||internalFormat===_gl.R32F||internalFormat===_gl.RG16F||internalFormat===_gl.RG32F||internalFormat===_gl.RGBA16F||internalFormat===_gl.RGBA32F){extensions.get('EXT_color_buffer_float');}return internalFormat;}function getInternalDepthFormat(useStencil,depthType){let glInternalFormat;if(useStencil){if(depthType===null||depthType===UnsignedIntType||depthType===UnsignedInt248Type){glInternalFormat=_gl.DEPTH24_STENCIL8;}else if(depthType===FloatType$1){glInternalFormat=_gl.DEPTH32F_STENCIL8;}else if(depthType===UnsignedShortType){glInternalFormat=_gl.DEPTH24_STENCIL8;warn$1('DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.');}}else {if(depthType===null||depthType===UnsignedIntType||depthType===UnsignedInt248Type){glInternalFormat=_gl.DEPTH_COMPONENT24;}else if(depthType===FloatType$1){glInternalFormat=_gl.DEPTH_COMPONENT32F;}else if(depthType===UnsignedShortType){glInternalFormat=_gl.DEPTH_COMPONENT16;}}return glInternalFormat;}function getMipLevels(texture,image){if(textureNeedsGenerateMipmaps(texture)===true||texture.isFramebufferTexture&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){return Math.log2(Math.max(image.width,image.height))+1;}else if(texture.mipmaps!==undefined&&texture.mipmaps.length>0){// user-defined mipmaps
	return texture.mipmaps.length;}else if(texture.isCompressedTexture&&Array.isArray(texture.image)){return image.mipmaps.length;}else {// texture without mipmaps (only base level)
	return 1;}}//
	function onTextureDispose(event){const texture=event.target;texture.removeEventListener('dispose',onTextureDispose);deallocateTexture(texture);if(texture.isVideoTexture){_videoTextures.delete(texture);}}function onRenderTargetDispose(event){const renderTarget=event.target;renderTarget.removeEventListener('dispose',onRenderTargetDispose);deallocateRenderTarget(renderTarget);}//
	function deallocateTexture(texture){const textureProperties=properties.get(texture);if(textureProperties.__webglInit===undefined)return;// check if it's necessary to remove the WebGLTexture object
	const source=texture.source;const webglTextures=_sources.get(source);if(webglTextures){const webglTexture=webglTextures[textureProperties.__cacheKey];webglTexture.usedTimes--;// the WebGLTexture object is not used anymore, remove it
	if(webglTexture.usedTimes===0){deleteTexture(texture);}// remove the weak map entry if no WebGLTexture uses the source anymore
	if(Object.keys(webglTextures).length===0){_sources.delete(source);}}properties.remove(texture);}function deleteTexture(texture){const textureProperties=properties.get(texture);_gl.deleteTexture(textureProperties.__webglTexture);const source=texture.source;const webglTextures=_sources.get(source);delete webglTextures[textureProperties.__cacheKey];info.memory.textures--;}function deallocateRenderTarget(renderTarget){const renderTargetProperties=properties.get(renderTarget);if(renderTarget.depthTexture){renderTarget.depthTexture.dispose();properties.remove(renderTarget.depthTexture);}if(renderTarget.isWebGLCubeRenderTarget){for(let i=0;i<6;i++){if(Array.isArray(renderTargetProperties.__webglFramebuffer[i])){for(let level=0;level<renderTargetProperties.__webglFramebuffer[i].length;level++)_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);}else {_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);}if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);}}else {if(Array.isArray(renderTargetProperties.__webglFramebuffer)){for(let level=0;level<renderTargetProperties.__webglFramebuffer.length;level++)_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);}else {_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);}if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);if(renderTargetProperties.__webglMultisampledFramebuffer)_gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);if(renderTargetProperties.__webglColorRenderbuffer){for(let i=0;i<renderTargetProperties.__webglColorRenderbuffer.length;i++){if(renderTargetProperties.__webglColorRenderbuffer[i])_gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);}}if(renderTargetProperties.__webglDepthRenderbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);}const textures=renderTarget.textures;for(let i=0,il=textures.length;i<il;i++){const attachmentProperties=properties.get(textures[i]);if(attachmentProperties.__webglTexture){_gl.deleteTexture(attachmentProperties.__webglTexture);info.memory.textures--;}properties.remove(textures[i]);}properties.remove(renderTarget);}//
	let textureUnits=0;function resetTextureUnits(){textureUnits=0;}function allocateTextureUnit(){const textureUnit=textureUnits;if(textureUnit>=capabilities.maxTextures){warn$1('WebGLTextures: Trying to use '+textureUnit+' texture units while this GPU supports only '+capabilities.maxTextures);}textureUnits+=1;return textureUnit;}function getTextureCacheKey(texture){const array=[];array.push(texture.wrapS);array.push(texture.wrapT);array.push(texture.wrapR||0);array.push(texture.magFilter);array.push(texture.minFilter);array.push(texture.anisotropy);array.push(texture.internalFormat);array.push(texture.format);array.push(texture.type);array.push(texture.generateMipmaps);array.push(texture.premultiplyAlpha);array.push(texture.flipY);array.push(texture.unpackAlignment);array.push(texture.colorSpace);return array.join();}//
	function setTexture2D(texture,slot){const textureProperties=properties.get(texture);if(texture.isVideoTexture)updateVideoTexture(texture);if(texture.isRenderTargetTexture===false&&texture.isExternalTexture!==true&&texture.version>0&&textureProperties.__version!==texture.version){const image=texture.image;if(image===null){warn$1('WebGLRenderer: Texture marked for update but no image data found.');}else if(image.complete===false){warn$1('WebGLRenderer: Texture marked for update but image is incomplete');}else {uploadTexture(textureProperties,texture,slot);return;}}else if(texture.isExternalTexture){textureProperties.__webglTexture=texture.sourceTexture?texture.sourceTexture:null;}state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture,_gl.TEXTURE0+slot);}function setTexture2DArray(texture,slot){const textureProperties=properties.get(texture);if(texture.isRenderTargetTexture===false&&texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}else if(texture.isExternalTexture){textureProperties.__webglTexture=texture.sourceTexture?texture.sourceTexture:null;}state.bindTexture(_gl.TEXTURE_2D_ARRAY,textureProperties.__webglTexture,_gl.TEXTURE0+slot);}function setTexture3D(texture,slot){const textureProperties=properties.get(texture);if(texture.isRenderTargetTexture===false&&texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}state.bindTexture(_gl.TEXTURE_3D,textureProperties.__webglTexture,_gl.TEXTURE0+slot);}function setTextureCube(texture,slot){const textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadCubeTexture(textureProperties,texture,slot);return;}state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture,_gl.TEXTURE0+slot);}const wrappingToGL={[RepeatWrapping]:_gl.REPEAT,[ClampToEdgeWrapping]:_gl.CLAMP_TO_EDGE,[MirroredRepeatWrapping]:_gl.MIRRORED_REPEAT};const filterToGL={[NearestFilter]:_gl.NEAREST,[NearestMipmapNearestFilter]:_gl.NEAREST_MIPMAP_NEAREST,[NearestMipmapLinearFilter]:_gl.NEAREST_MIPMAP_LINEAR,[LinearFilter]:_gl.LINEAR,[LinearMipmapNearestFilter]:_gl.LINEAR_MIPMAP_NEAREST,[LinearMipmapLinearFilter]:_gl.LINEAR_MIPMAP_LINEAR};const compareToGL={[NeverCompare]:_gl.NEVER,[AlwaysCompare]:_gl.ALWAYS,[LessCompare]:_gl.LESS,[LessEqualCompare]:_gl.LEQUAL,[EqualCompare]:_gl.EQUAL,[GreaterEqualCompare]:_gl.GEQUAL,[GreaterCompare]:_gl.GREATER,[NotEqualCompare]:_gl.NOTEQUAL};function setTextureParameters(textureType,texture){if(texture.type===FloatType$1&&extensions.has('OES_texture_float_linear')===false&&(texture.magFilter===LinearFilter||texture.magFilter===LinearMipmapNearestFilter||texture.magFilter===NearestMipmapLinearFilter||texture.magFilter===LinearMipmapLinearFilter||texture.minFilter===LinearFilter||texture.minFilter===LinearMipmapNearestFilter||texture.minFilter===NearestMipmapLinearFilter||texture.minFilter===LinearMipmapLinearFilter)){warn$1('WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.');}_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,wrappingToGL[texture.wrapS]);_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,wrappingToGL[texture.wrapT]);if(textureType===_gl.TEXTURE_3D||textureType===_gl.TEXTURE_2D_ARRAY){_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_R,wrappingToGL[texture.wrapR]);}_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,filterToGL[texture.magFilter]);_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,filterToGL[texture.minFilter]);if(texture.compareFunction){_gl.texParameteri(textureType,_gl.TEXTURE_COMPARE_MODE,_gl.COMPARE_REF_TO_TEXTURE);_gl.texParameteri(textureType,_gl.TEXTURE_COMPARE_FUNC,compareToGL[texture.compareFunction]);}if(extensions.has('EXT_texture_filter_anisotropic')===true){if(texture.magFilter===NearestFilter)return;if(texture.minFilter!==NearestMipmapLinearFilter&&texture.minFilter!==LinearMipmapLinearFilter)return;if(texture.type===FloatType$1&&extensions.has('OES_texture_float_linear')===false)return;// verify extension
	if(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){const extension=extensions.get('EXT_texture_filter_anisotropic');_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));properties.get(texture).__currentAnisotropy=texture.anisotropy;}}}function initTexture(textureProperties,texture){let forceUpload=false;if(textureProperties.__webglInit===undefined){textureProperties.__webglInit=true;texture.addEventListener('dispose',onTextureDispose);}// create Source <-> WebGLTextures mapping if necessary
	const source=texture.source;let webglTextures=_sources.get(source);if(webglTextures===undefined){webglTextures={};_sources.set(source,webglTextures);}// check if there is already a WebGLTexture object for the given texture parameters
	const textureCacheKey=getTextureCacheKey(texture);if(textureCacheKey!==textureProperties.__cacheKey){// if not, create a new instance of WebGLTexture
	if(webglTextures[textureCacheKey]===undefined){// create new entry
	webglTextures[textureCacheKey]={texture:_gl.createTexture(),usedTimes:0};info.memory.textures++;// when a new instance of WebGLTexture was created, a texture upload is required
	// even if the image contents are identical
	forceUpload=true;}webglTextures[textureCacheKey].usedTimes++;// every time the texture cache key changes, it's necessary to check if an instance of
	// WebGLTexture can be deleted in order to avoid a memory leak.
	const webglTexture=webglTextures[textureProperties.__cacheKey];if(webglTexture!==undefined){webglTextures[textureProperties.__cacheKey].usedTimes--;if(webglTexture.usedTimes===0){deleteTexture(texture);}}// store references to cache key and WebGLTexture object
	textureProperties.__cacheKey=textureCacheKey;textureProperties.__webglTexture=webglTextures[textureCacheKey].texture;}return forceUpload;}function getRow(index,rowLength,componentStride){return Math.floor(Math.floor(index/componentStride)/rowLength);}function updateTexture(texture,image,glFormat,glType){const componentStride=4;// only RGBA supported
	const updateRanges=texture.updateRanges;if(updateRanges.length===0){state.texSubImage2D(_gl.TEXTURE_2D,0,0,0,image.width,image.height,glFormat,glType,image.data);}else {// Before applying update ranges, we merge any adjacent / overlapping
	// ranges to reduce load on `gl.texSubImage2D`. Empirically, this has led
	// to performance improvements for applications which make heavy use of
	// update ranges. Likely due to GPU command overhead.
	//
	// Note that to reduce garbage collection between frames, we merge the
	// update ranges in-place. This is safe because this method will clear the
	// update ranges once updated.
	updateRanges.sort((a,b)=>a.start-b.start);// To merge the update ranges in-place, we work from left to right in the
	// existing updateRanges array, merging ranges. This may result in a final
	// array which is smaller than the original. This index tracks the last
	// index representing a merged range, any data after this index can be
	// trimmed once the merge algorithm is completed.
	let mergeIndex=0;for(let i=1;i<updateRanges.length;i++){const previousRange=updateRanges[mergeIndex];const range=updateRanges[i];// Only merge if in the same row and overlapping/adjacent
	const previousEnd=previousRange.start+previousRange.count;const currentRow=getRow(range.start,image.width,componentStride);const previousRow=getRow(previousRange.start,image.width,componentStride);// We add one here to merge adjacent ranges. This is safe because ranges
	// operate over positive integers.
	if(range.start<=previousEnd+1&&currentRow===previousRow&&getRow(range.start+range.count-1,image.width,componentStride)===currentRow// ensure range doesn't spill
	){previousRange.count=Math.max(previousRange.count,range.start+range.count-previousRange.start);}else {++mergeIndex;updateRanges[mergeIndex]=range;}}// Trim the array to only contain the merged ranges.
	updateRanges.length=mergeIndex+1;const currentUnpackRowLen=_gl.getParameter(_gl.UNPACK_ROW_LENGTH);const currentUnpackSkipPixels=_gl.getParameter(_gl.UNPACK_SKIP_PIXELS);const currentUnpackSkipRows=_gl.getParameter(_gl.UNPACK_SKIP_ROWS);_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH,image.width);for(let i=0,l=updateRanges.length;i<l;i++){const range=updateRanges[i];const pixelStart=Math.floor(range.start/componentStride);const pixelCount=Math.ceil(range.count/componentStride);const x=pixelStart%image.width;const y=Math.floor(pixelStart/image.width);// Assumes update ranges refer to contiguous memory
	const width=pixelCount;const height=1;_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS,x);_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS,y);state.texSubImage2D(_gl.TEXTURE_2D,0,x,y,width,height,glFormat,glType,image.data);}texture.clearUpdateRanges();_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH,currentUnpackRowLen);_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS,currentUnpackSkipPixels);_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS,currentUnpackSkipRows);}}function uploadTexture(textureProperties,texture,slot){let textureType=_gl.TEXTURE_2D;if(texture.isDataArrayTexture||texture.isCompressedArrayTexture)textureType=_gl.TEXTURE_2D_ARRAY;if(texture.isData3DTexture)textureType=_gl.TEXTURE_3D;const forceUpload=initTexture(textureProperties,texture);const source=texture.source;state.bindTexture(textureType,textureProperties.__webglTexture,_gl.TEXTURE0+slot);const sourceProperties=properties.get(source);if(source.version!==sourceProperties.__version||forceUpload===true){state.activeTexture(_gl.TEXTURE0+slot);const workingPrimaries=ColorManagement.getPrimaries(ColorManagement.workingColorSpace);const texturePrimaries=texture.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(texture.colorSpace);const unpackConversion=texture.colorSpace===NoColorSpace||workingPrimaries===texturePrimaries?_gl.NONE:_gl.BROWSER_DEFAULT_WEBGL;_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,texture.unpackAlignment);_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,unpackConversion);let image=resizeImage(texture.image,false,capabilities.maxTextureSize);image=verifyColorSpace(texture,image);const glFormat=utils.convert(texture.format,texture.colorSpace);const glType=utils.convert(texture.type);let glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace,texture.isVideoTexture);setTextureParameters(textureType,texture);let mipmap;const mipmaps=texture.mipmaps;const useTexStorage=texture.isVideoTexture!==true;const allocateMemory=sourceProperties.__version===undefined||forceUpload===true;const dataReady=source.dataReady;const levels=getMipLevels(texture,image);if(texture.isDepthTexture){glInternalFormat=getInternalDepthFormat(texture.format===DepthStencilFormat,texture.type);//
	if(allocateMemory){if(useTexStorage){state.texStorage2D(_gl.TEXTURE_2D,1,glInternalFormat,image.width,image.height);}else {state.texImage2D(_gl.TEXTURE_2D,0,glInternalFormat,image.width,image.height,0,glFormat,glType,null);}}}else if(texture.isDataTexture){// use manually created mipmaps if available
	// if there are no manual mipmaps
	// set 0 level mipmap and then use GL to generate other mipmap levels
	if(mipmaps.length>0){if(useTexStorage&&allocateMemory){state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height);}for(let i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_2D,i,0,0,mipmap.width,mipmap.height,glFormat,glType,mipmap.data);}}else {state.texImage2D(_gl.TEXTURE_2D,i,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}texture.generateMipmaps=false;}else {if(useTexStorage){if(allocateMemory){state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,image.width,image.height);}if(dataReady){updateTexture(texture,image,glFormat,glType);}}else {state.texImage2D(_gl.TEXTURE_2D,0,glInternalFormat,image.width,image.height,0,glFormat,glType,image.data);}}}else if(texture.isCompressedTexture){if(texture.isCompressedArrayTexture){if(useTexStorage&&allocateMemory){state.texStorage3D(_gl.TEXTURE_2D_ARRAY,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height,image.depth);}for(let i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(texture.format!==RGBAFormat){if(glFormat!==null){if(useTexStorage){if(dataReady){if(texture.layerUpdates.size>0){const layerByteLength=getByteLength(mipmap.width,mipmap.height,texture.format,texture.type);for(const layerIndex of texture.layerUpdates){const layerData=mipmap.data.subarray(layerIndex*layerByteLength/mipmap.data.BYTES_PER_ELEMENT,(layerIndex+1)*layerByteLength/mipmap.data.BYTES_PER_ELEMENT);state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY,i,0,0,layerIndex,mipmap.width,mipmap.height,1,glFormat,layerData);}texture.clearLayerUpdates();}else {state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY,i,0,0,0,mipmap.width,mipmap.height,image.depth,glFormat,mipmap.data);}}}else {state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY,i,glInternalFormat,mipmap.width,mipmap.height,image.depth,0,mipmap.data,0,0);}}else {warn$1('WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');}}else {if(useTexStorage){if(dataReady){state.texSubImage3D(_gl.TEXTURE_2D_ARRAY,i,0,0,0,mipmap.width,mipmap.height,image.depth,glFormat,glType,mipmap.data);}}else {state.texImage3D(_gl.TEXTURE_2D_ARRAY,i,glInternalFormat,mipmap.width,mipmap.height,image.depth,0,glFormat,glType,mipmap.data);}}}}else {if(useTexStorage&&allocateMemory){state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height);}for(let i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(texture.format!==RGBAFormat){if(glFormat!==null){if(useTexStorage){if(dataReady){state.compressedTexSubImage2D(_gl.TEXTURE_2D,i,0,0,mipmap.width,mipmap.height,glFormat,mipmap.data);}}else {state.compressedTexImage2D(_gl.TEXTURE_2D,i,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}}else {warn$1('WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');}}else {if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_2D,i,0,0,mipmap.width,mipmap.height,glFormat,glType,mipmap.data);}}else {state.texImage2D(_gl.TEXTURE_2D,i,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}}}else if(texture.isDataArrayTexture){if(useTexStorage){if(allocateMemory){state.texStorage3D(_gl.TEXTURE_2D_ARRAY,levels,glInternalFormat,image.width,image.height,image.depth);}if(dataReady){if(texture.layerUpdates.size>0){const layerByteLength=getByteLength(image.width,image.height,texture.format,texture.type);for(const layerIndex of texture.layerUpdates){const layerData=image.data.subarray(layerIndex*layerByteLength/image.data.BYTES_PER_ELEMENT,(layerIndex+1)*layerByteLength/image.data.BYTES_PER_ELEMENT);state.texSubImage3D(_gl.TEXTURE_2D_ARRAY,0,0,0,layerIndex,image.width,image.height,1,glFormat,glType,layerData);}texture.clearLayerUpdates();}else {state.texSubImage3D(_gl.TEXTURE_2D_ARRAY,0,0,0,0,image.width,image.height,image.depth,glFormat,glType,image.data);}}}else {state.texImage3D(_gl.TEXTURE_2D_ARRAY,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);}}else if(texture.isData3DTexture){if(useTexStorage){if(allocateMemory){state.texStorage3D(_gl.TEXTURE_3D,levels,glInternalFormat,image.width,image.height,image.depth);}if(dataReady){state.texSubImage3D(_gl.TEXTURE_3D,0,0,0,0,image.width,image.height,image.depth,glFormat,glType,image.data);}}else {state.texImage3D(_gl.TEXTURE_3D,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);}}else if(texture.isFramebufferTexture){if(allocateMemory){if(useTexStorage){state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,image.width,image.height);}else {let width=image.width,height=image.height;for(let i=0;i<levels;i++){state.texImage2D(_gl.TEXTURE_2D,i,glInternalFormat,width,height,0,glFormat,glType,null);width>>=1;height>>=1;}}}}else {// regular Texture (image, video, canvas)
	// use manually created mipmaps if available
	// if there are no manual mipmaps
	// set 0 level mipmap and then use GL to generate other mipmap levels
	if(mipmaps.length>0){if(useTexStorage&&allocateMemory){const dimensions=getDimensions(mipmaps[0]);state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,dimensions.width,dimensions.height);}for(let i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_2D,i,0,0,glFormat,glType,mipmap);}}else {state.texImage2D(_gl.TEXTURE_2D,i,glInternalFormat,glFormat,glType,mipmap);}}texture.generateMipmaps=false;}else {if(useTexStorage){if(allocateMemory){const dimensions=getDimensions(image);state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,dimensions.width,dimensions.height);}if(dataReady){state.texSubImage2D(_gl.TEXTURE_2D,0,0,0,glFormat,glType,image);}}else {state.texImage2D(_gl.TEXTURE_2D,0,glInternalFormat,glFormat,glType,image);}}}if(textureNeedsGenerateMipmaps(texture)){generateMipmap(textureType);}sourceProperties.__version=source.version;if(texture.onUpdate)texture.onUpdate(texture);}textureProperties.__version=texture.version;}function uploadCubeTexture(textureProperties,texture,slot){if(texture.image.length!==6)return;const forceUpload=initTexture(textureProperties,texture);const source=texture.source;state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture,_gl.TEXTURE0+slot);const sourceProperties=properties.get(source);if(source.version!==sourceProperties.__version||forceUpload===true){state.activeTexture(_gl.TEXTURE0+slot);const workingPrimaries=ColorManagement.getPrimaries(ColorManagement.workingColorSpace);const texturePrimaries=texture.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(texture.colorSpace);const unpackConversion=texture.colorSpace===NoColorSpace||workingPrimaries===texturePrimaries?_gl.NONE:_gl.BROWSER_DEFAULT_WEBGL;_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,texture.unpackAlignment);_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,unpackConversion);const isCompressed=texture.isCompressedTexture||texture.image[0].isCompressedTexture;const isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;const cubeImage=[];for(let i=0;i<6;i++){if(!isCompressed&&!isDataTexture){cubeImage[i]=resizeImage(texture.image[i],true,capabilities.maxCubemapSize);}else {cubeImage[i]=isDataTexture?texture.image[i].image:texture.image[i];}cubeImage[i]=verifyColorSpace(texture,cubeImage[i]);}const image=cubeImage[0],glFormat=utils.convert(texture.format,texture.colorSpace),glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace);const useTexStorage=texture.isVideoTexture!==true;const allocateMemory=sourceProperties.__version===undefined||forceUpload===true;const dataReady=source.dataReady;let levels=getMipLevels(texture,image);setTextureParameters(_gl.TEXTURE_CUBE_MAP,texture);let mipmaps;if(isCompressed){if(useTexStorage&&allocateMemory){state.texStorage2D(_gl.TEXTURE_CUBE_MAP,levels,glInternalFormat,image.width,image.height);}for(let i=0;i<6;i++){mipmaps=cubeImage[i].mipmaps;for(let j=0;j<mipmaps.length;j++){const mipmap=mipmaps[j];if(texture.format!==RGBAFormat){if(glFormat!==null){if(useTexStorage){if(dataReady){state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,0,0,mipmap.width,mipmap.height,glFormat,mipmap.data);}}else {state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}}else {warn$1('WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');}}else {if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,0,0,mipmap.width,mipmap.height,glFormat,glType,mipmap.data);}}else {state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}}}else {mipmaps=texture.mipmaps;if(useTexStorage&&allocateMemory){// TODO: Uniformly handle mipmap definitions
	// Normal textures and compressed cube textures define base level + mips with their mipmap array
	// Uncompressed cube textures use their mipmap array only for mips (no base level)
	if(mipmaps.length>0)levels++;const dimensions=getDimensions(cubeImage[0]);state.texStorage2D(_gl.TEXTURE_CUBE_MAP,levels,glInternalFormat,dimensions.width,dimensions.height);}for(let i=0;i<6;i++){if(isDataTexture){if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,0,0,cubeImage[i].width,cubeImage[i].height,glFormat,glType,cubeImage[i].data);}}else {state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glInternalFormat,cubeImage[i].width,cubeImage[i].height,0,glFormat,glType,cubeImage[i].data);}for(let j=0;j<mipmaps.length;j++){const mipmap=mipmaps[j];const mipmapImage=mipmap.image[i].image;if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j+1,0,0,mipmapImage.width,mipmapImage.height,glFormat,glType,mipmapImage.data);}}else {state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j+1,glInternalFormat,mipmapImage.width,mipmapImage.height,0,glFormat,glType,mipmapImage.data);}}}else {if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,0,0,glFormat,glType,cubeImage[i]);}}else {state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glInternalFormat,glFormat,glType,cubeImage[i]);}for(let j=0;j<mipmaps.length;j++){const mipmap=mipmaps[j];if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j+1,0,0,glFormat,glType,mipmap.image[i]);}}else {state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j+1,glInternalFormat,glFormat,glType,mipmap.image[i]);}}}}}if(textureNeedsGenerateMipmaps(texture)){// We assume images for cube map have the same size.
	generateMipmap(_gl.TEXTURE_CUBE_MAP);}sourceProperties.__version=source.version;if(texture.onUpdate)texture.onUpdate(texture);}textureProperties.__version=texture.version;}// Render targets
	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture(framebuffer,renderTarget,texture,attachment,textureTarget,level){const glFormat=utils.convert(texture.format,texture.colorSpace);const glType=utils.convert(texture.type);const glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace);const renderTargetProperties=properties.get(renderTarget);const textureProperties=properties.get(texture);textureProperties.__renderTarget=renderTarget;if(!renderTargetProperties.__hasExternalTextures){const width=Math.max(1,renderTarget.width>>level);const height=Math.max(1,renderTarget.height>>level);if(textureTarget===_gl.TEXTURE_3D||textureTarget===_gl.TEXTURE_2D_ARRAY){state.texImage3D(textureTarget,level,glInternalFormat,width,height,renderTarget.depth,0,glFormat,glType,null);}else {state.texImage2D(textureTarget,level,glInternalFormat,width,height,0,glFormat,glType,null);}}state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);if(useMultisampledRTT(renderTarget)){multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER,attachment,textureTarget,textureProperties.__webglTexture,0,getRenderTargetSamples(renderTarget));}else if(textureTarget===_gl.TEXTURE_2D||textureTarget>=_gl.TEXTURE_CUBE_MAP_POSITIVE_X&&textureTarget<=_gl.TEXTURE_CUBE_MAP_NEGATIVE_Z){// see #24753
	_gl.framebufferTexture2D(_gl.FRAMEBUFFER,attachment,textureTarget,textureProperties.__webglTexture,level);}state.bindFramebuffer(_gl.FRAMEBUFFER,null);}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage(renderbuffer,renderTarget,isMultisample){_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer);if(renderTarget.depthBuffer){// retrieve the depth attachment types
	const depthTexture=renderTarget.depthTexture;const depthType=depthTexture&&depthTexture.isDepthTexture?depthTexture.type:null;const glInternalFormat=getInternalDepthFormat(renderTarget.stencilBuffer,depthType);const glAttachmentType=renderTarget.stencilBuffer?_gl.DEPTH_STENCIL_ATTACHMENT:_gl.DEPTH_ATTACHMENT;// set up the attachment
	const samples=getRenderTargetSamples(renderTarget);const isUseMultisampledRTT=useMultisampledRTT(renderTarget);if(isUseMultisampledRTT){multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else if(isMultisample){_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else {_gl.renderbufferStorage(_gl.RENDERBUFFER,glInternalFormat,renderTarget.width,renderTarget.height);}_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,glAttachmentType,_gl.RENDERBUFFER,renderbuffer);}else {const textures=renderTarget.textures;for(let i=0;i<textures.length;i++){const texture=textures[i];const glFormat=utils.convert(texture.format,texture.colorSpace);const glType=utils.convert(texture.type);const glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace);const samples=getRenderTargetSamples(renderTarget);if(isMultisample&&useMultisampledRTT(renderTarget)===false){_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else if(useMultisampledRTT(renderTarget)){multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else {_gl.renderbufferStorage(_gl.RENDERBUFFER,glInternalFormat,renderTarget.width,renderTarget.height);}}}_gl.bindRenderbuffer(_gl.RENDERBUFFER,null);}// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture(framebuffer,renderTarget){const isCube=renderTarget&&renderTarget.isWebGLCubeRenderTarget;if(isCube)throw new Error('Depth Texture with cube render targets is not supported');state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);if(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');}const textureProperties=properties.get(renderTarget.depthTexture);textureProperties.__renderTarget=renderTarget;// upload an empty depth texture with framebuffer size
	if(!textureProperties.__webglTexture||renderTarget.depthTexture.image.width!==renderTarget.width||renderTarget.depthTexture.image.height!==renderTarget.height){renderTarget.depthTexture.image.width=renderTarget.width;renderTarget.depthTexture.image.height=renderTarget.height;renderTarget.depthTexture.needsUpdate=true;}setTexture2D(renderTarget.depthTexture,0);const webglDepthTexture=textureProperties.__webglTexture;const samples=getRenderTargetSamples(renderTarget);if(renderTarget.depthTexture.format===DepthFormat){if(useMultisampledRTT(renderTarget)){multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0,samples);}else {_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}}else if(renderTarget.depthTexture.format===DepthStencilFormat){if(useMultisampledRTT(renderTarget)){multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0,samples);}else {_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}}else {throw new Error('Unknown depthTexture format');}}// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer(renderTarget){const renderTargetProperties=properties.get(renderTarget);const isCube=renderTarget.isWebGLCubeRenderTarget===true;// if the bound depth texture has changed
	if(renderTargetProperties.__boundDepthTexture!==renderTarget.depthTexture){// fire the dispose event to get rid of stored state associated with the previously bound depth buffer
	const depthTexture=renderTarget.depthTexture;if(renderTargetProperties.__depthDisposeCallback){renderTargetProperties.__depthDisposeCallback();}// set up dispose listeners to track when the currently attached buffer is implicitly unbound
	if(depthTexture){const disposeEvent=()=>{delete renderTargetProperties.__boundDepthTexture;delete renderTargetProperties.__depthDisposeCallback;depthTexture.removeEventListener('dispose',disposeEvent);};depthTexture.addEventListener('dispose',disposeEvent);renderTargetProperties.__depthDisposeCallback=disposeEvent;}renderTargetProperties.__boundDepthTexture=depthTexture;}if(renderTarget.depthTexture&&!renderTargetProperties.__autoAllocateDepthBuffer){if(isCube)throw new Error('target.depthTexture not supported in Cube render targets');const mipmaps=renderTarget.texture.mipmaps;if(mipmaps&&mipmaps.length>0){setupDepthTexture(renderTargetProperties.__webglFramebuffer[0],renderTarget);}else {setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);}}else {if(isCube){renderTargetProperties.__webglDepthbuffer=[];for(let i=0;i<6;i++){state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer[i]);if(renderTargetProperties.__webglDepthbuffer[i]===undefined){renderTargetProperties.__webglDepthbuffer[i]=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i],renderTarget,false);}else {// attach buffer if it's been created already
	const glAttachmentType=renderTarget.stencilBuffer?_gl.DEPTH_STENCIL_ATTACHMENT:_gl.DEPTH_ATTACHMENT;const renderbuffer=renderTargetProperties.__webglDepthbuffer[i];_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,glAttachmentType,_gl.RENDERBUFFER,renderbuffer);}}}else {const mipmaps=renderTarget.texture.mipmaps;if(mipmaps&&mipmaps.length>0){state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer[0]);}else {state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);}if(renderTargetProperties.__webglDepthbuffer===undefined){renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget,false);}else {// attach buffer if it's been created already
	const glAttachmentType=renderTarget.stencilBuffer?_gl.DEPTH_STENCIL_ATTACHMENT:_gl.DEPTH_ATTACHMENT;const renderbuffer=renderTargetProperties.__webglDepthbuffer;_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,glAttachmentType,_gl.RENDERBUFFER,renderbuffer);}}}state.bindFramebuffer(_gl.FRAMEBUFFER,null);}// rebind framebuffer with external textures
	function rebindTextures(renderTarget,colorTexture,depthTexture){const renderTargetProperties=properties.get(renderTarget);if(colorTexture!==undefined){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,renderTarget.texture,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D,0);}if(depthTexture!==undefined){setupDepthRenderbuffer(renderTarget);}}// Set up GL resources for the render target
	function setupRenderTarget(renderTarget){const texture=renderTarget.texture;const renderTargetProperties=properties.get(renderTarget);const textureProperties=properties.get(texture);renderTarget.addEventListener('dispose',onRenderTargetDispose);const textures=renderTarget.textures;const isCube=renderTarget.isWebGLCubeRenderTarget===true;const isMultipleRenderTargets=textures.length>1;if(!isMultipleRenderTargets){if(textureProperties.__webglTexture===undefined){textureProperties.__webglTexture=_gl.createTexture();}textureProperties.__version=texture.version;info.memory.textures++;}// Setup framebuffer
	if(isCube){renderTargetProperties.__webglFramebuffer=[];for(let i=0;i<6;i++){if(texture.mipmaps&&texture.mipmaps.length>0){renderTargetProperties.__webglFramebuffer[i]=[];for(let level=0;level<texture.mipmaps.length;level++){renderTargetProperties.__webglFramebuffer[i][level]=_gl.createFramebuffer();}}else {renderTargetProperties.__webglFramebuffer[i]=_gl.createFramebuffer();}}}else {if(texture.mipmaps&&texture.mipmaps.length>0){renderTargetProperties.__webglFramebuffer=[];for(let level=0;level<texture.mipmaps.length;level++){renderTargetProperties.__webglFramebuffer[level]=_gl.createFramebuffer();}}else {renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();}if(isMultipleRenderTargets){for(let i=0,il=textures.length;i<il;i++){const attachmentProperties=properties.get(textures[i]);if(attachmentProperties.__webglTexture===undefined){attachmentProperties.__webglTexture=_gl.createTexture();info.memory.textures++;}}}if(renderTarget.samples>0&&useMultisampledRTT(renderTarget)===false){renderTargetProperties.__webglMultisampledFramebuffer=_gl.createFramebuffer();renderTargetProperties.__webglColorRenderbuffer=[];state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer);for(let i=0;i<textures.length;i++){const texture=textures[i];renderTargetProperties.__webglColorRenderbuffer[i]=_gl.createRenderbuffer();_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[i]);const glFormat=utils.convert(texture.format,texture.colorSpace);const glType=utils.convert(texture.type);const glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace,renderTarget.isXRRenderTarget===true);const samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i,_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[i]);}_gl.bindRenderbuffer(_gl.RENDERBUFFER,null);if(renderTarget.depthBuffer){renderTargetProperties.__webglDepthRenderbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer,renderTarget,true);}state.bindFramebuffer(_gl.FRAMEBUFFER,null);}}// Setup color buffer
	if(isCube){state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_CUBE_MAP,texture);for(let i=0;i<6;i++){if(texture.mipmaps&&texture.mipmaps.length>0){for(let level=0;level<texture.mipmaps.length;level++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level],renderTarget,texture,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,level);}}else {setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i],renderTarget,texture,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0);}}if(textureNeedsGenerateMipmaps(texture)){generateMipmap(_gl.TEXTURE_CUBE_MAP);}state.unbindTexture();}else if(isMultipleRenderTargets){for(let i=0,il=textures.length;i<il;i++){const attachment=textures[i];const attachmentProperties=properties.get(attachment);let glTextureType=_gl.TEXTURE_2D;if(renderTarget.isWebGL3DRenderTarget||renderTarget.isWebGLArrayRenderTarget){glTextureType=renderTarget.isWebGL3DRenderTarget?_gl.TEXTURE_3D:_gl.TEXTURE_2D_ARRAY;}state.bindTexture(glTextureType,attachmentProperties.__webglTexture);setTextureParameters(glTextureType,attachment);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,attachment,_gl.COLOR_ATTACHMENT0+i,glTextureType,0);if(textureNeedsGenerateMipmaps(attachment)){generateMipmap(glTextureType);}}state.unbindTexture();}else {let glTextureType=_gl.TEXTURE_2D;if(renderTarget.isWebGL3DRenderTarget||renderTarget.isWebGLArrayRenderTarget){glTextureType=renderTarget.isWebGL3DRenderTarget?_gl.TEXTURE_3D:_gl.TEXTURE_2D_ARRAY;}state.bindTexture(glTextureType,textureProperties.__webglTexture);setTextureParameters(glTextureType,texture);if(texture.mipmaps&&texture.mipmaps.length>0){for(let level=0;level<texture.mipmaps.length;level++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level],renderTarget,texture,_gl.COLOR_ATTACHMENT0,glTextureType,level);}}else {setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,texture,_gl.COLOR_ATTACHMENT0,glTextureType,0);}if(textureNeedsGenerateMipmaps(texture)){generateMipmap(glTextureType);}state.unbindTexture();}// Setup depth and stencil buffers
	if(renderTarget.depthBuffer){setupDepthRenderbuffer(renderTarget);}}function updateRenderTargetMipmap(renderTarget){const textures=renderTarget.textures;for(let i=0,il=textures.length;i<il;i++){const texture=textures[i];if(textureNeedsGenerateMipmaps(texture)){const targetType=getTargetType(renderTarget);const webglTexture=properties.get(texture).__webglTexture;state.bindTexture(targetType,webglTexture);generateMipmap(targetType);state.unbindTexture();}}}const invalidationArrayRead=[];const invalidationArrayDraw=[];function updateMultisampleRenderTarget(renderTarget){if(renderTarget.samples>0){if(useMultisampledRTT(renderTarget)===false){const textures=renderTarget.textures;const width=renderTarget.width;const height=renderTarget.height;let mask=_gl.COLOR_BUFFER_BIT;const depthStyle=renderTarget.stencilBuffer?_gl.DEPTH_STENCIL_ATTACHMENT:_gl.DEPTH_ATTACHMENT;const renderTargetProperties=properties.get(renderTarget);const isMultipleRenderTargets=textures.length>1;// If MRT we need to remove FBO attachments
	if(isMultipleRenderTargets){for(let i=0;i<textures.length;i++){state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i,_gl.RENDERBUFFER,null);state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i,_gl.TEXTURE_2D,null,0);}}state.bindFramebuffer(_gl.READ_FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer);const mipmaps=renderTarget.texture.mipmaps;if(mipmaps&&mipmaps.length>0){state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,renderTargetProperties.__webglFramebuffer[0]);}else {state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);}for(let i=0;i<textures.length;i++){if(renderTarget.resolveDepthBuffer){if(renderTarget.depthBuffer)mask|=_gl.DEPTH_BUFFER_BIT;// resolving stencil is slow with a D3D backend. disable it for all transmission render targets (see #27799)
	if(renderTarget.stencilBuffer&&renderTarget.resolveStencilBuffer)mask|=_gl.STENCIL_BUFFER_BIT;}if(isMultipleRenderTargets){_gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[i]);const webglTexture=properties.get(textures[i]).__webglTexture;_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D,webglTexture,0);}_gl.blitFramebuffer(0,0,width,height,0,0,width,height,mask,_gl.NEAREST);if(supportsInvalidateFramebuffer===true){invalidationArrayRead.length=0;invalidationArrayDraw.length=0;invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0+i);if(renderTarget.depthBuffer&&renderTarget.resolveDepthBuffer===false){invalidationArrayRead.push(depthStyle);invalidationArrayDraw.push(depthStyle);_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER,invalidationArrayDraw);}_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER,invalidationArrayRead);}}state.bindFramebuffer(_gl.READ_FRAMEBUFFER,null);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,null);// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
	if(isMultipleRenderTargets){for(let i=0;i<textures.length;i++){state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i,_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[i]);const webglTexture=properties.get(textures[i]).__webglTexture;state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i,_gl.TEXTURE_2D,webglTexture,0);}}state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer);}else {if(renderTarget.depthBuffer&&renderTarget.resolveDepthBuffer===false&&supportsInvalidateFramebuffer){const depthStyle=renderTarget.stencilBuffer?_gl.DEPTH_STENCIL_ATTACHMENT:_gl.DEPTH_ATTACHMENT;_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER,[depthStyle]);}}}}function getRenderTargetSamples(renderTarget){return Math.min(capabilities.maxSamples,renderTarget.samples);}function useMultisampledRTT(renderTarget){const renderTargetProperties=properties.get(renderTarget);return renderTarget.samples>0&&extensions.has('WEBGL_multisampled_render_to_texture')===true&&renderTargetProperties.__useRenderToTexture!==false;}function updateVideoTexture(texture){const frame=info.render.frame;// Check the last frame we updated the VideoTexture
	if(_videoTextures.get(texture)!==frame){_videoTextures.set(texture,frame);texture.update();}}function verifyColorSpace(texture,image){const colorSpace=texture.colorSpace;const format=texture.format;const type=texture.type;if(texture.isCompressedTexture===true||texture.isVideoTexture===true)return image;if(colorSpace!==LinearSRGBColorSpace&&colorSpace!==NoColorSpace){// sRGB
	if(ColorManagement.getTransfer(colorSpace)===SRGBTransfer){// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format
	if(format!==RGBAFormat||type!==UnsignedByteType){warn$1('WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.');}}else {error$1('WebGLTextures: Unsupported texture color space:',colorSpace);}}return image;}function getDimensions(image){if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement){// if intrinsic data are not available, fallback to width/height
	_imageDimensions.width=image.naturalWidth||image.width;_imageDimensions.height=image.naturalHeight||image.height;}else if(typeof VideoFrame!=='undefined'&&image instanceof VideoFrame){_imageDimensions.width=image.displayWidth;_imageDimensions.height=image.displayHeight;}else {_imageDimensions.width=image.width;_imageDimensions.height=image.height;}return _imageDimensions;}//
	this.allocateTextureUnit=allocateTextureUnit;this.resetTextureUnits=resetTextureUnits;this.setTexture2D=setTexture2D;this.setTexture2DArray=setTexture2DArray;this.setTexture3D=setTexture3D;this.setTextureCube=setTextureCube;this.rebindTextures=rebindTextures;this.setupRenderTarget=setupRenderTarget;this.updateRenderTargetMipmap=updateRenderTargetMipmap;this.updateMultisampleRenderTarget=updateMultisampleRenderTarget;this.setupDepthRenderbuffer=setupDepthRenderbuffer;this.setupFrameBufferTexture=setupFrameBufferTexture;this.useMultisampledRTT=useMultisampledRTT;}function WebGLUtils(gl,extensions){function convert(p,colorSpace=NoColorSpace){let extension;const transfer=ColorManagement.getTransfer(colorSpace);if(p===UnsignedByteType)return gl.UNSIGNED_BYTE;if(p===UnsignedShort4444Type)return gl.UNSIGNED_SHORT_4_4_4_4;if(p===UnsignedShort5551Type)return gl.UNSIGNED_SHORT_5_5_5_1;if(p===UnsignedInt5999Type)return gl.UNSIGNED_INT_5_9_9_9_REV;if(p===UnsignedInt101111Type)return gl.UNSIGNED_INT_10F_11F_11F_REV;if(p===ByteType)return gl.BYTE;if(p===ShortType)return gl.SHORT;if(p===UnsignedShortType)return gl.UNSIGNED_SHORT;if(p===IntType)return gl.INT;if(p===UnsignedIntType)return gl.UNSIGNED_INT;if(p===FloatType$1)return gl.FLOAT;if(p===HalfFloatType)return gl.HALF_FLOAT;if(p===AlphaFormat)return gl.ALPHA;if(p===RGBFormat)return gl.RGB;if(p===RGBAFormat)return gl.RGBA;if(p===DepthFormat)return gl.DEPTH_COMPONENT;if(p===DepthStencilFormat)return gl.DEPTH_STENCIL;// WebGL2 formats.
	if(p===RedFormat)return gl.RED;if(p===RedIntegerFormat)return gl.RED_INTEGER;if(p===RGFormat)return gl.RG;if(p===RGIntegerFormat)return gl.RG_INTEGER;if(p===RGBAIntegerFormat)return gl.RGBA_INTEGER;// S3TC
	if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){if(transfer===SRGBTransfer){extension=extensions.get('WEBGL_compressed_texture_s3tc_srgb');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;}else {return null;}}else {extension=extensions.get('WEBGL_compressed_texture_s3tc');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;}else {return null;}}}// PVRTC
	if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){extension=extensions.get('WEBGL_compressed_texture_pvrtc');if(extension!==null){if(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;}else {return null;}}// ETC
	if(p===RGB_ETC1_Format||p===RGB_ETC2_Format||p===RGBA_ETC2_EAC_Format){extension=extensions.get('WEBGL_compressed_texture_etc');if(extension!==null){if(p===RGB_ETC1_Format||p===RGB_ETC2_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ETC2:extension.COMPRESSED_RGB8_ETC2;if(p===RGBA_ETC2_EAC_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:extension.COMPRESSED_RGBA8_ETC2_EAC;}else {return null;}}// ASTC
	if(p===RGBA_ASTC_4x4_Format||p===RGBA_ASTC_5x4_Format||p===RGBA_ASTC_5x5_Format||p===RGBA_ASTC_6x5_Format||p===RGBA_ASTC_6x6_Format||p===RGBA_ASTC_8x5_Format||p===RGBA_ASTC_8x6_Format||p===RGBA_ASTC_8x8_Format||p===RGBA_ASTC_10x5_Format||p===RGBA_ASTC_10x6_Format||p===RGBA_ASTC_10x8_Format||p===RGBA_ASTC_10x10_Format||p===RGBA_ASTC_12x10_Format||p===RGBA_ASTC_12x12_Format){extension=extensions.get('WEBGL_compressed_texture_astc');if(extension!==null){if(p===RGBA_ASTC_4x4_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:extension.COMPRESSED_RGBA_ASTC_4x4_KHR;if(p===RGBA_ASTC_5x4_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:extension.COMPRESSED_RGBA_ASTC_5x4_KHR;if(p===RGBA_ASTC_5x5_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:extension.COMPRESSED_RGBA_ASTC_5x5_KHR;if(p===RGBA_ASTC_6x5_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:extension.COMPRESSED_RGBA_ASTC_6x5_KHR;if(p===RGBA_ASTC_6x6_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:extension.COMPRESSED_RGBA_ASTC_6x6_KHR;if(p===RGBA_ASTC_8x5_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:extension.COMPRESSED_RGBA_ASTC_8x5_KHR;if(p===RGBA_ASTC_8x6_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:extension.COMPRESSED_RGBA_ASTC_8x6_KHR;if(p===RGBA_ASTC_8x8_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:extension.COMPRESSED_RGBA_ASTC_8x8_KHR;if(p===RGBA_ASTC_10x5_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:extension.COMPRESSED_RGBA_ASTC_10x5_KHR;if(p===RGBA_ASTC_10x6_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:extension.COMPRESSED_RGBA_ASTC_10x6_KHR;if(p===RGBA_ASTC_10x8_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:extension.COMPRESSED_RGBA_ASTC_10x8_KHR;if(p===RGBA_ASTC_10x10_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:extension.COMPRESSED_RGBA_ASTC_10x10_KHR;if(p===RGBA_ASTC_12x10_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:extension.COMPRESSED_RGBA_ASTC_12x10_KHR;if(p===RGBA_ASTC_12x12_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:extension.COMPRESSED_RGBA_ASTC_12x12_KHR;}else {return null;}}// BPTC
	if(p===RGBA_BPTC_Format||p===RGB_BPTC_SIGNED_Format||p===RGB_BPTC_UNSIGNED_Format){extension=extensions.get('EXT_texture_compression_bptc');if(extension!==null){if(p===RGBA_BPTC_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(p===RGB_BPTC_SIGNED_Format)return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(p===RGB_BPTC_UNSIGNED_Format)return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;}else {return null;}}// RGTC
	if(p===RED_RGTC1_Format||p===SIGNED_RED_RGTC1_Format||p===RED_GREEN_RGTC2_Format||p===SIGNED_RED_GREEN_RGTC2_Format){extension=extensions.get('EXT_texture_compression_rgtc');if(extension!==null){if(p===RED_RGTC1_Format)return extension.COMPRESSED_RED_RGTC1_EXT;if(p===SIGNED_RED_RGTC1_Format)return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(p===RED_GREEN_RGTC2_Format)return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;if(p===SIGNED_RED_GREEN_RGTC2_Format)return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;}else {return null;}}//
	if(p===UnsignedInt248Type)return gl.UNSIGNED_INT_24_8;// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)
	return gl[p]!==undefined?gl[p]:null;}return {convert:convert};}const _occlusion_vertex=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`;const _occlusion_fragment=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;/**
	 * A XR module that manages the access to the Depth Sensing API.
	 */class WebXRDepthSensing{/**
		 * Constructs a new depth sensing module.
		 */constructor(){/**
			 * An opaque texture representing the depth of the user's environment.
			 *
			 * @type {?ExternalTexture}
			 */this.texture=null;/**
			 * A plane mesh for visualizing the depth texture.
			 *
			 * @type {?Mesh}
			 */this.mesh=null;/**
			 * The depth near value.
			 *
			 * @type {number}
			 */this.depthNear=0;/**
			 * The depth near far.
			 *
			 * @type {number}
			 */this.depthFar=0;}/**
		 * Inits the depth sensing module
		 *
		 * @param {XRWebGLDepthInformation} depthData - The XR depth data.
		 * @param {XRRenderState} renderState - The XR render state.
		 */init(depthData,renderState){if(this.texture===null){const texture=new ExternalTexture(depthData.texture);if(depthData.depthNear!==renderState.depthNear||depthData.depthFar!==renderState.depthFar){this.depthNear=depthData.depthNear;this.depthFar=depthData.depthFar;}this.texture=texture;}}/**
		 * Returns a plane mesh that visualizes the depth texture.
		 *
		 * @param {ArrayCamera} cameraXR - The XR camera.
		 * @return {?Mesh} The plane mesh.
		 */getMesh(cameraXR){if(this.texture!==null){if(this.mesh===null){const viewport=cameraXR.cameras[0].viewport;const material=new ShaderMaterial({vertexShader:_occlusion_vertex,fragmentShader:_occlusion_fragment,uniforms:{depthColor:{value:this.texture},depthWidth:{value:viewport.z},depthHeight:{value:viewport.w}}});this.mesh=new Mesh(new PlaneGeometry(20,20),material);}}return this.mesh;}/**
		 * Resets the module
		 */reset(){this.texture=null;this.mesh=null;}/**
		 * Returns a texture representing the depth of the user's environment.
		 *
		 * @return {?ExternalTexture} The depth texture.
		 */getDepthTexture(){return this.texture;}}/**
	 * This class represents an abstraction of the WebXR Device API and is
	 * internally used by {@link WebGLRenderer}. `WebXRManager` also provides a public
	 * interface that allows users to enable/disable XR and perform XR related
	 * tasks like for instance retrieving controllers.
	 *
	 * @augments EventDispatcher
	 * @hideconstructor
	 */class WebXRManager extends EventDispatcher$1{/**
		 * Constructs a new WebGL renderer.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGL2RenderingContext} gl - The rendering context.
		 */constructor(renderer,gl){super();const scope=this;let session=null;let framebufferScaleFactor=1.0;let referenceSpace=null;let referenceSpaceType='local-floor';// Set default foveation to maximum.
	let foveation=1.0;let customReferenceSpace=null;let pose=null;let glBinding=null;let glProjLayer=null;let glBaseLayer=null;let xrFrame=null;const supportsGlBinding=typeof XRWebGLBinding!=='undefined';const depthSensing=new WebXRDepthSensing();const cameraAccessTextures={};const attributes=gl.getContextAttributes();let initialRenderTarget=null;let newRenderTarget=null;const controllers=[];const controllerInputSources=[];const currentSize=new Vector2$1();let currentPixelRatio=null;//
	const cameraL=new PerspectiveCamera();cameraL.viewport=new Vector4();const cameraR=new PerspectiveCamera();cameraR.viewport=new Vector4();const cameras=[cameraL,cameraR];const cameraXR=new ArrayCamera();let _currentDepthNear=null;let _currentDepthFar=null;//
	/**
			 * Whether the manager's XR camera should be automatically updated or not.
			 *
			 * @type {boolean}
			 * @default true
			 */this.cameraAutoUpdate=true;/**
			 * This flag notifies the renderer to be ready for XR rendering. Set it to `true`
			 * if you are going to use XR in your app.
			 *
			 * @type {boolean}
			 * @default false
			 */this.enabled=false;/**
			 * Whether XR presentation is active or not.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default false
			 */this.isPresenting=false;/**
			 * Returns a group representing the `target ray` space of the XR controller.
			 * Use this space for visualizing 3D objects that support the user in pointing
			 * tasks like UI interaction.
			 *
			 * @param {number} index - The index of the controller.
			 * @return {Group} A group representing the `target ray` space.
			 */this.getController=function(index){let controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getTargetRaySpace();};/**
			 * Returns a group representing the `grip` space of the XR controller.
			 * Use this space for visualizing 3D objects that support the user in pointing
			 * tasks like UI interaction.
			 *
			 * Note: If you want to show something in the user's hand AND offer a
			 * pointing ray at the same time, you'll want to attached the handheld object
			 * to the group returned by `getControllerGrip()` and the ray to the
			 * group returned by `getController()`. The idea is to have two
			 * different groups in two different coordinate spaces for the same WebXR
			 * controller.
			 *
			 * @param {number} index - The index of the controller.
			 * @return {Group} A group representing the `grip` space.
			 */this.getControllerGrip=function(index){let controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getGripSpace();};/**
			 * Returns a group representing the `hand` space of the XR controller.
			 * Use this space for visualizing 3D objects that support the user in pointing
			 * tasks like UI interaction.
			 *
			 * @param {number} index - The index of the controller.
			 * @return {Group} A group representing the `hand` space.
			 */this.getHand=function(index){let controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getHandSpace();};//
	function onSessionEvent(event){const controllerIndex=controllerInputSources.indexOf(event.inputSource);if(controllerIndex===-1){return;}const controller=controllers[controllerIndex];if(controller!==undefined){controller.update(event.inputSource,event.frame,customReferenceSpace||referenceSpace);controller.dispatchEvent({type:event.type,data:event.inputSource});}}function onSessionEnd(){session.removeEventListener('select',onSessionEvent);session.removeEventListener('selectstart',onSessionEvent);session.removeEventListener('selectend',onSessionEvent);session.removeEventListener('squeeze',onSessionEvent);session.removeEventListener('squeezestart',onSessionEvent);session.removeEventListener('squeezeend',onSessionEvent);session.removeEventListener('end',onSessionEnd);session.removeEventListener('inputsourceschange',onInputSourcesChange);for(let i=0;i<controllers.length;i++){const inputSource=controllerInputSources[i];if(inputSource===null)continue;controllerInputSources[i]=null;controllers[i].disconnect(inputSource);}_currentDepthNear=null;_currentDepthFar=null;depthSensing.reset();for(const key in cameraAccessTextures){delete cameraAccessTextures[key];}// restore framebuffer/rendering state
	renderer.setRenderTarget(initialRenderTarget);glBaseLayer=null;glProjLayer=null;glBinding=null;session=null;newRenderTarget=null;//
	animation.stop();scope.isPresenting=false;renderer.setPixelRatio(currentPixelRatio);renderer.setSize(currentSize.width,currentSize.height,false);scope.dispatchEvent({type:'sessionend'});}/**
			 * Sets the framebuffer scale factor.
			 *
			 * This method can not be used during a XR session.
			 *
			 * @param {number} value - The framebuffer scale factor.
			 */this.setFramebufferScaleFactor=function(value){framebufferScaleFactor=value;if(scope.isPresenting===true){warn$1('WebXRManager: Cannot change framebuffer scale while presenting.');}};/**
			 * Sets the reference space type. Can be used to configure a spatial relationship with the user's physical
			 * environment. Depending on how the user moves in 3D space, setting an appropriate reference space can
			 * improve tracking. Default is `local-floor`. Valid values can be found here
			 * https://developer.mozilla.org/en-US/docs/Web/API/XRReferenceSpace#reference_space_types.
			 *
			 * This method can not be used during a XR session.
			 *
			 * @param {string} value - The reference space type.
			 */this.setReferenceSpaceType=function(value){referenceSpaceType=value;if(scope.isPresenting===true){warn$1('WebXRManager: Cannot change reference space type while presenting.');}};/**
			 * Returns the XR reference space.
			 *
			 * @return {XRReferenceSpace} The XR reference space.
			 */this.getReferenceSpace=function(){return customReferenceSpace||referenceSpace;};/**
			 * Sets a custom XR reference space.
			 *
			 * @param {XRReferenceSpace} space - The XR reference space.
			 */this.setReferenceSpace=function(space){customReferenceSpace=space;};/**
			 * Returns the current base layer.
			 *
			 * This is an `XRProjectionLayer` when the targeted XR device supports the
			 * WebXR Layers API, or an `XRWebGLLayer` otherwise.
			 *
			 * @return {?(XRWebGLLayer|XRProjectionLayer)} The XR base layer.
			 */this.getBaseLayer=function(){return glProjLayer!==null?glProjLayer:glBaseLayer;};/**
			 * Returns the current XR binding.
			 *
			 * Creates a new binding if needed and the browser is
			 * capable of doing so.
			 *
			 * @return {?XRWebGLBinding} The XR binding. Returns `null` if one cannot be created.
			 */this.getBinding=function(){if(glBinding===null&&supportsGlBinding){glBinding=new XRWebGLBinding(session,gl);}return glBinding;};/**
			 * Returns the current XR frame.
			 *
			 * @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.
			 */this.getFrame=function(){return xrFrame;};/**
			 * Returns the current XR session.
			 *
			 * @return {?XRSession} The XR session. Returns `null` when used outside a XR session.
			 */this.getSession=function(){return session;};/**
			 * After a XR session has been requested usually with one of the `*Button` modules, it
			 * is injected into the renderer with this method. This method triggers the start of
			 * the actual XR rendering.
			 *
			 * @async
			 * @param {XRSession} value - The XR session to set.
			 * @return {Promise} A Promise that resolves when the session has been set.
			 */this.setSession=async function(value){session=value;if(session!==null){initialRenderTarget=renderer.getRenderTarget();session.addEventListener('select',onSessionEvent);session.addEventListener('selectstart',onSessionEvent);session.addEventListener('selectend',onSessionEvent);session.addEventListener('squeeze',onSessionEvent);session.addEventListener('squeezestart',onSessionEvent);session.addEventListener('squeezeend',onSessionEvent);session.addEventListener('end',onSessionEnd);session.addEventListener('inputsourceschange',onInputSourcesChange);if(attributes.xrCompatible!==true){await gl.makeXRCompatible();}currentPixelRatio=renderer.getPixelRatio();renderer.getSize(currentSize);// Check that the browser implements the necessary APIs to use an
	// XRProjectionLayer rather than an XRWebGLLayer
	const supportsLayers=supportsGlBinding&&'createProjectionLayer'in XRWebGLBinding.prototype;if(!supportsLayers){const layerInit={antialias:attributes.antialias,alpha:true,depth:attributes.depth,stencil:attributes.stencil,framebufferScaleFactor:framebufferScaleFactor};glBaseLayer=new XRWebGLLayer(session,gl,layerInit);session.updateRenderState({baseLayer:glBaseLayer});renderer.setPixelRatio(1);renderer.setSize(glBaseLayer.framebufferWidth,glBaseLayer.framebufferHeight,false);newRenderTarget=new WebGLRenderTarget(glBaseLayer.framebufferWidth,glBaseLayer.framebufferHeight,{format:RGBAFormat,type:UnsignedByteType,colorSpace:renderer.outputColorSpace,stencilBuffer:attributes.stencil,resolveDepthBuffer:glBaseLayer.ignoreDepthValues===false,resolveStencilBuffer:glBaseLayer.ignoreDepthValues===false});}else {let depthFormat=null;let depthType=null;let glDepthFormat=null;if(attributes.depth){glDepthFormat=attributes.stencil?gl.DEPTH24_STENCIL8:gl.DEPTH_COMPONENT24;depthFormat=attributes.stencil?DepthStencilFormat:DepthFormat;depthType=attributes.stencil?UnsignedInt248Type:UnsignedIntType;}const projectionlayerInit={colorFormat:gl.RGBA8,depthFormat:glDepthFormat,scaleFactor:framebufferScaleFactor};glBinding=this.getBinding();glProjLayer=glBinding.createProjectionLayer(projectionlayerInit);session.updateRenderState({layers:[glProjLayer]});renderer.setPixelRatio(1);renderer.setSize(glProjLayer.textureWidth,glProjLayer.textureHeight,false);newRenderTarget=new WebGLRenderTarget(glProjLayer.textureWidth,glProjLayer.textureHeight,{format:RGBAFormat,type:UnsignedByteType,depthTexture:new DepthTexture(glProjLayer.textureWidth,glProjLayer.textureHeight,depthType,undefined,undefined,undefined,undefined,undefined,undefined,depthFormat),stencilBuffer:attributes.stencil,colorSpace:renderer.outputColorSpace,samples:attributes.antialias?4:0,resolveDepthBuffer:glProjLayer.ignoreDepthValues===false,resolveStencilBuffer:glProjLayer.ignoreDepthValues===false});}newRenderTarget.isXRRenderTarget=true;// TODO Remove this when possible, see #23278
	this.setFoveation(foveation);customReferenceSpace=null;referenceSpace=await session.requestReferenceSpace(referenceSpaceType);animation.setContext(session);animation.start();scope.isPresenting=true;scope.dispatchEvent({type:'sessionstart'});}};/**
			 * Returns the environment blend mode from the current XR session.
			 *
			 * @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.
			 */this.getEnvironmentBlendMode=function(){if(session!==null){return session.environmentBlendMode;}};/**
			 * Returns the current depth texture computed via depth sensing.
			 *
			 * See {@link WebXRDepthSensing#getDepthTexture}.
			 *
			 * @return {?Texture} The depth texture.
			 */this.getDepthTexture=function(){return depthSensing.getDepthTexture();};function onInputSourcesChange(event){// Notify disconnected
	for(let i=0;i<event.removed.length;i++){const inputSource=event.removed[i];const index=controllerInputSources.indexOf(inputSource);if(index>=0){controllerInputSources[index]=null;controllers[index].disconnect(inputSource);}}// Notify connected
	for(let i=0;i<event.added.length;i++){const inputSource=event.added[i];let controllerIndex=controllerInputSources.indexOf(inputSource);if(controllerIndex===-1){// Assign input source a controller that currently has no input source
	for(let i=0;i<controllers.length;i++){if(i>=controllerInputSources.length){controllerInputSources.push(inputSource);controllerIndex=i;break;}else if(controllerInputSources[i]===null){controllerInputSources[i]=inputSource;controllerIndex=i;break;}}// If all controllers do currently receive input we ignore new ones
	if(controllerIndex===-1)break;}const controller=controllers[controllerIndex];if(controller){controller.connect(inputSource);}}}//
	const cameraLPos=new Vector3$1();const cameraRPos=new Vector3$1();/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 *
			 * @param {ArrayCamera} camera - The camera to update.
			 * @param {PerspectiveCamera} cameraL - The left camera.
			 * @param {PerspectiveCamera} cameraR - The right camera.
			 */function setProjectionFromUnion(camera,cameraL,cameraR){cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);const ipd=cameraLPos.distanceTo(cameraRPos);const projL=cameraL.projectionMatrix.elements;const projR=cameraR.projectionMatrix.elements;// VR systems will have identical far and near planes, and
	// most likely identical top and bottom frustum extents.
	// Use the left camera for these values.
	const near=projL[14]/(projL[10]-1);const far=projL[14]/(projL[10]+1);const topFov=(projL[9]+1)/projL[5];const bottomFov=(projL[9]-1)/projL[5];const leftFov=(projL[8]-1)/projL[0];const rightFov=(projR[8]+1)/projR[0];const left=near*leftFov;const right=near*rightFov;// Calculate the new camera's position offset from the
	// left camera. xOffset should be roughly half `ipd`.
	const zOffset=ipd/(-leftFov+rightFov);const xOffset=zOffset*-leftFov;// TODO: Better way to apply this offset?
	cameraL.matrixWorld.decompose(camera.position,camera.quaternion,camera.scale);camera.translateX(xOffset);camera.translateZ(zOffset);camera.matrixWorld.compose(camera.position,camera.quaternion,camera.scale);camera.matrixWorldInverse.copy(camera.matrixWorld).invert();// Check if the projection uses an infinite far plane.
	if(projL[10]===-1){// Use the projection matrix from the left eye.
	// The camera offset is sufficient to include the view volumes
	// of both eyes (assuming symmetric projections).
	camera.projectionMatrix.copy(cameraL.projectionMatrix);camera.projectionMatrixInverse.copy(cameraL.projectionMatrixInverse);}else {// Find the union of the frustum values of the cameras and scale
	// the values so that the near plane's position does not change in world space,
	// although must now be relative to the new union camera.
	const near2=near+zOffset;const far2=far+zOffset;const left2=left-xOffset;const right2=right+(ipd-xOffset);const top2=topFov*far/far2*near2;const bottom2=bottomFov*far/far2*near2;camera.projectionMatrix.makePerspective(left2,right2,top2,bottom2,near2,far2);camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();}}function updateCamera(camera,parent){if(parent===null){camera.matrixWorld.copy(camera.matrix);}else {camera.matrixWorld.multiplyMatrices(parent.matrixWorld,camera.matrix);}camera.matrixWorldInverse.copy(camera.matrixWorld).invert();}/**
			 * Updates the state of the XR camera. Use this method on app level if you
			 * set `cameraAutoUpdate` to `false`. The method requires the non-XR
			 * camera of the scene as a parameter. The passed in camera's transformation
			 * is automatically adjusted to the position of the XR camera when calling
			 * this method.
			 *
			 * @param {Camera} camera - The camera.
			 */this.updateCamera=function(camera){if(session===null)return;let depthNear=camera.near;let depthFar=camera.far;if(depthSensing.texture!==null){if(depthSensing.depthNear>0)depthNear=depthSensing.depthNear;if(depthSensing.depthFar>0)depthFar=depthSensing.depthFar;}cameraXR.near=cameraR.near=cameraL.near=depthNear;cameraXR.far=cameraR.far=cameraL.far=depthFar;if(_currentDepthNear!==cameraXR.near||_currentDepthFar!==cameraXR.far){// Note that the new renderState won't apply until the next frame. See #18320
	session.updateRenderState({depthNear:cameraXR.near,depthFar:cameraXR.far});_currentDepthNear=cameraXR.near;_currentDepthFar=cameraXR.far;}// inherit camera layers and enable eye layers (1 = left, 2 = right)
	cameraXR.layers.mask=camera.layers.mask|0b110;cameraL.layers.mask=cameraXR.layers.mask&0b011;cameraR.layers.mask=cameraXR.layers.mask&0b101;const parent=camera.parent;const cameras=cameraXR.cameras;updateCamera(cameraXR,parent);for(let i=0;i<cameras.length;i++){updateCamera(cameras[i],parent);}// update projection matrix for proper view frustum culling
	if(cameras.length===2){setProjectionFromUnion(cameraXR,cameraL,cameraR);}else {// assume single camera setup (AR)
	cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);}// update user camera and its children
	updateUserCamera(camera,cameraXR,parent);};function updateUserCamera(camera,cameraXR,parent){if(parent===null){camera.matrix.copy(cameraXR.matrixWorld);}else {camera.matrix.copy(parent.matrixWorld);camera.matrix.invert();camera.matrix.multiply(cameraXR.matrixWorld);}camera.matrix.decompose(camera.position,camera.quaternion,camera.scale);camera.updateMatrixWorld(true);camera.projectionMatrix.copy(cameraXR.projectionMatrix);camera.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse);if(camera.isPerspectiveCamera){camera.fov=RAD2DEG*2*Math.atan(1/camera.projectionMatrix.elements[5]);camera.zoom=1;}}/**
			 * Returns an instance of {@link ArrayCamera} which represents the XR camera
			 * of the active XR session. For each view it holds a separate camera object.
			 *
			 * The camera's `fov` is currently not used and does not reflect the fov of
			 * the XR camera. If you need the fov on app level, you have to compute in
			 * manually from the XR camera's projection matrices.
			 *
			 * @return {ArrayCamera} The XR camera.
			 */this.getCamera=function(){return cameraXR;};/**
			 * Returns the amount of foveation used by the XR compositor for the projection layer.
			 *
			 * @return {number|undefined} The amount of foveation.
			 */this.getFoveation=function(){if(glProjLayer===null&&glBaseLayer===null){return undefined;}return foveation;};/**
			 * Sets the foveation value.
			 *
			 * @param {number} value - A number in the range `[0,1]` where `0` means no foveation (full resolution)
			 * and `1` means maximum foveation (the edges render at lower resolution).
			 */this.setFoveation=function(value){// 0 = no foveation = full resolution
	// 1 = maximum foveation = the edges render at lower resolution
	foveation=value;if(glProjLayer!==null){glProjLayer.fixedFoveation=value;}if(glBaseLayer!==null&&glBaseLayer.fixedFoveation!==undefined){glBaseLayer.fixedFoveation=value;}};/**
			 * Returns `true` if depth sensing is supported.
			 *
			 * @return {boolean} Whether depth sensing is supported or not.
			 */this.hasDepthSensing=function(){return depthSensing.texture!==null;};/**
			 * Returns the depth sensing mesh.
			 *
			 * See {@link WebXRDepthSensing#getMesh}.
			 *
			 * @return {Mesh} The depth sensing mesh.
			 */this.getDepthSensingMesh=function(){return depthSensing.getMesh(cameraXR);};/**
			 * Retrieves an opaque texture from the view-aligned {@link XRCamera}.
			 * Only available during the current animation loop.
			 *
			 * @param {XRCamera} xrCamera - The camera to query.
			 * @return {?Texture} An opaque texture representing the current raw camera frame.
			 */this.getCameraTexture=function(xrCamera){return cameraAccessTextures[xrCamera];};// Animation Loop
	let onAnimationFrameCallback=null;function onAnimationFrame(time,frame){pose=frame.getViewerPose(customReferenceSpace||referenceSpace);xrFrame=frame;if(pose!==null){const views=pose.views;if(glBaseLayer!==null){renderer.setRenderTargetFramebuffer(newRenderTarget,glBaseLayer.framebuffer);renderer.setRenderTarget(newRenderTarget);}let cameraXRNeedsUpdate=false;// check if it's necessary to rebuild cameraXR's camera list
	if(views.length!==cameraXR.cameras.length){cameraXR.cameras.length=0;cameraXRNeedsUpdate=true;}for(let i=0;i<views.length;i++){const view=views[i];let viewport=null;if(glBaseLayer!==null){viewport=glBaseLayer.getViewport(view);}else {const glSubImage=glBinding.getViewSubImage(glProjLayer,view);viewport=glSubImage.viewport;// For side-by-side projection, we only produce a single texture for both eyes.
	if(i===0){renderer.setRenderTargetTextures(newRenderTarget,glSubImage.colorTexture,glSubImage.depthStencilTexture);renderer.setRenderTarget(newRenderTarget);}}let camera=cameras[i];if(camera===undefined){camera=new PerspectiveCamera();camera.layers.enable(i);camera.viewport=new Vector4();cameras[i]=camera;}camera.matrix.fromArray(view.transform.matrix);camera.matrix.decompose(camera.position,camera.quaternion,camera.scale);camera.projectionMatrix.fromArray(view.projectionMatrix);camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();camera.viewport.set(viewport.x,viewport.y,viewport.width,viewport.height);if(i===0){cameraXR.matrix.copy(camera.matrix);cameraXR.matrix.decompose(cameraXR.position,cameraXR.quaternion,cameraXR.scale);}if(cameraXRNeedsUpdate===true){cameraXR.cameras.push(camera);}}//
	const enabledFeatures=session.enabledFeatures;const gpuDepthSensingEnabled=enabledFeatures&&enabledFeatures.includes('depth-sensing')&&session.depthUsage=='gpu-optimized';if(gpuDepthSensingEnabled&&supportsGlBinding){glBinding=scope.getBinding();const depthData=glBinding.getDepthInformation(views[0]);if(depthData&&depthData.isValid&&depthData.texture){depthSensing.init(depthData,session.renderState);}}const cameraAccessEnabled=enabledFeatures&&enabledFeatures.includes('camera-access');if(cameraAccessEnabled&&supportsGlBinding){renderer.state.unbindTexture();glBinding=scope.getBinding();for(let i=0;i<views.length;i++){const camera=views[i].camera;if(camera){let cameraTex=cameraAccessTextures[camera];if(!cameraTex){cameraTex=new ExternalTexture();cameraAccessTextures[camera]=cameraTex;}const glTexture=glBinding.getCameraImage(camera);cameraTex.sourceTexture=glTexture;}}}}//
	for(let i=0;i<controllers.length;i++){const inputSource=controllerInputSources[i];const controller=controllers[i];if(inputSource!==null&&controller!==undefined){controller.update(inputSource,frame,customReferenceSpace||referenceSpace);}}if(onAnimationFrameCallback)onAnimationFrameCallback(time,frame);if(frame.detectedPlanes){scope.dispatchEvent({type:'planesdetected',data:frame});}xrFrame=null;}const animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;};this.dispose=function(){};}}const _e1=/*@__PURE__*/new Euler$1();const _m1$3=/*@__PURE__*/new Matrix4$1();function WebGLMaterials(renderer,properties){function refreshTransformUniform(map,uniform){if(map.matrixAutoUpdate===true){map.updateMatrix();}uniform.value.copy(map.matrix);}function refreshFogUniforms(uniforms,fog){fog.color.getRGB(uniforms.fogColor.value,getUnlitUniformColorSpace(renderer));if(fog.isFog){uniforms.fogNear.value=fog.near;uniforms.fogFar.value=fog.far;}else if(fog.isFogExp2){uniforms.fogDensity.value=fog.density;}}function refreshMaterialUniforms(uniforms,material,pixelRatio,height,transmissionRenderTarget){if(material.isMeshBasicMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isMeshLambertMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isMeshToonMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsToon(uniforms,material);}else if(material.isMeshPhongMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsPhong(uniforms,material);}else if(material.isMeshStandardMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsStandard(uniforms,material);if(material.isMeshPhysicalMaterial){refreshUniformsPhysical(uniforms,material,transmissionRenderTarget);}}else if(material.isMeshMatcapMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsMatcap(uniforms,material);}else if(material.isMeshDepthMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isMeshDistanceMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsDistance(uniforms,material);}else if(material.isMeshNormalMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isLineBasicMaterial){refreshUniformsLine(uniforms,material);if(material.isLineDashedMaterial){refreshUniformsDash(uniforms,material);}}else if(material.isPointsMaterial){refreshUniformsPoints(uniforms,material,pixelRatio,height);}else if(material.isSpriteMaterial){refreshUniformsSprites(uniforms,material);}else if(material.isShadowMaterial){uniforms.color.value.copy(material.color);uniforms.opacity.value=material.opacity;}else if(material.isShaderMaterial){material.uniformsNeedUpdate=false;// #15581
	}}function refreshUniformsCommon(uniforms,material){uniforms.opacity.value=material.opacity;if(material.color){uniforms.diffuse.value.copy(material.color);}if(material.emissive){uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);}if(material.map){uniforms.map.value=material.map;refreshTransformUniform(material.map,uniforms.mapTransform);}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;refreshTransformUniform(material.alphaMap,uniforms.alphaMapTransform);}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;refreshTransformUniform(material.bumpMap,uniforms.bumpMapTransform);uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide){uniforms.bumpScale.value*=-1;}}if(material.normalMap){uniforms.normalMap.value=material.normalMap;refreshTransformUniform(material.normalMap,uniforms.normalMapTransform);uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide){uniforms.normalScale.value.negate();}}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;refreshTransformUniform(material.displacementMap,uniforms.displacementMapTransform);uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;refreshTransformUniform(material.emissiveMap,uniforms.emissiveMapTransform);}if(material.specularMap){uniforms.specularMap.value=material.specularMap;refreshTransformUniform(material.specularMap,uniforms.specularMapTransform);}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}const materialProperties=properties.get(material);const envMap=materialProperties.envMap;const envMapRotation=materialProperties.envMapRotation;if(envMap){uniforms.envMap.value=envMap;_e1.copy(envMapRotation);// accommodate left-handed frame
	_e1.x*=-1;_e1.y*=-1;_e1.z*=-1;if(envMap.isCubeTexture&&envMap.isRenderTargetTexture===false){// environment maps which are not cube render targets or PMREMs follow a different convention
	_e1.y*=-1;_e1.z*=-1;}uniforms.envMapRotation.value.setFromMatrix4(_m1$3.makeRotationFromEuler(_e1));uniforms.flipEnvMap.value=envMap.isCubeTexture&&envMap.isRenderTargetTexture===false?-1:1;uniforms.reflectivity.value=material.reflectivity;uniforms.ior.value=material.ior;uniforms.refractionRatio.value=material.refractionRatio;}if(material.lightMap){uniforms.lightMap.value=material.lightMap;uniforms.lightMapIntensity.value=material.lightMapIntensity;refreshTransformUniform(material.lightMap,uniforms.lightMapTransform);}if(material.aoMap){uniforms.aoMap.value=material.aoMap;uniforms.aoMapIntensity.value=material.aoMapIntensity;refreshTransformUniform(material.aoMap,uniforms.aoMapTransform);}}function refreshUniformsLine(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;if(material.map){uniforms.map.value=material.map;refreshTransformUniform(material.map,uniforms.mapTransform);}}function refreshUniformsDash(uniforms,material){uniforms.dashSize.value=material.dashSize;uniforms.totalSize.value=material.dashSize+material.gapSize;uniforms.scale.value=material.scale;}function refreshUniformsPoints(uniforms,material,pixelRatio,height){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.size.value=material.size*pixelRatio;uniforms.scale.value=height*0.5;if(material.map){uniforms.map.value=material.map;refreshTransformUniform(material.map,uniforms.uvTransform);}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;refreshTransformUniform(material.alphaMap,uniforms.alphaMapTransform);}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}}function refreshUniformsSprites(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.rotation.value=material.rotation;if(material.map){uniforms.map.value=material.map;refreshTransformUniform(material.map,uniforms.mapTransform);}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;refreshTransformUniform(material.alphaMap,uniforms.alphaMapTransform);}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}}function refreshUniformsPhong(uniforms,material){uniforms.specular.value.copy(material.specular);uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )
	}function refreshUniformsToon(uniforms,material){if(material.gradientMap){uniforms.gradientMap.value=material.gradientMap;}}function refreshUniformsStandard(uniforms,material){uniforms.metalness.value=material.metalness;if(material.metalnessMap){uniforms.metalnessMap.value=material.metalnessMap;refreshTransformUniform(material.metalnessMap,uniforms.metalnessMapTransform);}uniforms.roughness.value=material.roughness;if(material.roughnessMap){uniforms.roughnessMap.value=material.roughnessMap;refreshTransformUniform(material.roughnessMap,uniforms.roughnessMapTransform);}if(material.envMap){//uniforms.envMap.value = material.envMap; // part of uniforms common
	uniforms.envMapIntensity.value=material.envMapIntensity;}}function refreshUniformsPhysical(uniforms,material,transmissionRenderTarget){uniforms.ior.value=material.ior;// also part of uniforms common
	if(material.sheen>0){uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);uniforms.sheenRoughness.value=material.sheenRoughness;if(material.sheenColorMap){uniforms.sheenColorMap.value=material.sheenColorMap;refreshTransformUniform(material.sheenColorMap,uniforms.sheenColorMapTransform);}if(material.sheenRoughnessMap){uniforms.sheenRoughnessMap.value=material.sheenRoughnessMap;refreshTransformUniform(material.sheenRoughnessMap,uniforms.sheenRoughnessMapTransform);}}if(material.clearcoat>0){uniforms.clearcoat.value=material.clearcoat;uniforms.clearcoatRoughness.value=material.clearcoatRoughness;if(material.clearcoatMap){uniforms.clearcoatMap.value=material.clearcoatMap;refreshTransformUniform(material.clearcoatMap,uniforms.clearcoatMapTransform);}if(material.clearcoatRoughnessMap){uniforms.clearcoatRoughnessMap.value=material.clearcoatRoughnessMap;refreshTransformUniform(material.clearcoatRoughnessMap,uniforms.clearcoatRoughnessMapTransform);}if(material.clearcoatNormalMap){uniforms.clearcoatNormalMap.value=material.clearcoatNormalMap;refreshTransformUniform(material.clearcoatNormalMap,uniforms.clearcoatNormalMapTransform);uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);if(material.side===BackSide){uniforms.clearcoatNormalScale.value.negate();}}}if(material.dispersion>0){uniforms.dispersion.value=material.dispersion;}if(material.iridescence>0){uniforms.iridescence.value=material.iridescence;uniforms.iridescenceIOR.value=material.iridescenceIOR;uniforms.iridescenceThicknessMinimum.value=material.iridescenceThicknessRange[0];uniforms.iridescenceThicknessMaximum.value=material.iridescenceThicknessRange[1];if(material.iridescenceMap){uniforms.iridescenceMap.value=material.iridescenceMap;refreshTransformUniform(material.iridescenceMap,uniforms.iridescenceMapTransform);}if(material.iridescenceThicknessMap){uniforms.iridescenceThicknessMap.value=material.iridescenceThicknessMap;refreshTransformUniform(material.iridescenceThicknessMap,uniforms.iridescenceThicknessMapTransform);}}if(material.transmission>0){uniforms.transmission.value=material.transmission;uniforms.transmissionSamplerMap.value=transmissionRenderTarget.texture;uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width,transmissionRenderTarget.height);if(material.transmissionMap){uniforms.transmissionMap.value=material.transmissionMap;refreshTransformUniform(material.transmissionMap,uniforms.transmissionMapTransform);}uniforms.thickness.value=material.thickness;if(material.thicknessMap){uniforms.thicknessMap.value=material.thicknessMap;refreshTransformUniform(material.thicknessMap,uniforms.thicknessMapTransform);}uniforms.attenuationDistance.value=material.attenuationDistance;uniforms.attenuationColor.value.copy(material.attenuationColor);}if(material.anisotropy>0){uniforms.anisotropyVector.value.set(material.anisotropy*Math.cos(material.anisotropyRotation),material.anisotropy*Math.sin(material.anisotropyRotation));if(material.anisotropyMap){uniforms.anisotropyMap.value=material.anisotropyMap;refreshTransformUniform(material.anisotropyMap,uniforms.anisotropyMapTransform);}}uniforms.specularIntensity.value=material.specularIntensity;uniforms.specularColor.value.copy(material.specularColor);if(material.specularColorMap){uniforms.specularColorMap.value=material.specularColorMap;refreshTransformUniform(material.specularColorMap,uniforms.specularColorMapTransform);}if(material.specularIntensityMap){uniforms.specularIntensityMap.value=material.specularIntensityMap;refreshTransformUniform(material.specularIntensityMap,uniforms.specularIntensityMapTransform);}}function refreshUniformsMatcap(uniforms,material){if(material.matcap){uniforms.matcap.value=material.matcap;}}function refreshUniformsDistance(uniforms,material){const light=properties.get(material).light;uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);uniforms.nearDistance.value=light.shadow.camera.near;uniforms.farDistance.value=light.shadow.camera.far;}return {refreshFogUniforms:refreshFogUniforms,refreshMaterialUniforms:refreshMaterialUniforms};}function WebGLUniformsGroups(gl,info,capabilities,state){let buffers={};let updateList={};let allocatedBindingPoints=[];const maxBindingPoints=gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);// binding points are global whereas block indices are per shader program
	function bind(uniformsGroup,program){const webglProgram=program.program;state.uniformBlockBinding(uniformsGroup,webglProgram);}function update(uniformsGroup,program){let buffer=buffers[uniformsGroup.id];if(buffer===undefined){prepareUniformsGroup(uniformsGroup);buffer=createBuffer(uniformsGroup);buffers[uniformsGroup.id]=buffer;uniformsGroup.addEventListener('dispose',onUniformsGroupsDispose);}// ensure to update the binding points/block indices mapping for this program
	const webglProgram=program.program;state.updateUBOMapping(uniformsGroup,webglProgram);// update UBO once per frame
	const frame=info.render.frame;if(updateList[uniformsGroup.id]!==frame){updateBufferData(uniformsGroup);updateList[uniformsGroup.id]=frame;}}function createBuffer(uniformsGroup){// the setup of an UBO is independent of a particular shader program but global
	const bindingPointIndex=allocateBindingPointIndex();uniformsGroup.__bindingPointIndex=bindingPointIndex;const buffer=gl.createBuffer();const size=uniformsGroup.__size;const usage=uniformsGroup.usage;gl.bindBuffer(gl.UNIFORM_BUFFER,buffer);gl.bufferData(gl.UNIFORM_BUFFER,size,usage);gl.bindBuffer(gl.UNIFORM_BUFFER,null);gl.bindBufferBase(gl.UNIFORM_BUFFER,bindingPointIndex,buffer);return buffer;}function allocateBindingPointIndex(){for(let i=0;i<maxBindingPoints;i++){if(allocatedBindingPoints.indexOf(i)===-1){allocatedBindingPoints.push(i);return i;}}error$1('WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.');return 0;}function updateBufferData(uniformsGroup){const buffer=buffers[uniformsGroup.id];const uniforms=uniformsGroup.uniforms;const cache=uniformsGroup.__cache;gl.bindBuffer(gl.UNIFORM_BUFFER,buffer);for(let i=0,il=uniforms.length;i<il;i++){const uniformArray=Array.isArray(uniforms[i])?uniforms[i]:[uniforms[i]];for(let j=0,jl=uniformArray.length;j<jl;j++){const uniform=uniformArray[j];if(hasUniformChanged(uniform,i,j,cache)===true){const offset=uniform.__offset;const values=Array.isArray(uniform.value)?uniform.value:[uniform.value];let arrayOffset=0;for(let k=0;k<values.length;k++){const value=values[k];const info=getUniformSize(value);// TODO add integer and struct support
	if(typeof value==='number'||typeof value==='boolean'){uniform.__data[0]=value;gl.bufferSubData(gl.UNIFORM_BUFFER,offset+arrayOffset,uniform.__data);}else if(value.isMatrix3){// manually converting 3x3 to 3x4
	uniform.__data[0]=value.elements[0];uniform.__data[1]=value.elements[1];uniform.__data[2]=value.elements[2];uniform.__data[3]=0;uniform.__data[4]=value.elements[3];uniform.__data[5]=value.elements[4];uniform.__data[6]=value.elements[5];uniform.__data[7]=0;uniform.__data[8]=value.elements[6];uniform.__data[9]=value.elements[7];uniform.__data[10]=value.elements[8];uniform.__data[11]=0;}else {value.toArray(uniform.__data,arrayOffset);arrayOffset+=info.storage/Float32Array.BYTES_PER_ELEMENT;}}gl.bufferSubData(gl.UNIFORM_BUFFER,offset,uniform.__data);}}}gl.bindBuffer(gl.UNIFORM_BUFFER,null);}function hasUniformChanged(uniform,index,indexArray,cache){const value=uniform.value;const indexString=index+'_'+indexArray;if(cache[indexString]===undefined){// cache entry does not exist so far
	if(typeof value==='number'||typeof value==='boolean'){cache[indexString]=value;}else {cache[indexString]=value.clone();}return true;}else {const cachedObject=cache[indexString];// compare current value with cached entry
	if(typeof value==='number'||typeof value==='boolean'){if(cachedObject!==value){cache[indexString]=value;return true;}}else {if(cachedObject.equals(value)===false){cachedObject.copy(value);return true;}}}return false;}function prepareUniformsGroup(uniformsGroup){// determine total buffer size according to the STD140 layout
	// Hint: STD140 is the only supported layout in WebGL 2
	const uniforms=uniformsGroup.uniforms;let offset=0;// global buffer offset in bytes
	const chunkSize=16;// size of a chunk in bytes
	for(let i=0,l=uniforms.length;i<l;i++){const uniformArray=Array.isArray(uniforms[i])?uniforms[i]:[uniforms[i]];for(let j=0,jl=uniformArray.length;j<jl;j++){const uniform=uniformArray[j];const values=Array.isArray(uniform.value)?uniform.value:[uniform.value];for(let k=0,kl=values.length;k<kl;k++){const value=values[k];const info=getUniformSize(value);const chunkOffset=offset%chunkSize;// offset in the current chunk
	const chunkPadding=chunkOffset%info.boundary;// required padding to match boundary
	const chunkStart=chunkOffset+chunkPadding;// the start position in the current chunk for the data
	offset+=chunkPadding;// Check for chunk overflow
	if(chunkStart!==0&&chunkSize-chunkStart<info.storage){// Add padding and adjust offset
	offset+=chunkSize-chunkStart;}// the following two properties will be used for partial buffer updates
	uniform.__data=new Float32Array(info.storage/Float32Array.BYTES_PER_ELEMENT);uniform.__offset=offset;// Update the global offset
	offset+=info.storage;}}}// ensure correct final padding
	const chunkOffset=offset%chunkSize;if(chunkOffset>0)offset+=chunkSize-chunkOffset;//
	uniformsGroup.__size=offset;uniformsGroup.__cache={};return this;}function getUniformSize(value){const info={boundary:0,// bytes
	storage:0// bytes
	};// determine sizes according to STD140
	if(typeof value==='number'||typeof value==='boolean'){// float/int/bool
	info.boundary=4;info.storage=4;}else if(value.isVector2){// vec2
	info.boundary=8;info.storage=8;}else if(value.isVector3||value.isColor){// vec3
	info.boundary=16;info.storage=12;// evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes
	}else if(value.isVector4){// vec4
	info.boundary=16;info.storage=16;}else if(value.isMatrix3){// mat3 (in STD140 a 3x3 matrix is represented as 3x4)
	info.boundary=48;info.storage=48;}else if(value.isMatrix4){// mat4
	info.boundary=64;info.storage=64;}else if(value.isTexture){warn$1('WebGLRenderer: Texture samplers can not be part of an uniforms group.');}else {warn$1('WebGLRenderer: Unsupported uniform value type.',value);}return info;}function onUniformsGroupsDispose(event){const uniformsGroup=event.target;uniformsGroup.removeEventListener('dispose',onUniformsGroupsDispose);const index=allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);allocatedBindingPoints.splice(index,1);gl.deleteBuffer(buffers[uniformsGroup.id]);delete buffers[uniformsGroup.id];delete updateList[uniformsGroup.id];}function dispose(){for(const id in buffers){gl.deleteBuffer(buffers[id]);}allocatedBindingPoints=[];buffers={};updateList={};}return {bind:bind,update:update,dispose:dispose};}/**
	 * Precomputed DFG LUT for Image-Based Lighting
	 * Resolution: 32x32
	 * Samples: 4096 per texel
	 * Format: RG16F (2 half floats per texel: scale, bias)
	 */const DATA=new Uint16Array([0x2cd9,0x3b64,0x2d0e,0x3b43,0x2e20,0x3aa7,0x3061,0x39fb,0x325e,0x397c,0x3454,0x3908,0x357d,0x3893,0x3698,0x381e,0x379d,0x375b,0x3845,0x3689,0x38af,0x35ca,0x390d,0x351e,0x395f,0x3484,0x39a8,0x33f9,0x39e6,0x330a,0x3a1c,0x3239,0x3a4b,0x3183,0x3a73,0x30e5,0x3a95,0x305b,0x3ab1,0x2fc6,0x3ac9,0x2ef7,0x3ade,0x2e43,0x3aee,0x2da7,0x3afc,0x2d1f,0x3b07,0x2ca9,0x3b10,0x2c42,0x3b17,0x2bd1,0x3b1c,0x2b34,0x3b1f,0x2aaa,0x3b22,0x2a31,0x3b23,0x29c7,0x3b23,0x2968,0x32d4,0x3a4b,0x32dc,0x3a45,0x3308,0x3a26,0x3378,0x39d0,0x3425,0x394a,0x34c9,0x38be,0x359c,0x383e,0x3688,0x3796,0x3778,0x36c4,0x382f,0x3603,0x3898,0x3553,0x38f7,0x34b3,0x394b,0x3424,0x3994,0x334c,0x39d3,0x326c,0x3a08,0x31a9,0x3a35,0x30fe,0x3a5a,0x306a,0x3a78,0x2fd1,0x3a90,0x2ef1,0x3aa2,0x2e2e,0x3ab0,0x2d86,0x3aba,0x2cf3,0x3ac1,0x2c74,0x3ac4,0x2c05,0x3ac4,0x2b49,0x3ac2,0x2aa1,0x3abd,0x2a0c,0x3ab7,0x298b,0x3aaf,0x2918,0x3aa6,0x28b3,0x3a9b,0x285a,0x3559,0x3954,0x355a,0x3951,0x3566,0x3944,0x3582,0x391e,0x35b6,0x38d3,0x360a,0x386a,0x3684,0x37ed,0x3720,0x370d,0x37d3,0x3641,0x3847,0x3588,0x38a3,0x34e2,0x38fa,0x344d,0x3948,0x3391,0x398d,0x32a6,0x39c8,0x31d6,0x39fa,0x3121,0x3a22,0x3082,0x3a43,0x2ff0,0x3a5c,0x2f01,0x3a6f,0x2e32,0x3a7c,0x2d7e,0x3a84,0x2ce2,0x3a87,0x2c5b,0x3a87,0x2bcc,0x3a83,0x2b00,0x3a7b,0x2a4e,0x3a71,0x29b3,0x3a66,0x292c,0x3a58,0x28b4,0x3a4b,0x284b,0x3a3d,0x27dc,0x3a2e,0x2739,0x3709,0x387c,0x370a,0x387b,0x3710,0x3874,0x3720,0x385f,0x373d,0x3834,0x376a,0x37e1,0x37ac,0x3732,0x3805,0x3675,0x383f,0x35bc,0x3883,0x3511,0x38cb,0x3476,0x3912,0x33d8,0x3955,0x32e2,0x3991,0x3208,0x39c6,0x3149,0x39f1,0x30a1,0x3a15,0x300f,0x3a30,0x2f21,0x3a44,0x2e45,0x3a51,0x2d87,0x3a59,0x2ce2,0x3a5b,0x2c53,0x3a58,0x2bb0,0x3a52,0x2ada,0x3a49,0x2a1f,0x3a40,0x297d,0x3a34,0x28f0,0x3a25,0x2874,0x3a13,0x2807,0x3a00,0x274e,0x39eb,0x26a6,0x39d5,0x2611,0x3840,0x3780,0x3840,0x377e,0x3842,0x3776,0x3846,0x375e,0x384f,0x372a,0x385b,0x36d3,0x386c,0x3659,0x3885,0x35c7,0x38a8,0x352d,0x38d4,0x3497,0x3906,0x340c,0x393b,0x331a,0x3970,0x323a,0x39a0,0x3172,0x39cb,0x30c3,0x39ef,0x302a,0x3a0c,0x2f4a,0x3a21,0x2e63,0x3a2f,0x2d9b,0x3a37,0x2ced,0x3a39,0x2c57,0x3a37,0x2baa,0x3a34,0x2ac9,0x3a2c,0x2a05,0x3a20,0x295d,0x3a11,0x28ca,0x39ff,0x2849,0x39eb,0x27b2,0x39d5,0x26ed,0x39be,0x2640,0x39a5,0x25aa,0x398b,0x2523,0x38e2,0x363b,0x38e2,0x363b,0x38e3,0x3635,0x38e6,0x3626,0x38ea,0x3606,0x38f0,0x35cd,0x38f8,0x3579,0x3903,0x350e,0x3915,0x3495,0x392d,0x3418,0x394c,0x3340,0x3970,0x3261,0x3995,0x3197,0x39b8,0x30e4,0x39d8,0x3046,0x39f3,0x2f76,0x3a08,0x2e86,0x3a16,0x2db5,0x3a1e,0x2cff,0x3a22,0x2c61,0x3a24,0x2bb3,0x3a20,0x2ac7,0x3a17,0x29fc,0x3a0a,0x294c,0x39fa,0x28b2,0x39e7,0x282e,0x39d1,0x2773,0x39b9,0x26a9,0x399f,0x25fa,0x3985,0x255f,0x3968,0x24d6,0x394a,0x245d,0x396e,0x3524,0x396e,0x3524,0x396e,0x3520,0x396f,0x3517,0x3971,0x3502,0x3973,0x34dd,0x3975,0x34a5,0x3978,0x3458,0x397e,0x33f9,0x3987,0x3332,0x3997,0x326b,0x39aa,0x31ac,0x39c0,0x30fb,0x39d7,0x305c,0x39eb,0x2f9e,0x39fc,0x2ea7,0x3a07,0x2dcf,0x3a0f,0x2d13,0x3a16,0x2c70,0x3a17,0x2bc4,0x3a14,0x2ad0,0x3a0a,0x29fc,0x39fd,0x2945,0x39ed,0x28a6,0x39d9,0x281d,0x39c2,0x274a,0x39a9,0x267c,0x398e,0x25c7,0x3971,0x2528,0x3952,0x249e,0x3931,0x2425,0x3910,0x2374,0x39e5,0x3436,0x39e5,0x3435,0x39e5,0x3434,0x39e5,0x342e,0x39e5,0x3420,0x39e5,0x3408,0x39e3,0x33c4,0x39e1,0x3359,0x39df,0x32d3,0x39de,0x323a,0x39e1,0x319a,0x39e7,0x30fb,0x39f0,0x3065,0x39f9,0x2fb6,0x3a02,0x2ec0,0x3a08,0x2de6,0x3a0d,0x2d26,0x3a12,0x2c7e,0x3a13,0x2bda,0x3a0e,0x2adc,0x3a05,0x2a02,0x39f8,0x2945,0x39e7,0x28a1,0x39d3,0x2813,0x39bc,0x2730,0x39a2,0x265c,0x3985,0x25a3,0x3966,0x2501,0x3945,0x2475,0x3923,0x23f3,0x3901,0x231c,0x38dd,0x225e,0x3a4b,0x32d6,0x3a4a,0x32d6,0x3a4a,0x32d4,0x3a4a,0x32cc,0x3a48,0x32bb,0x3a47,0x329d,0x3a43,0x326b,0x3a3d,0x3222,0x3a36,0x31c2,0x3a2e,0x314f,0x3a28,0x30d2,0x3a23,0x3052,0x3a20,0x2fab,0x3a1e,0x2ec2,0x3a1b,0x2def,0x3a19,0x2d31,0x3a1a,0x2c89,0x3a18,0x2beb,0x3a11,0x2aea,0x3a07,0x2a0a,0x39fa,0x2948,0x39e9,0x28a1,0x39d4,0x280f,0x39bd,0x2721,0x39a2,0x2647,0x3985,0x258b,0x3964,0x24e5,0x3942,0x2455,0x391f,0x23b3,0x38fb,0x22d8,0x38d4,0x2219,0x38ad,0x2172,0x3aa0,0x3180,0x3aa0,0x3180,0x3aa0,0x317f,0x3a9f,0x317b,0x3a9d,0x3170,0x3a99,0x315d,0x3a95,0x313d,0x3a8d,0x310c,0x3a82,0x30ca,0x3a76,0x3077,0x3a69,0x3019,0x3a5c,0x2f68,0x3a4f,0x2e9e,0x3a42,0x2dde,0x3a37,0x2d2b,0x3a30,0x2c89,0x3a29,0x2bef,0x3a1f,0x2af0,0x3a12,0x2a0f,0x3a03,0x294a,0x39f1,0x28a0,0x39dc,0x280c,0x39c5,0x2717,0x39a9,0x2638,0x398b,0x2578,0x396a,0x24d0,0x3947,0x243f,0x3923,0x2380,0x38fc,0x22a4,0x38d4,0x21e4,0x38ac,0x213c,0x3883,0x20a8,0x3ae8,0x3062,0x3ae8,0x3062,0x3ae7,0x3061,0x3ae6,0x305f,0x3ae4,0x305a,0x3ae0,0x304f,0x3ada,0x303b,0x3ad1,0x301b,0x3ac5,0x2fdd,0x3ab6,0x2f6a,0x3aa4,0x2ede,0x3a91,0x2e45,0x3a7c,0x2da5,0x3a67,0x2d0a,0x3a57,0x2c77,0x3a48,0x2bdc,0x3a38,0x2ae5,0x3a27,0x2a0a,0x3a16,0x2947,0x3a02,0x289d,0x39eb,0x2808,0x39d3,0x270d,0x39b6,0x262b,0x3997,0x256a,0x3976,0x24bf,0x3952,0x242b,0x392d,0x2358,0x3904,0x227a,0x38db,0x21b8,0x38b2,0x2110,0x3887,0x207d,0x385b,0x1ff6,0x3b23,0x2ee8,0x3b23,0x2ee8,0x3b22,0x2ee8,0x3b21,0x2ee7,0x3b1f,0x2ee3,0x3b1a,0x2ed6,0x3b14,0x2ec1,0x3b0b,0x2e99,0x3afe,0x2e60,0x3aee,0x2e12,0x3ad8,0x2dad,0x3ac1,0x2d3d,0x3aa5,0x2cc3,0x3a8b,0x2c48,0x3a76,0x2ba2,0x3a60,0x2ac0,0x3a49,0x29f2,0x3a32,0x2938,0x3a1b,0x2893,0x3a02,0x27ff,0x39e8,0x26ff,0x39ca,0x261e,0x39aa,0x255b,0x3988,0x24b0,0x3964,0x241c,0x393d,0x2336,0x3913,0x2257,0x38e9,0x2195,0x38be,0x20eb,0x3891,0x2059,0x3864,0x1fae,0x3837,0x1ecd,0x3b54,0x2d61,0x3b54,0x2d61,0x3b53,0x2d61,0x3b52,0x2d62,0x3b4f,0x2d61,0x3b4b,0x2d5c,0x3b45,0x2d51,0x3b3b,0x2d3d,0x3b2e,0x2d1a,0x3b1d,0x2ce7,0x3b06,0x2ca3,0x3aeb,0x2c52,0x3acb,0x2bee,0x3ab0,0x2b31,0x3a94,0x2a74,0x3a77,0x29bf,0x3a5a,0x2915,0x3a3f,0x287a,0x3a22,0x27de,0x3a05,0x26e4,0x39e5,0x2609,0x39c3,0x2547,0x39a0,0x249f,0x397b,0x240c,0x3953,0x2314,0x3928,0x2238,0x38fd,0x2175,0x38d0,0x20cb,0x38a2,0x2038,0x3873,0x1f71,0x3844,0x1e90,0x3815,0x1dce,0x3b7c,0x2c22,0x3b7c,0x2c22,0x3b7b,0x2c23,0x3b7a,0x2c25,0x3b77,0x2c27,0x3b73,0x2c26,0x3b6d,0x2c23,0x3b64,0x2c1a,0x3b57,0x2c07,0x3b46,0x2bd1,0x3b2e,0x2b79,0x3b0f,0x2b07,0x3aef,0x2a86,0x3ad1,0x29f8,0x3ab0,0x2967,0x3a8e,0x28d7,0x3a6d,0x284e,0x3a4c,0x279f,0x3a2b,0x26b7,0x3a08,0x25e5,0x39e4,0x252c,0x39be,0x2488,0x3998,0x23f0,0x396f,0x22f2,0x3943,0x2215,0x3917,0x2155,0x38e8,0x20ae,0x38b9,0x201c,0x3888,0x1f38,0x3857,0x1e5a,0x3826,0x1d9a,0x37eb,0x1cf0,0x3b9c,0x2a43,0x3b9c,0x2a43,0x3b9b,0x2a46,0x3b9a,0x2a4a,0x3b98,0x2a50,0x3b93,0x2a54,0x3b8e,0x2a59,0x3b85,0x2a56,0x3b79,0x2a45,0x3b67,0x2a24,0x3b4f,0x29ee,0x3b2f,0x29a4,0x3b10,0x294b,0x3aef,0x28e5,0x3ac9,0x2877,0x3aa4,0x2809,0x3a7e,0x2739,0x3a59,0x266d,0x3a34,0x25af,0x3a0c,0x2503,0x39e4,0x2468,0x39bb,0x23bb,0x3990,0x22c6,0x3963,0x21f0,0x3936,0x2133,0x3906,0x208f,0x38d5,0x1ffd,0x38a3,0x1f04,0x3870,0x1e28,0x383d,0x1d69,0x380b,0x1cc3,0x37b0,0x1c32,0x3bb5,0x28aa,0x3bb5,0x28ab,0x3bb5,0x28ad,0x3bb4,0x28b2,0x3bb2,0x28b9,0x3bae,0x28c2,0x3ba8,0x28ca,0x3ba0,0x28d1,0x3b94,0x28cd,0x3b83,0x28c1,0x3b6a,0x28a3,0x3b4b,0x2876,0x3b2d,0x283d,0x3b09,0x27ea,0x3ae1,0x274b,0x3ab9,0x26a6,0x3a8f,0x25fe,0x3a67,0x255d,0x3a3d,0x24c5,0x3a11,0x2439,0x39e6,0x2371,0x39b9,0x228d,0x398a,0x21c1,0x395a,0x210b,0x3929,0x206c,0x38f7,0x1fc1,0x38c3,0x1ecb,0x388f,0x1df6,0x385a,0x1d3a,0x3825,0x1c99,0x37e1,0x1c08,0x3779,0x1b1b,0x3bc9,0x26d3,0x3bc9,0x26d4,0x3bc9,0x26d9,0x3bc8,0x26e3,0x3bc6,0x26ef,0x3bc2,0x2705,0x3bbd,0x271a,0x3bb6,0x2731,0x3baa,0x273c,0x3b9a,0x273d,0x3b81,0x2726,0x3b65,0x26f7,0x3b46,0x26af,0x3b20,0x2650,0x3af7,0x25e1,0x3acd,0x256a,0x3aa1,0x24eb,0x3a75,0x246f,0x3a46,0x23ee,0x3a17,0x230d,0x39e9,0x223e,0x39b7,0x2183,0x3985,0x20d8,0x3953,0x2043,0x391e,0x1f7a,0x38e9,0x1e8d,0x38b3,0x1dbf,0x387c,0x1d0b,0x3845,0x1c6c,0x380e,0x1bc4,0x37b0,0x1ad2,0x3745,0x19fd,0x3bd9,0x24e4,0x3bd9,0x24e5,0x3bd9,0x24e8,0x3bd8,0x24f2,0x3bd5,0x24fe,0x3bd2,0x2512,0x3bce,0x252b,0x3bc6,0x2544,0x3bbc,0x255a,0x3bac,0x256b,0x3b93,0x2569,0x3b7a,0x2557,0x3b5b,0x252f,0x3b34,0x24f7,0x3b0c,0x24ad,0x3adf,0x2458,0x3ab1,0x23f8,0x3a82,0x233f,0x3a4f,0x2286,0x3a1e,0x21d5,0x39eb,0x2130,0x39b6,0x2098,0x3982,0x200e,0x394b,0x1f25,0x3914,0x1e45,0x38dc,0x1d83,0x38a3,0x1cd6,0x386b,0x1c3d,0x3831,0x1b71,0x37f2,0x1a87,0x3782,0x19bc,0x3714,0x1909,0x3be5,0x22d8,0x3be5,0x22d9,0x3be4,0x22df,0x3be4,0x22ef,0x3be1,0x2305,0x3bde,0x232a,0x3bda,0x2358,0x3bd4,0x2392,0x3bcb,0x23ca,0x3bbb,0x23f4,0x3ba3,0x2405,0x3b8c,0x2405,0x3b6c,0x23ec,0x3b47,0x23ae,0x3b1d,0x2353,0x3af0,0x22e2,0x3ac0,0x2261,0x3a8e,0x21d9,0x3a5a,0x214e,0x3a26,0x20c7,0x39ee,0x2045,0x39b7,0x1f97,0x397f,0x1eba,0x3945,0x1df0,0x390b,0x1d3a,0x38d0,0x1c9a,0x3895,0x1c0a,0x385a,0x1b18,0x381f,0x1a39,0x37c9,0x1975,0x3756,0x18cc,0x36e6,0x1836,0x3bed,0x20a8,0x3bed,0x20a9,0x3bed,0x20ae,0x3bed,0x20bb,0x3beb,0x20cf,0x3be8,0x20ef,0x3be4,0x2119,0x3bde,0x214f,0x3bd6,0x2189,0x3bc6,0x21b8,0x3bb1,0x21de,0x3b9a,0x21f2,0x3b7b,0x21f2,0x3b57,0x21d8,0x3b2d,0x21a4,0x3b00,0x215f,0x3acf,0x2108,0x3a99,0x20a8,0x3a64,0x2043,0x3a2c,0x1fba,0x39f2,0x1ef3,0x39b8,0x1e36,0x397c,0x1d86,0x3940,0x1ce5,0x3903,0x1c52,0x38c6,0x1b9e,0x3888,0x1ab3,0x384a,0x19e4,0x380e,0x192b,0x37a3,0x188b,0x372d,0x17f7,0x36ba,0x1701,0x3bf4,0x1e23,0x3bf4,0x1e25,0x3bf4,0x1e2d,0x3bf3,0x1e41,0x3bf1,0x1e64,0x3bef,0x1e9c,0x3beb,0x1ee1,0x3be6,0x1f40,0x3bde,0x1fa7,0x3bce,0x2001,0x3bbd,0x202f,0x3ba6,0x204e,0x3b88,0x205f,0x3b64,0x205b,0x3b3b,0x2044,0x3b0e,0x201f,0x3adb,0x1fcf,0x3aa6,0x1f4e,0x3a6e,0x1ec1,0x3a33,0x1e2b,0x39f7,0x1d95,0x39ba,0x1d06,0x397b,0x1c7d,0x393c,0x1bfc,0x38fc,0x1b13,0x38bc,0x1a40,0x387c,0x1983,0x383c,0x18da,0x37fa,0x1842,0x377f,0x177f,0x3706,0x1695,0x3691,0x15c8,0x3bf8,0x1bca,0x3bf8,0x1bcc,0x3bf8,0x1bd8,0x3bf8,0x1bf7,0x3bf6,0x1c1b,0x3bf4,0x1c45,0x3bf1,0x1c83,0x3bec,0x1cce,0x3be4,0x1d21,0x3bd5,0x1d78,0x3bc5,0x1dd1,0x3bb0,0x1e17,0x3b93,0x1e4a,0x3b70,0x1e5f,0x3b48,0x1e57,0x3b1b,0x1e35,0x3ae7,0x1df6,0x3ab2,0x1da4,0x3a77,0x1d44,0x3a3a,0x1cdb,0x39fc,0x1c6e,0x39bb,0x1c03,0x397a,0x1b35,0x3938,0x1a72,0x38f5,0x19bb,0x38b3,0x1914,0x3870,0x187d,0x382e,0x17eb,0x37db,0x16f9,0x375c,0x1621,0x36e1,0x1565,0x3669,0x14be,0x3bfb,0x18b9,0x3bfb,0x18ba,0x3bfb,0x18c3,0x3bfb,0x18da,0x3bf9,0x190a,0x3bf7,0x1948,0x3bf5,0x19ac,0x3bf0,0x1a20,0x3be9,0x1ab3,0x3bdb,0x1b49,0x3bcd,0x1be6,0x3bb7,0x1c34,0x3b9c,0x1c6d,0x3b7a,0x1c8e,0x3b54,0x1c9e,0x3b26,0x1c96,0x3af2,0x1c75,0x3abc,0x1c47,0x3a80,0x1c09,0x3a42,0x1b85,0x3a01,0x1aec,0x39be,0x1a50,0x397a,0x19b5,0x3935,0x1921,0x38f0,0x1895,0x38aa,0x1814,0x3866,0x173a,0x3821,0x1665,0x37be,0x15a4,0x373c,0x14f9,0x36be,0x1460,0x3644,0x13b3,0x3bfd,0x156b,0x3bfd,0x156c,0x3bfd,0x1578,0x3bfd,0x1598,0x3bfc,0x15dd,0x3bfa,0x163c,0x3bf7,0x16cb,0x3bf3,0x177b,0x3beb,0x1833,0x3be0,0x18ad,0x3bd2,0x192e,0x3bbd,0x19a6,0x3ba4,0x1a0c,0x3b83,0x1a5a,0x3b5d,0x1a8c,0x3b30,0x1a9b,0x3afd,0x1a86,0x3ac6,0x1a5c,0x3a89,0x1a11,0x3a49,0x19b7,0x3a06,0x194f,0x39c1,0x18e3,0x397a,0x1873,0x3933,0x1805,0x38eb,0x173a,0x38a3,0x1676,0x385c,0x15bf,0x3816,0x1519,0x37a2,0x1482,0x371d,0x13f7,0x369c,0x1306,0x3620,0x1231,0x3bff,0x11cb,0x3bff,0x11cd,0x3bfe,0x11dd,0x3bfe,0x1219,0x3bfd,0x126b,0x3bfb,0x12e9,0x3bf9,0x13c5,0x3bf5,0x1460,0x3bee,0x150f,0x3be3,0x15c9,0x3bd6,0x168a,0x3bc3,0x174f,0x3baa,0x1806,0x3b8b,0x184f,0x3b66,0x1888,0x3b39,0x18a6,0x3b07,0x18ad,0x3acf,0x189c,0x3a92,0x1876,0x3a50,0x1840,0x3a0c,0x17fd,0x39c4,0x176a,0x397b,0x16ce,0x3931,0x1634,0x38e6,0x1599,0x389c,0x1508,0x3852,0x147f,0x380a,0x1401,0x3788,0x131c,0x36ff,0x124a,0x367c,0x1190,0x35fe,0x10ea,0x3bff,0x0daa,0x3bff,0x0dad,0x3bff,0x0dc0,0x3bff,0x0e0e,0x3bfe,0x0e87,0x3bfc,0x0f14,0x3bfb,0x1029,0x3bf7,0x10d1,0x3bf0,0x11d3,0x3be6,0x12c9,0x3bd9,0x13fc,0x3bc7,0x1499,0x3bb0,0x152a,0x3b92,0x15ab,0x3b6e,0x1615,0x3b42,0x165a,0x3b10,0x1681,0x3ad8,0x1683,0x3a9a,0x1665,0x3a57,0x1629,0x3a11,0x15dd,0x39c8,0x1580,0x397c,0x1518,0x3930,0x14ae,0x38e3,0x1441,0x3896,0x13b1,0x384a,0x12e9,0x37ff,0x122f,0x376f,0x1182,0x36e3,0x10e5,0x365e,0x1057,0x35de,0x0fac,0x3c00,0x08ea,0x3c00,0x08ed,0x3c00,0x0902,0x3c00,0x0961,0x3bff,0x09f3,0x3bfd,0x0abc,0x3bfb,0x0c1f,0x3bf8,0x0d15,0x3bf1,0x0e5b,0x3be8,0x0fb4,0x3bdc,0x10b0,0x3bcb,0x1190,0x3bb5,0x126c,0x3b97,0x132c,0x3b74,0x13de,0x3b4a,0x1432,0x3b18,0x145e,0x3ae0,0x1472,0x3aa2,0x146f,0x3a5f,0x1456,0x3a17,0x142e,0x39cc,0x13ee,0x397e,0x136b,0x392f,0x12e1,0x38df,0x124f,0x3890,0x11bd,0x3842,0x1131,0x37eb,0x10ac,0x3757,0x102e,0x36c9,0x0f76,0x3640,0x0ea3,0x35bf,0x0de4,0x3c00,0x039b,0x3c00,0x039d,0x3c00,0x03b2,0x3c00,0x041c,0x3bff,0x04be,0x3bfd,0x05d6,0x3bfc,0x0764,0x3bf8,0x08e2,0x3bf2,0x0a67,0x3bea,0x0c1b,0x3bde,0x0d41,0x3bcd,0x0e5f,0x3bb8,0x0f8c,0x3b9c,0x1057,0x3b7a,0x10e5,0x3b51,0x1155,0x3b20,0x11a5,0x3ae8,0x11da,0x3aaa,0x11ef,0x3a66,0x11e5,0x3a1d,0x11c1,0x39d0,0x1185,0x3980,0x113b,0x392e,0x10e5,0x38dc,0x1087,0x388b,0x1028,0x383b,0x0f94,0x37d9,0x0edb,0x3741,0x0e2c,0x36af,0x0d89,0x3625,0x0cf2,0x35a1,0x0c69,0x3c00,0x0107,0x3c00,0x0108,0x3c00,0x0110,0x3c00,0x0145,0x3bff,0x0197,0x3bfe,0x0224,0x3bfc,0x030c,0x3bf8,0x0478,0x3bf3,0x062c,0x3beb,0x0833,0x3be0,0x0979,0x3bd0,0x0aeb,0x3bbc,0x0c3d,0x3ba0,0x0d01,0x3b80,0x0dbd,0x3b57,0x0e69,0x3b27,0x0eeb,0x3af0,0x0f53,0x3ab1,0x0f8a,0x3a6c,0x0f9f,0x3a22,0x0f8b,0x39d4,0x0f5b,0x3982,0x0f0f,0x392f,0x0eac,0x38da,0x0e3d,0x3886,0x0dc9,0x3834,0x0d51,0x37c7,0x0cd9,0x372c,0x0c65,0x3697,0x0bef,0x360a,0x0b20,0x3585,0x0a62,0x3c00,0x0031,0x3c00,0x0031,0x3c00,0x0034,0x3c00,0x004b,0x3bff,0x006f,0x3bfe,0x00c9,0x3bfc,0x011b,0x3bf9,0x0207,0x3bf4,0x02d6,0x3bec,0x0415,0x3be1,0x0587,0x3bd2,0x0703,0x3bbf,0x087d,0x3ba5,0x096a,0x3b85,0x0a59,0x3b5d,0x0b32,0x3b2e,0x0bee,0x3af7,0x0c44,0x3ab8,0x0c7c,0x3a73,0x0c9c,0x3a28,0x0ca4,0x39d8,0x0c98,0x3985,0x0c77,0x392f,0x0c4a,0x38d9,0x0c10,0x3882,0x0ba0,0x382e,0x0b14,0x37b6,0x0a84,0x3717,0x09f5,0x3680,0x0969,0x35f0,0x08e6,0x356a,0x086a,0x3c00,0x0004,0x3c00,0x0004,0x3c00,0x0004,0x3c00,0x000d,0x3bff,0x0021,0x3bfe,0x003b,0x3bfd,0x0070,0x3bf9,0x00c7,0x3bf4,0x012e,0x3bed,0x01c8,0x3be3,0x0274,0x3bd4,0x033b,0x3bc1,0x043a,0x3ba8,0x0534,0x3b89,0x0641,0x3b62,0x073b,0x3b34,0x0815,0x3afd,0x087c,0x3abf,0x08d0,0x3a7a,0x090a,0x3a2e,0x092c,0x39dd,0x0936,0x3988,0x0928,0x3930,0x0907,0x38d7,0x08d7,0x387f,0x089b,0x3828,0x0855,0x37a7,0x080b,0x3704,0x077b,0x366a,0x06e1,0x35d8,0x0649,0x3550,0x05b8,0x3c00,0x0000,0x3c00,0x0000,0x3c00,0x0000,0x3c00,0x0003,0x3bff,0x0012,0x3bfe,0x001a,0x3bfd,0x0035,0x3bfa,0x0050,0x3bf4,0x0061,0x3bed,0x00a5,0x3be4,0x00ee,0x3bd6,0x0146,0x3bc3,0x01ab,0x3bab,0x0211,0x3b8d,0x028e,0x3b67,0x0303,0x3b39,0x0375,0x3b04,0x03e2,0x3ac6,0x0441,0x3a80,0x0492,0x3a34,0x04cd,0x39e1,0x04f2,0x398b,0x0504,0x3931,0x0502,0x38d6,0x04ec,0x387c,0x04c7,0x3822,0x0496,0x3798,0x045c,0x36f2,0x041a,0x3655,0x03d5,0x35c1,0x038e,0x3537,0x0347]);let lut=null;function getDFGLUT(){if(lut===null){lut=new DataTexture(DATA,32,32,RGFormat,HalfFloatType);lut.minFilter=LinearFilter;lut.magFilter=LinearFilter;lut.wrapS=ClampToEdgeWrapping;lut.wrapT=ClampToEdgeWrapping;lut.generateMipmaps=false;lut.needsUpdate=true;}return lut;}/**
	 * This renderer uses WebGL 2 to display scenes.
	 *
	 * WebGL 1 is not supported since `r163`.
	 */class WebGLRenderer{/**
		 * Constructs a new WebGL renderer.
		 *
		 * @param {WebGLRenderer~Options} [parameters] - The configuration parameter.
		 */constructor(parameters={}){const{canvas=createCanvasElement(),context=null,depth=true,stencil=false,alpha=false,antialias=false,premultipliedAlpha=true,preserveDrawingBuffer=false,powerPreference='default',failIfMajorPerformanceCaveat=false,reversedDepthBuffer=false}=parameters;/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */this.isWebGLRenderer=true;let _alpha;if(context!==null){if(typeof WebGLRenderingContext!=='undefined'&&context instanceof WebGLRenderingContext){throw new Error('THREE.WebGLRenderer: WebGL 1 is not supported since r163.');}_alpha=context.getContextAttributes().alpha;}else {_alpha=alpha;}const INTEGER_FORMATS=new Set([RGBAIntegerFormat,RGIntegerFormat,RedIntegerFormat]);const UNSIGNED_TYPES=new Set([UnsignedByteType,UnsignedIntType,UnsignedShortType,UnsignedInt248Type,UnsignedShort4444Type,UnsignedShort5551Type]);const uintClearColor=new Uint32Array(4);const intClearColor=new Int32Array(4);let currentRenderList=null;let currentRenderState=null;// render() can be called from within a callback triggered by another render.
	// We track this so that the nested render call gets its list and state isolated from the parent render call.
	const renderListStack=[];const renderStateStack=[];// public properties
	/**
			 * A canvas where the renderer draws its output.This is automatically created by the renderer
			 * in the constructor (if not provided already); you just need to add it to your page like so:
			 * ```js
			 * document.body.appendChild( renderer.domElement );
			 * ```
			 *
			 * @type {HTMLCanvasElement|OffscreenCanvas}
			 */this.domElement=canvas;/**
			 * A object with debug configuration settings.
			 *
			 * - `checkShaderErrors`: If it is `true`, defines whether material shader programs are
			 * checked for errors during compilation and linkage process. It may be useful to disable
			 * this check in production for performance gain. It is strongly recommended to keep these
			 * checks enabled during development. If the shader does not compile and link - it will not
			 * work and associated material will not render.
			 * - `onShaderError(gl, program, glVertexShader,glFragmentShader)`: A callback function that
			 * can be used for custom error reporting. The callback receives the WebGL context, an instance
			 * of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader.
			 * Assigning a custom function disables the default error reporting.
			 *
			 * @type {Object}
			 */this.debug={/**
				 * Enables error checking and reporting when shader programs are being compiled.
				 * @type {boolean}
				 */checkShaderErrors:true,/**
				 * Callback for custom error reporting.
				 * @type {?Function}
				 */onShaderError:null};// clearing
	/**
			 * Whether the renderer should automatically clear its output before rendering a frame or not.
			 *
			 * @type {boolean}
			 * @default true
			 */this.autoClear=true;/**
			 * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
			 * the color buffer or not.
			 *
			 * @type {boolean}
			 * @default true
			 */this.autoClearColor=true;/**
			 * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
			 * the depth buffer or not.
			 *
			 * @type {boolean}
			 * @default true
			 */this.autoClearDepth=true;/**
			 * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
			 * the stencil buffer or not.
			 *
			 * @type {boolean}
			 * @default true
			 */this.autoClearStencil=true;// scene graph
	/**
			 * Whether the renderer should sort objects or not.
			 *
			 * Note: Sorting is used to attempt to properly render objects that have some
			 * degree of transparency. By definition, sorting objects may not work in all
			 * cases. Depending on the needs of application, it may be necessary to turn
			 * off sorting and use other methods to deal with transparency rendering e.g.
			 * manually determining each object's rendering order.
			 *
			 * @type {boolean}
			 * @default true
			 */this.sortObjects=true;// user-defined clipping
	/**
			 * User-defined clipping planes specified in world space. These planes apply globally.
			 * Points in space whose dot product with the plane is negative are cut away.
			 *
			 * @type {Array<Plane>}
			 */this.clippingPlanes=[];/**
			 * Whether the renderer respects object-level clipping planes or not.
			 *
			 * @type {boolean}
			 * @default false
			 */this.localClippingEnabled=false;// tone mapping
	/**
			 * The tone mapping technique of the renderer.
			 *
			 * @type {(NoToneMapping|LinearToneMapping|ReinhardToneMapping|CineonToneMapping|ACESFilmicToneMapping|CustomToneMapping|AgXToneMapping|NeutralToneMapping)}
			 * @default NoToneMapping
			 */this.toneMapping=NoToneMapping;/**
			 * Exposure level of tone mapping.
			 *
			 * @type {number}
			 * @default 1
			 */this.toneMappingExposure=1.0;// transmission
	/**
			 * The normalized resolution scale for the transmission render target, measured in percentage
			 * of viewport dimensions. Lowering this value can result in significant performance improvements
			 * when using {@link MeshPhysicalMaterial#transmission}.
			 *
			 * @type {number}
			 * @default 1
			 */this.transmissionResolutionScale=1.0;// internal properties
	const _this=this;let _isContextLost=false;// internal state cache
	this._outputColorSpace=SRGBColorSpace;let _currentActiveCubeFace=0;let _currentActiveMipmapLevel=0;let _currentRenderTarget=null;let _currentMaterialId=-1;let _currentCamera=null;const _currentViewport=new Vector4();const _currentScissor=new Vector4();let _currentScissorTest=null;const _currentClearColor=new Color(0x000000);let _currentClearAlpha=0;//
	let _width=canvas.width;let _height=canvas.height;let _pixelRatio=1;let _opaqueSort=null;let _transparentSort=null;const _viewport=new Vector4(0,0,_width,_height);const _scissor=new Vector4(0,0,_width,_height);let _scissorTest=false;// frustum
	const _frustum=new Frustum();// clipping
	let _clippingEnabled=false;let _localClippingEnabled=false;// camera matrices cache
	const _projScreenMatrix=new Matrix4$1();const _vector3=new Vector3$1();const _vector4=new Vector4();const _emptyScene={background:null,fog:null,environment:null,overrideMaterial:null,isScene:true};let _renderBackground=false;function getTargetPixelRatio(){return _currentRenderTarget===null?_pixelRatio:1;}// initialize
	let _gl=context;function getContext(contextName,contextAttributes){return canvas.getContext(contextName,contextAttributes);}try{const contextAttributes={alpha:true,depth,stencil,antialias,premultipliedAlpha,preserveDrawingBuffer,powerPreference,failIfMajorPerformanceCaveat};// OffscreenCanvas does not have setAttribute, see #22811
	if('setAttribute'in canvas)canvas.setAttribute('data-engine',`three.js r${REVISION}`);// event listeners must be registered before WebGL context is created, see #12753
	canvas.addEventListener('webglcontextlost',onContextLost,false);canvas.addEventListener('webglcontextrestored',onContextRestore,false);canvas.addEventListener('webglcontextcreationerror',onContextCreationError,false);if(_gl===null){const contextName='webgl2';_gl=getContext(contextName,contextAttributes);if(_gl===null){if(getContext(contextName)){throw new Error('Error creating WebGL context with your selected attributes.');}else {throw new Error('Error creating WebGL context.');}}}}catch(error){error('WebGLRenderer: '+error.message);throw error;}let extensions,capabilities,state,info;let properties,textures,cubemaps,cubeuvmaps,attributes,geometries,objects;let programCache,materials,renderLists,renderStates,clipping,shadowMap;let background,morphtargets,bufferRenderer,indexedBufferRenderer;let utils,bindingStates,uniformsGroups;function initGLContext(){extensions=new WebGLExtensions(_gl);extensions.init();utils=new WebGLUtils(_gl,extensions);capabilities=new WebGLCapabilities(_gl,extensions,parameters,utils);state=new WebGLState(_gl,extensions);if(capabilities.reversedDepthBuffer&&reversedDepthBuffer){state.buffers.depth.setReversed(true);}info=new WebGLInfo(_gl);properties=new WebGLProperties();textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info);cubemaps=new WebGLCubeMaps(_this);cubeuvmaps=new WebGLCubeUVMaps(_this);attributes=new WebGLAttributes(_gl);bindingStates=new WebGLBindingStates(_gl,attributes);geometries=new WebGLGeometries(_gl,attributes,info,bindingStates);objects=new WebGLObjects(_gl,geometries,attributes,info);morphtargets=new WebGLMorphtargets(_gl,capabilities,textures);clipping=new WebGLClipping(properties);programCache=new WebGLPrograms(_this,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping);materials=new WebGLMaterials(_this,properties);renderLists=new WebGLRenderLists();renderStates=new WebGLRenderStates(extensions);background=new WebGLBackground(_this,cubemaps,cubeuvmaps,state,objects,_alpha,premultipliedAlpha);shadowMap=new WebGLShadowMap(_this,objects,capabilities);uniformsGroups=new WebGLUniformsGroups(_gl,info,capabilities,state);bufferRenderer=new WebGLBufferRenderer(_gl,extensions,info);indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,info);info.programs=programCache.programs;/**
				 * Holds details about the capabilities of the current rendering context.
				 *
				 * @name WebGLRenderer#capabilities
				 * @type {WebGLRenderer~Capabilities}
				 */_this.capabilities=capabilities;/**
				 * Provides methods for retrieving and testing WebGL extensions.
				 *
				 * - `get(extensionName:string)`: Used to check whether a WebGL extension is supported
				 * and return the extension object if available.
				 * - `has(extensionName:string)`: returns `true` if the extension is supported.
				 *
				 * @name WebGLRenderer#extensions
				 * @type {Object}
				 */_this.extensions=extensions;/**
				 * Used to track properties of other objects like native WebGL objects.
				 *
				 * @name WebGLRenderer#properties
				 * @type {Object}
				 */_this.properties=properties;/**
				 * Manages the render lists of the renderer.
				 *
				 * @name WebGLRenderer#renderLists
				 * @type {Object}
				 */_this.renderLists=renderLists;/**
				 * Interface for managing shadows.
				 *
				 * @name WebGLRenderer#shadowMap
				 * @type {WebGLRenderer~ShadowMap}
				 */_this.shadowMap=shadowMap;/**
				 * Interface for managing the WebGL state.
				 *
				 * @name WebGLRenderer#state
				 * @type {Object}
				 */_this.state=state;/**
				 * Holds a series of statistical information about the GPU memory
				 * and the rendering process. Useful for debugging and monitoring.
				 *
				 * By default these data are reset at each render call but when having
				 * multiple render passes per frame (e.g. when using post processing) it can
				 * be preferred to reset with a custom pattern. First, set `autoReset` to
				 * `false`.
				 * ```js
				 * renderer.info.autoReset = false;
				 * ```
				 * Call `reset()` whenever you have finished to render a single frame.
				 * ```js
				 * renderer.info.reset();
				 * ```
				 *
				 * @name WebGLRenderer#info
				 * @type {WebGLRenderer~Info}
				 */_this.info=info;}initGLContext();// xr
	const xr=new WebXRManager(_this,_gl);/**
			 * A reference to the XR manager.
			 *
			 * @type {WebXRManager}
			 */this.xr=xr;/**
			 * Returns the rendering context.
			 *
			 * @return {WebGL2RenderingContext} The rendering context.
			 */this.getContext=function(){return _gl;};/**
			 * Returns the rendering context attributes.
			 *
			 * @return {WebGLContextAttributes} The rendering context attributes.
			 */this.getContextAttributes=function(){return _gl.getContextAttributes();};/**
			 * Simulates a loss of the WebGL context. This requires support for the `WEBGL_lose_context` extension.
			 */this.forceContextLoss=function(){const extension=extensions.get('WEBGL_lose_context');if(extension)extension.loseContext();};/**
			 * Simulates a restore of the WebGL context. This requires support for the `WEBGL_lose_context` extension.
			 */this.forceContextRestore=function(){const extension=extensions.get('WEBGL_lose_context');if(extension)extension.restoreContext();};/**
			 * Returns the pixel ratio.
			 *
			 * @return {number} The pixel ratio.
			 */this.getPixelRatio=function(){return _pixelRatio;};/**
			 * Sets the given pixel ratio and resizes the canvas if necessary.
			 *
			 * @param {number} value - The pixel ratio.
			 */this.setPixelRatio=function(value){if(value===undefined)return;_pixelRatio=value;this.setSize(_width,_height,false);};/**
			 * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
			 *
			 * @param {Vector2} target - The method writes the result in this target object.
			 * @return {Vector2} The renderer's size in logical pixels.
			 */this.getSize=function(target){return target.set(_width,_height);};/**
			 * Resizes the output canvas to (width, height) with device pixel ratio taken
			 * into account, and also sets the viewport to fit that size, starting in (0,
			 * 0). Setting `updateStyle` to false prevents any style changes to the output canvas.
			 *
			 * @param {number} width - The width in logical pixels.
			 * @param {number} height - The height in logical pixels.
			 * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
			 */this.setSize=function(width,height,updateStyle=true){if(xr.isPresenting){warn$1('WebGLRenderer: Can\'t change size while VR device is presenting.');return;}_width=width;_height=height;canvas.width=Math.floor(width*_pixelRatio);canvas.height=Math.floor(height*_pixelRatio);if(updateStyle===true){canvas.style.width=width+'px';canvas.style.height=height+'px';}this.setViewport(0,0,width,height);};/**
			 * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
			 *
			 * @param {Vector2} target - The method writes the result in this target object.
			 * @return {Vector2} The drawing buffer size.
			 */this.getDrawingBufferSize=function(target){return target.set(_width*_pixelRatio,_height*_pixelRatio).floor();};/**
			 * This method allows to define the drawing buffer size by specifying
			 * width, height and pixel ratio all at once. The size of the drawing
			 * buffer is computed with this formula:
			 * ```js
			 * size.x = width * pixelRatio;
			 * size.y = height * pixelRatio;
			 * ```
			 *
			 * @param {number} width - The width in logical pixels.
			 * @param {number} height - The height in logical pixels.
			 * @param {number} pixelRatio - The pixel ratio.
			 */this.setDrawingBufferSize=function(width,height,pixelRatio){_width=width;_height=height;_pixelRatio=pixelRatio;canvas.width=Math.floor(width*pixelRatio);canvas.height=Math.floor(height*pixelRatio);this.setViewport(0,0,width,height);};/**
			 * Returns the current viewport definition.
			 *
			 * @param {Vector2} target - The method writes the result in this target object.
			 * @return {Vector2} The current viewport definition.
			 */this.getCurrentViewport=function(target){return target.copy(_currentViewport);};/**
			 * Returns the viewport definition.
			 *
			 * @param {Vector4} target - The method writes the result in this target object.
			 * @return {Vector4} The viewport definition.
			 */this.getViewport=function(target){return target.copy(_viewport);};/**
			 * Sets the viewport to render from `(x, y)` to `(x + width, y + height)`.
			 *
			 * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
			 * Or alternatively a four-component vector specifying all the parameters of the viewport.
			 * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
			 * @param {number} width - The width of the viewport in logical pixel unit.
			 * @param {number} height - The height of the viewport in logical pixel unit.
			 */this.setViewport=function(x,y,width,height){if(x.isVector4){_viewport.set(x.x,x.y,x.z,x.w);}else {_viewport.set(x,y,width,height);}state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round());};/**
			 * Returns the scissor region.
			 *
			 * @param {Vector4} target - The method writes the result in this target object.
			 * @return {Vector4} The scissor region.
			 */this.getScissor=function(target){return target.copy(_scissor);};/**
			 * Sets the scissor region to render from `(x, y)` to `(x + width, y + height)`.
			 *
			 * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the scissor region origin in logical pixel unit.
			 * Or alternatively a four-component vector specifying all the parameters of the scissor region.
			 * @param {number} y - The vertical coordinate for the lower left corner of the scissor region origin  in logical pixel unit.
			 * @param {number} width - The width of the scissor region in logical pixel unit.
			 * @param {number} height - The height of the scissor region in logical pixel unit.
			 */this.setScissor=function(x,y,width,height){if(x.isVector4){_scissor.set(x.x,x.y,x.z,x.w);}else {_scissor.set(x,y,width,height);}state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());};/**
			 * Returns `true` if the scissor test is enabled.
			 *
			 * @return {boolean} Whether the scissor test is enabled or not.
			 */this.getScissorTest=function(){return _scissorTest;};/**
			 * Enable or disable the scissor test. When this is enabled, only the pixels
			 * within the defined scissor area will be affected by further renderer
			 * actions.
			 *
			 * @param {boolean} boolean - Whether the scissor test is enabled or not.
			 */this.setScissorTest=function(boolean){state.setScissorTest(_scissorTest=boolean);};/**
			 * Sets a custom opaque sort function for the render lists. Pass `null`
			 * to use the default `painterSortStable` function.
			 *
			 * @param {?Function} method - The opaque sort function.
			 */this.setOpaqueSort=function(method){_opaqueSort=method;};/**
			 * Sets a custom transparent sort function for the render lists. Pass `null`
			 * to use the default `reversePainterSortStable` function.
			 *
			 * @param {?Function} method - The opaque sort function.
			 */this.setTransparentSort=function(method){_transparentSort=method;};// Clearing
	/**
			 * Returns the clear color.
			 *
			 * @param {Color} target - The method writes the result in this target object.
			 * @return {Color} The clear color.
			 */this.getClearColor=function(target){return target.copy(background.getClearColor());};/**
			 * Sets the clear color and alpha.
			 *
			 * @param {Color} color - The clear color.
			 * @param {number} [alpha=1] - The clear alpha.
			 */this.setClearColor=function(){background.setClearColor(...arguments);};/**
			 * Returns the clear alpha. Ranges within `[0,1]`.
			 *
			 * @return {number} The clear alpha.
			 */this.getClearAlpha=function(){return background.getClearAlpha();};/**
			 * Sets the clear alpha.
			 *
			 * @param {number} alpha - The clear alpha.
			 */this.setClearAlpha=function(){background.setClearAlpha(...arguments);};/**
			 * Tells the renderer to clear its color, depth or stencil drawing buffer(s).
			 * This method initializes the buffers to the current clear color values.
			 *
			 * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
			 * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
			 * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
			 */this.clear=function(color=true,depth=true,stencil=true){let bits=0;if(color){// check if we're trying to clear an integer target
	let isIntegerFormat=false;if(_currentRenderTarget!==null){const targetFormat=_currentRenderTarget.texture.format;isIntegerFormat=INTEGER_FORMATS.has(targetFormat);}// use the appropriate clear functions to clear the target if it's a signed
	// or unsigned integer target
	if(isIntegerFormat){const targetType=_currentRenderTarget.texture.type;const isUnsignedType=UNSIGNED_TYPES.has(targetType);const clearColor=background.getClearColor();const a=background.getClearAlpha();const r=clearColor.r;const g=clearColor.g;const b=clearColor.b;if(isUnsignedType){uintClearColor[0]=r;uintClearColor[1]=g;uintClearColor[2]=b;uintClearColor[3]=a;_gl.clearBufferuiv(_gl.COLOR,0,uintClearColor);}else {intClearColor[0]=r;intClearColor[1]=g;intClearColor[2]=b;intClearColor[3]=a;_gl.clearBufferiv(_gl.COLOR,0,intClearColor);}}else {bits|=_gl.COLOR_BUFFER_BIT;}}if(depth){bits|=_gl.DEPTH_BUFFER_BIT;}if(stencil){bits|=_gl.STENCIL_BUFFER_BIT;this.state.buffers.stencil.setMask(0xffffffff);}_gl.clear(bits);};/**
			 * Clears the color buffer. Equivalent to calling `renderer.clear( true, false, false )`.
			 */this.clearColor=function(){this.clear(true,false,false);};/**
			 * Clears the depth buffer. Equivalent to calling `renderer.clear( false, true, false )`.
			 */this.clearDepth=function(){this.clear(false,true,false);};/**
			 * Clears the stencil buffer. Equivalent to calling `renderer.clear( false, false, true )`.
			 */this.clearStencil=function(){this.clear(false,false,true);};/**
			 * Frees the GPU-related resources allocated by this instance. Call this
			 * method whenever this instance is no longer used in your app.
			 */this.dispose=function(){canvas.removeEventListener('webglcontextlost',onContextLost,false);canvas.removeEventListener('webglcontextrestored',onContextRestore,false);canvas.removeEventListener('webglcontextcreationerror',onContextCreationError,false);background.dispose();renderLists.dispose();renderStates.dispose();properties.dispose();cubemaps.dispose();cubeuvmaps.dispose();objects.dispose();bindingStates.dispose();uniformsGroups.dispose();programCache.dispose();xr.dispose();xr.removeEventListener('sessionstart',onXRSessionStart);xr.removeEventListener('sessionend',onXRSessionEnd);animation.stop();};// Events
	function onContextLost(event){event.preventDefault();log('WebGLRenderer: Context Lost.');_isContextLost=true;}function onContextRestore(/* event */){log('WebGLRenderer: Context Restored.');_isContextLost=false;const infoAutoReset=info.autoReset;const shadowMapEnabled=shadowMap.enabled;const shadowMapAutoUpdate=shadowMap.autoUpdate;const shadowMapNeedsUpdate=shadowMap.needsUpdate;const shadowMapType=shadowMap.type;initGLContext();info.autoReset=infoAutoReset;shadowMap.enabled=shadowMapEnabled;shadowMap.autoUpdate=shadowMapAutoUpdate;shadowMap.needsUpdate=shadowMapNeedsUpdate;shadowMap.type=shadowMapType;}function onContextCreationError(event){error$1('WebGLRenderer: A WebGL context could not be created. Reason: ',event.statusMessage);}function onMaterialDispose(event){const material=event.target;material.removeEventListener('dispose',onMaterialDispose);deallocateMaterial(material);}// Buffer deallocation
	function deallocateMaterial(material){releaseMaterialProgramReferences(material);properties.remove(material);}function releaseMaterialProgramReferences(material){const programs=properties.get(material).programs;if(programs!==undefined){programs.forEach(function(program){programCache.releaseProgram(program);});if(material.isShaderMaterial){programCache.releaseShaderCache(material);}}}// Buffer rendering
	this.renderBufferDirect=function(camera,scene,geometry,material,object,group){if(scene===null)scene=_emptyScene;// renderBufferDirect second parameter used to be fog (could be null)
	const frontFaceCW=object.isMesh&&object.matrixWorld.determinant()<0;const program=setProgram(camera,scene,geometry,material,object);state.setMaterial(material,frontFaceCW);//
	let index=geometry.index;let rangeFactor=1;if(material.wireframe===true){index=geometries.getWireframeAttribute(geometry);if(index===undefined)return;rangeFactor=2;}//
	const drawRange=geometry.drawRange;const position=geometry.attributes.position;let drawStart=drawRange.start*rangeFactor;let drawEnd=(drawRange.start+drawRange.count)*rangeFactor;if(group!==null){drawStart=Math.max(drawStart,group.start*rangeFactor);drawEnd=Math.min(drawEnd,(group.start+group.count)*rangeFactor);}if(index!==null){drawStart=Math.max(drawStart,0);drawEnd=Math.min(drawEnd,index.count);}else if(position!==undefined&&position!==null){drawStart=Math.max(drawStart,0);drawEnd=Math.min(drawEnd,position.count);}const drawCount=drawEnd-drawStart;if(drawCount<0||drawCount===Infinity)return;//
	bindingStates.setup(object,material,program,geometry,index);let attribute;let renderer=bufferRenderer;if(index!==null){attribute=attributes.get(index);renderer=indexedBufferRenderer;renderer.setIndex(attribute);}//
	if(object.isMesh){if(material.wireframe===true){state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());renderer.setMode(_gl.LINES);}else {renderer.setMode(_gl.TRIANGLES);}}else if(object.isLine){let lineWidth=material.linewidth;if(lineWidth===undefined)lineWidth=1;// Not using Line*Material
	state.setLineWidth(lineWidth*getTargetPixelRatio());if(object.isLineSegments){renderer.setMode(_gl.LINES);}else if(object.isLineLoop){renderer.setMode(_gl.LINE_LOOP);}else {renderer.setMode(_gl.LINE_STRIP);}}else if(object.isPoints){renderer.setMode(_gl.POINTS);}else if(object.isSprite){renderer.setMode(_gl.TRIANGLES);}if(object.isBatchedMesh){if(object._multiDrawInstances!==null){// @deprecated, r174
	warnOnce('WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.');renderer.renderMultiDrawInstances(object._multiDrawStarts,object._multiDrawCounts,object._multiDrawCount,object._multiDrawInstances);}else {if(!extensions.get('WEBGL_multi_draw')){const starts=object._multiDrawStarts;const counts=object._multiDrawCounts;const drawCount=object._multiDrawCount;const bytesPerElement=index?attributes.get(index).bytesPerElement:1;const uniforms=properties.get(material).currentProgram.getUniforms();for(let i=0;i<drawCount;i++){uniforms.setValue(_gl,'_gl_DrawID',i);renderer.render(starts[i]/bytesPerElement,counts[i]);}}else {renderer.renderMultiDraw(object._multiDrawStarts,object._multiDrawCounts,object._multiDrawCount);}}}else if(object.isInstancedMesh){renderer.renderInstances(drawStart,drawCount,object.count);}else if(geometry.isInstancedBufferGeometry){const maxInstanceCount=geometry._maxInstanceCount!==undefined?geometry._maxInstanceCount:Infinity;const instanceCount=Math.min(geometry.instanceCount,maxInstanceCount);renderer.renderInstances(drawStart,drawCount,instanceCount);}else {renderer.render(drawStart,drawCount);}};// Compile
	function prepareMaterial(material,scene,object){if(material.transparent===true&&material.side===DoubleSide&&material.forceSinglePass===false){material.side=BackSide;material.needsUpdate=true;getProgram(material,scene,object);material.side=FrontSide;material.needsUpdate=true;getProgram(material,scene,object);material.side=DoubleSide;}else {getProgram(material,scene,object);}}/**
			 * Compiles all materials in the scene with the camera. This is useful to precompile shaders
			 * before the first rendering. If you want to add a 3D object to an existing scene, use the third
			 * optional parameter for applying the target scene.
			 *
			 * Note that the (target) scene's lighting and environment must be configured before calling this method.
			 *
			 * @param {Object3D} scene - The scene or another type of 3D object to precompile.
			 * @param {Camera} camera - The camera.
			 * @param {?Scene} [targetScene=null] - The target scene.
			 * @return {Set<Material>} The precompiled materials.
			 */this.compile=function(scene,camera,targetScene=null){if(targetScene===null)targetScene=scene;currentRenderState=renderStates.get(targetScene);currentRenderState.init(camera);renderStateStack.push(currentRenderState);// gather lights from both the target scene and the new object that will be added to the scene.
	targetScene.traverseVisible(function(object){if(object.isLight&&object.layers.test(camera.layers)){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}});if(scene!==targetScene){scene.traverseVisible(function(object){if(object.isLight&&object.layers.test(camera.layers)){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}});}currentRenderState.setupLights();// Only initialize materials in the new scene, not the targetScene.
	const materials=new Set();scene.traverse(function(object){if(!(object.isMesh||object.isPoints||object.isLine||object.isSprite)){return;}const material=object.material;if(material){if(Array.isArray(material)){for(let i=0;i<material.length;i++){const material2=material[i];prepareMaterial(material2,targetScene,object);materials.add(material2);}}else {prepareMaterial(material,targetScene,object);materials.add(material);}}});currentRenderState=renderStateStack.pop();return materials;};// compileAsync
	/**
			 * Asynchronous version of {@link WebGLRenderer#compile}.
			 *
			 * This method makes use of the `KHR_parallel_shader_compile` WebGL extension. Hence,
			 * it is recommended to use this version of `compile()` whenever possible.
			 *
			 * @async
			 * @param {Object3D} scene - The scene or another type of 3D object to precompile.
			 * @param {Camera} camera - The camera.
			 * @param {?Scene} [targetScene=null] - The target scene.
			 * @return {Promise} A Promise that resolves when the given scene can be rendered without unnecessary stalling due to shader compilation.
			 */this.compileAsync=function(scene,camera,targetScene=null){const materials=this.compile(scene,camera,targetScene);// Wait for all the materials in the new object to indicate that they're
	// ready to be used before resolving the promise.
	return new Promise(resolve=>{function checkMaterialsReady(){materials.forEach(function(material){const materialProperties=properties.get(material);const program=materialProperties.currentProgram;if(program.isReady()){// remove any programs that report they're ready to use from the list
	materials.delete(material);}});// once the list of compiling materials is empty, call the callback
	if(materials.size===0){resolve(scene);return;}// if some materials are still not ready, wait a bit and check again
	setTimeout(checkMaterialsReady,10);}if(extensions.get('KHR_parallel_shader_compile')!==null){// If we can check the compilation status of the materials without
	// blocking then do so right away.
	checkMaterialsReady();}else {// Otherwise start by waiting a bit to give the materials we just
	// initialized a chance to finish.
	setTimeout(checkMaterialsReady,10);}});};// Animation Loop
	let onAnimationFrameCallback=null;function onAnimationFrame(time){if(onAnimationFrameCallback)onAnimationFrameCallback(time);}function onXRSessionStart(){animation.stop();}function onXRSessionEnd(){animation.start();}const animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);if(typeof self!=='undefined')animation.setContext(self);/**
			 * Applications are advised to always define the animation loop
			 * with this method and not manually with `requestAnimationFrame()`
			 * for best compatibility.
			 *
			 * @param {?onAnimationCallback} callback - The application's animation loop.
			 */this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;xr.setAnimationLoop(callback);callback===null?animation.stop():animation.start();};xr.addEventListener('sessionstart',onXRSessionStart);xr.addEventListener('sessionend',onXRSessionEnd);// Rendering
	/**
			 * Renders the given scene (or other type of 3D object) using the given camera.
			 *
			 * The render is done to a previously specified render target set by calling {@link WebGLRenderer#setRenderTarget}
			 * or to the canvas as usual.
			 *
			 * By default render buffers are cleared before rendering but you can prevent
			 * this by setting the property `autoClear` to `false`. If you want to prevent
			 * only certain buffers being cleared you can `autoClearColor`, `autoClearDepth`
			 * or `autoClearStencil` to `false`. To force a clear, use {@link WebGLRenderer#clear}.
			 *
			 * @param {Object3D} scene - The scene to render.
			 * @param {Camera} camera - The camera.
			 */this.render=function(scene,camera){if(camera!==undefined&&camera.isCamera!==true){error$1('WebGLRenderer.render: camera is not an instance of THREE.Camera.');return;}if(_isContextLost===true)return;// update scene graph
	if(scene.matrixWorldAutoUpdate===true)scene.updateMatrixWorld();// update camera matrices and frustum
	if(camera.parent===null&&camera.matrixWorldAutoUpdate===true)camera.updateMatrixWorld();if(xr.enabled===true&&xr.isPresenting===true){if(xr.cameraAutoUpdate===true)xr.updateCamera(camera);camera=xr.getCamera();// use XR camera for rendering
	}//
	if(scene.isScene===true)scene.onBeforeRender(_this,scene,camera,_currentRenderTarget);currentRenderState=renderStates.get(scene,renderStateStack.length);currentRenderState.init(camera);renderStateStack.push(currentRenderState);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);_frustum.setFromProjectionMatrix(_projScreenMatrix,WebGLCoordinateSystem$1,camera.reversedDepth);_localClippingEnabled=this.localClippingEnabled;_clippingEnabled=clipping.init(this.clippingPlanes,_localClippingEnabled);currentRenderList=renderLists.get(scene,renderListStack.length);currentRenderList.init();renderListStack.push(currentRenderList);if(xr.enabled===true&&xr.isPresenting===true){const depthSensingMesh=_this.xr.getDepthSensingMesh();if(depthSensingMesh!==null){projectObject(depthSensingMesh,camera,-Infinity,_this.sortObjects);}}projectObject(scene,camera,0,_this.sortObjects);currentRenderList.finish();if(_this.sortObjects===true){currentRenderList.sort(_opaqueSort,_transparentSort);}_renderBackground=xr.enabled===false||xr.isPresenting===false||xr.hasDepthSensing()===false;if(_renderBackground){background.addToRenderList(currentRenderList,scene);}//
	this.info.render.frame++;if(_clippingEnabled===true)clipping.beginShadows();const shadowsArray=currentRenderState.state.shadowsArray;shadowMap.render(shadowsArray,scene,camera);if(_clippingEnabled===true)clipping.endShadows();//
	if(this.info.autoReset===true)this.info.reset();// render scene
	const opaqueObjects=currentRenderList.opaque;const transmissiveObjects=currentRenderList.transmissive;currentRenderState.setupLights();if(camera.isArrayCamera){const cameras=camera.cameras;if(transmissiveObjects.length>0){for(let i=0,l=cameras.length;i<l;i++){const camera2=cameras[i];renderTransmissionPass(opaqueObjects,transmissiveObjects,scene,camera2);}}if(_renderBackground)background.render(scene);for(let i=0,l=cameras.length;i<l;i++){const camera2=cameras[i];renderScene(currentRenderList,scene,camera2,camera2.viewport);}}else {if(transmissiveObjects.length>0)renderTransmissionPass(opaqueObjects,transmissiveObjects,scene,camera);if(_renderBackground)background.render(scene);renderScene(currentRenderList,scene,camera);}//
	if(_currentRenderTarget!==null&&_currentActiveMipmapLevel===0){// resolve multisample renderbuffers to a single-sample texture if necessary
	textures.updateMultisampleRenderTarget(_currentRenderTarget);// Generate mipmap if we're using any kind of mipmap filtering
	textures.updateRenderTargetMipmap(_currentRenderTarget);}//
	if(scene.isScene===true)scene.onAfterRender(_this,scene,camera);// _gl.finish();
	bindingStates.resetDefaultState();_currentMaterialId=-1;_currentCamera=null;renderStateStack.pop();if(renderStateStack.length>0){currentRenderState=renderStateStack[renderStateStack.length-1];if(_clippingEnabled===true)clipping.setGlobalState(_this.clippingPlanes,currentRenderState.state.camera);}else {currentRenderState=null;}renderListStack.pop();if(renderListStack.length>0){currentRenderList=renderListStack[renderListStack.length-1];}else {currentRenderList=null;}};function projectObject(object,camera,groupOrder,sortObjects){if(object.visible===false)return;const visible=object.layers.test(camera.layers);if(visible){if(object.isGroup){groupOrder=object.renderOrder;}else if(object.isLOD){if(object.autoUpdate===true)object.update(camera);}else if(object.isLight){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}else if(object.isSprite){if(!object.frustumCulled||_frustum.intersectsSprite(object)){if(sortObjects){_vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}const geometry=objects.update(object);const material=object.material;if(material.visible){currentRenderList.push(object,geometry,material,groupOrder,_vector4.z,null);}}}else if(object.isMesh||object.isLine||object.isPoints){if(!object.frustumCulled||_frustum.intersectsObject(object)){const geometry=objects.update(object);const material=object.material;if(sortObjects){if(object.boundingSphere!==undefined){if(object.boundingSphere===null)object.computeBoundingSphere();_vector4.copy(object.boundingSphere.center);}else {if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_vector4.copy(geometry.boundingSphere.center);}_vector4.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);}if(Array.isArray(material)){const groups=geometry.groups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i];const groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){currentRenderList.push(object,geometry,groupMaterial,groupOrder,_vector4.z,group);}}}else if(material.visible){currentRenderList.push(object,geometry,material,groupOrder,_vector4.z,null);}}}}const children=object.children;for(let i=0,l=children.length;i<l;i++){projectObject(children[i],camera,groupOrder,sortObjects);}}function renderScene(currentRenderList,scene,camera,viewport){const{opaque:opaqueObjects,transmissive:transmissiveObjects,transparent:transparentObjects}=currentRenderList;currentRenderState.setupLightsView(camera);if(_clippingEnabled===true)clipping.setGlobalState(_this.clippingPlanes,camera);if(viewport)state.viewport(_currentViewport.copy(viewport));if(opaqueObjects.length>0)renderObjects(opaqueObjects,scene,camera);if(transmissiveObjects.length>0)renderObjects(transmissiveObjects,scene,camera);if(transparentObjects.length>0)renderObjects(transparentObjects,scene,camera);// Ensure depth buffer writing is enabled so it can be cleared on next render
	state.buffers.depth.setTest(true);state.buffers.depth.setMask(true);state.buffers.color.setMask(true);state.setPolygonOffset(false);}function renderTransmissionPass(opaqueObjects,transmissiveObjects,scene,camera){const overrideMaterial=scene.isScene===true?scene.overrideMaterial:null;if(overrideMaterial!==null){return;}if(currentRenderState.state.transmissionRenderTarget[camera.id]===undefined){currentRenderState.state.transmissionRenderTarget[camera.id]=new WebGLRenderTarget(1,1,{generateMipmaps:true,type:extensions.has('EXT_color_buffer_half_float')||extensions.has('EXT_color_buffer_float')?HalfFloatType:UnsignedByteType,minFilter:LinearMipmapLinearFilter,samples:4,stencilBuffer:stencil,resolveDepthBuffer:false,resolveStencilBuffer:false,colorSpace:ColorManagement.workingColorSpace});// debug
	/*
					const geometry = new PlaneGeometry();
					const material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );

					const mesh = new Mesh( geometry, material );
					scene.add( mesh );
					*/}const transmissionRenderTarget=currentRenderState.state.transmissionRenderTarget[camera.id];const activeViewport=camera.viewport||_currentViewport;transmissionRenderTarget.setSize(activeViewport.z*_this.transmissionResolutionScale,activeViewport.w*_this.transmissionResolutionScale);//
	const currentRenderTarget=_this.getRenderTarget();const currentActiveCubeFace=_this.getActiveCubeFace();const currentActiveMipmapLevel=_this.getActiveMipmapLevel();_this.setRenderTarget(transmissionRenderTarget);_this.getClearColor(_currentClearColor);_currentClearAlpha=_this.getClearAlpha();if(_currentClearAlpha<1)_this.setClearColor(0xffffff,0.5);_this.clear();if(_renderBackground)background.render(scene);// Turn off the features which can affect the frag color for opaque objects pass.
	// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
	const currentToneMapping=_this.toneMapping;_this.toneMapping=NoToneMapping;// Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).
	// Transmission render pass requires viewport to match the transmissionRenderTarget.
	const currentCameraViewport=camera.viewport;if(camera.viewport!==undefined)camera.viewport=undefined;currentRenderState.setupLightsView(camera);if(_clippingEnabled===true)clipping.setGlobalState(_this.clippingPlanes,camera);renderObjects(opaqueObjects,scene,camera);textures.updateMultisampleRenderTarget(transmissionRenderTarget);textures.updateRenderTargetMipmap(transmissionRenderTarget);if(extensions.has('WEBGL_multisampled_render_to_texture')===false){// see #28131
	let renderTargetNeedsUpdate=false;for(let i=0,l=transmissiveObjects.length;i<l;i++){const renderItem=transmissiveObjects[i];const{object,geometry,material,group}=renderItem;if(material.side===DoubleSide&&object.layers.test(camera.layers)){const currentSide=material.side;material.side=BackSide;material.needsUpdate=true;renderObject(object,scene,camera,geometry,material,group);material.side=currentSide;material.needsUpdate=true;renderTargetNeedsUpdate=true;}}if(renderTargetNeedsUpdate===true){textures.updateMultisampleRenderTarget(transmissionRenderTarget);textures.updateRenderTargetMipmap(transmissionRenderTarget);}}_this.setRenderTarget(currentRenderTarget,currentActiveCubeFace,currentActiveMipmapLevel);_this.setClearColor(_currentClearColor,_currentClearAlpha);if(currentCameraViewport!==undefined)camera.viewport=currentCameraViewport;_this.toneMapping=currentToneMapping;}function renderObjects(renderList,scene,camera){const overrideMaterial=scene.isScene===true?scene.overrideMaterial:null;for(let i=0,l=renderList.length;i<l;i++){const renderItem=renderList[i];const{object,geometry,group}=renderItem;let material=renderItem.material;if(material.allowOverride===true&&overrideMaterial!==null){material=overrideMaterial;}if(object.layers.test(camera.layers)){renderObject(object,scene,camera,geometry,material,group);}}}function renderObject(object,scene,camera,geometry,material,group){object.onBeforeRender(_this,scene,camera,geometry,material,group);object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);object.normalMatrix.getNormalMatrix(object.modelViewMatrix);material.onBeforeRender(_this,scene,camera,geometry,object,group);if(material.transparent===true&&material.side===DoubleSide&&material.forceSinglePass===false){material.side=BackSide;material.needsUpdate=true;_this.renderBufferDirect(camera,scene,geometry,material,object,group);material.side=FrontSide;material.needsUpdate=true;_this.renderBufferDirect(camera,scene,geometry,material,object,group);material.side=DoubleSide;}else {_this.renderBufferDirect(camera,scene,geometry,material,object,group);}object.onAfterRender(_this,scene,camera,geometry,material,group);}function getProgram(material,scene,object){if(scene.isScene!==true)scene=_emptyScene;// scene could be a Mesh, Line, Points, ...
	const materialProperties=properties.get(material);const lights=currentRenderState.state.lights;const shadowsArray=currentRenderState.state.shadowsArray;const lightsStateVersion=lights.state.version;const parameters=programCache.getParameters(material,lights.state,shadowsArray,scene,object);const programCacheKey=programCache.getProgramCacheKey(parameters);let programs=materialProperties.programs;// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
	materialProperties.environment=material.isMeshStandardMaterial?scene.environment:null;materialProperties.fog=scene.fog;materialProperties.envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||materialProperties.environment);materialProperties.envMapRotation=materialProperties.environment!==null&&material.envMap===null?scene.environmentRotation:material.envMapRotation;if(programs===undefined){// new material
	material.addEventListener('dispose',onMaterialDispose);programs=new Map();materialProperties.programs=programs;}let program=programs.get(programCacheKey);if(program!==undefined){// early out if program and light state is identical
	if(materialProperties.currentProgram===program&&materialProperties.lightsStateVersion===lightsStateVersion){updateCommonMaterialProperties(material,parameters);return program;}}else {parameters.uniforms=programCache.getUniforms(material);material.onBeforeCompile(parameters,_this);program=programCache.acquireProgram(parameters,programCacheKey);programs.set(programCacheKey,program);materialProperties.uniforms=parameters.uniforms;}const uniforms=materialProperties.uniforms;if(!material.isShaderMaterial&&!material.isRawShaderMaterial||material.clipping===true){uniforms.clippingPlanes=clipping.uniform;}updateCommonMaterialProperties(material,parameters);// store the light setup it was created for
	materialProperties.needsLights=materialNeedsLights(material);materialProperties.lightsStateVersion=lightsStateVersion;if(materialProperties.needsLights){// wire up the material to this renderer's lighting state
	uniforms.ambientLightColor.value=lights.state.ambient;uniforms.lightProbe.value=lights.state.probe;uniforms.directionalLights.value=lights.state.directional;uniforms.directionalLightShadows.value=lights.state.directionalShadow;uniforms.spotLights.value=lights.state.spot;uniforms.spotLightShadows.value=lights.state.spotShadow;uniforms.rectAreaLights.value=lights.state.rectArea;uniforms.ltc_1.value=lights.state.rectAreaLTC1;uniforms.ltc_2.value=lights.state.rectAreaLTC2;uniforms.pointLights.value=lights.state.point;uniforms.pointLightShadows.value=lights.state.pointShadow;uniforms.hemisphereLights.value=lights.state.hemi;uniforms.directionalShadowMap.value=lights.state.directionalShadowMap;uniforms.directionalShadowMatrix.value=lights.state.directionalShadowMatrix;uniforms.spotShadowMap.value=lights.state.spotShadowMap;uniforms.spotLightMatrix.value=lights.state.spotLightMatrix;uniforms.spotLightMap.value=lights.state.spotLightMap;uniforms.pointShadowMap.value=lights.state.pointShadowMap;uniforms.pointShadowMatrix.value=lights.state.pointShadowMatrix;// TODO (abelnation): add area lights shadow info to uniforms
	}materialProperties.currentProgram=program;materialProperties.uniformsList=null;return program;}function getUniformList(materialProperties){if(materialProperties.uniformsList===null){const progUniforms=materialProperties.currentProgram.getUniforms();materialProperties.uniformsList=WebGLUniforms.seqWithValue(progUniforms.seq,materialProperties.uniforms);}return materialProperties.uniformsList;}function updateCommonMaterialProperties(material,parameters){const materialProperties=properties.get(material);materialProperties.outputColorSpace=parameters.outputColorSpace;materialProperties.batching=parameters.batching;materialProperties.batchingColor=parameters.batchingColor;materialProperties.instancing=parameters.instancing;materialProperties.instancingColor=parameters.instancingColor;materialProperties.instancingMorph=parameters.instancingMorph;materialProperties.skinning=parameters.skinning;materialProperties.morphTargets=parameters.morphTargets;materialProperties.morphNormals=parameters.morphNormals;materialProperties.morphColors=parameters.morphColors;materialProperties.morphTargetsCount=parameters.morphTargetsCount;materialProperties.numClippingPlanes=parameters.numClippingPlanes;materialProperties.numIntersection=parameters.numClipIntersection;materialProperties.vertexAlphas=parameters.vertexAlphas;materialProperties.vertexTangents=parameters.vertexTangents;materialProperties.toneMapping=parameters.toneMapping;}function setProgram(camera,scene,geometry,material,object){if(scene.isScene!==true)scene=_emptyScene;// scene could be a Mesh, Line, Points, ...
	textures.resetTextureUnits();const fog=scene.fog;const environment=material.isMeshStandardMaterial?scene.environment:null;const colorSpace=_currentRenderTarget===null?_this.outputColorSpace:_currentRenderTarget.isXRRenderTarget===true?_currentRenderTarget.texture.colorSpace:LinearSRGBColorSpace;const envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment);const vertexAlphas=material.vertexColors===true&&!!geometry.attributes.color&&geometry.attributes.color.itemSize===4;const vertexTangents=!!geometry.attributes.tangent&&(!!material.normalMap||material.anisotropy>0);const morphTargets=!!geometry.morphAttributes.position;const morphNormals=!!geometry.morphAttributes.normal;const morphColors=!!geometry.morphAttributes.color;let toneMapping=NoToneMapping;if(material.toneMapped){if(_currentRenderTarget===null||_currentRenderTarget.isXRRenderTarget===true){toneMapping=_this.toneMapping;}}const morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color;const morphTargetsCount=morphAttribute!==undefined?morphAttribute.length:0;const materialProperties=properties.get(material);const lights=currentRenderState.state.lights;if(_clippingEnabled===true){if(_localClippingEnabled===true||camera!==_currentCamera){const useCache=camera===_currentCamera&&material.id===_currentMaterialId;// we might want to call this function with some ClippingGroup
	// object instead of the material, once it becomes feasible
	// (#8465, #8379)
	clipping.setState(material,camera,useCache);}}//
	let needsProgramChange=false;if(material.version===materialProperties.__version){if(materialProperties.needsLights&&materialProperties.lightsStateVersion!==lights.state.version){needsProgramChange=true;}else if(materialProperties.outputColorSpace!==colorSpace){needsProgramChange=true;}else if(object.isBatchedMesh&&materialProperties.batching===false){needsProgramChange=true;}else if(!object.isBatchedMesh&&materialProperties.batching===true){needsProgramChange=true;}else if(object.isBatchedMesh&&materialProperties.batchingColor===true&&object.colorTexture===null){needsProgramChange=true;}else if(object.isBatchedMesh&&materialProperties.batchingColor===false&&object.colorTexture!==null){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancing===false){needsProgramChange=true;}else if(!object.isInstancedMesh&&materialProperties.instancing===true){needsProgramChange=true;}else if(object.isSkinnedMesh&&materialProperties.skinning===false){needsProgramChange=true;}else if(!object.isSkinnedMesh&&materialProperties.skinning===true){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancingColor===true&&object.instanceColor===null){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancingColor===false&&object.instanceColor!==null){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancingMorph===true&&object.morphTexture===null){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancingMorph===false&&object.morphTexture!==null){needsProgramChange=true;}else if(materialProperties.envMap!==envMap){needsProgramChange=true;}else if(material.fog===true&&materialProperties.fog!==fog){needsProgramChange=true;}else if(materialProperties.numClippingPlanes!==undefined&&(materialProperties.numClippingPlanes!==clipping.numPlanes||materialProperties.numIntersection!==clipping.numIntersection)){needsProgramChange=true;}else if(materialProperties.vertexAlphas!==vertexAlphas){needsProgramChange=true;}else if(materialProperties.vertexTangents!==vertexTangents){needsProgramChange=true;}else if(materialProperties.morphTargets!==morphTargets){needsProgramChange=true;}else if(materialProperties.morphNormals!==morphNormals){needsProgramChange=true;}else if(materialProperties.morphColors!==morphColors){needsProgramChange=true;}else if(materialProperties.toneMapping!==toneMapping){needsProgramChange=true;}else if(materialProperties.morphTargetsCount!==morphTargetsCount){needsProgramChange=true;}}else {needsProgramChange=true;materialProperties.__version=material.version;}//
	let program=materialProperties.currentProgram;if(needsProgramChange===true){program=getProgram(material,scene,object);}let refreshProgram=false;let refreshMaterial=false;let refreshLights=false;const p_uniforms=program.getUniforms(),m_uniforms=materialProperties.uniforms;if(state.useProgram(program.program)){refreshProgram=true;refreshMaterial=true;refreshLights=true;}if(material.id!==_currentMaterialId){_currentMaterialId=material.id;refreshMaterial=true;}if(refreshProgram||_currentCamera!==camera){// common camera uniforms
	const reversedDepthBuffer=state.buffers.depth.getReversed();if(reversedDepthBuffer&&camera.reversedDepth!==true){camera._reversedDepth=true;camera.updateProjectionMatrix();}p_uniforms.setValue(_gl,'projectionMatrix',camera.projectionMatrix);p_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);const uCamPos=p_uniforms.map.cameraPosition;if(uCamPos!==undefined){uCamPos.setValue(_gl,_vector3.setFromMatrixPosition(camera.matrixWorld));}if(capabilities.logarithmicDepthBuffer){p_uniforms.setValue(_gl,'logDepthBufFC',2.0/(Math.log(camera.far+1.0)/Math.LN2));}// consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067
	if(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial){p_uniforms.setValue(_gl,'isOrthographic',camera.isOrthographicCamera===true);}if(_currentCamera!==camera){_currentCamera=camera;// lighting uniforms depend on the camera so enforce an update
	// now, in case this material supports lights - or later, when
	// the next material that does gets activated:
	refreshMaterial=true;// set to true on material change
	refreshLights=true;// remains set until update done
	}}// skinning and morph target uniforms must be set even if material didn't change
	// auto-setting of texture unit for bone and morph texture must go before other textures
	// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures
	if(object.isSkinnedMesh){p_uniforms.setOptional(_gl,object,'bindMatrix');p_uniforms.setOptional(_gl,object,'bindMatrixInverse');const skeleton=object.skeleton;if(skeleton){if(skeleton.boneTexture===null)skeleton.computeBoneTexture();p_uniforms.setValue(_gl,'boneTexture',skeleton.boneTexture,textures);}}if(object.isBatchedMesh){p_uniforms.setOptional(_gl,object,'batchingTexture');p_uniforms.setValue(_gl,'batchingTexture',object._matricesTexture,textures);p_uniforms.setOptional(_gl,object,'batchingIdTexture');p_uniforms.setValue(_gl,'batchingIdTexture',object._indirectTexture,textures);p_uniforms.setOptional(_gl,object,'batchingColorTexture');if(object._colorsTexture!==null){p_uniforms.setValue(_gl,'batchingColorTexture',object._colorsTexture,textures);}}const morphAttributes=geometry.morphAttributes;if(morphAttributes.position!==undefined||morphAttributes.normal!==undefined||morphAttributes.color!==undefined){morphtargets.update(object,geometry,program);}if(refreshMaterial||materialProperties.receiveShadow!==object.receiveShadow){materialProperties.receiveShadow=object.receiveShadow;p_uniforms.setValue(_gl,'receiveShadow',object.receiveShadow);}// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512
	if(material.isMeshGouraudMaterial&&material.envMap!==null){m_uniforms.envMap.value=envMap;m_uniforms.flipEnvMap.value=envMap.isCubeTexture&&envMap.isRenderTargetTexture===false?-1:1;}if(material.isMeshStandardMaterial&&material.envMap===null&&scene.environment!==null){m_uniforms.envMapIntensity.value=scene.environmentIntensity;}// Set DFG LUT for physically-based materials
	if(m_uniforms.dfgLUT!==undefined){m_uniforms.dfgLUT.value=getDFGLUT();}if(refreshMaterial){p_uniforms.setValue(_gl,'toneMappingExposure',_this.toneMappingExposure);if(materialProperties.needsLights){// the current material requires lighting info
	// note: all lighting uniforms are always set correctly
	// they simply reference the renderer's state for their
	// values
	//
	// use the current material's .needsUpdate flags to set
	// the GL state when required
	markUniformsLightsNeedsUpdate(m_uniforms,refreshLights);}// refresh uniforms common to several materials
	if(fog&&material.fog===true){materials.refreshFogUniforms(m_uniforms,fog);}materials.refreshMaterialUniforms(m_uniforms,material,_pixelRatio,_height,currentRenderState.state.transmissionRenderTarget[camera.id]);WebGLUniforms.upload(_gl,getUniformList(materialProperties),m_uniforms,textures);}if(material.isShaderMaterial&&material.uniformsNeedUpdate===true){WebGLUniforms.upload(_gl,getUniformList(materialProperties),m_uniforms,textures);material.uniformsNeedUpdate=false;}if(material.isSpriteMaterial){p_uniforms.setValue(_gl,'center',object.center);}// common matrices
	p_uniforms.setValue(_gl,'modelViewMatrix',object.modelViewMatrix);p_uniforms.setValue(_gl,'normalMatrix',object.normalMatrix);p_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);// UBOs
	if(material.isShaderMaterial||material.isRawShaderMaterial){const groups=material.uniformsGroups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i];uniformsGroups.update(group,program);uniformsGroups.bind(group,program);}}return program;}// If uniforms are marked as clean, they don't need to be loaded to the GPU.
	function markUniformsLightsNeedsUpdate(uniforms,value){uniforms.ambientLightColor.needsUpdate=value;uniforms.lightProbe.needsUpdate=value;uniforms.directionalLights.needsUpdate=value;uniforms.directionalLightShadows.needsUpdate=value;uniforms.pointLights.needsUpdate=value;uniforms.pointLightShadows.needsUpdate=value;uniforms.spotLights.needsUpdate=value;uniforms.spotLightShadows.needsUpdate=value;uniforms.rectAreaLights.needsUpdate=value;uniforms.hemisphereLights.needsUpdate=value;}function materialNeedsLights(material){return material.isMeshLambertMaterial||material.isMeshToonMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.isShadowMaterial||material.isShaderMaterial&&material.lights===true;}/**
			 * Returns the active cube face.
			 *
			 * @return {number} The active cube face.
			 */this.getActiveCubeFace=function(){return _currentActiveCubeFace;};/**
			 * Returns the active mipmap level.
			 *
			 * @return {number} The active mipmap level.
			 */this.getActiveMipmapLevel=function(){return _currentActiveMipmapLevel;};/**
			 * Returns the active render target.
			 *
			 * @return {?WebGLRenderTarget} The active render target. Returns `null` if no render target
			 * is currently set.
			 */this.getRenderTarget=function(){return _currentRenderTarget;};this.setRenderTargetTextures=function(renderTarget,colorTexture,depthTexture){const renderTargetProperties=properties.get(renderTarget);renderTargetProperties.__autoAllocateDepthBuffer=renderTarget.resolveDepthBuffer===false;if(renderTargetProperties.__autoAllocateDepthBuffer===false){// The multisample_render_to_texture extension doesn't work properly if there
	// are midframe flushes and an external depth buffer. Disable use of the extension.
	renderTargetProperties.__useRenderToTexture=false;}properties.get(renderTarget.texture).__webglTexture=colorTexture;properties.get(renderTarget.depthTexture).__webglTexture=renderTargetProperties.__autoAllocateDepthBuffer?undefined:depthTexture;renderTargetProperties.__hasExternalTextures=true;};this.setRenderTargetFramebuffer=function(renderTarget,defaultFramebuffer){const renderTargetProperties=properties.get(renderTarget);renderTargetProperties.__webglFramebuffer=defaultFramebuffer;renderTargetProperties.__useDefaultFramebuffer=defaultFramebuffer===undefined;};const _scratchFrameBuffer=_gl.createFramebuffer();/**
			 * Sets the active rendertarget.
			 *
			 * @param {?WebGLRenderTarget} renderTarget - The render target to set. When `null` is given,
			 * the canvas is set as the active render target instead.
			 * @param {number} [activeCubeFace=0] - The active cube face when using a cube render target.
			 * Indicates the z layer to render in to when using 3D or array render targets.
			 * @param {number} [activeMipmapLevel=0] - The active mipmap level.
			 */this.setRenderTarget=function(renderTarget,activeCubeFace=0,activeMipmapLevel=0){_currentRenderTarget=renderTarget;_currentActiveCubeFace=activeCubeFace;_currentActiveMipmapLevel=activeMipmapLevel;let useDefaultFramebuffer=true;let framebuffer=null;let isCube=false;let isRenderTarget3D=false;if(renderTarget){const renderTargetProperties=properties.get(renderTarget);if(renderTargetProperties.__useDefaultFramebuffer!==undefined){// We need to make sure to rebind the framebuffer.
	state.bindFramebuffer(_gl.FRAMEBUFFER,null);useDefaultFramebuffer=false;}else if(renderTargetProperties.__webglFramebuffer===undefined){textures.setupRenderTarget(renderTarget);}else if(renderTargetProperties.__hasExternalTextures){// Color and depth texture must be rebound in order for the swapchain to update.
	textures.rebindTextures(renderTarget,properties.get(renderTarget.texture).__webglTexture,properties.get(renderTarget.depthTexture).__webglTexture);}else if(renderTarget.depthBuffer){// check if the depth texture is already bound to the frame buffer and that it's been initialized
	const depthTexture=renderTarget.depthTexture;if(renderTargetProperties.__boundDepthTexture!==depthTexture){// check if the depth texture is compatible
	if(depthTexture!==null&&properties.has(depthTexture)&&(renderTarget.width!==depthTexture.image.width||renderTarget.height!==depthTexture.image.height)){throw new Error('WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.');}// Swap the depth buffer to the currently attached one
	textures.setupDepthRenderbuffer(renderTarget);}}const texture=renderTarget.texture;if(texture.isData3DTexture||texture.isDataArrayTexture||texture.isCompressedArrayTexture){isRenderTarget3D=true;}const __webglFramebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget){if(Array.isArray(__webglFramebuffer[activeCubeFace])){framebuffer=__webglFramebuffer[activeCubeFace][activeMipmapLevel];}else {framebuffer=__webglFramebuffer[activeCubeFace];}isCube=true;}else if(renderTarget.samples>0&&textures.useMultisampledRTT(renderTarget)===false){framebuffer=properties.get(renderTarget).__webglMultisampledFramebuffer;}else {if(Array.isArray(__webglFramebuffer)){framebuffer=__webglFramebuffer[activeMipmapLevel];}else {framebuffer=__webglFramebuffer;}}_currentViewport.copy(renderTarget.viewport);_currentScissor.copy(renderTarget.scissor);_currentScissorTest=renderTarget.scissorTest;}else {_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();_currentScissorTest=_scissorTest;}// Use a scratch frame buffer if rendering to a mip level to avoid depth buffers
	// being bound that are different sizes.
	if(activeMipmapLevel!==0){framebuffer=_scratchFrameBuffer;}const framebufferBound=state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);if(framebufferBound&&useDefaultFramebuffer){state.drawBuffers(renderTarget,framebuffer);}state.viewport(_currentViewport);state.scissor(_currentScissor);state.setScissorTest(_currentScissorTest);if(isCube){const textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+activeCubeFace,textureProperties.__webglTexture,activeMipmapLevel);}else if(isRenderTarget3D){const layer=activeCubeFace;for(let i=0;i<renderTarget.textures.length;i++){const textureProperties=properties.get(renderTarget.textures[i]);_gl.framebufferTextureLayer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i,textureProperties.__webglTexture,activeMipmapLevel,layer);}}else if(renderTarget!==null&&activeMipmapLevel!==0){// Only bind the frame buffer if we are using a scratch frame buffer to render to a mipmap.
	// If we rebind the texture when using a multi sample buffer then an error about inconsistent samples will be thrown.
	const textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D,textureProperties.__webglTexture,activeMipmapLevel);}_currentMaterialId=-1;// reset current material to ensure correct uniform bindings
	};/**
			 * Reads the pixel data from the given render target into the given buffer.
			 *
			 * @param {WebGLRenderTarget} renderTarget - The render target to read from.
			 * @param {number} x - The `x` coordinate of the copy region's origin.
			 * @param {number} y - The `y` coordinate of the copy region's origin.
			 * @param {number} width - The width of the copy region.
			 * @param {number} height - The height of the copy region.
			 * @param {TypedArray} buffer - The result buffer.
			 * @param {number} [activeCubeFaceIndex] - The active cube face index.
			 * @param {number} [textureIndex=0] - The texture index of an MRT render target.
			 */this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer,activeCubeFaceIndex,textureIndex=0){if(!(renderTarget&&renderTarget.isWebGLRenderTarget)){error$1('WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');return;}let framebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget&&activeCubeFaceIndex!==undefined){framebuffer=framebuffer[activeCubeFaceIndex];}if(framebuffer){state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);try{const texture=renderTarget.textures[textureIndex];const textureFormat=texture.format;const textureType=texture.type;if(!capabilities.textureFormatReadable(textureFormat)){error$1('WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');return;}if(!capabilities.textureTypeReadable(textureType)){error$1('WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');return;}// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
	if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){// when using MRT, select the correct color buffer for the subsequent read command
	if(renderTarget.textures.length>1)_gl.readBuffer(_gl.COLOR_ATTACHMENT0+textureIndex);_gl.readPixels(x,y,width,height,utils.convert(textureFormat),utils.convert(textureType),buffer);}}finally{// restore framebuffer of current render target if necessary
	const framebuffer=_currentRenderTarget!==null?properties.get(_currentRenderTarget).__webglFramebuffer:null;state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);}}};/**
			 * Asynchronous, non-blocking version of {@link WebGLRenderer#readRenderTargetPixels}.
			 *
			 * It is recommended to use this version of `readRenderTargetPixels()` whenever possible.
			 *
			 * @async
			 * @param {WebGLRenderTarget} renderTarget - The render target to read from.
			 * @param {number} x - The `x` coordinate of the copy region's origin.
			 * @param {number} y - The `y` coordinate of the copy region's origin.
			 * @param {number} width - The width of the copy region.
			 * @param {number} height - The height of the copy region.
			 * @param {TypedArray} buffer - The result buffer.
			 * @param {number} [activeCubeFaceIndex] - The active cube face index.
			 * @param {number} [textureIndex=0] - The texture index of an MRT render target.
			 * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
			 */this.readRenderTargetPixelsAsync=async function(renderTarget,x,y,width,height,buffer,activeCubeFaceIndex,textureIndex=0){if(!(renderTarget&&renderTarget.isWebGLRenderTarget)){throw new Error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');}let framebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget&&activeCubeFaceIndex!==undefined){framebuffer=framebuffer[activeCubeFaceIndex];}if(framebuffer){// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
	if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){// set the active frame buffer to the one we want to read
	state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);const texture=renderTarget.textures[textureIndex];const textureFormat=texture.format;const textureType=texture.type;if(!capabilities.textureFormatReadable(textureFormat)){throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.');}if(!capabilities.textureTypeReadable(textureType)){throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.');}const glBuffer=_gl.createBuffer();_gl.bindBuffer(_gl.PIXEL_PACK_BUFFER,glBuffer);_gl.bufferData(_gl.PIXEL_PACK_BUFFER,buffer.byteLength,_gl.STREAM_READ);// when using MRT, select the correct color buffer for the subsequent read command
	if(renderTarget.textures.length>1)_gl.readBuffer(_gl.COLOR_ATTACHMENT0+textureIndex);_gl.readPixels(x,y,width,height,utils.convert(textureFormat),utils.convert(textureType),0);// reset the frame buffer to the currently set buffer before waiting
	const currFramebuffer=_currentRenderTarget!==null?properties.get(_currentRenderTarget).__webglFramebuffer:null;state.bindFramebuffer(_gl.FRAMEBUFFER,currFramebuffer);// check if the commands have finished every 8 ms
	const sync=_gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE,0);_gl.flush();await probeAsync(_gl,sync,4);// read the data and delete the buffer
	_gl.bindBuffer(_gl.PIXEL_PACK_BUFFER,glBuffer);_gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER,0,buffer);_gl.deleteBuffer(glBuffer);_gl.deleteSync(sync);return buffer;}else {throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.');}}};/**
			 * Copies pixels from the current bound framebuffer into the given texture.
			 *
			 * @param {FramebufferTexture} texture - The texture.
			 * @param {?Vector2} [position=null] - The start position of the copy operation.
			 * @param {number} [level=0] - The mip level. The default represents the base mip.
			 */this.copyFramebufferToTexture=function(texture,position=null,level=0){const levelScale=Math.pow(2,-level);const width=Math.floor(texture.image.width*levelScale);const height=Math.floor(texture.image.height*levelScale);const x=position!==null?position.x:0;const y=position!==null?position.y:0;textures.setTexture2D(texture,0);_gl.copyTexSubImage2D(_gl.TEXTURE_2D,level,0,0,x,y,width,height);state.unbindTexture();};const _srcFramebuffer=_gl.createFramebuffer();const _dstFramebuffer=_gl.createFramebuffer();/**
			 * Copies data of the given source texture into a destination texture.
			 *
			 * When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are initialized
			 * {@link WebGLRenderer#initRenderTarget}.
			 *
			 * @param {Texture} srcTexture - The source texture.
			 * @param {Texture} dstTexture - The destination texture.
			 * @param {?(Box2|Box3)} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
			 * @param {?(Vector2|Vector3)} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
			 * @param {number} [srcLevel=0] - The source mipmap level to copy.
			 * @param {?number} [dstLevel=null] - The destination mipmap level.
			 */this.copyTextureToTexture=function(srcTexture,dstTexture,srcRegion=null,dstPosition=null,srcLevel=0,dstLevel=null){// support the previous signature with just a single dst mipmap level
	if(dstLevel===null){if(srcLevel!==0){// @deprecated, r171
	warnOnce('WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.');dstLevel=srcLevel;srcLevel=0;}else {dstLevel=0;}}// gather the necessary dimensions to copy
	let width,height,depth,minX,minY,minZ;let dstX,dstY,dstZ;const image=srcTexture.isCompressedTexture?srcTexture.mipmaps[dstLevel]:srcTexture.image;if(srcRegion!==null){width=srcRegion.max.x-srcRegion.min.x;height=srcRegion.max.y-srcRegion.min.y;depth=srcRegion.isBox3?srcRegion.max.z-srcRegion.min.z:1;minX=srcRegion.min.x;minY=srcRegion.min.y;minZ=srcRegion.isBox3?srcRegion.min.z:0;}else {const levelScale=Math.pow(2,-srcLevel);width=Math.floor(image.width*levelScale);height=Math.floor(image.height*levelScale);if(srcTexture.isDataArrayTexture){depth=image.depth;}else if(srcTexture.isData3DTexture){depth=Math.floor(image.depth*levelScale);}else {depth=1;}minX=0;minY=0;minZ=0;}if(dstPosition!==null){dstX=dstPosition.x;dstY=dstPosition.y;dstZ=dstPosition.z;}else {dstX=0;dstY=0;dstZ=0;}// Set up the destination target
	const glFormat=utils.convert(dstTexture.format);const glType=utils.convert(dstTexture.type);let glTarget;if(dstTexture.isData3DTexture){textures.setTexture3D(dstTexture,0);glTarget=_gl.TEXTURE_3D;}else if(dstTexture.isDataArrayTexture||dstTexture.isCompressedArrayTexture){textures.setTexture2DArray(dstTexture,0);glTarget=_gl.TEXTURE_2D_ARRAY;}else {textures.setTexture2D(dstTexture,0);glTarget=_gl.TEXTURE_2D;}_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,dstTexture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,dstTexture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,dstTexture.unpackAlignment);// used for copying data from cpu
	const currentUnpackRowLen=_gl.getParameter(_gl.UNPACK_ROW_LENGTH);const currentUnpackImageHeight=_gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);const currentUnpackSkipPixels=_gl.getParameter(_gl.UNPACK_SKIP_PIXELS);const currentUnpackSkipRows=_gl.getParameter(_gl.UNPACK_SKIP_ROWS);const currentUnpackSkipImages=_gl.getParameter(_gl.UNPACK_SKIP_IMAGES);_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH,image.width);_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT,image.height);_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS,minX);_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS,minY);_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES,minZ);// set up the src texture
	const isSrc3D=srcTexture.isDataArrayTexture||srcTexture.isData3DTexture;const isDst3D=dstTexture.isDataArrayTexture||dstTexture.isData3DTexture;if(srcTexture.isDepthTexture){const srcTextureProperties=properties.get(srcTexture);const dstTextureProperties=properties.get(dstTexture);const srcRenderTargetProperties=properties.get(srcTextureProperties.__renderTarget);const dstRenderTargetProperties=properties.get(dstTextureProperties.__renderTarget);state.bindFramebuffer(_gl.READ_FRAMEBUFFER,srcRenderTargetProperties.__webglFramebuffer);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,dstRenderTargetProperties.__webglFramebuffer);for(let i=0;i<depth;i++){// if the source or destination are a 3d target then a layer needs to be bound
	if(isSrc3D){_gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,properties.get(srcTexture).__webglTexture,srcLevel,minZ+i);_gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,properties.get(dstTexture).__webglTexture,dstLevel,dstZ+i);}_gl.blitFramebuffer(minX,minY,width,height,dstX,dstY,width,height,_gl.DEPTH_BUFFER_BIT,_gl.NEAREST);}state.bindFramebuffer(_gl.READ_FRAMEBUFFER,null);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,null);}else if(srcLevel!==0||srcTexture.isRenderTargetTexture||properties.has(srcTexture)){// get the appropriate frame buffers
	const srcTextureProperties=properties.get(srcTexture);const dstTextureProperties=properties.get(dstTexture);// bind the frame buffer targets
	state.bindFramebuffer(_gl.READ_FRAMEBUFFER,_srcFramebuffer);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,_dstFramebuffer);for(let i=0;i<depth;i++){// assign the correct layers and mip maps to the frame buffers
	if(isSrc3D){_gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,srcTextureProperties.__webglTexture,srcLevel,minZ+i);}else {_gl.framebufferTexture2D(_gl.READ_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D,srcTextureProperties.__webglTexture,srcLevel);}if(isDst3D){_gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,dstTextureProperties.__webglTexture,dstLevel,dstZ+i);}else {_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D,dstTextureProperties.__webglTexture,dstLevel);}// copy the data using the fastest function that can achieve the copy
	if(srcLevel!==0){_gl.blitFramebuffer(minX,minY,width,height,dstX,dstY,width,height,_gl.COLOR_BUFFER_BIT,_gl.NEAREST);}else if(isDst3D){_gl.copyTexSubImage3D(glTarget,dstLevel,dstX,dstY,dstZ+i,minX,minY,width,height);}else {_gl.copyTexSubImage2D(glTarget,dstLevel,dstX,dstY,minX,minY,width,height);}}// unbind read, draw buffers
	state.bindFramebuffer(_gl.READ_FRAMEBUFFER,null);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,null);}else {if(isDst3D){// copy data into the 3d texture
	if(srcTexture.isDataTexture||srcTexture.isData3DTexture){_gl.texSubImage3D(glTarget,dstLevel,dstX,dstY,dstZ,width,height,depth,glFormat,glType,image.data);}else if(dstTexture.isCompressedArrayTexture){_gl.compressedTexSubImage3D(glTarget,dstLevel,dstX,dstY,dstZ,width,height,depth,glFormat,image.data);}else {_gl.texSubImage3D(glTarget,dstLevel,dstX,dstY,dstZ,width,height,depth,glFormat,glType,image);}}else {// copy data into the 2d texture
	if(srcTexture.isDataTexture){_gl.texSubImage2D(_gl.TEXTURE_2D,dstLevel,dstX,dstY,width,height,glFormat,glType,image.data);}else if(srcTexture.isCompressedTexture){_gl.compressedTexSubImage2D(_gl.TEXTURE_2D,dstLevel,dstX,dstY,image.width,image.height,glFormat,image.data);}else {_gl.texSubImage2D(_gl.TEXTURE_2D,dstLevel,dstX,dstY,width,height,glFormat,glType,image);}}}// reset values
	_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH,currentUnpackRowLen);_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT,currentUnpackImageHeight);_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS,currentUnpackSkipPixels);_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS,currentUnpackSkipRows);_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES,currentUnpackSkipImages);// Generate mipmaps only when copying level 0
	if(dstLevel===0&&dstTexture.generateMipmaps){_gl.generateMipmap(glTarget);}state.unbindTexture();};/**
			 * Initializes the given WebGLRenderTarget memory. Useful for initializing a render target so data
			 * can be copied into it using {@link WebGLRenderer#copyTextureToTexture} before it has been
			 * rendered to.
			 *
			 * @param {WebGLRenderTarget} target - The render target.
			 */this.initRenderTarget=function(target){if(properties.get(target).__webglFramebuffer===undefined){textures.setupRenderTarget(target);}};/**
			 * Initializes the given texture. Useful for preloading a texture rather than waiting until first
			 * render (which can cause noticeable lags due to decode and GPU upload overhead).
			 *
			 * @param {Texture} texture - The texture.
			 */this.initTexture=function(texture){if(texture.isCubeTexture){textures.setTextureCube(texture,0);}else if(texture.isData3DTexture){textures.setTexture3D(texture,0);}else if(texture.isDataArrayTexture||texture.isCompressedArrayTexture){textures.setTexture2DArray(texture,0);}else {textures.setTexture2D(texture,0);}state.unbindTexture();};/**
			 * Can be used to reset the internal WebGL state. This method is mostly
			 * relevant for applications which share a single WebGL context across
			 * multiple WebGL libraries.
			 */this.resetState=function(){_currentActiveCubeFace=0;_currentActiveMipmapLevel=0;_currentRenderTarget=null;state.reset();bindingStates.reset();};if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:this}));}}/**
		 * Defines the coordinate system of the renderer.
		 *
		 * In `WebGLRenderer`, the value is always `WebGLCoordinateSystem`.
		 *
		 * @type {WebGLCoordinateSystem|WebGPUCoordinateSystem}
		 * @default WebGLCoordinateSystem
		 * @readonly
		 */get coordinateSystem(){return WebGLCoordinateSystem$1;}/**
		 * Defines the output color space of the renderer.
		 *
		 * @type {SRGBColorSpace|LinearSRGBColorSpace}
		 * @default SRGBColorSpace
		 */get outputColorSpace(){return this._outputColorSpace;}set outputColorSpace(colorSpace){this._outputColorSpace=colorSpace;const gl=this.getContext();gl.drawingBufferColorSpace=ColorManagement._getDrawingBufferColorSpace(colorSpace);gl.unpackColorSpace=ColorManagement._getUnpackColorSpace();}}

	/**
	 * Fires when the camera has been transformed by the controls.
	 *
	 * @event OrbitControls#change
	 * @type {Object}
	 */
	const _changeEvent = {
	  type: 'change'
	};

	/**
	 * Fires when an interaction was initiated.
	 *
	 * @event OrbitControls#start
	 * @type {Object}
	 */
	const _startEvent = {
	  type: 'start'
	};

	/**
	 * Fires when an interaction has finished.
	 *
	 * @event OrbitControls#end
	 * @type {Object}
	 */
	const _endEvent = {
	  type: 'end'
	};
	const _ray = new Ray();
	const _plane = new Plane();
	const _TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);
	const _v = new Vector3$1();
	const _twoPI = 2 * Math.PI;
	const _STATE = {
	  NONE: -1,
	  ROTATE: 0,
	  DOLLY: 1,
	  PAN: 2,
	  TOUCH_ROTATE: 3,
	  TOUCH_PAN: 4,
	  TOUCH_DOLLY_PAN: 5,
	  TOUCH_DOLLY_ROTATE: 6
	};
	const _EPS = 0.000001;

	/**
	 * Orbit controls allow the camera to orbit around a target.
	 *
	 * OrbitControls performs orbiting, dollying (zooming), and panning. Unlike {@link TrackballControls},
	 * it maintains the "up" direction `object.up` (+Y by default).
	 *
	 * - Orbit: Left mouse / touch: one-finger move.
	 * - Zoom: Middle mouse, or mousewheel / touch: two-finger spread or squish.
	 * - Pan: Right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move.
	 *
	 * ```js
	 * const controls = new OrbitControls( camera, renderer.domElement );
	 *
	 * // controls.update() must be called after any manual changes to the camera's transform
	 * camera.position.set( 0, 20, 100 );
	 * controls.update();
	 *
	 * function animate() {
	 *
	 * 	// required if controls.enableDamping or controls.autoRotate are set to true
	 * 	controls.update();
	 *
	 * 	renderer.render( scene, camera );
	 *
	 * }
	 * ```
	 *
	 * @augments Controls
	 * @three_import import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	 */
	class OrbitControls extends Controls {
	  /**
	   * Constructs a new controls instance.
	   *
	   * @param {Object3D} object - The object that is managed by the controls.
	   * @param {?HTMLElement} domElement - The HTML element used for event listeners.
	   */
	  constructor(object, domElement = null) {
	    super(object, domElement);
	    this.state = _STATE.NONE;

	    /**
	     * The focus point of the controls, the `object` orbits around this.
	     * It can be updated manually at any point to change the focus of the controls.
	     *
	     * @type {Vector3}
	     */
	    this.target = new Vector3$1();

	    /**
	     * The focus point of the `minTargetRadius` and `maxTargetRadius` limits.
	     * It can be updated manually at any point to change the center of interest
	     * for the `target`.
	     *
	     * @type {Vector3}
	     */
	    this.cursor = new Vector3$1();

	    /**
	     * How far you can dolly in (perspective camera only).
	     *
	     * @type {number}
	     * @default 0
	     */
	    this.minDistance = 0;

	    /**
	     * How far you can dolly out (perspective camera only).
	     *
	     * @type {number}
	     * @default Infinity
	     */
	    this.maxDistance = Infinity;

	    /**
	     * How far you can zoom in (orthographic camera only).
	     *
	     * @type {number}
	     * @default 0
	     */
	    this.minZoom = 0;

	    /**
	     * How far you can zoom out (orthographic camera only).
	     *
	     * @type {number}
	     * @default Infinity
	     */
	    this.maxZoom = Infinity;

	    /**
	     * How close you can get the target to the 3D `cursor`.
	     *
	     * @type {number}
	     * @default 0
	     */
	    this.minTargetRadius = 0;

	    /**
	     * How far you can move the target from the 3D `cursor`.
	     *
	     * @type {number}
	     * @default Infinity
	     */
	    this.maxTargetRadius = Infinity;

	    /**
	     * How far you can orbit vertically, lower limit. Range is `[0, Math.PI]` radians.
	     *
	     * @type {number}
	     * @default 0
	     */
	    this.minPolarAngle = 0;

	    /**
	     * How far you can orbit vertically, upper limit. Range is `[0, Math.PI]` radians.
	     *
	     * @type {number}
	     * @default Math.PI
	     */
	    this.maxPolarAngle = Math.PI;

	    /**
	     * How far you can orbit horizontally, lower limit. If set, the interval `[ min, max ]`
	     * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.
	     *
	     * @type {number}
	     * @default -Infinity
	     */
	    this.minAzimuthAngle = -Infinity;

	    /**
	     * How far you can orbit horizontally, upper limit. If set, the interval `[ min, max ]`
	     * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.
	     *
	     * @type {number}
	     * @default -Infinity
	     */
	    this.maxAzimuthAngle = Infinity;

	    /**
	     * Set to `true` to enable damping (inertia), which can be used to give a sense of weight
	     * to the controls. Note that if this is enabled, you must call `update()` in your animation
	     * loop.
	     *
	     * @type {boolean}
	     * @default false
	     */
	    this.enableDamping = false;

	    /**
	     * The damping inertia used if `enableDamping` is set to `true`.
	     *
	     * Note that for this to work, you must call `update()` in your animation loop.
	     *
	     * @type {number}
	     * @default 0.05
	     */
	    this.dampingFactor = 0.05;

	    /**
	     * Enable or disable zooming (dollying) of the camera.
	     *
	     * @type {boolean}
	     * @default true
	     */
	    this.enableZoom = true;

	    /**
	     * Speed of zooming / dollying.
	     *
	     * @type {number}
	     * @default 1
	     */
	    this.zoomSpeed = 1.0;

	    /**
	     * Enable or disable horizontal and vertical rotation of the camera.
	     *
	     * Note that it is possible to disable a single axis by setting the min and max of the
	     * `minPolarAngle` or `minAzimuthAngle` to the same value, which will cause the vertical
	     * or horizontal rotation to be fixed at that value.
	     *
	     * @type {boolean}
	     * @default true
	     */
	    this.enableRotate = true;

	    /**
	     * Speed of rotation.
	     *
	     * @type {number}
	     * @default 1
	     */
	    this.rotateSpeed = 1.0;

	    /**
	     * How fast to rotate the camera when the keyboard is used.
	     *
	     * @type {number}
	     * @default 1
	     */
	    this.keyRotateSpeed = 1.0;

	    /**
	     * Enable or disable camera panning.
	     *
	     * @type {boolean}
	     * @default true
	     */
	    this.enablePan = true;

	    /**
	     * Speed of panning.
	     *
	     * @type {number}
	     * @default 1
	     */
	    this.panSpeed = 1.0;

	    /**
	     * Defines how the camera's position is translated when panning. If `true`, the camera pans
	     * in screen space. Otherwise, the camera pans in the plane orthogonal to the camera's up
	     * direction.
	     *
	     * @type {boolean}
	     * @default true
	     */
	    this.screenSpacePanning = true;

	    /**
	     * How fast to pan the camera when the keyboard is used in
	     * pixels per keypress.
	     *
	     * @type {number}
	     * @default 7
	     */
	    this.keyPanSpeed = 7.0;

	    /**
	     * Setting this property to `true` allows to zoom to the cursor's position.
	     *
	     * @type {boolean}
	     * @default false
	     */
	    this.zoomToCursor = false;

	    /**
	     * Set to true to automatically rotate around the target
	     *
	     * Note that if this is enabled, you must call `update()` in your animation loop.
	     * If you want the auto-rotate speed to be independent of the frame rate (the refresh
	     * rate of the display), you must pass the time `deltaTime`, in seconds, to `update()`.
	     *
	     * @type {boolean}
	     * @default false
	     */
	    this.autoRotate = false;

	    /**
	     * How fast to rotate around the target if `autoRotate` is `true`. The default  equates to 30 seconds
	     * per orbit at 60fps.
	     *
	     * Note that if `autoRotate` is enabled, you must call `update()` in your animation loop.
	     *
	     * @type {number}
	     * @default 2
	     */
	    this.autoRotateSpeed = 2.0;

	    /**
	     * This object contains references to the keycodes for controlling camera panning.
	     *
	     * ```js
	     * controls.keys = {
	     * 	LEFT: 'ArrowLeft', //left arrow
	     * 	UP: 'ArrowUp', // up arrow
	     * 	RIGHT: 'ArrowRight', // right arrow
	     * 	BOTTOM: 'ArrowDown' // down arrow
	     * }
	     * ```
	     * @type {Object}
	     */
	    this.keys = {
	      LEFT: 'ArrowLeft',
	      UP: 'ArrowUp',
	      RIGHT: 'ArrowRight',
	      BOTTOM: 'ArrowDown'
	    };

	    /**
	     * This object contains references to the mouse actions used by the controls.
	     *
	     * ```js
	     * controls.mouseButtons = {
	     * 	LEFT: THREE.MOUSE.ROTATE,
	     * 	MIDDLE: THREE.MOUSE.DOLLY,
	     * 	RIGHT: THREE.MOUSE.PAN
	     * }
	     * ```
	     * @type {Object}
	     */
	    this.mouseButtons = {
	      LEFT: MOUSE.ROTATE,
	      MIDDLE: MOUSE.DOLLY,
	      RIGHT: MOUSE.PAN
	    };

	    /**
	     * This object contains references to the touch actions used by the controls.
	     *
	     * ```js
	     * controls.mouseButtons = {
	     * 	ONE: THREE.TOUCH.ROTATE,
	     * 	TWO: THREE.TOUCH.DOLLY_PAN
	     * }
	     * ```
	     * @type {Object}
	     */
	    this.touches = {
	      ONE: TOUCH.ROTATE,
	      TWO: TOUCH.DOLLY_PAN
	    };

	    /**
	     * Used internally by `saveState()` and `reset()`.
	     *
	     * @type {Vector3}
	     */
	    this.target0 = this.target.clone();

	    /**
	     * Used internally by `saveState()` and `reset()`.
	     *
	     * @type {Vector3}
	     */
	    this.position0 = this.object.position.clone();

	    /**
	     * Used internally by `saveState()` and `reset()`.
	     *
	     * @type {number}
	     */
	    this.zoom0 = this.object.zoom;

	    // the target DOM element for key events
	    this._domElementKeyEvents = null;

	    // internals

	    this._lastPosition = new Vector3$1();
	    this._lastQuaternion = new Quaternion$1();
	    this._lastTargetPosition = new Vector3$1();

	    // so camera.up is the orbit axis
	    this._quat = new Quaternion$1().setFromUnitVectors(object.up, new Vector3$1(0, 1, 0));
	    this._quatInverse = this._quat.clone().invert();

	    // current position in spherical coordinates
	    this._spherical = new Spherical();
	    this._sphericalDelta = new Spherical();
	    this._scale = 1;
	    this._panOffset = new Vector3$1();
	    this._rotateStart = new Vector2$1();
	    this._rotateEnd = new Vector2$1();
	    this._rotateDelta = new Vector2$1();
	    this._panStart = new Vector2$1();
	    this._panEnd = new Vector2$1();
	    this._panDelta = new Vector2$1();
	    this._dollyStart = new Vector2$1();
	    this._dollyEnd = new Vector2$1();
	    this._dollyDelta = new Vector2$1();
	    this._dollyDirection = new Vector3$1();
	    this._mouse = new Vector2$1();
	    this._performCursorZoom = false;
	    this._pointers = [];
	    this._pointerPositions = {};
	    this._controlActive = false;

	    // event listeners

	    this._onPointerMove = onPointerMove.bind(this);
	    this._onPointerDown = onPointerDown.bind(this);
	    this._onPointerUp = onPointerUp.bind(this);
	    this._onContextMenu = onContextMenu.bind(this);
	    this._onMouseWheel = onMouseWheel.bind(this);
	    this._onKeyDown = onKeyDown.bind(this);
	    this._onTouchStart = onTouchStart.bind(this);
	    this._onTouchMove = onTouchMove.bind(this);
	    this._onMouseDown = onMouseDown.bind(this);
	    this._onMouseMove = onMouseMove.bind(this);
	    this._interceptControlDown = interceptControlDown.bind(this);
	    this._interceptControlUp = interceptControlUp.bind(this);

	    //

	    if (this.domElement !== null) {
	      this.connect(this.domElement);
	    }
	    this.update();
	  }
	  connect(element) {
	    super.connect(element);
	    this.domElement.addEventListener('pointerdown', this._onPointerDown);
	    this.domElement.addEventListener('pointercancel', this._onPointerUp);
	    this.domElement.addEventListener('contextmenu', this._onContextMenu);
	    this.domElement.addEventListener('wheel', this._onMouseWheel, {
	      passive: false
	    });
	    const document = this.domElement.getRootNode(); // offscreen canvas compatibility
	    document.addEventListener('keydown', this._interceptControlDown, {
	      passive: true,
	      capture: true
	    });
	    this.domElement.style.touchAction = 'none'; // disable touch scroll
	  }
	  disconnect() {
	    this.domElement.removeEventListener('pointerdown', this._onPointerDown);
	    this.domElement.removeEventListener('pointermove', this._onPointerMove);
	    this.domElement.removeEventListener('pointerup', this._onPointerUp);
	    this.domElement.removeEventListener('pointercancel', this._onPointerUp);
	    this.domElement.removeEventListener('wheel', this._onMouseWheel);
	    this.domElement.removeEventListener('contextmenu', this._onContextMenu);
	    this.stopListenToKeyEvents();
	    const document = this.domElement.getRootNode(); // offscreen canvas compatibility
	    document.removeEventListener('keydown', this._interceptControlDown, {
	      capture: true
	    });
	    this.domElement.style.touchAction = 'auto';
	  }
	  dispose() {
	    this.disconnect();
	  }

	  /**
	   * Get the current vertical rotation, in radians.
	   *
	   * @return {number} The current vertical rotation, in radians.
	   */
	  getPolarAngle() {
	    return this._spherical.phi;
	  }

	  /**
	   * Get the current horizontal rotation, in radians.
	   *
	   * @return {number} The current horizontal rotation, in radians.
	   */
	  getAzimuthalAngle() {
	    return this._spherical.theta;
	  }

	  /**
	   * Returns the distance from the camera to the target.
	   *
	   * @return {number} The distance from the camera to the target.
	   */
	  getDistance() {
	    return this.object.position.distanceTo(this.target);
	  }

	  /**
	   * Adds key event listeners to the given DOM element.
	   * `window` is a recommended argument for using this method.
	   *
	   * @param {HTMLElement} domElement - The DOM element
	   */
	  listenToKeyEvents(domElement) {
	    domElement.addEventListener('keydown', this._onKeyDown);
	    this._domElementKeyEvents = domElement;
	  }

	  /**
	   * Removes the key event listener previously defined with `listenToKeyEvents()`.
	   */
	  stopListenToKeyEvents() {
	    if (this._domElementKeyEvents !== null) {
	      this._domElementKeyEvents.removeEventListener('keydown', this._onKeyDown);
	      this._domElementKeyEvents = null;
	    }
	  }

	  /**
	   * Save the current state of the controls. This can later be recovered with `reset()`.
	   */
	  saveState() {
	    this.target0.copy(this.target);
	    this.position0.copy(this.object.position);
	    this.zoom0 = this.object.zoom;
	  }

	  /**
	   * Reset the controls to their state from either the last time the `saveState()`
	   * was called, or the initial state.
	   */
	  reset() {
	    this.target.copy(this.target0);
	    this.object.position.copy(this.position0);
	    this.object.zoom = this.zoom0;
	    this.object.updateProjectionMatrix();
	    this.dispatchEvent(_changeEvent);
	    this.update();
	    this.state = _STATE.NONE;
	  }
	  update(deltaTime = null) {
	    const position = this.object.position;
	    _v.copy(position).sub(this.target);

	    // rotate offset to "y-axis-is-up" space
	    _v.applyQuaternion(this._quat);

	    // angle from z-axis around y-axis
	    this._spherical.setFromVector3(_v);
	    if (this.autoRotate && this.state === _STATE.NONE) {
	      this._rotateLeft(this._getAutoRotationAngle(deltaTime));
	    }
	    if (this.enableDamping) {
	      this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
	      this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;
	    } else {
	      this._spherical.theta += this._sphericalDelta.theta;
	      this._spherical.phi += this._sphericalDelta.phi;
	    }

	    // restrict theta to be between desired limits

	    let min = this.minAzimuthAngle;
	    let max = this.maxAzimuthAngle;
	    if (isFinite(min) && isFinite(max)) {
	      if (min < -Math.PI) min += _twoPI;else if (min > Math.PI) min -= _twoPI;
	      if (max < -Math.PI) max += _twoPI;else if (max > Math.PI) max -= _twoPI;
	      if (min <= max) {
	        this._spherical.theta = Math.max(min, Math.min(max, this._spherical.theta));
	      } else {
	        this._spherical.theta = this._spherical.theta > (min + max) / 2 ? Math.max(min, this._spherical.theta) : Math.min(max, this._spherical.theta);
	      }
	    }

	    // restrict phi to be between desired limits
	    this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));
	    this._spherical.makeSafe();

	    // move target to panned location

	    if (this.enableDamping === true) {
	      this.target.addScaledVector(this._panOffset, this.dampingFactor);
	    } else {
	      this.target.add(this._panOffset);
	    }

	    // Limit the target distance from the cursor to create a sphere around the center of interest
	    this.target.sub(this.cursor);
	    this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);
	    this.target.add(this.cursor);
	    let zoomChanged = false;
	    // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
	    // we adjust zoom later in these cases
	    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) {
	      this._spherical.radius = this._clampDistance(this._spherical.radius);
	    } else {
	      const prevRadius = this._spherical.radius;
	      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale);
	      zoomChanged = prevRadius != this._spherical.radius;
	    }
	    _v.setFromSpherical(this._spherical);

	    // rotate offset back to "camera-up-vector-is-up" space
	    _v.applyQuaternion(this._quatInverse);
	    position.copy(this.target).add(_v);
	    this.object.lookAt(this.target);
	    if (this.enableDamping === true) {
	      this._sphericalDelta.theta *= 1 - this.dampingFactor;
	      this._sphericalDelta.phi *= 1 - this.dampingFactor;
	      this._panOffset.multiplyScalar(1 - this.dampingFactor);
	    } else {
	      this._sphericalDelta.set(0, 0, 0);
	      this._panOffset.set(0, 0, 0);
	    }

	    // adjust camera position
	    if (this.zoomToCursor && this._performCursorZoom) {
	      let newRadius = null;
	      if (this.object.isPerspectiveCamera) {
	        // move the camera down the pointer ray
	        // this method avoids floating point error
	        const prevRadius = _v.length();
	        newRadius = this._clampDistance(prevRadius * this._scale);
	        const radiusDelta = prevRadius - newRadius;
	        this.object.position.addScaledVector(this._dollyDirection, radiusDelta);
	        this.object.updateMatrixWorld();
	        zoomChanged = !!radiusDelta;
	      } else if (this.object.isOrthographicCamera) {
	        // adjust the ortho camera position based on zoom changes
	        const mouseBefore = new Vector3$1(this._mouse.x, this._mouse.y, 0);
	        mouseBefore.unproject(this.object);
	        const prevZoom = this.object.zoom;
	        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
	        this.object.updateProjectionMatrix();
	        zoomChanged = prevZoom !== this.object.zoom;
	        const mouseAfter = new Vector3$1(this._mouse.x, this._mouse.y, 0);
	        mouseAfter.unproject(this.object);
	        this.object.position.sub(mouseAfter).add(mouseBefore);
	        this.object.updateMatrixWorld();
	        newRadius = _v.length();
	      } else {
	        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.');
	        this.zoomToCursor = false;
	      }

	      // handle the placement of the target
	      if (newRadius !== null) {
	        if (this.screenSpacePanning) {
	          // position the orbit target in front of the new camera position
	          this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this.object.position);
	        } else {
	          // get the ray and translation plane to compute target
	          _ray.origin.copy(this.object.position);
	          _ray.direction.set(0, 0, -1).transformDirection(this.object.matrix);

	          // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
	          // extremely large values
	          if (Math.abs(this.object.up.dot(_ray.direction)) < _TILT_LIMIT) {
	            this.object.lookAt(this.target);
	          } else {
	            _plane.setFromNormalAndCoplanarPoint(this.object.up, this.target);
	            _ray.intersectPlane(_plane, this.target);
	          }
	        }
	      }
	    } else if (this.object.isOrthographicCamera) {
	      const prevZoom = this.object.zoom;
	      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
	      if (prevZoom !== this.object.zoom) {
	        this.object.updateProjectionMatrix();
	        zoomChanged = true;
	      }
	    }
	    this._scale = 1;
	    this._performCursorZoom = false;

	    // update condition is:
	    // min(camera displacement, camera rotation in radians)^2 > EPS
	    // using small-angle approximation cos(x/2) = 1 - x^2 / 8

	    if (zoomChanged || this._lastPosition.distanceToSquared(this.object.position) > _EPS || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS || this._lastTargetPosition.distanceToSquared(this.target) > _EPS) {
	      this.dispatchEvent(_changeEvent);
	      this._lastPosition.copy(this.object.position);
	      this._lastQuaternion.copy(this.object.quaternion);
	      this._lastTargetPosition.copy(this.target);
	      return true;
	    }
	    return false;
	  }
	  _getAutoRotationAngle(deltaTime) {
	    if (deltaTime !== null) {
	      return _twoPI / 60 * this.autoRotateSpeed * deltaTime;
	    } else {
	      return _twoPI / 60 / 60 * this.autoRotateSpeed;
	    }
	  }
	  _getZoomScale(delta) {
	    const normalizedDelta = Math.abs(delta * 0.01);
	    return Math.pow(0.95, this.zoomSpeed * normalizedDelta);
	  }
	  _rotateLeft(angle) {
	    this._sphericalDelta.theta -= angle;
	  }
	  _rotateUp(angle) {
	    this._sphericalDelta.phi -= angle;
	  }
	  _panLeft(distance, objectMatrix) {
	    _v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
	    _v.multiplyScalar(-distance);
	    this._panOffset.add(_v);
	  }
	  _panUp(distance, objectMatrix) {
	    if (this.screenSpacePanning === true) {
	      _v.setFromMatrixColumn(objectMatrix, 1);
	    } else {
	      _v.setFromMatrixColumn(objectMatrix, 0);
	      _v.crossVectors(this.object.up, _v);
	    }
	    _v.multiplyScalar(distance);
	    this._panOffset.add(_v);
	  }

	  // deltaX and deltaY are in pixels; right and down are positive
	  _pan(deltaX, deltaY) {
	    const element = this.domElement;
	    if (this.object.isPerspectiveCamera) {
	      // perspective
	      const position = this.object.position;
	      _v.copy(position).sub(this.target);
	      let targetDistance = _v.length();

	      // half of the fov is center to top of screen
	      targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180.0);

	      // we use only clientHeight here so aspect ratio does not distort speed
	      this._panLeft(2 * deltaX * targetDistance / element.clientHeight, this.object.matrix);
	      this._panUp(2 * deltaY * targetDistance / element.clientHeight, this.object.matrix);
	    } else if (this.object.isOrthographicCamera) {
	      // orthographic
	      this._panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element.clientWidth, this.object.matrix);
	      this._panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element.clientHeight, this.object.matrix);
	    } else {
	      // camera neither orthographic nor perspective
	      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
	      this.enablePan = false;
	    }
	  }
	  _dollyOut(dollyScale) {
	    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
	      this._scale /= dollyScale;
	    } else {
	      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
	      this.enableZoom = false;
	    }
	  }
	  _dollyIn(dollyScale) {
	    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
	      this._scale *= dollyScale;
	    } else {
	      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
	      this.enableZoom = false;
	    }
	  }
	  _updateZoomParameters(x, y) {
	    if (!this.zoomToCursor) {
	      return;
	    }
	    this._performCursorZoom = true;
	    const rect = this.domElement.getBoundingClientRect();
	    const dx = x - rect.left;
	    const dy = y - rect.top;
	    const w = rect.width;
	    const h = rect.height;
	    this._mouse.x = dx / w * 2 - 1;
	    this._mouse.y = -(dy / h) * 2 + 1;
	    this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
	  }
	  _clampDistance(dist) {
	    return Math.max(this.minDistance, Math.min(this.maxDistance, dist));
	  }

	  //
	  // event callbacks - update the object state
	  //

	  _handleMouseDownRotate(event) {
	    this._rotateStart.set(event.clientX, event.clientY);
	  }
	  _handleMouseDownDolly(event) {
	    this._updateZoomParameters(event.clientX, event.clientX);
	    this._dollyStart.set(event.clientX, event.clientY);
	  }
	  _handleMouseDownPan(event) {
	    this._panStart.set(event.clientX, event.clientY);
	  }
	  _handleMouseMoveRotate(event) {
	    this._rotateEnd.set(event.clientX, event.clientY);
	    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
	    const element = this.domElement;
	    this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight); // yes, height

	    this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);
	    this._rotateStart.copy(this._rotateEnd);
	    this.update();
	  }
	  _handleMouseMoveDolly(event) {
	    this._dollyEnd.set(event.clientX, event.clientY);
	    this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);
	    if (this._dollyDelta.y > 0) {
	      this._dollyOut(this._getZoomScale(this._dollyDelta.y));
	    } else if (this._dollyDelta.y < 0) {
	      this._dollyIn(this._getZoomScale(this._dollyDelta.y));
	    }
	    this._dollyStart.copy(this._dollyEnd);
	    this.update();
	  }
	  _handleMouseMovePan(event) {
	    this._panEnd.set(event.clientX, event.clientY);
	    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
	    this._pan(this._panDelta.x, this._panDelta.y);
	    this._panStart.copy(this._panEnd);
	    this.update();
	  }
	  _handleMouseWheel(event) {
	    this._updateZoomParameters(event.clientX, event.clientY);
	    if (event.deltaY < 0) {
	      this._dollyIn(this._getZoomScale(event.deltaY));
	    } else if (event.deltaY > 0) {
	      this._dollyOut(this._getZoomScale(event.deltaY));
	    }
	    this.update();
	  }
	  _handleKeyDown(event) {
	    let needsUpdate = false;
	    switch (event.code) {
	      case this.keys.UP:
	        if (event.ctrlKey || event.metaKey || event.shiftKey) {
	          if (this.enableRotate) {
	            this._rotateUp(_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
	          }
	        } else {
	          if (this.enablePan) {
	            this._pan(0, this.keyPanSpeed);
	          }
	        }
	        needsUpdate = true;
	        break;
	      case this.keys.BOTTOM:
	        if (event.ctrlKey || event.metaKey || event.shiftKey) {
	          if (this.enableRotate) {
	            this._rotateUp(-_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
	          }
	        } else {
	          if (this.enablePan) {
	            this._pan(0, -this.keyPanSpeed);
	          }
	        }
	        needsUpdate = true;
	        break;
	      case this.keys.LEFT:
	        if (event.ctrlKey || event.metaKey || event.shiftKey) {
	          if (this.enableRotate) {
	            this._rotateLeft(_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
	          }
	        } else {
	          if (this.enablePan) {
	            this._pan(this.keyPanSpeed, 0);
	          }
	        }
	        needsUpdate = true;
	        break;
	      case this.keys.RIGHT:
	        if (event.ctrlKey || event.metaKey || event.shiftKey) {
	          if (this.enableRotate) {
	            this._rotateLeft(-_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
	          }
	        } else {
	          if (this.enablePan) {
	            this._pan(-this.keyPanSpeed, 0);
	          }
	        }
	        needsUpdate = true;
	        break;
	    }
	    if (needsUpdate) {
	      // prevent the browser from scrolling on cursor keys
	      event.preventDefault();
	      this.update();
	    }
	  }
	  _handleTouchStartRotate(event) {
	    if (this._pointers.length === 1) {
	      this._rotateStart.set(event.pageX, event.pageY);
	    } else {
	      const position = this._getSecondPointerPosition(event);
	      const x = 0.5 * (event.pageX + position.x);
	      const y = 0.5 * (event.pageY + position.y);
	      this._rotateStart.set(x, y);
	    }
	  }
	  _handleTouchStartPan(event) {
	    if (this._pointers.length === 1) {
	      this._panStart.set(event.pageX, event.pageY);
	    } else {
	      const position = this._getSecondPointerPosition(event);
	      const x = 0.5 * (event.pageX + position.x);
	      const y = 0.5 * (event.pageY + position.y);
	      this._panStart.set(x, y);
	    }
	  }
	  _handleTouchStartDolly(event) {
	    const position = this._getSecondPointerPosition(event);
	    const dx = event.pageX - position.x;
	    const dy = event.pageY - position.y;
	    const distance = Math.sqrt(dx * dx + dy * dy);
	    this._dollyStart.set(0, distance);
	  }
	  _handleTouchStartDollyPan(event) {
	    if (this.enableZoom) this._handleTouchStartDolly(event);
	    if (this.enablePan) this._handleTouchStartPan(event);
	  }
	  _handleTouchStartDollyRotate(event) {
	    if (this.enableZoom) this._handleTouchStartDolly(event);
	    if (this.enableRotate) this._handleTouchStartRotate(event);
	  }
	  _handleTouchMoveRotate(event) {
	    if (this._pointers.length == 1) {
	      this._rotateEnd.set(event.pageX, event.pageY);
	    } else {
	      const position = this._getSecondPointerPosition(event);
	      const x = 0.5 * (event.pageX + position.x);
	      const y = 0.5 * (event.pageY + position.y);
	      this._rotateEnd.set(x, y);
	    }
	    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
	    const element = this.domElement;
	    this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight); // yes, height

	    this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);
	    this._rotateStart.copy(this._rotateEnd);
	  }
	  _handleTouchMovePan(event) {
	    if (this._pointers.length === 1) {
	      this._panEnd.set(event.pageX, event.pageY);
	    } else {
	      const position = this._getSecondPointerPosition(event);
	      const x = 0.5 * (event.pageX + position.x);
	      const y = 0.5 * (event.pageY + position.y);
	      this._panEnd.set(x, y);
	    }
	    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
	    this._pan(this._panDelta.x, this._panDelta.y);
	    this._panStart.copy(this._panEnd);
	  }
	  _handleTouchMoveDolly(event) {
	    const position = this._getSecondPointerPosition(event);
	    const dx = event.pageX - position.x;
	    const dy = event.pageY - position.y;
	    const distance = Math.sqrt(dx * dx + dy * dy);
	    this._dollyEnd.set(0, distance);
	    this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed));
	    this._dollyOut(this._dollyDelta.y);
	    this._dollyStart.copy(this._dollyEnd);
	    const centerX = (event.pageX + position.x) * 0.5;
	    const centerY = (event.pageY + position.y) * 0.5;
	    this._updateZoomParameters(centerX, centerY);
	  }
	  _handleTouchMoveDollyPan(event) {
	    if (this.enableZoom) this._handleTouchMoveDolly(event);
	    if (this.enablePan) this._handleTouchMovePan(event);
	  }
	  _handleTouchMoveDollyRotate(event) {
	    if (this.enableZoom) this._handleTouchMoveDolly(event);
	    if (this.enableRotate) this._handleTouchMoveRotate(event);
	  }

	  // pointers

	  _addPointer(event) {
	    this._pointers.push(event.pointerId);
	  }
	  _removePointer(event) {
	    delete this._pointerPositions[event.pointerId];
	    for (let i = 0; i < this._pointers.length; i++) {
	      if (this._pointers[i] == event.pointerId) {
	        this._pointers.splice(i, 1);
	        return;
	      }
	    }
	  }
	  _isTrackingPointer(event) {
	    for (let i = 0; i < this._pointers.length; i++) {
	      if (this._pointers[i] == event.pointerId) return true;
	    }
	    return false;
	  }
	  _trackPointer(event) {
	    let position = this._pointerPositions[event.pointerId];
	    if (position === undefined) {
	      position = new Vector2$1();
	      this._pointerPositions[event.pointerId] = position;
	    }
	    position.set(event.pageX, event.pageY);
	  }
	  _getSecondPointerPosition(event) {
	    const pointerId = event.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
	    return this._pointerPositions[pointerId];
	  }

	  //

	  _customWheelEvent(event) {
	    const mode = event.deltaMode;

	    // minimal wheel event altered to meet delta-zoom demand
	    const newEvent = {
	      clientX: event.clientX,
	      clientY: event.clientY,
	      deltaY: event.deltaY
	    };
	    switch (mode) {
	      case 1:
	        // LINE_MODE
	        newEvent.deltaY *= 16;
	        break;
	      case 2:
	        // PAGE_MODE
	        newEvent.deltaY *= 100;
	        break;
	    }

	    // detect if event was triggered by pinching
	    if (event.ctrlKey && !this._controlActive) {
	      newEvent.deltaY *= 10;
	    }
	    return newEvent;
	  }
	}
	function onPointerDown(event) {
	  if (this.enabled === false) return;
	  if (this._pointers.length === 0) {
	    this.domElement.setPointerCapture(event.pointerId);
	    this.domElement.addEventListener('pointermove', this._onPointerMove);
	    this.domElement.addEventListener('pointerup', this._onPointerUp);
	  }

	  //

	  if (this._isTrackingPointer(event)) return;

	  //

	  this._addPointer(event);
	  if (event.pointerType === 'touch') {
	    this._onTouchStart(event);
	  } else {
	    this._onMouseDown(event);
	  }
	}
	function onPointerMove(event) {
	  if (this.enabled === false) return;
	  if (event.pointerType === 'touch') {
	    this._onTouchMove(event);
	  } else {
	    this._onMouseMove(event);
	  }
	}
	function onPointerUp(event) {
	  this._removePointer(event);
	  switch (this._pointers.length) {
	    case 0:
	      this.domElement.releasePointerCapture(event.pointerId);
	      this.domElement.removeEventListener('pointermove', this._onPointerMove);
	      this.domElement.removeEventListener('pointerup', this._onPointerUp);
	      this.dispatchEvent(_endEvent);
	      this.state = _STATE.NONE;
	      break;
	    case 1:
	      const pointerId = this._pointers[0];
	      const position = this._pointerPositions[pointerId];

	      // minimal placeholder event - allows state correction on pointer-up
	      this._onTouchStart({
	        pointerId: pointerId,
	        pageX: position.x,
	        pageY: position.y
	      });
	      break;
	  }
	}
	function onMouseDown(event) {
	  let mouseAction;
	  switch (event.button) {
	    case 0:
	      mouseAction = this.mouseButtons.LEFT;
	      break;
	    case 1:
	      mouseAction = this.mouseButtons.MIDDLE;
	      break;
	    case 2:
	      mouseAction = this.mouseButtons.RIGHT;
	      break;
	    default:
	      mouseAction = -1;
	  }
	  switch (mouseAction) {
	    case MOUSE.DOLLY:
	      if (this.enableZoom === false) return;
	      this._handleMouseDownDolly(event);
	      this.state = _STATE.DOLLY;
	      break;
	    case MOUSE.ROTATE:
	      if (event.ctrlKey || event.metaKey || event.shiftKey) {
	        if (this.enablePan === false) return;
	        this._handleMouseDownPan(event);
	        this.state = _STATE.PAN;
	      } else {
	        if (this.enableRotate === false) return;
	        this._handleMouseDownRotate(event);
	        this.state = _STATE.ROTATE;
	      }
	      break;
	    case MOUSE.PAN:
	      if (event.ctrlKey || event.metaKey || event.shiftKey) {
	        if (this.enableRotate === false) return;
	        this._handleMouseDownRotate(event);
	        this.state = _STATE.ROTATE;
	      } else {
	        if (this.enablePan === false) return;
	        this._handleMouseDownPan(event);
	        this.state = _STATE.PAN;
	      }
	      break;
	    default:
	      this.state = _STATE.NONE;
	  }
	  if (this.state !== _STATE.NONE) {
	    this.dispatchEvent(_startEvent);
	  }
	}
	function onMouseMove(event) {
	  switch (this.state) {
	    case _STATE.ROTATE:
	      if (this.enableRotate === false) return;
	      this._handleMouseMoveRotate(event);
	      break;
	    case _STATE.DOLLY:
	      if (this.enableZoom === false) return;
	      this._handleMouseMoveDolly(event);
	      break;
	    case _STATE.PAN:
	      if (this.enablePan === false) return;
	      this._handleMouseMovePan(event);
	      break;
	  }
	}
	function onMouseWheel(event) {
	  if (this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE) return;
	  event.preventDefault();
	  this.dispatchEvent(_startEvent);
	  this._handleMouseWheel(this._customWheelEvent(event));
	  this.dispatchEvent(_endEvent);
	}
	function onKeyDown(event) {
	  if (this.enabled === false) return;
	  this._handleKeyDown(event);
	}
	function onTouchStart(event) {
	  this._trackPointer(event);
	  switch (this._pointers.length) {
	    case 1:
	      switch (this.touches.ONE) {
	        case TOUCH.ROTATE:
	          if (this.enableRotate === false) return;
	          this._handleTouchStartRotate(event);
	          this.state = _STATE.TOUCH_ROTATE;
	          break;
	        case TOUCH.PAN:
	          if (this.enablePan === false) return;
	          this._handleTouchStartPan(event);
	          this.state = _STATE.TOUCH_PAN;
	          break;
	        default:
	          this.state = _STATE.NONE;
	      }
	      break;
	    case 2:
	      switch (this.touches.TWO) {
	        case TOUCH.DOLLY_PAN:
	          if (this.enableZoom === false && this.enablePan === false) return;
	          this._handleTouchStartDollyPan(event);
	          this.state = _STATE.TOUCH_DOLLY_PAN;
	          break;
	        case TOUCH.DOLLY_ROTATE:
	          if (this.enableZoom === false && this.enableRotate === false) return;
	          this._handleTouchStartDollyRotate(event);
	          this.state = _STATE.TOUCH_DOLLY_ROTATE;
	          break;
	        default:
	          this.state = _STATE.NONE;
	      }
	      break;
	    default:
	      this.state = _STATE.NONE;
	  }
	  if (this.state !== _STATE.NONE) {
	    this.dispatchEvent(_startEvent);
	  }
	}
	function onTouchMove(event) {
	  this._trackPointer(event);
	  switch (this.state) {
	    case _STATE.TOUCH_ROTATE:
	      if (this.enableRotate === false) return;
	      this._handleTouchMoveRotate(event);
	      this.update();
	      break;
	    case _STATE.TOUCH_PAN:
	      if (this.enablePan === false) return;
	      this._handleTouchMovePan(event);
	      this.update();
	      break;
	    case _STATE.TOUCH_DOLLY_PAN:
	      if (this.enableZoom === false && this.enablePan === false) return;
	      this._handleTouchMoveDollyPan(event);
	      this.update();
	      break;
	    case _STATE.TOUCH_DOLLY_ROTATE:
	      if (this.enableZoom === false && this.enableRotate === false) return;
	      this._handleTouchMoveDollyRotate(event);
	      this.update();
	      break;
	    default:
	      this.state = _STATE.NONE;
	  }
	}
	function onContextMenu(event) {
	  if (this.enabled === false) return;
	  event.preventDefault();
	}
	function interceptControlDown(event) {
	  if (event.key === 'Control') {
	    this._controlActive = true;
	    const document = this.domElement.getRootNode(); // offscreen canvas compatibility

	    document.addEventListener('keyup', this._interceptControlUp, {
	      passive: true,
	      capture: true
	    });
	  }
	}
	function interceptControlUp(event) {
	  if (event.key === 'Control') {
	    this._controlActive = false;
	    const document = this.domElement.getRootNode(); // offscreen canvas compatibility

	    document.removeEventListener('keyup', this._interceptControlUp, {
	      passive: true,
	      capture: true
	    });
	  }
	}

	function arrayNeedsUint32(array) {
	  // assumes larger values usually on last

	  for (let i = array.length - 1; i >= 0; --i) {
	    if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
	  }
	  return false;
	}
	function warn(...params) {
	  const message = 'THREE.' + params.shift();
	  {
	    console.warn(message, ...params);
	  }
	}
	function error(...params) {
	  const message = 'THREE.' + params.shift();
	  {
	    console.error(message, ...params);
	  }
	}

	const _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];

	/**
	 * Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
	 * (universally unique identifier).
	 *
	 * @return {string} The UUID.
	 */
	function generateUUID() {
	  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

	  const d0 = Math.random() * 0xffffffff | 0;
	  const d1 = Math.random() * 0xffffffff | 0;
	  const d2 = Math.random() * 0xffffffff | 0;
	  const d3 = Math.random() * 0xffffffff | 0;
	  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];

	  // .toLowerCase() here flattens concatenated strings to save heap memory space.
	  return uuid.toLowerCase();
	}

	/**
	 * Clamps the given value between min and max.
	 *
	 * @param {number} value - The value to clamp.
	 * @param {number} min - The min value.
	 * @param {number} max - The max value.
	 * @return {number} The clamped value.
	 */
	function clamp(value, min, max) {
	  return Math.max(min, Math.min(max, value));
	}

	/**
	 * Denormalizes the given value according to the given typed array.
	 *
	 * @param {number} value - The value to denormalize.
	 * @param {TypedArray} array - The typed array that defines the data type of the value.
	 * @return {number} The denormalize (float) value in the range `[0,1]`.
	 */
	function denormalize(value, array) {
	  switch (array.constructor) {
	    case Float32Array:
	      return value;
	    case Uint32Array:
	      return value / 4294967295.0;
	    case Uint16Array:
	      return value / 65535.0;
	    case Uint8Array:
	      return value / 255.0;
	    case Int32Array:
	      return Math.max(value / 2147483647.0, -1);
	    case Int16Array:
	      return Math.max(value / 32767.0, -1);
	    case Int8Array:
	      return Math.max(value / 127.0, -1);
	    default:
	      throw new Error('Invalid component type.');
	  }
	}

	/**
	 * Normalizes the given value according to the given typed array.
	 *
	 * @param {number} value - The float value in the range `[0,1]` to normalize.
	 * @param {TypedArray} array - The typed array that defines the data type of the value.
	 * @return {number} The normalize value.
	 */
	function normalize(value, array) {
	  switch (array.constructor) {
	    case Float32Array:
	      return value;
	    case Uint32Array:
	      return Math.round(value * 4294967295.0);
	    case Uint16Array:
	      return Math.round(value * 65535.0);
	    case Uint8Array:
	      return Math.round(value * 255.0);
	    case Int32Array:
	      return Math.round(value * 2147483647.0);
	    case Int16Array:
	      return Math.round(value * 32767.0);
	    case Int8Array:
	      return Math.round(value * 127.0);
	    default:
	      throw new Error('Invalid component type.');
	  }
	}

	/**
	 * Class for representing a Quaternion. Quaternions are used in three.js to represent rotations.
	 *
	 * Iterating through a vector instance will yield its components `(x, y, z, w)` in
	 * the corresponding order.
	 *
	 * Note that three.js expects Quaternions to be normalized.
	 * ```js
	 * const quaternion = new THREE.Quaternion();
	 * quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
	 *
	 * const vector = new THREE.Vector3( 1, 0, 0 );
	 * vector.applyQuaternion( quaternion );
	 * ```
	 */
	class Quaternion {
	  /**
	   * Constructs a new quaternion.
	   *
	   * @param {number} [x=0] - The x value of this quaternion.
	   * @param {number} [y=0] - The y value of this quaternion.
	   * @param {number} [z=0] - The z value of this quaternion.
	   * @param {number} [w=1] - The w value of this quaternion.
	   */
	  constructor(x = 0, y = 0, z = 0, w = 1) {
	    /**
	     * This flag can be used for type testing.
	     *
	     * @type {boolean}
	     * @readonly
	     * @default true
	     */
	    this.isQuaternion = true;
	    this._x = x;
	    this._y = y;
	    this._z = z;
	    this._w = w;
	  }

	  /**
	   * Interpolates between two quaternions via SLERP. This implementation assumes the
	   * quaternion data are managed in flat arrays.
	   *
	   * @param {Array<number>} dst - The destination array.
	   * @param {number} dstOffset - An offset into the destination array.
	   * @param {Array<number>} src0 - The source array of the first quaternion.
	   * @param {number} srcOffset0 - An offset into the first source array.
	   * @param {Array<number>} src1 -  The source array of the second quaternion.
	   * @param {number} srcOffset1 - An offset into the second source array.
	   * @param {number} t - The interpolation factor in the range `[0,1]`.
	   * @see {@link Quaternion#slerp}
	   */
	  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
	    let x0 = src0[srcOffset0 + 0],
	      y0 = src0[srcOffset0 + 1],
	      z0 = src0[srcOffset0 + 2],
	      w0 = src0[srcOffset0 + 3];
	    let x1 = src1[srcOffset1 + 0],
	      y1 = src1[srcOffset1 + 1],
	      z1 = src1[srcOffset1 + 2],
	      w1 = src1[srcOffset1 + 3];
	    if (t <= 0) {
	      dst[dstOffset + 0] = x0;
	      dst[dstOffset + 1] = y0;
	      dst[dstOffset + 2] = z0;
	      dst[dstOffset + 3] = w0;
	      return;
	    }
	    if (t >= 1) {
	      dst[dstOffset + 0] = x1;
	      dst[dstOffset + 1] = y1;
	      dst[dstOffset + 2] = z1;
	      dst[dstOffset + 3] = w1;
	      return;
	    }
	    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
	      let dot = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;
	      if (dot < 0) {
	        x1 = -x1;
	        y1 = -y1;
	        z1 = -z1;
	        w1 = -w1;
	        dot = -dot;
	      }
	      let s = 1 - t;
	      if (dot < 0.9995) {
	        // slerp

	        const theta = Math.acos(dot);
	        const sin = Math.sin(theta);
	        s = Math.sin(s * theta) / sin;
	        t = Math.sin(t * theta) / sin;
	        x0 = x0 * s + x1 * t;
	        y0 = y0 * s + y1 * t;
	        z0 = z0 * s + z1 * t;
	        w0 = w0 * s + w1 * t;
	      } else {
	        // for small angles, lerp then normalize

	        x0 = x0 * s + x1 * t;
	        y0 = y0 * s + y1 * t;
	        z0 = z0 * s + z1 * t;
	        w0 = w0 * s + w1 * t;
	        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
	        x0 *= f;
	        y0 *= f;
	        z0 *= f;
	        w0 *= f;
	      }
	    }
	    dst[dstOffset] = x0;
	    dst[dstOffset + 1] = y0;
	    dst[dstOffset + 2] = z0;
	    dst[dstOffset + 3] = w0;
	  }

	  /**
	   * Multiplies two quaternions. This implementation assumes the quaternion data are managed
	   * in flat arrays.
	   *
	   * @param {Array<number>} dst - The destination array.
	   * @param {number} dstOffset - An offset into the destination array.
	   * @param {Array<number>} src0 - The source array of the first quaternion.
	   * @param {number} srcOffset0 - An offset into the first source array.
	   * @param {Array<number>} src1 -  The source array of the second quaternion.
	   * @param {number} srcOffset1 - An offset into the second source array.
	   * @return {Array<number>} The destination array.
	   * @see {@link Quaternion#multiplyQuaternions}.
	   */
	  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
	    const x0 = src0[srcOffset0];
	    const y0 = src0[srcOffset0 + 1];
	    const z0 = src0[srcOffset0 + 2];
	    const w0 = src0[srcOffset0 + 3];
	    const x1 = src1[srcOffset1];
	    const y1 = src1[srcOffset1 + 1];
	    const z1 = src1[srcOffset1 + 2];
	    const w1 = src1[srcOffset1 + 3];
	    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
	    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
	    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
	    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
	    return dst;
	  }

	  /**
	   * The x value of this quaternion.
	   *
	   * @type {number}
	   * @default 0
	   */
	  get x() {
	    return this._x;
	  }
	  set x(value) {
	    this._x = value;
	    this._onChangeCallback();
	  }

	  /**
	   * The y value of this quaternion.
	   *
	   * @type {number}
	   * @default 0
	   */
	  get y() {
	    return this._y;
	  }
	  set y(value) {
	    this._y = value;
	    this._onChangeCallback();
	  }

	  /**
	   * The z value of this quaternion.
	   *
	   * @type {number}
	   * @default 0
	   */
	  get z() {
	    return this._z;
	  }
	  set z(value) {
	    this._z = value;
	    this._onChangeCallback();
	  }

	  /**
	   * The w value of this quaternion.
	   *
	   * @type {number}
	   * @default 1
	   */
	  get w() {
	    return this._w;
	  }
	  set w(value) {
	    this._w = value;
	    this._onChangeCallback();
	  }

	  /**
	   * Sets the quaternion components.
	   *
	   * @param {number} x - The x value of this quaternion.
	   * @param {number} y - The y value of this quaternion.
	   * @param {number} z - The z value of this quaternion.
	   * @param {number} w - The w value of this quaternion.
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  set(x, y, z, w) {
	    this._x = x;
	    this._y = y;
	    this._z = z;
	    this._w = w;
	    this._onChangeCallback();
	    return this;
	  }

	  /**
	   * Returns a new quaternion with copied values from this instance.
	   *
	   * @return {Quaternion} A clone of this instance.
	   */
	  clone() {
	    return new this.constructor(this._x, this._y, this._z, this._w);
	  }

	  /**
	   * Copies the values of the given quaternion to this instance.
	   *
	   * @param {Quaternion} quaternion - The quaternion to copy.
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  copy(quaternion) {
	    this._x = quaternion.x;
	    this._y = quaternion.y;
	    this._z = quaternion.z;
	    this._w = quaternion.w;
	    this._onChangeCallback();
	    return this;
	  }

	  /**
	   * Sets this quaternion from the rotation specified by the given
	   * Euler angles.
	   *
	   * @param {Euler} euler - The Euler angles.
	   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  setFromEuler(euler, update = true) {
	    const x = euler._x,
	      y = euler._y,
	      z = euler._z,
	      order = euler._order;

	    // http://www.mathworks.com/matlabcentral/fileexchange/
	    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
	    //	content/SpinCalc.m

	    const cos = Math.cos;
	    const sin = Math.sin;
	    const c1 = cos(x / 2);
	    const c2 = cos(y / 2);
	    const c3 = cos(z / 2);
	    const s1 = sin(x / 2);
	    const s2 = sin(y / 2);
	    const s3 = sin(z / 2);
	    switch (order) {
	      case 'XYZ':
	        this._x = s1 * c2 * c3 + c1 * s2 * s3;
	        this._y = c1 * s2 * c3 - s1 * c2 * s3;
	        this._z = c1 * c2 * s3 + s1 * s2 * c3;
	        this._w = c1 * c2 * c3 - s1 * s2 * s3;
	        break;
	      case 'YXZ':
	        this._x = s1 * c2 * c3 + c1 * s2 * s3;
	        this._y = c1 * s2 * c3 - s1 * c2 * s3;
	        this._z = c1 * c2 * s3 - s1 * s2 * c3;
	        this._w = c1 * c2 * c3 + s1 * s2 * s3;
	        break;
	      case 'ZXY':
	        this._x = s1 * c2 * c3 - c1 * s2 * s3;
	        this._y = c1 * s2 * c3 + s1 * c2 * s3;
	        this._z = c1 * c2 * s3 + s1 * s2 * c3;
	        this._w = c1 * c2 * c3 - s1 * s2 * s3;
	        break;
	      case 'ZYX':
	        this._x = s1 * c2 * c3 - c1 * s2 * s3;
	        this._y = c1 * s2 * c3 + s1 * c2 * s3;
	        this._z = c1 * c2 * s3 - s1 * s2 * c3;
	        this._w = c1 * c2 * c3 + s1 * s2 * s3;
	        break;
	      case 'YZX':
	        this._x = s1 * c2 * c3 + c1 * s2 * s3;
	        this._y = c1 * s2 * c3 + s1 * c2 * s3;
	        this._z = c1 * c2 * s3 - s1 * s2 * c3;
	        this._w = c1 * c2 * c3 - s1 * s2 * s3;
	        break;
	      case 'XZY':
	        this._x = s1 * c2 * c3 - c1 * s2 * s3;
	        this._y = c1 * s2 * c3 - s1 * c2 * s3;
	        this._z = c1 * c2 * s3 + s1 * s2 * c3;
	        this._w = c1 * c2 * c3 + s1 * s2 * s3;
	        break;
	      default:
	        warn('Quaternion: .setFromEuler() encountered an unknown order: ' + order);
	    }
	    if (update === true) this._onChangeCallback();
	    return this;
	  }

	  /**
	   * Sets this quaternion from the given axis and angle.
	   *
	   * @param {Vector3} axis - The normalized axis.
	   * @param {number} angle - The angle in radians.
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  setFromAxisAngle(axis, angle) {
	    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

	    const halfAngle = angle / 2,
	      s = Math.sin(halfAngle);
	    this._x = axis.x * s;
	    this._y = axis.y * s;
	    this._z = axis.z * s;
	    this._w = Math.cos(halfAngle);
	    this._onChangeCallback();
	    return this;
	  }

	  /**
	   * Sets this quaternion from the given rotation matrix.
	   *
	   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  setFromRotationMatrix(m) {
	    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

	    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

	    const te = m.elements,
	      m11 = te[0],
	      m12 = te[4],
	      m13 = te[8],
	      m21 = te[1],
	      m22 = te[5],
	      m23 = te[9],
	      m31 = te[2],
	      m32 = te[6],
	      m33 = te[10],
	      trace = m11 + m22 + m33;
	    if (trace > 0) {
	      const s = 0.5 / Math.sqrt(trace + 1.0);
	      this._w = 0.25 / s;
	      this._x = (m32 - m23) * s;
	      this._y = (m13 - m31) * s;
	      this._z = (m21 - m12) * s;
	    } else if (m11 > m22 && m11 > m33) {
	      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
	      this._w = (m32 - m23) / s;
	      this._x = 0.25 * s;
	      this._y = (m12 + m21) / s;
	      this._z = (m13 + m31) / s;
	    } else if (m22 > m33) {
	      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
	      this._w = (m13 - m31) / s;
	      this._x = (m12 + m21) / s;
	      this._y = 0.25 * s;
	      this._z = (m23 + m32) / s;
	    } else {
	      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
	      this._w = (m21 - m12) / s;
	      this._x = (m13 + m31) / s;
	      this._y = (m23 + m32) / s;
	      this._z = 0.25 * s;
	    }
	    this._onChangeCallback();
	    return this;
	  }

	  /**
	   * Sets this quaternion to the rotation required to rotate the direction vector
	   * `vFrom` to the direction vector `vTo`.
	   *
	   * @param {Vector3} vFrom - The first (normalized) direction vector.
	   * @param {Vector3} vTo - The second (normalized) direction vector.
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  setFromUnitVectors(vFrom, vTo) {
	    // assumes direction vectors vFrom and vTo are normalized

	    let r = vFrom.dot(vTo) + 1;
	    if (r < 1e-8) {
	      // the epsilon value has been discussed in #31286

	      // vFrom and vTo point in opposite directions

	      r = 0;
	      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
	        this._x = -vFrom.y;
	        this._y = vFrom.x;
	        this._z = 0;
	        this._w = r;
	      } else {
	        this._x = 0;
	        this._y = -vFrom.z;
	        this._z = vFrom.y;
	        this._w = r;
	      }
	    } else {
	      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

	      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
	      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
	      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
	      this._w = r;
	    }
	    return this.normalize();
	  }

	  /**
	   * Returns the angle between this quaternion and the given one in radians.
	   *
	   * @param {Quaternion} q - The quaternion to compute the angle with.
	   * @return {number} The angle in radians.
	   */
	  angleTo(q) {
	    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
	  }

	  /**
	   * Rotates this quaternion by a given angular step to the given quaternion.
	   * The method ensures that the final quaternion will not overshoot `q`.
	   *
	   * @param {Quaternion} q - The target quaternion.
	   * @param {number} step - The angular step in radians.
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  rotateTowards(q, step) {
	    const angle = this.angleTo(q);
	    if (angle === 0) return this;
	    const t = Math.min(1, step / angle);
	    this.slerp(q, t);
	    return this;
	  }

	  /**
	   * Sets this quaternion to the identity quaternion; that is, to the
	   * quaternion that represents "no rotation".
	   *
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  identity() {
	    return this.set(0, 0, 0, 1);
	  }

	  /**
	   * Inverts this quaternion via {@link Quaternion#conjugate}. The
	   * quaternion is assumed to have unit length.
	   *
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  invert() {
	    return this.conjugate();
	  }

	  /**
	   * Returns the rotational conjugate of this quaternion. The conjugate of a
	   * quaternion represents the same rotation in the opposite direction about
	   * the rotational axis.
	   *
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  conjugate() {
	    this._x *= -1;
	    this._y *= -1;
	    this._z *= -1;
	    this._onChangeCallback();
	    return this;
	  }

	  /**
	   * Calculates the dot product of this quaternion and the given one.
	   *
	   * @param {Quaternion} v - The quaternion to compute the dot product with.
	   * @return {number} The result of the dot product.
	   */
	  dot(v) {
	    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	  }

	  /**
	   * Computes the squared Euclidean length (straight-line length) of this quaternion,
	   * considered as a 4 dimensional vector. This can be useful if you are comparing the
	   * lengths of two quaternions, as this is a slightly more efficient calculation than
	   * {@link Quaternion#length}.
	   *
	   * @return {number} The squared Euclidean length.
	   */
	  lengthSq() {
	    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	  }

	  /**
	   * Computes the Euclidean length (straight-line length) of this quaternion,
	   * considered as a 4 dimensional vector.
	   *
	   * @return {number} The Euclidean length.
	   */
	  length() {
	    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
	  }

	  /**
	   * Normalizes this quaternion - that is, calculated the quaternion that performs
	   * the same rotation as this one, but has a length equal to `1`.
	   *
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  normalize() {
	    let l = this.length();
	    if (l === 0) {
	      this._x = 0;
	      this._y = 0;
	      this._z = 0;
	      this._w = 1;
	    } else {
	      l = 1 / l;
	      this._x = this._x * l;
	      this._y = this._y * l;
	      this._z = this._z * l;
	      this._w = this._w * l;
	    }
	    this._onChangeCallback();
	    return this;
	  }

	  /**
	   * Multiplies this quaternion by the given one.
	   *
	   * @param {Quaternion} q - The quaternion.
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  multiply(q) {
	    return this.multiplyQuaternions(this, q);
	  }

	  /**
	   * Pre-multiplies this quaternion by the given one.
	   *
	   * @param {Quaternion} q - The quaternion.
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  premultiply(q) {
	    return this.multiplyQuaternions(q, this);
	  }

	  /**
	   * Multiplies the given quaternions and stores the result in this instance.
	   *
	   * @param {Quaternion} a - The first quaternion.
	   * @param {Quaternion} b - The second quaternion.
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  multiplyQuaternions(a, b) {
	    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

	    const qax = a._x,
	      qay = a._y,
	      qaz = a._z,
	      qaw = a._w;
	    const qbx = b._x,
	      qby = b._y,
	      qbz = b._z,
	      qbw = b._w;
	    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
	    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
	    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
	    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	    this._onChangeCallback();
	    return this;
	  }

	  /**
	   * Performs a spherical linear interpolation between quaternions.
	   *
	   * @param {Quaternion} qb - The target quaternion.
	   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  slerp(qb, t) {
	    if (t <= 0) return this;
	    if (t >= 1) return this.copy(qb); // copy calls _onChangeCallback()

	    let x = qb._x,
	      y = qb._y,
	      z = qb._z,
	      w = qb._w;
	    let dot = this.dot(qb);
	    if (dot < 0) {
	      x = -x;
	      y = -y;
	      z = -z;
	      w = -w;
	      dot = -dot;
	    }
	    let s = 1 - t;
	    if (dot < 0.9995) {
	      // slerp

	      const theta = Math.acos(dot);
	      const sin = Math.sin(theta);
	      s = Math.sin(s * theta) / sin;
	      t = Math.sin(t * theta) / sin;
	      this._x = this._x * s + x * t;
	      this._y = this._y * s + y * t;
	      this._z = this._z * s + z * t;
	      this._w = this._w * s + w * t;
	      this._onChangeCallback();
	    } else {
	      // for small angles, lerp then normalize

	      this._x = this._x * s + x * t;
	      this._y = this._y * s + y * t;
	      this._z = this._z * s + z * t;
	      this._w = this._w * s + w * t;
	      this.normalize(); // normalize calls _onChangeCallback()
	    }
	    return this;
	  }

	  /**
	   * Performs a spherical linear interpolation between the given quaternions
	   * and stores the result in this quaternion.
	   *
	   * @param {Quaternion} qa - The source quaternion.
	   * @param {Quaternion} qb - The target quaternion.
	   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  slerpQuaternions(qa, qb, t) {
	    return this.copy(qa).slerp(qb, t);
	  }

	  /**
	   * Sets this quaternion to a uniformly random, normalized quaternion.
	   *
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  random() {
	    // Ken Shoemake
	    // Uniform random rotations
	    // D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

	    const theta1 = 2 * Math.PI * Math.random();
	    const theta2 = 2 * Math.PI * Math.random();
	    const x0 = Math.random();
	    const r1 = Math.sqrt(1 - x0);
	    const r2 = Math.sqrt(x0);
	    return this.set(r1 * Math.sin(theta1), r1 * Math.cos(theta1), r2 * Math.sin(theta2), r2 * Math.cos(theta2));
	  }

	  /**
	   * Returns `true` if this quaternion is equal with the given one.
	   *
	   * @param {Quaternion} quaternion - The quaternion to test for equality.
	   * @return {boolean} Whether this quaternion is equal with the given one.
	   */
	  equals(quaternion) {
	    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
	  }

	  /**
	   * Sets this quaternion's components from the given array.
	   *
	   * @param {Array<number>} array - An array holding the quaternion component values.
	   * @param {number} [offset=0] - The offset into the array.
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  fromArray(array, offset = 0) {
	    this._x = array[offset];
	    this._y = array[offset + 1];
	    this._z = array[offset + 2];
	    this._w = array[offset + 3];
	    this._onChangeCallback();
	    return this;
	  }

	  /**
	   * Writes the components of this quaternion to the given array. If no array is provided,
	   * the method returns a new instance.
	   *
	   * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
	   * @param {number} [offset=0] - Index of the first element in the array.
	   * @return {Array<number>} The quaternion components.
	   */
	  toArray(array = [], offset = 0) {
	    array[offset] = this._x;
	    array[offset + 1] = this._y;
	    array[offset + 2] = this._z;
	    array[offset + 3] = this._w;
	    return array;
	  }

	  /**
	   * Sets the components of this quaternion from the given buffer attribute.
	   *
	   * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
	   * @param {number} index - The index into the attribute.
	   * @return {Quaternion} A reference to this quaternion.
	   */
	  fromBufferAttribute(attribute, index) {
	    this._x = attribute.getX(index);
	    this._y = attribute.getY(index);
	    this._z = attribute.getZ(index);
	    this._w = attribute.getW(index);
	    this._onChangeCallback();
	    return this;
	  }

	  /**
	   * This methods defines the serialization result of this class. Returns the
	   * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
	   *
	   * @return {Array<number>} The serialized quaternion.
	   */
	  toJSON() {
	    return this.toArray();
	  }
	  _onChange(callback) {
	    this._onChangeCallback = callback;
	    return this;
	  }
	  _onChangeCallback() {}
	  *[Symbol.iterator]() {
	    yield this._x;
	    yield this._y;
	    yield this._z;
	    yield this._w;
	  }
	}

	/**
	 * Class representing a 3D vector. A 3D vector is an ordered triplet of numbers
	 * (labeled x, y and z), which can be used to represent a number of things, such as:
	 *
	 * - A point in 3D space.
	 * - A direction and length in 3D space. In three.js the length will
	 * always be the Euclidean distance(straight-line distance) from `(0, 0, 0)` to `(x, y, z)`
	 * and the direction is also measured from `(0, 0, 0)` towards `(x, y, z)`.
	 * - Any arbitrary ordered triplet of numbers.
	 *
	 * There are other things a 3D vector can be used to represent, such as
	 * momentum vectors and so on, however these are the most
	 * common uses in three.js.
	 *
	 * Iterating through a vector instance will yield its components `(x, y, z)` in
	 * the corresponding order.
	 * ```js
	 * const a = new THREE.Vector3( 0, 1, 0 );
	 *
	 * //no arguments; will be initialised to (0, 0, 0)
	 * const b = new THREE.Vector3( );
	 *
	 * const d = a.distanceTo( b );
	 * ```
	 */
	class Vector3 {
	  /**
	   * Constructs a new 3D vector.
	   *
	   * @param {number} [x=0] - The x value of this vector.
	   * @param {number} [y=0] - The y value of this vector.
	   * @param {number} [z=0] - The z value of this vector.
	   */
	  constructor(x = 0, y = 0, z = 0) {
	    /**
	     * This flag can be used for type testing.
	     *
	     * @type {boolean}
	     * @readonly
	     * @default true
	     */
	    Vector3.prototype.isVector3 = true;

	    /**
	     * The x value of this vector.
	     *
	     * @type {number}
	     */
	    this.x = x;

	    /**
	     * The y value of this vector.
	     *
	     * @type {number}
	     */
	    this.y = y;

	    /**
	     * The z value of this vector.
	     *
	     * @type {number}
	     */
	    this.z = z;
	  }

	  /**
	   * Sets the vector components.
	   *
	   * @param {number} x - The value of the x component.
	   * @param {number} y - The value of the y component.
	   * @param {number} z - The value of the z component.
	   * @return {Vector3} A reference to this vector.
	   */
	  set(x, y, z) {
	    if (z === undefined) z = this.z; // sprite.scale.set(x,y)

	    this.x = x;
	    this.y = y;
	    this.z = z;
	    return this;
	  }

	  /**
	   * Sets the vector components to the same value.
	   *
	   * @param {number} scalar - The value to set for all vector components.
	   * @return {Vector3} A reference to this vector.
	   */
	  setScalar(scalar) {
	    this.x = scalar;
	    this.y = scalar;
	    this.z = scalar;
	    return this;
	  }

	  /**
	   * Sets the vector's x component to the given value
	   *
	   * @param {number} x - The value to set.
	   * @return {Vector3} A reference to this vector.
	   */
	  setX(x) {
	    this.x = x;
	    return this;
	  }

	  /**
	   * Sets the vector's y component to the given value
	   *
	   * @param {number} y - The value to set.
	   * @return {Vector3} A reference to this vector.
	   */
	  setY(y) {
	    this.y = y;
	    return this;
	  }

	  /**
	   * Sets the vector's z component to the given value
	   *
	   * @param {number} z - The value to set.
	   * @return {Vector3} A reference to this vector.
	   */
	  setZ(z) {
	    this.z = z;
	    return this;
	  }

	  /**
	   * Allows to set a vector component with an index.
	   *
	   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
	   * @param {number} value - The value to set.
	   * @return {Vector3} A reference to this vector.
	   */
	  setComponent(index, value) {
	    switch (index) {
	      case 0:
	        this.x = value;
	        break;
	      case 1:
	        this.y = value;
	        break;
	      case 2:
	        this.z = value;
	        break;
	      default:
	        throw new Error('index is out of range: ' + index);
	    }
	    return this;
	  }

	  /**
	   * Returns the value of the vector component which matches the given index.
	   *
	   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
	   * @return {number} A vector component value.
	   */
	  getComponent(index) {
	    switch (index) {
	      case 0:
	        return this.x;
	      case 1:
	        return this.y;
	      case 2:
	        return this.z;
	      default:
	        throw new Error('index is out of range: ' + index);
	    }
	  }

	  /**
	   * Returns a new vector with copied values from this instance.
	   *
	   * @return {Vector3} A clone of this instance.
	   */
	  clone() {
	    return new this.constructor(this.x, this.y, this.z);
	  }

	  /**
	   * Copies the values of the given vector to this instance.
	   *
	   * @param {Vector3} v - The vector to copy.
	   * @return {Vector3} A reference to this vector.
	   */
	  copy(v) {
	    this.x = v.x;
	    this.y = v.y;
	    this.z = v.z;
	    return this;
	  }

	  /**
	   * Adds the given vector to this instance.
	   *
	   * @param {Vector3} v - The vector to add.
	   * @return {Vector3} A reference to this vector.
	   */
	  add(v) {
	    this.x += v.x;
	    this.y += v.y;
	    this.z += v.z;
	    return this;
	  }

	  /**
	   * Adds the given scalar value to all components of this instance.
	   *
	   * @param {number} s - The scalar to add.
	   * @return {Vector3} A reference to this vector.
	   */
	  addScalar(s) {
	    this.x += s;
	    this.y += s;
	    this.z += s;
	    return this;
	  }

	  /**
	   * Adds the given vectors and stores the result in this instance.
	   *
	   * @param {Vector3} a - The first vector.
	   * @param {Vector3} b - The second vector.
	   * @return {Vector3} A reference to this vector.
	   */
	  addVectors(a, b) {
	    this.x = a.x + b.x;
	    this.y = a.y + b.y;
	    this.z = a.z + b.z;
	    return this;
	  }

	  /**
	   * Adds the given vector scaled by the given factor to this instance.
	   *
	   * @param {Vector3|Vector4} v - The vector.
	   * @param {number} s - The factor that scales `v`.
	   * @return {Vector3} A reference to this vector.
	   */
	  addScaledVector(v, s) {
	    this.x += v.x * s;
	    this.y += v.y * s;
	    this.z += v.z * s;
	    return this;
	  }

	  /**
	   * Subtracts the given vector from this instance.
	   *
	   * @param {Vector3} v - The vector to subtract.
	   * @return {Vector3} A reference to this vector.
	   */
	  sub(v) {
	    this.x -= v.x;
	    this.y -= v.y;
	    this.z -= v.z;
	    return this;
	  }

	  /**
	   * Subtracts the given scalar value from all components of this instance.
	   *
	   * @param {number} s - The scalar to subtract.
	   * @return {Vector3} A reference to this vector.
	   */
	  subScalar(s) {
	    this.x -= s;
	    this.y -= s;
	    this.z -= s;
	    return this;
	  }

	  /**
	   * Subtracts the given vectors and stores the result in this instance.
	   *
	   * @param {Vector3} a - The first vector.
	   * @param {Vector3} b - The second vector.
	   * @return {Vector3} A reference to this vector.
	   */
	  subVectors(a, b) {
	    this.x = a.x - b.x;
	    this.y = a.y - b.y;
	    this.z = a.z - b.z;
	    return this;
	  }

	  /**
	   * Multiplies the given vector with this instance.
	   *
	   * @param {Vector3} v - The vector to multiply.
	   * @return {Vector3} A reference to this vector.
	   */
	  multiply(v) {
	    this.x *= v.x;
	    this.y *= v.y;
	    this.z *= v.z;
	    return this;
	  }

	  /**
	   * Multiplies the given scalar value with all components of this instance.
	   *
	   * @param {number} scalar - The scalar to multiply.
	   * @return {Vector3} A reference to this vector.
	   */
	  multiplyScalar(scalar) {
	    this.x *= scalar;
	    this.y *= scalar;
	    this.z *= scalar;
	    return this;
	  }

	  /**
	   * Multiplies the given vectors and stores the result in this instance.
	   *
	   * @param {Vector3} a - The first vector.
	   * @param {Vector3} b - The second vector.
	   * @return {Vector3} A reference to this vector.
	   */
	  multiplyVectors(a, b) {
	    this.x = a.x * b.x;
	    this.y = a.y * b.y;
	    this.z = a.z * b.z;
	    return this;
	  }

	  /**
	   * Applies the given Euler rotation to this vector.
	   *
	   * @param {Euler} euler - The Euler angles.
	   * @return {Vector3} A reference to this vector.
	   */
	  applyEuler(euler) {
	    return this.applyQuaternion(_quaternion$2.setFromEuler(euler));
	  }

	  /**
	   * Applies a rotation specified by an axis and an angle to this vector.
	   *
	   * @param {Vector3} axis - A normalized vector representing the rotation axis.
	   * @param {number} angle - The angle in radians.
	   * @return {Vector3} A reference to this vector.
	   */
	  applyAxisAngle(axis, angle) {
	    return this.applyQuaternion(_quaternion$2.setFromAxisAngle(axis, angle));
	  }

	  /**
	   * Multiplies this vector with the given 3x3 matrix.
	   *
	   * @param {Matrix3} m - The 3x3 matrix.
	   * @return {Vector3} A reference to this vector.
	   */
	  applyMatrix3(m) {
	    const x = this.x,
	      y = this.y,
	      z = this.z;
	    const e = m.elements;
	    this.x = e[0] * x + e[3] * y + e[6] * z;
	    this.y = e[1] * x + e[4] * y + e[7] * z;
	    this.z = e[2] * x + e[5] * y + e[8] * z;
	    return this;
	  }

	  /**
	   * Multiplies this vector by the given normal matrix and normalizes
	   * the result.
	   *
	   * @param {Matrix3} m - The normal matrix.
	   * @return {Vector3} A reference to this vector.
	   */
	  applyNormalMatrix(m) {
	    return this.applyMatrix3(m).normalize();
	  }

	  /**
	   * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
	   * divides by perspective.
	   *
	   * @param {Matrix4} m - The matrix to apply.
	   * @return {Vector3} A reference to this vector.
	   */
	  applyMatrix4(m) {
	    const x = this.x,
	      y = this.y,
	      z = this.z;
	    const e = m.elements;
	    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
	    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
	    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
	    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
	    return this;
	  }

	  /**
	   * Applies the given Quaternion to this vector.
	   *
	   * @param {Quaternion} q - The Quaternion.
	   * @return {Vector3} A reference to this vector.
	   */
	  applyQuaternion(q) {
	    // quaternion q is assumed to have unit length

	    const vx = this.x,
	      vy = this.y,
	      vz = this.z;
	    const qx = q.x,
	      qy = q.y,
	      qz = q.z,
	      qw = q.w;

	    // t = 2 * cross( q.xyz, v );
	    const tx = 2 * (qy * vz - qz * vy);
	    const ty = 2 * (qz * vx - qx * vz);
	    const tz = 2 * (qx * vy - qy * vx);

	    // v + q.w * t + cross( q.xyz, t );
	    this.x = vx + qw * tx + qy * tz - qz * ty;
	    this.y = vy + qw * ty + qz * tx - qx * tz;
	    this.z = vz + qw * tz + qx * ty - qy * tx;
	    return this;
	  }

	  /**
	   * Projects this vector from world space into the camera's normalized
	   * device coordinate (NDC) space.
	   *
	   * @param {Camera} camera - The camera.
	   * @return {Vector3} A reference to this vector.
	   */
	  project(camera) {
	    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
	  }

	  /**
	   * Unprojects this vector from the camera's normalized device coordinate (NDC)
	   * space into world space.
	   *
	   * @param {Camera} camera - The camera.
	   * @return {Vector3} A reference to this vector.
	   */
	  unproject(camera) {
	    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
	  }

	  /**
	   * Transforms the direction of this vector by a matrix (the upper left 3 x 3
	   * subset of the given 4x4 matrix and then normalizes the result.
	   *
	   * @param {Matrix4} m - The matrix.
	   * @return {Vector3} A reference to this vector.
	   */
	  transformDirection(m) {
	    // input: THREE.Matrix4 affine matrix
	    // vector interpreted as a direction

	    const x = this.x,
	      y = this.y,
	      z = this.z;
	    const e = m.elements;
	    this.x = e[0] * x + e[4] * y + e[8] * z;
	    this.y = e[1] * x + e[5] * y + e[9] * z;
	    this.z = e[2] * x + e[6] * y + e[10] * z;
	    return this.normalize();
	  }

	  /**
	   * Divides this instance by the given vector.
	   *
	   * @param {Vector3} v - The vector to divide.
	   * @return {Vector3} A reference to this vector.
	   */
	  divide(v) {
	    this.x /= v.x;
	    this.y /= v.y;
	    this.z /= v.z;
	    return this;
	  }

	  /**
	   * Divides this vector by the given scalar.
	   *
	   * @param {number} scalar - The scalar to divide.
	   * @return {Vector3} A reference to this vector.
	   */
	  divideScalar(scalar) {
	    return this.multiplyScalar(1 / scalar);
	  }

	  /**
	   * If this vector's x, y or z value is greater than the given vector's x, y or z
	   * value, replace that value with the corresponding min value.
	   *
	   * @param {Vector3} v - The vector.
	   * @return {Vector3} A reference to this vector.
	   */
	  min(v) {
	    this.x = Math.min(this.x, v.x);
	    this.y = Math.min(this.y, v.y);
	    this.z = Math.min(this.z, v.z);
	    return this;
	  }

	  /**
	   * If this vector's x, y or z value is less than the given vector's x, y or z
	   * value, replace that value with the corresponding max value.
	   *
	   * @param {Vector3} v - The vector.
	   * @return {Vector3} A reference to this vector.
	   */
	  max(v) {
	    this.x = Math.max(this.x, v.x);
	    this.y = Math.max(this.y, v.y);
	    this.z = Math.max(this.z, v.z);
	    return this;
	  }

	  /**
	   * If this vector's x, y or z value is greater than the max vector's x, y or z
	   * value, it is replaced by the corresponding value.
	   * If this vector's x, y or z value is less than the min vector's x, y or z value,
	   * it is replaced by the corresponding value.
	   *
	   * @param {Vector3} min - The minimum x, y and z values.
	   * @param {Vector3} max - The maximum x, y and z values in the desired range.
	   * @return {Vector3} A reference to this vector.
	   */
	  clamp(min, max) {
	    // assumes min < max, componentwise

	    this.x = clamp(this.x, min.x, max.x);
	    this.y = clamp(this.y, min.y, max.y);
	    this.z = clamp(this.z, min.z, max.z);
	    return this;
	  }

	  /**
	   * If this vector's x, y or z values are greater than the max value, they are
	   * replaced by the max value.
	   * If this vector's x, y or z values are less than the min value, they are
	   * replaced by the min value.
	   *
	   * @param {number} minVal - The minimum value the components will be clamped to.
	   * @param {number} maxVal - The maximum value the components will be clamped to.
	   * @return {Vector3} A reference to this vector.
	   */
	  clampScalar(minVal, maxVal) {
	    this.x = clamp(this.x, minVal, maxVal);
	    this.y = clamp(this.y, minVal, maxVal);
	    this.z = clamp(this.z, minVal, maxVal);
	    return this;
	  }

	  /**
	   * If this vector's length is greater than the max value, it is replaced by
	   * the max value.
	   * If this vector's length is less than the min value, it is replaced by the
	   * min value.
	   *
	   * @param {number} min - The minimum value the vector length will be clamped to.
	   * @param {number} max - The maximum value the vector length will be clamped to.
	   * @return {Vector3} A reference to this vector.
	   */
	  clampLength(min, max) {
	    const length = this.length();
	    return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
	  }

	  /**
	   * The components of this vector are rounded down to the nearest integer value.
	   *
	   * @return {Vector3} A reference to this vector.
	   */
	  floor() {
	    this.x = Math.floor(this.x);
	    this.y = Math.floor(this.y);
	    this.z = Math.floor(this.z);
	    return this;
	  }

	  /**
	   * The components of this vector are rounded up to the nearest integer value.
	   *
	   * @return {Vector3} A reference to this vector.
	   */
	  ceil() {
	    this.x = Math.ceil(this.x);
	    this.y = Math.ceil(this.y);
	    this.z = Math.ceil(this.z);
	    return this;
	  }

	  /**
	   * The components of this vector are rounded to the nearest integer value
	   *
	   * @return {Vector3} A reference to this vector.
	   */
	  round() {
	    this.x = Math.round(this.x);
	    this.y = Math.round(this.y);
	    this.z = Math.round(this.z);
	    return this;
	  }

	  /**
	   * The components of this vector are rounded towards zero (up if negative,
	   * down if positive) to an integer value.
	   *
	   * @return {Vector3} A reference to this vector.
	   */
	  roundToZero() {
	    this.x = Math.trunc(this.x);
	    this.y = Math.trunc(this.y);
	    this.z = Math.trunc(this.z);
	    return this;
	  }

	  /**
	   * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
	   *
	   * @return {Vector3} A reference to this vector.
	   */
	  negate() {
	    this.x = -this.x;
	    this.y = -this.y;
	    this.z = -this.z;
	    return this;
	  }

	  /**
	   * Calculates the dot product of the given vector with this instance.
	   *
	   * @param {Vector3} v - The vector to compute the dot product with.
	   * @return {number} The result of the dot product.
	   */
	  dot(v) {
	    return this.x * v.x + this.y * v.y + this.z * v.z;
	  }

	  // TODO lengthSquared?

	  /**
	   * Computes the square of the Euclidean length (straight-line length) from
	   * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
	   * compare the length squared instead as it is slightly more efficient to calculate.
	   *
	   * @return {number} The square length of this vector.
	   */
	  lengthSq() {
	    return this.x * this.x + this.y * this.y + this.z * this.z;
	  }

	  /**
	   * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
	   *
	   * @return {number} The length of this vector.
	   */
	  length() {
	    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	  }

	  /**
	   * Computes the Manhattan length of this vector.
	   *
	   * @return {number} The length of this vector.
	   */
	  manhattanLength() {
	    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
	  }

	  /**
	   * Converts this vector to a unit vector - that is, sets it equal to a vector
	   * with the same direction as this one, but with a vector length of `1`.
	   *
	   * @return {Vector3} A reference to this vector.
	   */
	  normalize() {
	    return this.divideScalar(this.length() || 1);
	  }

	  /**
	   * Sets this vector to a vector with the same direction as this one, but
	   * with the specified length.
	   *
	   * @param {number} length - The new length of this vector.
	   * @return {Vector3} A reference to this vector.
	   */
	  setLength(length) {
	    return this.normalize().multiplyScalar(length);
	  }

	  /**
	   * Linearly interpolates between the given vector and this instance, where
	   * alpha is the percent distance along the line - alpha = 0 will be this
	   * vector, and alpha = 1 will be the given one.
	   *
	   * @param {Vector3} v - The vector to interpolate towards.
	   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	   * @return {Vector3} A reference to this vector.
	   */
	  lerp(v, alpha) {
	    this.x += (v.x - this.x) * alpha;
	    this.y += (v.y - this.y) * alpha;
	    this.z += (v.z - this.z) * alpha;
	    return this;
	  }

	  /**
	   * Linearly interpolates between the given vectors, where alpha is the percent
	   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
	   * be the second one. The result is stored in this instance.
	   *
	   * @param {Vector3} v1 - The first vector.
	   * @param {Vector3} v2 - The second vector.
	   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	   * @return {Vector3} A reference to this vector.
	   */
	  lerpVectors(v1, v2, alpha) {
	    this.x = v1.x + (v2.x - v1.x) * alpha;
	    this.y = v1.y + (v2.y - v1.y) * alpha;
	    this.z = v1.z + (v2.z - v1.z) * alpha;
	    return this;
	  }

	  /**
	   * Calculates the cross product of the given vector with this instance.
	   *
	   * @param {Vector3} v - The vector to compute the cross product with.
	   * @return {Vector3} The result of the cross product.
	   */
	  cross(v) {
	    return this.crossVectors(this, v);
	  }

	  /**
	   * Calculates the cross product of the given vectors and stores the result
	   * in this instance.
	   *
	   * @param {Vector3} a - The first vector.
	   * @param {Vector3} b - The second vector.
	   * @return {Vector3} A reference to this vector.
	   */
	  crossVectors(a, b) {
	    const ax = a.x,
	      ay = a.y,
	      az = a.z;
	    const bx = b.x,
	      by = b.y,
	      bz = b.z;
	    this.x = ay * bz - az * by;
	    this.y = az * bx - ax * bz;
	    this.z = ax * by - ay * bx;
	    return this;
	  }

	  /**
	   * Projects this vector onto the given one.
	   *
	   * @param {Vector3} v - The vector to project to.
	   * @return {Vector3} A reference to this vector.
	   */
	  projectOnVector(v) {
	    const denominator = v.lengthSq();
	    if (denominator === 0) return this.set(0, 0, 0);
	    const scalar = v.dot(this) / denominator;
	    return this.copy(v).multiplyScalar(scalar);
	  }

	  /**
	   * Projects this vector onto a plane by subtracting this
	   * vector projected onto the plane's normal from this vector.
	   *
	   * @param {Vector3} planeNormal - The plane normal.
	   * @return {Vector3} A reference to this vector.
	   */
	  projectOnPlane(planeNormal) {
	    _vector$3.copy(this).projectOnVector(planeNormal);
	    return this.sub(_vector$3);
	  }

	  /**
	   * Reflects this vector off a plane orthogonal to the given normal vector.
	   *
	   * @param {Vector3} normal - The (normalized) normal vector.
	   * @return {Vector3} A reference to this vector.
	   */
	  reflect(normal) {
	    return this.sub(_vector$3.copy(normal).multiplyScalar(2 * this.dot(normal)));
	  }
	  /**
	   * Returns the angle between the given vector and this instance in radians.
	   *
	   * @param {Vector3} v - The vector to compute the angle with.
	   * @return {number} The angle in radians.
	   */
	  angleTo(v) {
	    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
	    if (denominator === 0) return Math.PI / 2;
	    const theta = this.dot(v) / denominator;

	    // clamp, to handle numerical problems

	    return Math.acos(clamp(theta, -1, 1));
	  }

	  /**
	   * Computes the distance from the given vector to this instance.
	   *
	   * @param {Vector3} v - The vector to compute the distance to.
	   * @return {number} The distance.
	   */
	  distanceTo(v) {
	    return Math.sqrt(this.distanceToSquared(v));
	  }

	  /**
	   * Computes the squared distance from the given vector to this instance.
	   * If you are just comparing the distance with another distance, you should compare
	   * the distance squared instead as it is slightly more efficient to calculate.
	   *
	   * @param {Vector3} v - The vector to compute the squared distance to.
	   * @return {number} The squared distance.
	   */
	  distanceToSquared(v) {
	    const dx = this.x - v.x,
	      dy = this.y - v.y,
	      dz = this.z - v.z;
	    return dx * dx + dy * dy + dz * dz;
	  }

	  /**
	   * Computes the Manhattan distance from the given vector to this instance.
	   *
	   * @param {Vector3} v - The vector to compute the Manhattan distance to.
	   * @return {number} The Manhattan distance.
	   */
	  manhattanDistanceTo(v) {
	    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
	  }

	  /**
	   * Sets the vector components from the given spherical coordinates.
	   *
	   * @param {Spherical} s - The spherical coordinates.
	   * @return {Vector3} A reference to this vector.
	   */
	  setFromSpherical(s) {
	    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
	  }

	  /**
	   * Sets the vector components from the given spherical coordinates.
	   *
	   * @param {number} radius - The radius.
	   * @param {number} phi - The phi angle in radians.
	   * @param {number} theta - The theta angle in radians.
	   * @return {Vector3} A reference to this vector.
	   */
	  setFromSphericalCoords(radius, phi, theta) {
	    const sinPhiRadius = Math.sin(phi) * radius;
	    this.x = sinPhiRadius * Math.sin(theta);
	    this.y = Math.cos(phi) * radius;
	    this.z = sinPhiRadius * Math.cos(theta);
	    return this;
	  }

	  /**
	   * Sets the vector components from the given cylindrical coordinates.
	   *
	   * @param {Cylindrical} c - The cylindrical coordinates.
	   * @return {Vector3} A reference to this vector.
	   */
	  setFromCylindrical(c) {
	    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
	  }

	  /**
	   * Sets the vector components from the given cylindrical coordinates.
	   *
	   * @param {number} radius - The radius.
	   * @param {number} theta - The theta angle in radians.
	   * @param {number} y - The y value.
	   * @return {Vector3} A reference to this vector.
	   */
	  setFromCylindricalCoords(radius, theta, y) {
	    this.x = radius * Math.sin(theta);
	    this.y = y;
	    this.z = radius * Math.cos(theta);
	    return this;
	  }

	  /**
	   * Sets the vector components to the position elements of the
	   * given transformation matrix.
	   *
	   * @param {Matrix4} m - The 4x4 matrix.
	   * @return {Vector3} A reference to this vector.
	   */
	  setFromMatrixPosition(m) {
	    const e = m.elements;
	    this.x = e[12];
	    this.y = e[13];
	    this.z = e[14];
	    return this;
	  }

	  /**
	   * Sets the vector components to the scale elements of the
	   * given transformation matrix.
	   *
	   * @param {Matrix4} m - The 4x4 matrix.
	   * @return {Vector3} A reference to this vector.
	   */
	  setFromMatrixScale(m) {
	    const sx = this.setFromMatrixColumn(m, 0).length();
	    const sy = this.setFromMatrixColumn(m, 1).length();
	    const sz = this.setFromMatrixColumn(m, 2).length();
	    this.x = sx;
	    this.y = sy;
	    this.z = sz;
	    return this;
	  }

	  /**
	   * Sets the vector components from the specified matrix column.
	   *
	   * @param {Matrix4} m - The 4x4 matrix.
	   * @param {number} index - The column index.
	   * @return {Vector3} A reference to this vector.
	   */
	  setFromMatrixColumn(m, index) {
	    return this.fromArray(m.elements, index * 4);
	  }

	  /**
	   * Sets the vector components from the specified matrix column.
	   *
	   * @param {Matrix3} m - The 3x3 matrix.
	   * @param {number} index - The column index.
	   * @return {Vector3} A reference to this vector.
	   */
	  setFromMatrix3Column(m, index) {
	    return this.fromArray(m.elements, index * 3);
	  }

	  /**
	   * Sets the vector components from the given Euler angles.
	   *
	   * @param {Euler} e - The Euler angles to set.
	   * @return {Vector3} A reference to this vector.
	   */
	  setFromEuler(e) {
	    this.x = e._x;
	    this.y = e._y;
	    this.z = e._z;
	    return this;
	  }

	  /**
	   * Sets the vector components from the RGB components of the
	   * given color.
	   *
	   * @param {Color} c - The color to set.
	   * @return {Vector3} A reference to this vector.
	   */
	  setFromColor(c) {
	    this.x = c.r;
	    this.y = c.g;
	    this.z = c.b;
	    return this;
	  }

	  /**
	   * Returns `true` if this vector is equal with the given one.
	   *
	   * @param {Vector3} v - The vector to test for equality.
	   * @return {boolean} Whether this vector is equal with the given one.
	   */
	  equals(v) {
	    return v.x === this.x && v.y === this.y && v.z === this.z;
	  }

	  /**
	   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
	   * and z value to be `array[ offset + 2 ]`.
	   *
	   * @param {Array<number>} array - An array holding the vector component values.
	   * @param {number} [offset=0] - The offset into the array.
	   * @return {Vector3} A reference to this vector.
	   */
	  fromArray(array, offset = 0) {
	    this.x = array[offset];
	    this.y = array[offset + 1];
	    this.z = array[offset + 2];
	    return this;
	  }

	  /**
	   * Writes the components of this vector to the given array. If no array is provided,
	   * the method returns a new instance.
	   *
	   * @param {Array<number>} [array=[]] - The target array holding the vector components.
	   * @param {number} [offset=0] - Index of the first element in the array.
	   * @return {Array<number>} The vector components.
	   */
	  toArray(array = [], offset = 0) {
	    array[offset] = this.x;
	    array[offset + 1] = this.y;
	    array[offset + 2] = this.z;
	    return array;
	  }

	  /**
	   * Sets the components of this vector from the given buffer attribute.
	   *
	   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
	   * @param {number} index - The index into the attribute.
	   * @return {Vector3} A reference to this vector.
	   */
	  fromBufferAttribute(attribute, index) {
	    this.x = attribute.getX(index);
	    this.y = attribute.getY(index);
	    this.z = attribute.getZ(index);
	    return this;
	  }

	  /**
	   * Sets each component of this vector to a pseudo-random value between `0` and
	   * `1`, excluding `1`.
	   *
	   * @return {Vector3} A reference to this vector.
	   */
	  random() {
	    this.x = Math.random();
	    this.y = Math.random();
	    this.z = Math.random();
	    return this;
	  }

	  /**
	   * Sets this vector to a uniformly random point on a unit sphere.
	   *
	   * @return {Vector3} A reference to this vector.
	   */
	  randomDirection() {
	    // https://mathworld.wolfram.com/SpherePointPicking.html

	    const theta = Math.random() * Math.PI * 2;
	    const u = Math.random() * 2 - 1;
	    const c = Math.sqrt(1 - u * u);
	    this.x = c * Math.cos(theta);
	    this.y = u;
	    this.z = c * Math.sin(theta);
	    return this;
	  }
	  *[Symbol.iterator]() {
	    yield this.x;
	    yield this.y;
	    yield this.z;
	  }
	}
	const _vector$3 = /*@__PURE__*/new Vector3();
	const _quaternion$2 = /*@__PURE__*/new Quaternion();

	/**
	 * Class representing a 2D vector. A 2D vector is an ordered pair of numbers
	 * (labeled x and y), which can be used to represent a number of things, such as:
	 *
	 * - A point in 2D space (i.e. a position on a plane).
	 * - A direction and length across a plane. In three.js the length will
	 * always be the Euclidean distance(straight-line distance) from `(0, 0)` to `(x, y)`
	 * and the direction is also measured from `(0, 0)` towards `(x, y)`.
	 * - Any arbitrary ordered pair of numbers.
	 *
	 * There are other things a 2D vector can be used to represent, such as
	 * momentum vectors, complex numbers and so on, however these are the most
	 * common uses in three.js.
	 *
	 * Iterating through a vector instance will yield its components `(x, y)` in
	 * the corresponding order.
	 * ```js
	 * const a = new THREE.Vector2( 0, 1 );
	 *
	 * //no arguments; will be initialised to (0, 0)
	 * const b = new THREE.Vector2( );
	 *
	 * const d = a.distanceTo( b );
	 * ```
	 */
	class Vector2 {
	  /**
	   * Constructs a new 2D vector.
	   *
	   * @param {number} [x=0] - The x value of this vector.
	   * @param {number} [y=0] - The y value of this vector.
	   */
	  constructor(x = 0, y = 0) {
	    /**
	     * This flag can be used for type testing.
	     *
	     * @type {boolean}
	     * @readonly
	     * @default true
	     */
	    Vector2.prototype.isVector2 = true;

	    /**
	     * The x value of this vector.
	     *
	     * @type {number}
	     */
	    this.x = x;

	    /**
	     * The y value of this vector.
	     *
	     * @type {number}
	     */
	    this.y = y;
	  }

	  /**
	   * Alias for {@link Vector2#x}.
	   *
	   * @type {number}
	   */
	  get width() {
	    return this.x;
	  }
	  set width(value) {
	    this.x = value;
	  }

	  /**
	   * Alias for {@link Vector2#y}.
	   *
	   * @type {number}
	   */
	  get height() {
	    return this.y;
	  }
	  set height(value) {
	    this.y = value;
	  }

	  /**
	   * Sets the vector components.
	   *
	   * @param {number} x - The value of the x component.
	   * @param {number} y - The value of the y component.
	   * @return {Vector2} A reference to this vector.
	   */
	  set(x, y) {
	    this.x = x;
	    this.y = y;
	    return this;
	  }

	  /**
	   * Sets the vector components to the same value.
	   *
	   * @param {number} scalar - The value to set for all vector components.
	   * @return {Vector2} A reference to this vector.
	   */
	  setScalar(scalar) {
	    this.x = scalar;
	    this.y = scalar;
	    return this;
	  }

	  /**
	   * Sets the vector's x component to the given value
	   *
	   * @param {number} x - The value to set.
	   * @return {Vector2} A reference to this vector.
	   */
	  setX(x) {
	    this.x = x;
	    return this;
	  }

	  /**
	   * Sets the vector's y component to the given value
	   *
	   * @param {number} y - The value to set.
	   * @return {Vector2} A reference to this vector.
	   */
	  setY(y) {
	    this.y = y;
	    return this;
	  }

	  /**
	   * Allows to set a vector component with an index.
	   *
	   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
	   * @param {number} value - The value to set.
	   * @return {Vector2} A reference to this vector.
	   */
	  setComponent(index, value) {
	    switch (index) {
	      case 0:
	        this.x = value;
	        break;
	      case 1:
	        this.y = value;
	        break;
	      default:
	        throw new Error('index is out of range: ' + index);
	    }
	    return this;
	  }

	  /**
	   * Returns the value of the vector component which matches the given index.
	   *
	   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
	   * @return {number} A vector component value.
	   */
	  getComponent(index) {
	    switch (index) {
	      case 0:
	        return this.x;
	      case 1:
	        return this.y;
	      default:
	        throw new Error('index is out of range: ' + index);
	    }
	  }

	  /**
	   * Returns a new vector with copied values from this instance.
	   *
	   * @return {Vector2} A clone of this instance.
	   */
	  clone() {
	    return new this.constructor(this.x, this.y);
	  }

	  /**
	   * Copies the values of the given vector to this instance.
	   *
	   * @param {Vector2} v - The vector to copy.
	   * @return {Vector2} A reference to this vector.
	   */
	  copy(v) {
	    this.x = v.x;
	    this.y = v.y;
	    return this;
	  }

	  /**
	   * Adds the given vector to this instance.
	   *
	   * @param {Vector2} v - The vector to add.
	   * @return {Vector2} A reference to this vector.
	   */
	  add(v) {
	    this.x += v.x;
	    this.y += v.y;
	    return this;
	  }

	  /**
	   * Adds the given scalar value to all components of this instance.
	   *
	   * @param {number} s - The scalar to add.
	   * @return {Vector2} A reference to this vector.
	   */
	  addScalar(s) {
	    this.x += s;
	    this.y += s;
	    return this;
	  }

	  /**
	   * Adds the given vectors and stores the result in this instance.
	   *
	   * @param {Vector2} a - The first vector.
	   * @param {Vector2} b - The second vector.
	   * @return {Vector2} A reference to this vector.
	   */
	  addVectors(a, b) {
	    this.x = a.x + b.x;
	    this.y = a.y + b.y;
	    return this;
	  }

	  /**
	   * Adds the given vector scaled by the given factor to this instance.
	   *
	   * @param {Vector2} v - The vector.
	   * @param {number} s - The factor that scales `v`.
	   * @return {Vector2} A reference to this vector.
	   */
	  addScaledVector(v, s) {
	    this.x += v.x * s;
	    this.y += v.y * s;
	    return this;
	  }

	  /**
	   * Subtracts the given vector from this instance.
	   *
	   * @param {Vector2} v - The vector to subtract.
	   * @return {Vector2} A reference to this vector.
	   */
	  sub(v) {
	    this.x -= v.x;
	    this.y -= v.y;
	    return this;
	  }

	  /**
	   * Subtracts the given scalar value from all components of this instance.
	   *
	   * @param {number} s - The scalar to subtract.
	   * @return {Vector2} A reference to this vector.
	   */
	  subScalar(s) {
	    this.x -= s;
	    this.y -= s;
	    return this;
	  }

	  /**
	   * Subtracts the given vectors and stores the result in this instance.
	   *
	   * @param {Vector2} a - The first vector.
	   * @param {Vector2} b - The second vector.
	   * @return {Vector2} A reference to this vector.
	   */
	  subVectors(a, b) {
	    this.x = a.x - b.x;
	    this.y = a.y - b.y;
	    return this;
	  }

	  /**
	   * Multiplies the given vector with this instance.
	   *
	   * @param {Vector2} v - The vector to multiply.
	   * @return {Vector2} A reference to this vector.
	   */
	  multiply(v) {
	    this.x *= v.x;
	    this.y *= v.y;
	    return this;
	  }

	  /**
	   * Multiplies the given scalar value with all components of this instance.
	   *
	   * @param {number} scalar - The scalar to multiply.
	   * @return {Vector2} A reference to this vector.
	   */
	  multiplyScalar(scalar) {
	    this.x *= scalar;
	    this.y *= scalar;
	    return this;
	  }

	  /**
	   * Divides this instance by the given vector.
	   *
	   * @param {Vector2} v - The vector to divide.
	   * @return {Vector2} A reference to this vector.
	   */
	  divide(v) {
	    this.x /= v.x;
	    this.y /= v.y;
	    return this;
	  }

	  /**
	   * Divides this vector by the given scalar.
	   *
	   * @param {number} scalar - The scalar to divide.
	   * @return {Vector2} A reference to this vector.
	   */
	  divideScalar(scalar) {
	    return this.multiplyScalar(1 / scalar);
	  }

	  /**
	   * Multiplies this vector (with an implicit 1 as the 3rd component) by
	   * the given 3x3 matrix.
	   *
	   * @param {Matrix3} m - The matrix to apply.
	   * @return {Vector2} A reference to this vector.
	   */
	  applyMatrix3(m) {
	    const x = this.x,
	      y = this.y;
	    const e = m.elements;
	    this.x = e[0] * x + e[3] * y + e[6];
	    this.y = e[1] * x + e[4] * y + e[7];
	    return this;
	  }

	  /**
	   * If this vector's x or y value is greater than the given vector's x or y
	   * value, replace that value with the corresponding min value.
	   *
	   * @param {Vector2} v - The vector.
	   * @return {Vector2} A reference to this vector.
	   */
	  min(v) {
	    this.x = Math.min(this.x, v.x);
	    this.y = Math.min(this.y, v.y);
	    return this;
	  }

	  /**
	   * If this vector's x or y value is less than the given vector's x or y
	   * value, replace that value with the corresponding max value.
	   *
	   * @param {Vector2} v - The vector.
	   * @return {Vector2} A reference to this vector.
	   */
	  max(v) {
	    this.x = Math.max(this.x, v.x);
	    this.y = Math.max(this.y, v.y);
	    return this;
	  }

	  /**
	   * If this vector's x or y value is greater than the max vector's x or y
	   * value, it is replaced by the corresponding value.
	   * If this vector's x or y value is less than the min vector's x or y value,
	   * it is replaced by the corresponding value.
	   *
	   * @param {Vector2} min - The minimum x and y values.
	   * @param {Vector2} max - The maximum x and y values in the desired range.
	   * @return {Vector2} A reference to this vector.
	   */
	  clamp(min, max) {
	    // assumes min < max, componentwise

	    this.x = clamp(this.x, min.x, max.x);
	    this.y = clamp(this.y, min.y, max.y);
	    return this;
	  }

	  /**
	   * If this vector's x or y values are greater than the max value, they are
	   * replaced by the max value.
	   * If this vector's x or y values are less than the min value, they are
	   * replaced by the min value.
	   *
	   * @param {number} minVal - The minimum value the components will be clamped to.
	   * @param {number} maxVal - The maximum value the components will be clamped to.
	   * @return {Vector2} A reference to this vector.
	   */
	  clampScalar(minVal, maxVal) {
	    this.x = clamp(this.x, minVal, maxVal);
	    this.y = clamp(this.y, minVal, maxVal);
	    return this;
	  }

	  /**
	   * If this vector's length is greater than the max value, it is replaced by
	   * the max value.
	   * If this vector's length is less than the min value, it is replaced by the
	   * min value.
	   *
	   * @param {number} min - The minimum value the vector length will be clamped to.
	   * @param {number} max - The maximum value the vector length will be clamped to.
	   * @return {Vector2} A reference to this vector.
	   */
	  clampLength(min, max) {
	    const length = this.length();
	    return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
	  }

	  /**
	   * The components of this vector are rounded down to the nearest integer value.
	   *
	   * @return {Vector2} A reference to this vector.
	   */
	  floor() {
	    this.x = Math.floor(this.x);
	    this.y = Math.floor(this.y);
	    return this;
	  }

	  /**
	   * The components of this vector are rounded up to the nearest integer value.
	   *
	   * @return {Vector2} A reference to this vector.
	   */
	  ceil() {
	    this.x = Math.ceil(this.x);
	    this.y = Math.ceil(this.y);
	    return this;
	  }

	  /**
	   * The components of this vector are rounded to the nearest integer value
	   *
	   * @return {Vector2} A reference to this vector.
	   */
	  round() {
	    this.x = Math.round(this.x);
	    this.y = Math.round(this.y);
	    return this;
	  }

	  /**
	   * The components of this vector are rounded towards zero (up if negative,
	   * down if positive) to an integer value.
	   *
	   * @return {Vector2} A reference to this vector.
	   */
	  roundToZero() {
	    this.x = Math.trunc(this.x);
	    this.y = Math.trunc(this.y);
	    return this;
	  }

	  /**
	   * Inverts this vector - i.e. sets x = -x and y = -y.
	   *
	   * @return {Vector2} A reference to this vector.
	   */
	  negate() {
	    this.x = -this.x;
	    this.y = -this.y;
	    return this;
	  }

	  /**
	   * Calculates the dot product of the given vector with this instance.
	   *
	   * @param {Vector2} v - The vector to compute the dot product with.
	   * @return {number} The result of the dot product.
	   */
	  dot(v) {
	    return this.x * v.x + this.y * v.y;
	  }

	  /**
	   * Calculates the cross product of the given vector with this instance.
	   *
	   * @param {Vector2} v - The vector to compute the cross product with.
	   * @return {number} The result of the cross product.
	   */
	  cross(v) {
	    return this.x * v.y - this.y * v.x;
	  }

	  /**
	   * Computes the square of the Euclidean length (straight-line length) from
	   * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
	   * compare the length squared instead as it is slightly more efficient to calculate.
	   *
	   * @return {number} The square length of this vector.
	   */
	  lengthSq() {
	    return this.x * this.x + this.y * this.y;
	  }

	  /**
	   * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
	   *
	   * @return {number} The length of this vector.
	   */
	  length() {
	    return Math.sqrt(this.x * this.x + this.y * this.y);
	  }

	  /**
	   * Computes the Manhattan length of this vector.
	   *
	   * @return {number} The length of this vector.
	   */
	  manhattanLength() {
	    return Math.abs(this.x) + Math.abs(this.y);
	  }

	  /**
	   * Converts this vector to a unit vector - that is, sets it equal to a vector
	   * with the same direction as this one, but with a vector length of `1`.
	   *
	   * @return {Vector2} A reference to this vector.
	   */
	  normalize() {
	    return this.divideScalar(this.length() || 1);
	  }

	  /**
	   * Computes the angle in radians of this vector with respect to the positive x-axis.
	   *
	   * @return {number} The angle in radians.
	   */
	  angle() {
	    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
	    return angle;
	  }

	  /**
	   * Returns the angle between the given vector and this instance in radians.
	   *
	   * @param {Vector2} v - The vector to compute the angle with.
	   * @return {number} The angle in radians.
	   */
	  angleTo(v) {
	    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
	    if (denominator === 0) return Math.PI / 2;
	    const theta = this.dot(v) / denominator;

	    // clamp, to handle numerical problems

	    return Math.acos(clamp(theta, -1, 1));
	  }

	  /**
	   * Computes the distance from the given vector to this instance.
	   *
	   * @param {Vector2} v - The vector to compute the distance to.
	   * @return {number} The distance.
	   */
	  distanceTo(v) {
	    return Math.sqrt(this.distanceToSquared(v));
	  }

	  /**
	   * Computes the squared distance from the given vector to this instance.
	   * If you are just comparing the distance with another distance, you should compare
	   * the distance squared instead as it is slightly more efficient to calculate.
	   *
	   * @param {Vector2} v - The vector to compute the squared distance to.
	   * @return {number} The squared distance.
	   */
	  distanceToSquared(v) {
	    const dx = this.x - v.x,
	      dy = this.y - v.y;
	    return dx * dx + dy * dy;
	  }

	  /**
	   * Computes the Manhattan distance from the given vector to this instance.
	   *
	   * @param {Vector2} v - The vector to compute the Manhattan distance to.
	   * @return {number} The Manhattan distance.
	   */
	  manhattanDistanceTo(v) {
	    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
	  }

	  /**
	   * Sets this vector to a vector with the same direction as this one, but
	   * with the specified length.
	   *
	   * @param {number} length - The new length of this vector.
	   * @return {Vector2} A reference to this vector.
	   */
	  setLength(length) {
	    return this.normalize().multiplyScalar(length);
	  }

	  /**
	   * Linearly interpolates between the given vector and this instance, where
	   * alpha is the percent distance along the line - alpha = 0 will be this
	   * vector, and alpha = 1 will be the given one.
	   *
	   * @param {Vector2} v - The vector to interpolate towards.
	   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	   * @return {Vector2} A reference to this vector.
	   */
	  lerp(v, alpha) {
	    this.x += (v.x - this.x) * alpha;
	    this.y += (v.y - this.y) * alpha;
	    return this;
	  }

	  /**
	   * Linearly interpolates between the given vectors, where alpha is the percent
	   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
	   * be the second one. The result is stored in this instance.
	   *
	   * @param {Vector2} v1 - The first vector.
	   * @param {Vector2} v2 - The second vector.
	   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	   * @return {Vector2} A reference to this vector.
	   */
	  lerpVectors(v1, v2, alpha) {
	    this.x = v1.x + (v2.x - v1.x) * alpha;
	    this.y = v1.y + (v2.y - v1.y) * alpha;
	    return this;
	  }

	  /**
	   * Returns `true` if this vector is equal with the given one.
	   *
	   * @param {Vector2} v - The vector to test for equality.
	   * @return {boolean} Whether this vector is equal with the given one.
	   */
	  equals(v) {
	    return v.x === this.x && v.y === this.y;
	  }

	  /**
	   * Sets this vector's x value to be `array[ offset ]` and y
	   * value to be `array[ offset + 1 ]`.
	   *
	   * @param {Array<number>} array - An array holding the vector component values.
	   * @param {number} [offset=0] - The offset into the array.
	   * @return {Vector2} A reference to this vector.
	   */
	  fromArray(array, offset = 0) {
	    this.x = array[offset];
	    this.y = array[offset + 1];
	    return this;
	  }

	  /**
	   * Writes the components of this vector to the given array. If no array is provided,
	   * the method returns a new instance.
	   *
	   * @param {Array<number>} [array=[]] - The target array holding the vector components.
	   * @param {number} [offset=0] - Index of the first element in the array.
	   * @return {Array<number>} The vector components.
	   */
	  toArray(array = [], offset = 0) {
	    array[offset] = this.x;
	    array[offset + 1] = this.y;
	    return array;
	  }

	  /**
	   * Sets the components of this vector from the given buffer attribute.
	   *
	   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
	   * @param {number} index - The index into the attribute.
	   * @return {Vector2} A reference to this vector.
	   */
	  fromBufferAttribute(attribute, index) {
	    this.x = attribute.getX(index);
	    this.y = attribute.getY(index);
	    return this;
	  }

	  /**
	   * Rotates this vector around the given center by the given angle.
	   *
	   * @param {Vector2} center - The point around which to rotate.
	   * @param {number} angle - The angle to rotate, in radians.
	   * @return {Vector2} A reference to this vector.
	   */
	  rotateAround(center, angle) {
	    const c = Math.cos(angle),
	      s = Math.sin(angle);
	    const x = this.x - center.x;
	    const y = this.y - center.y;
	    this.x = x * c - y * s + center.x;
	    this.y = x * s + y * c + center.y;
	    return this;
	  }

	  /**
	   * Sets each component of this vector to a pseudo-random value between `0` and
	   * `1`, excluding `1`.
	   *
	   * @return {Vector2} A reference to this vector.
	   */
	  random() {
	    this.x = Math.random();
	    this.y = Math.random();
	    return this;
	  }
	  *[Symbol.iterator]() {
	    yield this.x;
	    yield this.y;
	  }
	}

	/**
	 * Represents an axis-aligned bounding box (AABB) in 3D space.
	 */
	class Box3 {
	  /**
	   * Constructs a new bounding box.
	   *
	   * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
	   * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
	   */
	  constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
	    /**
	     * This flag can be used for type testing.
	     *
	     * @type {boolean}
	     * @readonly
	     * @default true
	     */
	    this.isBox3 = true;

	    /**
	     * The lower boundary of the box.
	     *
	     * @type {Vector3}
	     */
	    this.min = min;

	    /**
	     * The upper boundary of the box.
	     *
	     * @type {Vector3}
	     */
	    this.max = max;
	  }

	  /**
	   * Sets the lower and upper boundaries of this box.
	   * Please note that this method only copies the values from the given objects.
	   *
	   * @param {Vector3} min - The lower boundary of the box.
	   * @param {Vector3} max - The upper boundary of the box.
	   * @return {Box3} A reference to this bounding box.
	   */
	  set(min, max) {
	    this.min.copy(min);
	    this.max.copy(max);
	    return this;
	  }

	  /**
	   * Sets the upper and lower bounds of this box so it encloses the position data
	   * in the given array.
	   *
	   * @param {Array<number>} array - An array holding 3D position data.
	   * @return {Box3} A reference to this bounding box.
	   */
	  setFromArray(array) {
	    this.makeEmpty();
	    for (let i = 0, il = array.length; i < il; i += 3) {
	      this.expandByPoint(_vector$2.fromArray(array, i));
	    }
	    return this;
	  }

	  /**
	   * Sets the upper and lower bounds of this box so it encloses the position data
	   * in the given buffer attribute.
	   *
	   * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
	   * @return {Box3} A reference to this bounding box.
	   */
	  setFromBufferAttribute(attribute) {
	    this.makeEmpty();
	    for (let i = 0, il = attribute.count; i < il; i++) {
	      this.expandByPoint(_vector$2.fromBufferAttribute(attribute, i));
	    }
	    return this;
	  }

	  /**
	   * Sets the upper and lower bounds of this box so it encloses the position data
	   * in the given array.
	   *
	   * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
	   * @return {Box3} A reference to this bounding box.
	   */
	  setFromPoints(points) {
	    this.makeEmpty();
	    for (let i = 0, il = points.length; i < il; i++) {
	      this.expandByPoint(points[i]);
	    }
	    return this;
	  }

	  /**
	   * Centers this box on the given center vector and sets this box's width, height and
	   * depth to the given size values.
	   *
	   * @param {Vector3} center - The center of the box.
	   * @param {Vector3} size - The x, y and z dimensions of the box.
	   * @return {Box3} A reference to this bounding box.
	   */
	  setFromCenterAndSize(center, size) {
	    const halfSize = _vector$2.copy(size).multiplyScalar(0.5);
	    this.min.copy(center).sub(halfSize);
	    this.max.copy(center).add(halfSize);
	    return this;
	  }

	  /**
	   * Computes the world-axis-aligned bounding box for the given 3D object
	   * (including its children), accounting for the object's, and children's,
	   * world transforms. The function may result in a larger box than strictly necessary.
	   *
	   * @param {Object3D} object - The 3D object to compute the bounding box for.
	   * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
	   * world-axis-aligned bounding box at the expense of more computation.
	   * @return {Box3} A reference to this bounding box.
	   */
	  setFromObject(object, precise = false) {
	    this.makeEmpty();
	    return this.expandByObject(object, precise);
	  }

	  /**
	   * Returns a new box with copied values from this instance.
	   *
	   * @return {Box3} A clone of this instance.
	   */
	  clone() {
	    return new this.constructor().copy(this);
	  }

	  /**
	   * Copies the values of the given box to this instance.
	   *
	   * @param {Box3} box - The box to copy.
	   * @return {Box3} A reference to this bounding box.
	   */
	  copy(box) {
	    this.min.copy(box.min);
	    this.max.copy(box.max);
	    return this;
	  }

	  /**
	   * Makes this box empty which means in encloses a zero space in 3D.
	   *
	   * @return {Box3} A reference to this bounding box.
	   */
	  makeEmpty() {
	    this.min.x = this.min.y = this.min.z = +Infinity;
	    this.max.x = this.max.y = this.max.z = -Infinity;
	    return this;
	  }

	  /**
	   * Returns true if this box includes zero points within its bounds.
	   * Note that a box with equal lower and upper bounds still includes one
	   * point, the one both bounds share.
	   *
	   * @return {boolean} Whether this box is empty or not.
	   */
	  isEmpty() {
	    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

	    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
	  }

	  /**
	   * Returns the center point of this box.
	   *
	   * @param {Vector3} target - The target vector that is used to store the method's result.
	   * @return {Vector3} The center point.
	   */
	  getCenter(target) {
	    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
	  }

	  /**
	   * Returns the dimensions of this box.
	   *
	   * @param {Vector3} target - The target vector that is used to store the method's result.
	   * @return {Vector3} The size.
	   */
	  getSize(target) {
	    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
	  }

	  /**
	   * Expands the boundaries of this box to include the given point.
	   *
	   * @param {Vector3} point - The point that should be included by the bounding box.
	   * @return {Box3} A reference to this bounding box.
	   */
	  expandByPoint(point) {
	    this.min.min(point);
	    this.max.max(point);
	    return this;
	  }

	  /**
	   * Expands this box equilaterally by the given vector. The width of this
	   * box will be expanded by the x component of the vector in both
	   * directions. The height of this box will be expanded by the y component of
	   * the vector in both directions. The depth of this box will be
	   * expanded by the z component of the vector in both directions.
	   *
	   * @param {Vector3} vector - The vector that should expand the bounding box.
	   * @return {Box3} A reference to this bounding box.
	   */
	  expandByVector(vector) {
	    this.min.sub(vector);
	    this.max.add(vector);
	    return this;
	  }

	  /**
	   * Expands each dimension of the box by the given scalar. If negative, the
	   * dimensions of the box will be contracted.
	   *
	   * @param {number} scalar - The scalar value that should expand the bounding box.
	   * @return {Box3} A reference to this bounding box.
	   */
	  expandByScalar(scalar) {
	    this.min.addScalar(-scalar);
	    this.max.addScalar(scalar);
	    return this;
	  }

	  /**
	   * Expands the boundaries of this box to include the given 3D object and
	   * its children, accounting for the object's, and children's, world
	   * transforms. The function may result in a larger box than strictly
	   * necessary (unless the precise parameter is set to true).
	   *
	   * @param {Object3D} object - The 3D object that should expand the bounding box.
	   * @param {boolean} precise - If set to `true`, the method expands the bounding box
	   * as little as necessary at the expense of more computation.
	   * @return {Box3} A reference to this bounding box.
	   */
	  expandByObject(object, precise = false) {
	    // Computes the world-axis-aligned bounding box of an object (including its children),
	    // accounting for both the object's, and children's, world transforms

	    object.updateWorldMatrix(false, false);
	    const geometry = object.geometry;
	    if (geometry !== undefined) {
	      const positionAttribute = geometry.getAttribute('position');

	      // precise AABB computation based on vertex data requires at least a position attribute.
	      // instancing isn't supported so far and uses the normal (conservative) code path.

	      if (precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true) {
	        for (let i = 0, l = positionAttribute.count; i < l; i++) {
	          if (object.isMesh === true) {
	            object.getVertexPosition(i, _vector$2);
	          } else {
	            _vector$2.fromBufferAttribute(positionAttribute, i);
	          }
	          _vector$2.applyMatrix4(object.matrixWorld);
	          this.expandByPoint(_vector$2);
	        }
	      } else {
	        if (object.boundingBox !== undefined) {
	          // object-level bounding box

	          if (object.boundingBox === null) {
	            object.computeBoundingBox();
	          }
	          _box$2.copy(object.boundingBox);
	        } else {
	          // geometry-level bounding box

	          if (geometry.boundingBox === null) {
	            geometry.computeBoundingBox();
	          }
	          _box$2.copy(geometry.boundingBox);
	        }
	        _box$2.applyMatrix4(object.matrixWorld);
	        this.union(_box$2);
	      }
	    }
	    const children = object.children;
	    for (let i = 0, l = children.length; i < l; i++) {
	      this.expandByObject(children[i], precise);
	    }
	    return this;
	  }

	  /**
	   * Returns `true` if the given point lies within or on the boundaries of this box.
	   *
	   * @param {Vector3} point - The point to test.
	   * @return {boolean} Whether the bounding box contains the given point or not.
	   */
	  containsPoint(point) {
	    return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
	  }

	  /**
	   * Returns `true` if this bounding box includes the entirety of the given bounding box.
	   * If this box and the given one are identical, this function also returns `true`.
	   *
	   * @param {Box3} box - The bounding box to test.
	   * @return {boolean} Whether the bounding box contains the given bounding box or not.
	   */
	  containsBox(box) {
	    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
	  }

	  /**
	   * Returns a point as a proportion of this box's width, height and depth.
	   *
	   * @param {Vector3} point - A point in 3D space.
	   * @param {Vector3} target - The target vector that is used to store the method's result.
	   * @return {Vector3} A point as a proportion of this box's width, height and depth.
	   */
	  getParameter(point, target) {
	    // This can potentially have a divide by zero if the box
	    // has a size dimension of 0.

	    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
	  }

	  /**
	   * Returns `true` if the given bounding box intersects with this bounding box.
	   *
	   * @param {Box3} box - The bounding box to test.
	   * @return {boolean} Whether the given bounding box intersects with this bounding box.
	   */
	  intersectsBox(box) {
	    // using 6 splitting planes to rule out intersections.
	    return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
	  }

	  /**
	   * Returns `true` if the given bounding sphere intersects with this bounding box.
	   *
	   * @param {Sphere} sphere - The bounding sphere to test.
	   * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
	   */
	  intersectsSphere(sphere) {
	    // Find the point on the AABB closest to the sphere center.
	    this.clampPoint(sphere.center, _vector$2);

	    // If that point is inside the sphere, the AABB and sphere intersect.
	    return _vector$2.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
	  }

	  /**
	   * Returns `true` if the given plane intersects with this bounding box.
	   *
	   * @param {Plane} plane - The plane to test.
	   * @return {boolean} Whether the given plane intersects with this bounding box.
	   */
	  intersectsPlane(plane) {
	    // We compute the minimum and maximum dot product values. If those values
	    // are on the same side (back or front) of the plane, then there is no intersection.

	    let min, max;
	    if (plane.normal.x > 0) {
	      min = plane.normal.x * this.min.x;
	      max = plane.normal.x * this.max.x;
	    } else {
	      min = plane.normal.x * this.max.x;
	      max = plane.normal.x * this.min.x;
	    }
	    if (plane.normal.y > 0) {
	      min += plane.normal.y * this.min.y;
	      max += plane.normal.y * this.max.y;
	    } else {
	      min += plane.normal.y * this.max.y;
	      max += plane.normal.y * this.min.y;
	    }
	    if (plane.normal.z > 0) {
	      min += plane.normal.z * this.min.z;
	      max += plane.normal.z * this.max.z;
	    } else {
	      min += plane.normal.z * this.max.z;
	      max += plane.normal.z * this.min.z;
	    }
	    return min <= -plane.constant && max >= -plane.constant;
	  }

	  /**
	   * Returns `true` if the given triangle intersects with this bounding box.
	   *
	   * @param {Triangle} triangle - The triangle to test.
	   * @return {boolean} Whether the given triangle intersects with this bounding box.
	   */
	  intersectsTriangle(triangle) {
	    if (this.isEmpty()) {
	      return false;
	    }

	    // compute box center and extents
	    this.getCenter(_center);
	    _extents.subVectors(this.max, _center);

	    // translate triangle to aabb origin
	    _v0.subVectors(triangle.a, _center);
	    _v1$3.subVectors(triangle.b, _center);
	    _v2$1.subVectors(triangle.c, _center);

	    // compute edge vectors for triangle
	    _f0.subVectors(_v1$3, _v0);
	    _f1.subVectors(_v2$1, _v1$3);
	    _f2.subVectors(_v0, _v2$1);

	    // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
	    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
	    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
	    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
	    if (!satForAxes(axes, _v0, _v1$3, _v2$1, _extents)) {
	      return false;
	    }

	    // test 3 face normals from the aabb
	    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	    if (!satForAxes(axes, _v0, _v1$3, _v2$1, _extents)) {
	      return false;
	    }

	    // finally testing the face normal of the triangle
	    // use already existing triangle edge vectors here
	    _triangleNormal.crossVectors(_f0, _f1);
	    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
	    return satForAxes(axes, _v0, _v1$3, _v2$1, _extents);
	  }

	  /**
	   * Clamps the given point within the bounds of this box.
	   *
	   * @param {Vector3} point - The point to clamp.
	   * @param {Vector3} target - The target vector that is used to store the method's result.
	   * @return {Vector3} The clamped point.
	   */
	  clampPoint(point, target) {
	    return target.copy(point).clamp(this.min, this.max);
	  }

	  /**
	   * Returns the euclidean distance from any edge of this box to the specified point. If
	   * the given point lies inside of this box, the distance will be `0`.
	   *
	   * @param {Vector3} point - The point to compute the distance to.
	   * @return {number} The euclidean distance.
	   */
	  distanceToPoint(point) {
	    return this.clampPoint(point, _vector$2).distanceTo(point);
	  }

	  /**
	   * Returns a bounding sphere that encloses this bounding box.
	   *
	   * @param {Sphere} target - The target sphere that is used to store the method's result.
	   * @return {Sphere} The bounding sphere that encloses this bounding box.
	   */
	  getBoundingSphere(target) {
	    if (this.isEmpty()) {
	      target.makeEmpty();
	    } else {
	      this.getCenter(target.center);
	      target.radius = this.getSize(_vector$2).length() * 0.5;
	    }
	    return target;
	  }

	  /**
	   * Computes the intersection of this bounding box and the given one, setting the upper
	   * bound of this box to the lesser of the two boxes' upper bounds and the
	   * lower bound of this box to the greater of the two boxes' lower bounds. If
	   * there's no overlap, makes this box empty.
	   *
	   * @param {Box3} box - The bounding box to intersect with.
	   * @return {Box3} A reference to this bounding box.
	   */
	  intersect(box) {
	    this.min.max(box.min);
	    this.max.min(box.max);

	    // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
	    if (this.isEmpty()) this.makeEmpty();
	    return this;
	  }

	  /**
	   * Computes the union of this box and another and the given one, setting the upper
	   * bound of this box to the greater of the two boxes' upper bounds and the
	   * lower bound of this box to the lesser of the two boxes' lower bounds.
	   *
	   * @param {Box3} box - The bounding box that will be unioned with this instance.
	   * @return {Box3} A reference to this bounding box.
	   */
	  union(box) {
	    this.min.min(box.min);
	    this.max.max(box.max);
	    return this;
	  }

	  /**
	   * Transforms this bounding box by the given 4x4 transformation matrix.
	   *
	   * @param {Matrix4} matrix - The transformation matrix.
	   * @return {Box3} A reference to this bounding box.
	   */
	  applyMatrix4(matrix) {
	    // transform of empty box is an empty box.
	    if (this.isEmpty()) return this;

	    // NOTE: I am using a binary pattern to specify all 2^3 combinations below
	    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
	    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
	    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
	    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
	    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
	    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
	    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
	    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

	    this.setFromPoints(_points);
	    return this;
	  }

	  /**
	   * Adds the given offset to both the upper and lower bounds of this bounding box,
	   * effectively moving it in 3D space.
	   *
	   * @param {Vector3} offset - The offset that should be used to translate the bounding box.
	   * @return {Box3} A reference to this bounding box.
	   */
	  translate(offset) {
	    this.min.add(offset);
	    this.max.add(offset);
	    return this;
	  }

	  /**
	   * Returns `true` if this bounding box is equal with the given one.
	   *
	   * @param {Box3} box - The box to test for equality.
	   * @return {boolean} Whether this bounding box is equal with the given one.
	   */
	  equals(box) {
	    return box.min.equals(this.min) && box.max.equals(this.max);
	  }

	  /**
	   * Returns a serialized structure of the bounding box.
	   *
	   * @return {Object} Serialized structure with fields representing the object state.
	   */
	  toJSON() {
	    return {
	      min: this.min.toArray(),
	      max: this.max.toArray()
	    };
	  }

	  /**
	   * Returns a serialized structure of the bounding box.
	   *
	   * @param {Object} json - The serialized json to set the box from.
	   * @return {Box3} A reference to this bounding box.
	   */
	  fromJSON(json) {
	    this.min.fromArray(json.min);
	    this.max.fromArray(json.max);
	    return this;
	  }
	}
	const _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];
	const _vector$2 = /*@__PURE__*/new Vector3();
	const _box$2 = /*@__PURE__*/new Box3();

	// triangle centered vertices

	const _v0 = /*@__PURE__*/new Vector3();
	const _v1$3 = /*@__PURE__*/new Vector3();
	const _v2$1 = /*@__PURE__*/new Vector3();

	// triangle edge vectors

	const _f0 = /*@__PURE__*/new Vector3();
	const _f1 = /*@__PURE__*/new Vector3();
	const _f2 = /*@__PURE__*/new Vector3();
	const _center = /*@__PURE__*/new Vector3();
	const _extents = /*@__PURE__*/new Vector3();
	const _triangleNormal = /*@__PURE__*/new Vector3();
	const _testAxis = /*@__PURE__*/new Vector3();
	function satForAxes(axes, v0, v1, v2, extents) {
	  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
	    _testAxis.fromArray(axes, i);
	    // project the aabb onto the separating axis
	    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
	    // project all 3 vertices of the triangle onto the separating axis
	    const p0 = v0.dot(_testAxis);
	    const p1 = v1.dot(_testAxis);
	    const p2 = v2.dot(_testAxis);
	    // actual test, basically see if either of the most extreme of the triangle points intersects r
	    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
	      // points of the projected triangle are outside the projected half-length of the aabb
	      // the axis is separating and we can exit
	      return false;
	    }
	  }
	  return true;
	}

	/**
	 * This modules allows to dispatch event objects on custom JavaScript objects.
	 *
	 * Main repository: [eventdispatcher.js](https://github.com/mrdoob/eventdispatcher.js/)
	 *
	 * Code Example:
	 * ```js
	 * class Car extends EventDispatcher {
	 * 	start() {
	 *		this.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );
	 *	}
	 *};
	 *
	 * // Using events with the custom object
	 * const car = new Car();
	 * car.addEventListener( 'start', function ( event ) {
	 * 	alert( event.message );
	 * } );
	 *
	 * car.start();
	 * ```
	 */
	class EventDispatcher {
	  /**
	   * Adds the given event listener to the given event type.
	   *
	   * @param {string} type - The type of event to listen to.
	   * @param {Function} listener - The function that gets called when the event is fired.
	   */
	  addEventListener(type, listener) {
	    if (this._listeners === undefined) this._listeners = {};
	    const listeners = this._listeners;
	    if (listeners[type] === undefined) {
	      listeners[type] = [];
	    }
	    if (listeners[type].indexOf(listener) === -1) {
	      listeners[type].push(listener);
	    }
	  }

	  /**
	   * Returns `true` if the given event listener has been added to the given event type.
	   *
	   * @param {string} type - The type of event.
	   * @param {Function} listener - The listener to check.
	   * @return {boolean} Whether the given event listener has been added to the given event type.
	   */
	  hasEventListener(type, listener) {
	    const listeners = this._listeners;
	    if (listeners === undefined) return false;
	    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
	  }

	  /**
	   * Removes the given event listener from the given event type.
	   *
	   * @param {string} type - The type of event.
	   * @param {Function} listener - The listener to remove.
	   */
	  removeEventListener(type, listener) {
	    const listeners = this._listeners;
	    if (listeners === undefined) return;
	    const listenerArray = listeners[type];
	    if (listenerArray !== undefined) {
	      const index = listenerArray.indexOf(listener);
	      if (index !== -1) {
	        listenerArray.splice(index, 1);
	      }
	    }
	  }

	  /**
	   * Dispatches an event object.
	   *
	   * @param {Object} event - The event that gets fired.
	   */
	  dispatchEvent(event) {
	    const listeners = this._listeners;
	    if (listeners === undefined) return;
	    const listenerArray = listeners[event.type];
	    if (listenerArray !== undefined) {
	      event.target = this;

	      // Make a copy, in case listeners are removed while iterating.
	      const array = listenerArray.slice(0);
	      for (let i = 0, l = array.length; i < l; i++) {
	        array[i].call(this, event);
	      }
	      event.target = null;
	    }
	  }
	}

	/**
	 * A float data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const FloatType = 1015;

	/**
	 * The contents are intended to be specified once by the application, and used many
	 * times as the source for drawing and image specification commands.
	 *
	 * @type {number}
	 * @constant
	 */
	const StaticDrawUsage = 35044;

	/**
	 * WebGL coordinate system.
	 *
	 * @type {number}
	 * @constant
	 */
	const WebGLCoordinateSystem = 2000;

	/**
	 * WebGPU coordinate system.
	 *
	 * @type {number}
	 * @constant
	 */
	const WebGPUCoordinateSystem = 2001;

	/**
	 * This type represents mouse buttons and interaction types in context of controls.
	 *
	 * @typedef {Object} ConstantsMouse
	 * @property {number} MIDDLE - The left mouse button.
	 * @property {number} LEFT - The middle mouse button.
	 * @property {number} RIGHT - The right mouse button.
	 * @property {number} ROTATE - A rotate interaction.
	 * @property {number} DOLLY - A dolly interaction.
	 * @property {number} PAN - A pan interaction.
	 **/

	/**
	 * This type represents touch interaction types in context of controls.
	 *
	 * @typedef {Object} ConstantsTouch
	 * @property {number} ROTATE - A rotate interaction.
	 * @property {number} PAN - A pan interaction.
	 * @property {number} DOLLY_PAN - The dolly-pan interaction.
	 * @property {number} DOLLY_ROTATE - A dolly-rotate interaction.
	 **/

	/**
	 * This type represents the different timestamp query types.
	 *
	 * @typedef {Object} ConstantsTimestampQuery
	 * @property {string} COMPUTE - A `compute` timestamp query.
	 * @property {string} RENDER - A `render` timestamp query.
	 **/

	/**
	 * Represents the different interpolation sampling types.
	 *
	 * @typedef {Object} ConstantsInterpolationSamplingType
	 * @property {string} PERSPECTIVE - Perspective-correct interpolation.
	 * @property {string} LINEAR - Linear interpolation.
	 * @property {string} FLAT - Flat interpolation.
	 */

	/**
	 * Represents the different interpolation sampling modes.
	 *
	 * @typedef {Object} ConstantsInterpolationSamplingMode
	 * @property {string} NORMAL - Normal sampling mode.
	 * @property {string} CENTROID - Centroid sampling mode.
	 * @property {string} SAMPLE - Sample-specific sampling mode.
	 * @property {string} FIRST - Flat interpolation using the first vertex.
	 * @property {string} EITHER - Flat interpolation using either vertex.
	 */

	const _vector$1 = /*@__PURE__*/new Vector3();
	const _vector2 = /*@__PURE__*/new Vector2();
	let _id$1 = 0;

	/**
	 * This class stores data for an attribute (such as vertex positions, face
	 * indices, normals, colors, UVs, and any custom attributes ) associated with
	 * a geometry, which allows for more efficient passing of data to the GPU.
	 *
	 * When working with vector-like data, the `fromBufferAttribute( attribute, index )`
	 * helper methods on vector and color class might be helpful. E.g. {@link Vector3#fromBufferAttribute}.
	 */
	class BufferAttribute {
	  /**
	   * Constructs a new buffer attribute.
	   *
	   * @param {TypedArray} array - The array holding the attribute data.
	   * @param {number} itemSize - The item size.
	   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	   */
	  constructor(array, itemSize, normalized = false) {
	    if (Array.isArray(array)) {
	      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
	    }

	    /**
	     * This flag can be used for type testing.
	     *
	     * @type {boolean}
	     * @readonly
	     * @default true
	     */
	    this.isBufferAttribute = true;

	    /**
	     * The ID of the buffer attribute.
	     *
	     * @name BufferAttribute#id
	     * @type {number}
	     * @readonly
	     */
	    Object.defineProperty(this, 'id', {
	      value: _id$1++
	    });

	    /**
	     * The name of the buffer attribute.
	     *
	     * @type {string}
	     */
	    this.name = '';

	    /**
	     * The array holding the attribute data. It should have `itemSize * numVertices`
	     * elements, where `numVertices` is the number of vertices in the associated geometry.
	     *
	     * @type {TypedArray}
	     */
	    this.array = array;

	    /**
	     * The number of values of the array that should be associated with a particular vertex.
	     * For instance, if this attribute is storing a 3-component vector (such as a position,
	     * normal, or color), then the value should be `3`.
	     *
	     * @type {number}
	     */
	    this.itemSize = itemSize;

	    /**
	     * Represents the number of items this buffer attribute stores. It is internally computed
	     * by dividing the `array` length by the `itemSize`.
	     *
	     * @type {number}
	     * @readonly
	     */
	    this.count = array !== undefined ? array.length / itemSize : 0;

	    /**
	     * Applies to integer data only. Indicates how the underlying data in the buffer maps to
	     * the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
	     * and `normalized` is `true`, the values `0 - +65535` in the array data will be mapped to
	     * `0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
	     * to floats unmodified, i.e. `65535` becomes `65535.0f`.
	     *
	     * @type {boolean}
	     */
	    this.normalized = normalized;

	    /**
	     * Defines the intended usage pattern of the data store for optimization purposes.
	     *
	     * Note: After the initial use of a buffer, its usage cannot be changed. Instead,
	     * instantiate a new one and set the desired usage before the next render.
	     *
	     * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
	     * @default StaticDrawUsage
	     */
	    this.usage = StaticDrawUsage;

	    /**
	     * This can be used to only update some components of stored vectors (for example, just the
	     * component related to color). Use the `addUpdateRange()` function to add ranges to this array.
	     *
	     * @type {Array<Object>}
	     */
	    this.updateRanges = [];

	    /**
	     * Configures the bound GPU type for use in shaders.
	     *
	     * Note: this only has an effect for integer arrays and is not configurable for float arrays.
	     * For lower precision float types, use `Float16BufferAttribute`.
	     *
	     * @type {(FloatType|IntType)}
	     * @default FloatType
	     */
	    this.gpuType = FloatType;

	    /**
	     * A version number, incremented every time the `needsUpdate` is set to `true`.
	     *
	     * @type {number}
	     */
	    this.version = 0;
	  }

	  /**
	   * A callback function that is executed after the renderer has transferred the attribute
	   * array data to the GPU.
	   */
	  onUploadCallback() {}

	  /**
	   * Flag to indicate that this attribute has changed and should be re-sent to
	   * the GPU. Set this to `true` when you modify the value of the array.
	   *
	   * @type {number}
	   * @default false
	   * @param {boolean} value
	   */
	  set needsUpdate(value) {
	    if (value === true) this.version++;
	  }

	  /**
	   * Sets the usage of this buffer attribute.
	   *
	   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
	   * @return {BufferAttribute} A reference to this buffer attribute.
	   */
	  setUsage(value) {
	    this.usage = value;
	    return this;
	  }

	  /**
	   * Adds a range of data in the data array to be updated on the GPU.
	   *
	   * @param {number} start - Position at which to start update.
	   * @param {number} count - The number of components to update.
	   */
	  addUpdateRange(start, count) {
	    this.updateRanges.push({
	      start,
	      count
	    });
	  }

	  /**
	   * Clears the update ranges.
	   */
	  clearUpdateRanges() {
	    this.updateRanges.length = 0;
	  }

	  /**
	   * Copies the values of the given buffer attribute to this instance.
	   *
	   * @param {BufferAttribute} source - The buffer attribute to copy.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  copy(source) {
	    this.name = source.name;
	    this.array = new source.array.constructor(source.array);
	    this.itemSize = source.itemSize;
	    this.count = source.count;
	    this.normalized = source.normalized;
	    this.usage = source.usage;
	    this.gpuType = source.gpuType;
	    return this;
	  }

	  /**
	   * Copies a vector from the given buffer attribute to this one. The start
	   * and destination position in the attribute buffers are represented by the
	   * given indices.
	   *
	   * @param {number} index1 - The destination index into this buffer attribute.
	   * @param {BufferAttribute} attribute - The buffer attribute to copy from.
	   * @param {number} index2 - The source index into the given buffer attribute.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  copyAt(index1, attribute, index2) {
	    index1 *= this.itemSize;
	    index2 *= attribute.itemSize;
	    for (let i = 0, l = this.itemSize; i < l; i++) {
	      this.array[index1 + i] = attribute.array[index2 + i];
	    }
	    return this;
	  }

	  /**
	   * Copies the given array data into this buffer attribute.
	   *
	   * @param {(TypedArray|Array)} array - The array to copy.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  copyArray(array) {
	    this.array.set(array);
	    return this;
	  }

	  /**
	   * Applies the given 3x3 matrix to the given attribute. Works with
	   * item size `2` and `3`.
	   *
	   * @param {Matrix3} m - The matrix to apply.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  applyMatrix3(m) {
	    if (this.itemSize === 2) {
	      for (let i = 0, l = this.count; i < l; i++) {
	        _vector2.fromBufferAttribute(this, i);
	        _vector2.applyMatrix3(m);
	        this.setXY(i, _vector2.x, _vector2.y);
	      }
	    } else if (this.itemSize === 3) {
	      for (let i = 0, l = this.count; i < l; i++) {
	        _vector$1.fromBufferAttribute(this, i);
	        _vector$1.applyMatrix3(m);
	        this.setXYZ(i, _vector$1.x, _vector$1.y, _vector$1.z);
	      }
	    }
	    return this;
	  }

	  /**
	   * Applies the given 4x4 matrix to the given attribute. Only works with
	   * item size `3`.
	   *
	   * @param {Matrix4} m - The matrix to apply.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  applyMatrix4(m) {
	    for (let i = 0, l = this.count; i < l; i++) {
	      _vector$1.fromBufferAttribute(this, i);
	      _vector$1.applyMatrix4(m);
	      this.setXYZ(i, _vector$1.x, _vector$1.y, _vector$1.z);
	    }
	    return this;
	  }

	  /**
	   * Applies the given 3x3 normal matrix to the given attribute. Only works with
	   * item size `3`.
	   *
	   * @param {Matrix3} m - The normal matrix to apply.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  applyNormalMatrix(m) {
	    for (let i = 0, l = this.count; i < l; i++) {
	      _vector$1.fromBufferAttribute(this, i);
	      _vector$1.applyNormalMatrix(m);
	      this.setXYZ(i, _vector$1.x, _vector$1.y, _vector$1.z);
	    }
	    return this;
	  }

	  /**
	   * Applies the given 4x4 matrix to the given attribute. Only works with
	   * item size `3` and with direction vectors.
	   *
	   * @param {Matrix4} m - The matrix to apply.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  transformDirection(m) {
	    for (let i = 0, l = this.count; i < l; i++) {
	      _vector$1.fromBufferAttribute(this, i);
	      _vector$1.transformDirection(m);
	      this.setXYZ(i, _vector$1.x, _vector$1.y, _vector$1.z);
	    }
	    return this;
	  }

	  /**
	   * Sets the given array data in the buffer attribute.
	   *
	   * @param {(TypedArray|Array)} value - The array data to set.
	   * @param {number} [offset=0] - The offset in this buffer attribute's array.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  set(value, offset = 0) {
	    // Matching BufferAttribute constructor, do not normalize the array.
	    this.array.set(value, offset);
	    return this;
	  }

	  /**
	   * Returns the given component of the vector at the given index.
	   *
	   * @param {number} index - The index into the buffer attribute.
	   * @param {number} component - The component index.
	   * @return {number} The returned value.
	   */
	  getComponent(index, component) {
	    let value = this.array[index * this.itemSize + component];
	    if (this.normalized) value = denormalize(value, this.array);
	    return value;
	  }

	  /**
	   * Sets the given value to the given component of the vector at the given index.
	   *
	   * @param {number} index - The index into the buffer attribute.
	   * @param {number} component - The component index.
	   * @param {number} value - The value to set.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  setComponent(index, component, value) {
	    if (this.normalized) value = normalize(value, this.array);
	    this.array[index * this.itemSize + component] = value;
	    return this;
	  }

	  /**
	   * Returns the x component of the vector at the given index.
	   *
	   * @param {number} index - The index into the buffer attribute.
	   * @return {number} The x component.
	   */
	  getX(index) {
	    let x = this.array[index * this.itemSize];
	    if (this.normalized) x = denormalize(x, this.array);
	    return x;
	  }

	  /**
	   * Sets the x component of the vector at the given index.
	   *
	   * @param {number} index - The index into the buffer attribute.
	   * @param {number} x - The value to set.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  setX(index, x) {
	    if (this.normalized) x = normalize(x, this.array);
	    this.array[index * this.itemSize] = x;
	    return this;
	  }

	  /**
	   * Returns the y component of the vector at the given index.
	   *
	   * @param {number} index - The index into the buffer attribute.
	   * @return {number} The y component.
	   */
	  getY(index) {
	    let y = this.array[index * this.itemSize + 1];
	    if (this.normalized) y = denormalize(y, this.array);
	    return y;
	  }

	  /**
	   * Sets the y component of the vector at the given index.
	   *
	   * @param {number} index - The index into the buffer attribute.
	   * @param {number} y - The value to set.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  setY(index, y) {
	    if (this.normalized) y = normalize(y, this.array);
	    this.array[index * this.itemSize + 1] = y;
	    return this;
	  }

	  /**
	   * Returns the z component of the vector at the given index.
	   *
	   * @param {number} index - The index into the buffer attribute.
	   * @return {number} The z component.
	   */
	  getZ(index) {
	    let z = this.array[index * this.itemSize + 2];
	    if (this.normalized) z = denormalize(z, this.array);
	    return z;
	  }

	  /**
	   * Sets the z component of the vector at the given index.
	   *
	   * @param {number} index - The index into the buffer attribute.
	   * @param {number} z - The value to set.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  setZ(index, z) {
	    if (this.normalized) z = normalize(z, this.array);
	    this.array[index * this.itemSize + 2] = z;
	    return this;
	  }

	  /**
	   * Returns the w component of the vector at the given index.
	   *
	   * @param {number} index - The index into the buffer attribute.
	   * @return {number} The w component.
	   */
	  getW(index) {
	    let w = this.array[index * this.itemSize + 3];
	    if (this.normalized) w = denormalize(w, this.array);
	    return w;
	  }

	  /**
	   * Sets the w component of the vector at the given index.
	   *
	   * @param {number} index - The index into the buffer attribute.
	   * @param {number} w - The value to set.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  setW(index, w) {
	    if (this.normalized) w = normalize(w, this.array);
	    this.array[index * this.itemSize + 3] = w;
	    return this;
	  }

	  /**
	   * Sets the x and y component of the vector at the given index.
	   *
	   * @param {number} index - The index into the buffer attribute.
	   * @param {number} x - The value for the x component to set.
	   * @param {number} y - The value for the y component to set.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  setXY(index, x, y) {
	    index *= this.itemSize;
	    if (this.normalized) {
	      x = normalize(x, this.array);
	      y = normalize(y, this.array);
	    }
	    this.array[index + 0] = x;
	    this.array[index + 1] = y;
	    return this;
	  }

	  /**
	   * Sets the x, y and z component of the vector at the given index.
	   *
	   * @param {number} index - The index into the buffer attribute.
	   * @param {number} x - The value for the x component to set.
	   * @param {number} y - The value for the y component to set.
	   * @param {number} z - The value for the z component to set.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  setXYZ(index, x, y, z) {
	    index *= this.itemSize;
	    if (this.normalized) {
	      x = normalize(x, this.array);
	      y = normalize(y, this.array);
	      z = normalize(z, this.array);
	    }
	    this.array[index + 0] = x;
	    this.array[index + 1] = y;
	    this.array[index + 2] = z;
	    return this;
	  }

	  /**
	   * Sets the x, y, z and w component of the vector at the given index.
	   *
	   * @param {number} index - The index into the buffer attribute.
	   * @param {number} x - The value for the x component to set.
	   * @param {number} y - The value for the y component to set.
	   * @param {number} z - The value for the z component to set.
	   * @param {number} w - The value for the w component to set.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  setXYZW(index, x, y, z, w) {
	    index *= this.itemSize;
	    if (this.normalized) {
	      x = normalize(x, this.array);
	      y = normalize(y, this.array);
	      z = normalize(z, this.array);
	      w = normalize(w, this.array);
	    }
	    this.array[index + 0] = x;
	    this.array[index + 1] = y;
	    this.array[index + 2] = z;
	    this.array[index + 3] = w;
	    return this;
	  }

	  /**
	   * Sets the given callback function that is executed after the Renderer has transferred
	   * the attribute array data to the GPU. Can be used to perform clean-up operations after
	   * the upload when attribute data are not needed anymore on the CPU side.
	   *
	   * @param {Function} callback - The `onUpload()` callback.
	   * @return {BufferAttribute} A reference to this instance.
	   */
	  onUpload(callback) {
	    this.onUploadCallback = callback;
	    return this;
	  }

	  /**
	   * Returns a new buffer attribute with copied values from this instance.
	   *
	   * @return {BufferAttribute} A clone of this instance.
	   */
	  clone() {
	    return new this.constructor(this.array, this.itemSize).copy(this);
	  }

	  /**
	   * Serializes the buffer attribute into JSON.
	   *
	   * @return {Object} A JSON object representing the serialized buffer attribute.
	   */
	  toJSON() {
	    const data = {
	      itemSize: this.itemSize,
	      type: this.array.constructor.name,
	      array: Array.from(this.array),
	      normalized: this.normalized
	    };
	    if (this.name !== '') data.name = this.name;
	    if (this.usage !== StaticDrawUsage) data.usage = this.usage;
	    return data;
	  }
	}

	/**
	 * Convenient class that can be used when creating a `UInt16` buffer attribute with
	 * a plain `Array` instance.
	 *
	 * @augments BufferAttribute
	 */
	class Uint16BufferAttribute extends BufferAttribute {
	  /**
	   * Constructs a new buffer attribute.
	   *
	   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
	   * @param {number} itemSize - The item size.
	   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	   */
	  constructor(array, itemSize, normalized) {
	    super(new Uint16Array(array), itemSize, normalized);
	  }
	}

	/**
	 * Convenient class that can be used when creating a `UInt32` buffer attribute with
	 * a plain `Array` instance.
	 *
	 * @augments BufferAttribute
	 */
	class Uint32BufferAttribute extends BufferAttribute {
	  /**
	   * Constructs a new buffer attribute.
	   *
	   * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
	   * @param {number} itemSize - The item size.
	   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	   */
	  constructor(array, itemSize, normalized) {
	    super(new Uint32Array(array), itemSize, normalized);
	  }
	}

	/**
	 * Convenient class that can be used when creating a `Float32` buffer attribute with
	 * a plain `Array` instance.
	 *
	 * @augments BufferAttribute
	 */
	class Float32BufferAttribute extends BufferAttribute {
	  /**
	   * Constructs a new buffer attribute.
	   *
	   * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
	   * @param {number} itemSize - The item size.
	   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	   */
	  constructor(array, itemSize, normalized) {
	    super(new Float32Array(array), itemSize, normalized);
	  }
	}

	const _box$1 = /*@__PURE__*/new Box3();
	const _v1$2 = /*@__PURE__*/new Vector3();
	const _v2 = /*@__PURE__*/new Vector3();

	/**
	 * An analytical 3D sphere defined by a center and radius. This class is mainly
	 * used as a Bounding Sphere for 3D objects.
	 */
	class Sphere {
	  /**
	   * Constructs a new sphere.
	   *
	   * @param {Vector3} [center=(0,0,0)] - The center of the sphere
	   * @param {number} [radius=-1] - The radius of the sphere.
	   */
	  constructor(center = new Vector3(), radius = -1) {
	    /**
	     * This flag can be used for type testing.
	     *
	     * @type {boolean}
	     * @readonly
	     * @default true
	     */
	    this.isSphere = true;

	    /**
	     * The center of the sphere
	     *
	     * @type {Vector3}
	     */
	    this.center = center;

	    /**
	     * The radius of the sphere.
	     *
	     * @type {number}
	     */
	    this.radius = radius;
	  }

	  /**
	   * Sets the sphere's components by copying the given values.
	   *
	   * @param {Vector3} center - The center.
	   * @param {number} radius - The radius.
	   * @return {Sphere} A reference to this sphere.
	   */
	  set(center, radius) {
	    this.center.copy(center);
	    this.radius = radius;
	    return this;
	  }

	  /**
	   * Computes the minimum bounding sphere for list of points.
	   * If the optional center point is given, it is used as the sphere's
	   * center. Otherwise, the center of the axis-aligned bounding box
	   * encompassing the points is calculated.
	   *
	   * @param {Array<Vector3>} points - A list of points in 3D space.
	   * @param {Vector3} [optionalCenter] - The center of the sphere.
	   * @return {Sphere} A reference to this sphere.
	   */
	  setFromPoints(points, optionalCenter) {
	    const center = this.center;
	    if (optionalCenter !== undefined) {
	      center.copy(optionalCenter);
	    } else {
	      _box$1.setFromPoints(points).getCenter(center);
	    }
	    let maxRadiusSq = 0;
	    for (let i = 0, il = points.length; i < il; i++) {
	      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
	    }
	    this.radius = Math.sqrt(maxRadiusSq);
	    return this;
	  }

	  /**
	   * Copies the values of the given sphere to this instance.
	   *
	   * @param {Sphere} sphere - The sphere to copy.
	   * @return {Sphere} A reference to this sphere.
	   */
	  copy(sphere) {
	    this.center.copy(sphere.center);
	    this.radius = sphere.radius;
	    return this;
	  }

	  /**
	   * Returns `true` if the sphere is empty (the radius set to a negative number).
	   *
	   * Spheres with a radius of `0` contain only their center point and are not
	   * considered to be empty.
	   *
	   * @return {boolean} Whether this sphere is empty or not.
	   */
	  isEmpty() {
	    return this.radius < 0;
	  }

	  /**
	   * Makes this sphere empty which means in encloses a zero space in 3D.
	   *
	   * @return {Sphere} A reference to this sphere.
	   */
	  makeEmpty() {
	    this.center.set(0, 0, 0);
	    this.radius = -1;
	    return this;
	  }

	  /**
	   * Returns `true` if this sphere contains the given point inclusive of
	   * the surface of the sphere.
	   *
	   * @param {Vector3} point - The point to check.
	   * @return {boolean} Whether this sphere contains the given point or not.
	   */
	  containsPoint(point) {
	    return point.distanceToSquared(this.center) <= this.radius * this.radius;
	  }

	  /**
	   * Returns the closest distance from the boundary of the sphere to the
	   * given point. If the sphere contains the point, the distance will
	   * be negative.
	   *
	   * @param {Vector3} point - The point to compute the distance to.
	   * @return {number} The distance to the point.
	   */
	  distanceToPoint(point) {
	    return point.distanceTo(this.center) - this.radius;
	  }

	  /**
	   * Returns `true` if this sphere intersects with the given one.
	   *
	   * @param {Sphere} sphere - The sphere to test.
	   * @return {boolean} Whether this sphere intersects with the given one or not.
	   */
	  intersectsSphere(sphere) {
	    const radiusSum = this.radius + sphere.radius;
	    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
	  }

	  /**
	   * Returns `true` if this sphere intersects with the given box.
	   *
	   * @param {Box3} box - The box to test.
	   * @return {boolean} Whether this sphere intersects with the given box or not.
	   */
	  intersectsBox(box) {
	    return box.intersectsSphere(this);
	  }

	  /**
	   * Returns `true` if this sphere intersects with the given plane.
	   *
	   * @param {Plane} plane - The plane to test.
	   * @return {boolean} Whether this sphere intersects with the given plane or not.
	   */
	  intersectsPlane(plane) {
	    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
	  }

	  /**
	   * Clamps a point within the sphere. If the point is outside the sphere, it
	   * will clamp it to the closest point on the edge of the sphere. Points
	   * already inside the sphere will not be affected.
	   *
	   * @param {Vector3} point - The plane to clamp.
	   * @param {Vector3} target - The target vector that is used to store the method's result.
	   * @return {Vector3} The clamped point.
	   */
	  clampPoint(point, target) {
	    const deltaLengthSq = this.center.distanceToSquared(point);
	    target.copy(point);
	    if (deltaLengthSq > this.radius * this.radius) {
	      target.sub(this.center).normalize();
	      target.multiplyScalar(this.radius).add(this.center);
	    }
	    return target;
	  }

	  /**
	   * Returns a bounding box that encloses this sphere.
	   *
	   * @param {Box3} target - The target box that is used to store the method's result.
	   * @return {Box3} The bounding box that encloses this sphere.
	   */
	  getBoundingBox(target) {
	    if (this.isEmpty()) {
	      // Empty sphere produces empty bounding box
	      target.makeEmpty();
	      return target;
	    }
	    target.set(this.center, this.center);
	    target.expandByScalar(this.radius);
	    return target;
	  }

	  /**
	   * Transforms this sphere with the given 4x4 transformation matrix.
	   *
	   * @param {Matrix4} matrix - The transformation matrix.
	   * @return {Sphere} A reference to this sphere.
	   */
	  applyMatrix4(matrix) {
	    this.center.applyMatrix4(matrix);
	    this.radius = this.radius * matrix.getMaxScaleOnAxis();
	    return this;
	  }

	  /**
	   * Translates the sphere's center by the given offset.
	   *
	   * @param {Vector3} offset - The offset.
	   * @return {Sphere} A reference to this sphere.
	   */
	  translate(offset) {
	    this.center.add(offset);
	    return this;
	  }

	  /**
	   * Expands the boundaries of this sphere to include the given point.
	   *
	   * @param {Vector3} point - The point to include.
	   * @return {Sphere} A reference to this sphere.
	   */
	  expandByPoint(point) {
	    if (this.isEmpty()) {
	      this.center.copy(point);
	      this.radius = 0;
	      return this;
	    }
	    _v1$2.subVectors(point, this.center);
	    const lengthSq = _v1$2.lengthSq();
	    if (lengthSq > this.radius * this.radius) {
	      // calculate the minimal sphere

	      const length = Math.sqrt(lengthSq);
	      const delta = (length - this.radius) * 0.5;
	      this.center.addScaledVector(_v1$2, delta / length);
	      this.radius += delta;
	    }
	    return this;
	  }

	  /**
	   * Expands this sphere to enclose both the original sphere and the given sphere.
	   *
	   * @param {Sphere} sphere - The sphere to include.
	   * @return {Sphere} A reference to this sphere.
	   */
	  union(sphere) {
	    if (sphere.isEmpty()) {
	      return this;
	    }
	    if (this.isEmpty()) {
	      this.copy(sphere);
	      return this;
	    }
	    if (this.center.equals(sphere.center) === true) {
	      this.radius = Math.max(this.radius, sphere.radius);
	    } else {
	      _v2.subVectors(sphere.center, this.center).setLength(sphere.radius);
	      this.expandByPoint(_v1$2.copy(sphere.center).add(_v2));
	      this.expandByPoint(_v1$2.copy(sphere.center).sub(_v2));
	    }
	    return this;
	  }

	  /**
	   * Returns `true` if this sphere is equal with the given one.
	   *
	   * @param {Sphere} sphere - The sphere to test for equality.
	   * @return {boolean} Whether this bounding sphere is equal with the given one.
	   */
	  equals(sphere) {
	    return sphere.center.equals(this.center) && sphere.radius === this.radius;
	  }

	  /**
	   * Returns a new sphere with copied values from this instance.
	   *
	   * @return {Sphere} A clone of this instance.
	   */
	  clone() {
	    return new this.constructor().copy(this);
	  }

	  /**
	   * Returns a serialized structure of the bounding sphere.
	   *
	   * @return {Object} Serialized structure with fields representing the object state.
	   */
	  toJSON() {
	    return {
	      radius: this.radius,
	      center: this.center.toArray()
	    };
	  }

	  /**
	   * Returns a serialized structure of the bounding sphere.
	   *
	   * @param {Object} json - The serialized json to set the sphere from.
	   * @return {Box3} A reference to this bounding sphere.
	   */
	  fromJSON(json) {
	    this.radius = json.radius;
	    this.center.fromArray(json.center);
	    return this;
	  }
	}

	/**
	 * Represents a 4x4 matrix.
	 *
	 * The most common use of a 4x4 matrix in 3D computer graphics is as a transformation matrix.
	 * For an introduction to transformation matrices as used in WebGL, check out [this tutorial](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices)
	 *
	 * This allows a 3D vector representing a point in 3D space to undergo
	 * transformations such as translation, rotation, shear, scale, reflection,
	 * orthogonal or perspective projection and so on, by being multiplied by the
	 * matrix. This is known as `applying` the matrix to the vector.
	 *
	 * A Note on Row-Major and Column-Major Ordering:
	 *
	 * The constructor and {@link Matrix3#set} method take arguments in
	 * [row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
	 * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
	 * This means that calling:
	 * ```js
	 * const m = new THREE.Matrix4();
	 * m.set( 11, 12, 13, 14,
	 *        21, 22, 23, 24,
	 *        31, 32, 33, 34,
	 *        41, 42, 43, 44 );
	 * ```
	 * will result in the elements array containing:
	 * ```js
	 * m.elements = [ 11, 21, 31, 41,
	 *                12, 22, 32, 42,
	 *                13, 23, 33, 43,
	 *                14, 24, 34, 44 ];
	 * ```
	 * and internally all calculations are performed using column-major ordering.
	 * However, as the actual ordering makes no difference mathematically and
	 * most people are used to thinking about matrices in row-major order, the
	 * three.js documentation shows matrices in row-major order. Just bear in
	 * mind that if you are reading the source code, you'll have to take the
	 * transpose of any matrices outlined here to make sense of the calculations.
	 */
	class Matrix4 {
	  /**
	   * Constructs a new 4x4 matrix. The arguments are supposed to be
	   * in row-major order. If no arguments are provided, the constructor
	   * initializes the matrix as an identity matrix.
	   *
	   * @param {number} [n11] - 1-1 matrix element.
	   * @param {number} [n12] - 1-2 matrix element.
	   * @param {number} [n13] - 1-3 matrix element.
	   * @param {number} [n14] - 1-4 matrix element.
	   * @param {number} [n21] - 2-1 matrix element.
	   * @param {number} [n22] - 2-2 matrix element.
	   * @param {number} [n23] - 2-3 matrix element.
	   * @param {number} [n24] - 2-4 matrix element.
	   * @param {number} [n31] - 3-1 matrix element.
	   * @param {number} [n32] - 3-2 matrix element.
	   * @param {number} [n33] - 3-3 matrix element.
	   * @param {number} [n34] - 3-4 matrix element.
	   * @param {number} [n41] - 4-1 matrix element.
	   * @param {number} [n42] - 4-2 matrix element.
	   * @param {number} [n43] - 4-3 matrix element.
	   * @param {number} [n44] - 4-4 matrix element.
	   */
	  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
	    /**
	     * This flag can be used for type testing.
	     *
	     * @type {boolean}
	     * @readonly
	     * @default true
	     */
	    Matrix4.prototype.isMatrix4 = true;

	    /**
	     * A column-major list of matrix values.
	     *
	     * @type {Array<number>}
	     */
	    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	    if (n11 !== undefined) {
	      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
	    }
	  }

	  /**
	   * Sets the elements of the matrix.The arguments are supposed to be
	   * in row-major order.
	   *
	   * @param {number} [n11] - 1-1 matrix element.
	   * @param {number} [n12] - 1-2 matrix element.
	   * @param {number} [n13] - 1-3 matrix element.
	   * @param {number} [n14] - 1-4 matrix element.
	   * @param {number} [n21] - 2-1 matrix element.
	   * @param {number} [n22] - 2-2 matrix element.
	   * @param {number} [n23] - 2-3 matrix element.
	   * @param {number} [n24] - 2-4 matrix element.
	   * @param {number} [n31] - 3-1 matrix element.
	   * @param {number} [n32] - 3-2 matrix element.
	   * @param {number} [n33] - 3-3 matrix element.
	   * @param {number} [n34] - 3-4 matrix element.
	   * @param {number} [n41] - 4-1 matrix element.
	   * @param {number} [n42] - 4-2 matrix element.
	   * @param {number} [n43] - 4-3 matrix element.
	   * @param {number} [n44] - 4-4 matrix element.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
	    const te = this.elements;
	    te[0] = n11;
	    te[4] = n12;
	    te[8] = n13;
	    te[12] = n14;
	    te[1] = n21;
	    te[5] = n22;
	    te[9] = n23;
	    te[13] = n24;
	    te[2] = n31;
	    te[6] = n32;
	    te[10] = n33;
	    te[14] = n34;
	    te[3] = n41;
	    te[7] = n42;
	    te[11] = n43;
	    te[15] = n44;
	    return this;
	  }

	  /**
	   * Sets this matrix to the 4x4 identity matrix.
	   *
	   * @return {Matrix4} A reference to this matrix.
	   */
	  identity() {
	    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	    return this;
	  }

	  /**
	   * Returns a matrix with copied values from this instance.
	   *
	   * @return {Matrix4} A clone of this instance.
	   */
	  clone() {
	    return new Matrix4().fromArray(this.elements);
	  }

	  /**
	   * Copies the values of the given matrix to this instance.
	   *
	   * @param {Matrix4} m - The matrix to copy.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  copy(m) {
	    const te = this.elements;
	    const me = m.elements;
	    te[0] = me[0];
	    te[1] = me[1];
	    te[2] = me[2];
	    te[3] = me[3];
	    te[4] = me[4];
	    te[5] = me[5];
	    te[6] = me[6];
	    te[7] = me[7];
	    te[8] = me[8];
	    te[9] = me[9];
	    te[10] = me[10];
	    te[11] = me[11];
	    te[12] = me[12];
	    te[13] = me[13];
	    te[14] = me[14];
	    te[15] = me[15];
	    return this;
	  }

	  /**
	   * Copies the translation component of the given matrix
	   * into this matrix's translation component.
	   *
	   * @param {Matrix4} m - The matrix to copy the translation component.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  copyPosition(m) {
	    const te = this.elements,
	      me = m.elements;
	    te[12] = me[12];
	    te[13] = me[13];
	    te[14] = me[14];
	    return this;
	  }

	  /**
	   * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
	   *
	   * @param {Matrix3} m - The 3x3 matrix.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  setFromMatrix3(m) {
	    const me = m.elements;
	    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
	    return this;
	  }

	  /**
	   * Extracts the basis of this matrix into the three axis vectors provided.
	   *
	   * @param {Vector3} xAxis - The basis's x axis.
	   * @param {Vector3} yAxis - The basis's y axis.
	   * @param {Vector3} zAxis - The basis's z axis.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  extractBasis(xAxis, yAxis, zAxis) {
	    xAxis.setFromMatrixColumn(this, 0);
	    yAxis.setFromMatrixColumn(this, 1);
	    zAxis.setFromMatrixColumn(this, 2);
	    return this;
	  }

	  /**
	   * Sets the given basis vectors to this matrix.
	   *
	   * @param {Vector3} xAxis - The basis's x axis.
	   * @param {Vector3} yAxis - The basis's y axis.
	   * @param {Vector3} zAxis - The basis's z axis.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  makeBasis(xAxis, yAxis, zAxis) {
	    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
	    return this;
	  }

	  /**
	   * Extracts the rotation component of the given matrix
	   * into this matrix's rotation component.
	   *
	   * Note: This method does not support reflection matrices.
	   *
	   * @param {Matrix4} m - The matrix.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  extractRotation(m) {
	    const te = this.elements;
	    const me = m.elements;
	    const scaleX = 1 / _v1$1.setFromMatrixColumn(m, 0).length();
	    const scaleY = 1 / _v1$1.setFromMatrixColumn(m, 1).length();
	    const scaleZ = 1 / _v1$1.setFromMatrixColumn(m, 2).length();
	    te[0] = me[0] * scaleX;
	    te[1] = me[1] * scaleX;
	    te[2] = me[2] * scaleX;
	    te[3] = 0;
	    te[4] = me[4] * scaleY;
	    te[5] = me[5] * scaleY;
	    te[6] = me[6] * scaleY;
	    te[7] = 0;
	    te[8] = me[8] * scaleZ;
	    te[9] = me[9] * scaleZ;
	    te[10] = me[10] * scaleZ;
	    te[11] = 0;
	    te[12] = 0;
	    te[13] = 0;
	    te[14] = 0;
	    te[15] = 1;
	    return this;
	  }

	  /**
	   * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
	   * the rotation specified by the given Euler angles. The rest of
	   * the matrix is set to the identity. Depending on the {@link Euler#order},
	   * there are six possible outcomes. See [this page](https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix)
	   * for a complete list.
	   *
	   * @param {Euler} euler - The Euler angles.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  makeRotationFromEuler(euler) {
	    const te = this.elements;
	    const x = euler.x,
	      y = euler.y,
	      z = euler.z;
	    const a = Math.cos(x),
	      b = Math.sin(x);
	    const c = Math.cos(y),
	      d = Math.sin(y);
	    const e = Math.cos(z),
	      f = Math.sin(z);
	    if (euler.order === 'XYZ') {
	      const ae = a * e,
	        af = a * f,
	        be = b * e,
	        bf = b * f;
	      te[0] = c * e;
	      te[4] = -c * f;
	      te[8] = d;
	      te[1] = af + be * d;
	      te[5] = ae - bf * d;
	      te[9] = -b * c;
	      te[2] = bf - ae * d;
	      te[6] = be + af * d;
	      te[10] = a * c;
	    } else if (euler.order === 'YXZ') {
	      const ce = c * e,
	        cf = c * f,
	        de = d * e,
	        df = d * f;
	      te[0] = ce + df * b;
	      te[4] = de * b - cf;
	      te[8] = a * d;
	      te[1] = a * f;
	      te[5] = a * e;
	      te[9] = -b;
	      te[2] = cf * b - de;
	      te[6] = df + ce * b;
	      te[10] = a * c;
	    } else if (euler.order === 'ZXY') {
	      const ce = c * e,
	        cf = c * f,
	        de = d * e,
	        df = d * f;
	      te[0] = ce - df * b;
	      te[4] = -a * f;
	      te[8] = de + cf * b;
	      te[1] = cf + de * b;
	      te[5] = a * e;
	      te[9] = df - ce * b;
	      te[2] = -a * d;
	      te[6] = b;
	      te[10] = a * c;
	    } else if (euler.order === 'ZYX') {
	      const ae = a * e,
	        af = a * f,
	        be = b * e,
	        bf = b * f;
	      te[0] = c * e;
	      te[4] = be * d - af;
	      te[8] = ae * d + bf;
	      te[1] = c * f;
	      te[5] = bf * d + ae;
	      te[9] = af * d - be;
	      te[2] = -d;
	      te[6] = b * c;
	      te[10] = a * c;
	    } else if (euler.order === 'YZX') {
	      const ac = a * c,
	        ad = a * d,
	        bc = b * c,
	        bd = b * d;
	      te[0] = c * e;
	      te[4] = bd - ac * f;
	      te[8] = bc * f + ad;
	      te[1] = f;
	      te[5] = a * e;
	      te[9] = -b * e;
	      te[2] = -d * e;
	      te[6] = ad * f + bc;
	      te[10] = ac - bd * f;
	    } else if (euler.order === 'XZY') {
	      const ac = a * c,
	        ad = a * d,
	        bc = b * c,
	        bd = b * d;
	      te[0] = c * e;
	      te[4] = -f;
	      te[8] = d * e;
	      te[1] = ac * f + bd;
	      te[5] = a * e;
	      te[9] = ad * f - bc;
	      te[2] = bc * f - ad;
	      te[6] = b * e;
	      te[10] = bd * f + ac;
	    }

	    // bottom row
	    te[3] = 0;
	    te[7] = 0;
	    te[11] = 0;

	    // last column
	    te[12] = 0;
	    te[13] = 0;
	    te[14] = 0;
	    te[15] = 1;
	    return this;
	  }

	  /**
	   * Sets the rotation component of this matrix to the rotation specified by
	   * the given Quaternion as outlined [here](https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion)
	   * The rest of the matrix is set to the identity.
	   *
	   * @param {Quaternion} q - The Quaternion.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  makeRotationFromQuaternion(q) {
	    return this.compose(_zero, q, _one);
	  }

	  /**
	   * Sets the rotation component of the transformation matrix, looking from `eye` towards
	   * `target`, and oriented by the up-direction.
	   *
	   * @param {Vector3} eye - The eye vector.
	   * @param {Vector3} target - The target vector.
	   * @param {Vector3} up - The up vector.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  lookAt(eye, target, up) {
	    const te = this.elements;
	    _z.subVectors(eye, target);
	    if (_z.lengthSq() === 0) {
	      // eye and target are in the same position

	      _z.z = 1;
	    }
	    _z.normalize();
	    _x.crossVectors(up, _z);
	    if (_x.lengthSq() === 0) {
	      // up and z are parallel

	      if (Math.abs(up.z) === 1) {
	        _z.x += 0.0001;
	      } else {
	        _z.z += 0.0001;
	      }
	      _z.normalize();
	      _x.crossVectors(up, _z);
	    }
	    _x.normalize();
	    _y.crossVectors(_z, _x);
	    te[0] = _x.x;
	    te[4] = _y.x;
	    te[8] = _z.x;
	    te[1] = _x.y;
	    te[5] = _y.y;
	    te[9] = _z.y;
	    te[2] = _x.z;
	    te[6] = _y.z;
	    te[10] = _z.z;
	    return this;
	  }

	  /**
	   * Post-multiplies this matrix by the given 4x4 matrix.
	   *
	   * @param {Matrix4} m - The matrix to multiply with.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  multiply(m) {
	    return this.multiplyMatrices(this, m);
	  }

	  /**
	   * Pre-multiplies this matrix by the given 4x4 matrix.
	   *
	   * @param {Matrix4} m - The matrix to multiply with.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  premultiply(m) {
	    return this.multiplyMatrices(m, this);
	  }

	  /**
	   * Multiples the given 4x4 matrices and stores the result
	   * in this matrix.
	   *
	   * @param {Matrix4} a - The first matrix.
	   * @param {Matrix4} b - The second matrix.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  multiplyMatrices(a, b) {
	    const ae = a.elements;
	    const be = b.elements;
	    const te = this.elements;
	    const a11 = ae[0],
	      a12 = ae[4],
	      a13 = ae[8],
	      a14 = ae[12];
	    const a21 = ae[1],
	      a22 = ae[5],
	      a23 = ae[9],
	      a24 = ae[13];
	    const a31 = ae[2],
	      a32 = ae[6],
	      a33 = ae[10],
	      a34 = ae[14];
	    const a41 = ae[3],
	      a42 = ae[7],
	      a43 = ae[11],
	      a44 = ae[15];
	    const b11 = be[0],
	      b12 = be[4],
	      b13 = be[8],
	      b14 = be[12];
	    const b21 = be[1],
	      b22 = be[5],
	      b23 = be[9],
	      b24 = be[13];
	    const b31 = be[2],
	      b32 = be[6],
	      b33 = be[10],
	      b34 = be[14];
	    const b41 = be[3],
	      b42 = be[7],
	      b43 = be[11],
	      b44 = be[15];
	    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
	    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
	    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
	    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
	    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
	    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
	    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
	    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
	    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
	    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
	    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
	    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
	    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	    return this;
	  }

	  /**
	   * Multiplies every component of the matrix by the given scalar.
	   *
	   * @param {number} s - The scalar.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  multiplyScalar(s) {
	    const te = this.elements;
	    te[0] *= s;
	    te[4] *= s;
	    te[8] *= s;
	    te[12] *= s;
	    te[1] *= s;
	    te[5] *= s;
	    te[9] *= s;
	    te[13] *= s;
	    te[2] *= s;
	    te[6] *= s;
	    te[10] *= s;
	    te[14] *= s;
	    te[3] *= s;
	    te[7] *= s;
	    te[11] *= s;
	    te[15] *= s;
	    return this;
	  }

	  /**
	   * Computes and returns the determinant of this matrix.
	   *
	   * Based on the method outlined [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html).
	   *
	   * @return {number} The determinant.
	   */
	  determinant() {
	    const te = this.elements;
	    const n11 = te[0],
	      n12 = te[4],
	      n13 = te[8],
	      n14 = te[12];
	    const n21 = te[1],
	      n22 = te[5],
	      n23 = te[9],
	      n24 = te[13];
	    const n31 = te[2],
	      n32 = te[6],
	      n33 = te[10],
	      n34 = te[14];
	    const n41 = te[3],
	      n42 = te[7],
	      n43 = te[11],
	      n44 = te[15];

	    //TODO: make this more efficient

	    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
	  }

	  /**
	   * Transposes this matrix in place.
	   *
	   * @return {Matrix4} A reference to this matrix.
	   */
	  transpose() {
	    const te = this.elements;
	    let tmp;
	    tmp = te[1];
	    te[1] = te[4];
	    te[4] = tmp;
	    tmp = te[2];
	    te[2] = te[8];
	    te[8] = tmp;
	    tmp = te[6];
	    te[6] = te[9];
	    te[9] = tmp;
	    tmp = te[3];
	    te[3] = te[12];
	    te[12] = tmp;
	    tmp = te[7];
	    te[7] = te[13];
	    te[13] = tmp;
	    tmp = te[11];
	    te[11] = te[14];
	    te[14] = tmp;
	    return this;
	  }

	  /**
	   * Sets the position component for this matrix from the given vector,
	   * without affecting the rest of the matrix.
	   *
	   * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
	   * @param {number} y - The y component of the vector.
	   * @param {number} z - The z component of the vector.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  setPosition(x, y, z) {
	    const te = this.elements;
	    if (x.isVector3) {
	      te[12] = x.x;
	      te[13] = x.y;
	      te[14] = x.z;
	    } else {
	      te[12] = x;
	      te[13] = y;
	      te[14] = z;
	    }
	    return this;
	  }

	  /**
	   * Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
	   * You can not invert with a determinant of zero. If you attempt this, the method produces
	   * a zero matrix instead.
	   *
	   * @return {Matrix4} A reference to this matrix.
	   */
	  invert() {
	    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
	    const te = this.elements,
	      n11 = te[0],
	      n21 = te[1],
	      n31 = te[2],
	      n41 = te[3],
	      n12 = te[4],
	      n22 = te[5],
	      n32 = te[6],
	      n42 = te[7],
	      n13 = te[8],
	      n23 = te[9],
	      n33 = te[10],
	      n43 = te[11],
	      n14 = te[12],
	      n24 = te[13],
	      n34 = te[14],
	      n44 = te[15],
	      t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
	      t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
	      t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
	      t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
	    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
	    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	    const detInv = 1 / det;
	    te[0] = t11 * detInv;
	    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
	    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
	    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
	    te[4] = t12 * detInv;
	    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
	    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
	    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
	    te[8] = t13 * detInv;
	    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
	    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
	    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
	    te[12] = t14 * detInv;
	    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
	    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
	    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
	    return this;
	  }

	  /**
	   * Multiplies the columns of this matrix by the given vector.
	   *
	   * @param {Vector3} v - The scale vector.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  scale(v) {
	    const te = this.elements;
	    const x = v.x,
	      y = v.y,
	      z = v.z;
	    te[0] *= x;
	    te[4] *= y;
	    te[8] *= z;
	    te[1] *= x;
	    te[5] *= y;
	    te[9] *= z;
	    te[2] *= x;
	    te[6] *= y;
	    te[10] *= z;
	    te[3] *= x;
	    te[7] *= y;
	    te[11] *= z;
	    return this;
	  }

	  /**
	   * Gets the maximum scale value of the three axes.
	   *
	   * @return {number} The maximum scale.
	   */
	  getMaxScaleOnAxis() {
	    const te = this.elements;
	    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
	    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
	    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
	    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
	  }

	  /**
	   * Sets this matrix as a translation transform from the given vector.
	   *
	   * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
	   * @param {number} y - The amount to translate in the Y axis.
	   * @param {number} z - The amount to translate in the z axis.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  makeTranslation(x, y, z) {
	    if (x.isVector3) {
	      this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
	    } else {
	      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
	    }
	    return this;
	  }

	  /**
	   * Sets this matrix as a rotational transformation around the X axis by
	   * the given angle.
	   *
	   * @param {number} theta - The rotation in radians.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  makeRotationX(theta) {
	    const c = Math.cos(theta),
	      s = Math.sin(theta);
	    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
	    return this;
	  }

	  /**
	   * Sets this matrix as a rotational transformation around the Y axis by
	   * the given angle.
	   *
	   * @param {number} theta - The rotation in radians.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  makeRotationY(theta) {
	    const c = Math.cos(theta),
	      s = Math.sin(theta);
	    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
	    return this;
	  }

	  /**
	   * Sets this matrix as a rotational transformation around the Z axis by
	   * the given angle.
	   *
	   * @param {number} theta - The rotation in radians.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  makeRotationZ(theta) {
	    const c = Math.cos(theta),
	      s = Math.sin(theta);
	    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	    return this;
	  }

	  /**
	   * Sets this matrix as a rotational transformation around the given axis by
	   * the given angle.
	   *
	   * This is a somewhat controversial but mathematically sound alternative to
	   * rotating via Quaternions. See the discussion [here](https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199).
	   *
	   * @param {Vector3} axis - The normalized rotation axis.
	   * @param {number} angle - The rotation in radians.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  makeRotationAxis(axis, angle) {
	    // Based on http://www.gamedev.net/reference/articles/article1199.asp

	    const c = Math.cos(angle);
	    const s = Math.sin(angle);
	    const t = 1 - c;
	    const x = axis.x,
	      y = axis.y,
	      z = axis.z;
	    const tx = t * x,
	      ty = t * y;
	    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
	    return this;
	  }

	  /**
	   * Sets this matrix as a scale transformation.
	   *
	   * @param {number} x - The amount to scale in the X axis.
	   * @param {number} y - The amount to scale in the Y axis.
	   * @param {number} z - The amount to scale in the Z axis.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  makeScale(x, y, z) {
	    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
	    return this;
	  }

	  /**
	   * Sets this matrix as a shear transformation.
	   *
	   * @param {number} xy - The amount to shear X by Y.
	   * @param {number} xz - The amount to shear X by Z.
	   * @param {number} yx - The amount to shear Y by X.
	   * @param {number} yz - The amount to shear Y by Z.
	   * @param {number} zx - The amount to shear Z by X.
	   * @param {number} zy - The amount to shear Z by Y.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  makeShear(xy, xz, yx, yz, zx, zy) {
	    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
	    return this;
	  }

	  /**
	   * Sets this matrix to the transformation composed of the given position,
	   * rotation (Quaternion) and scale.
	   *
	   * @param {Vector3} position - The position vector.
	   * @param {Quaternion} quaternion - The rotation as a Quaternion.
	   * @param {Vector3} scale - The scale vector.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  compose(position, quaternion, scale) {
	    const te = this.elements;
	    const x = quaternion._x,
	      y = quaternion._y,
	      z = quaternion._z,
	      w = quaternion._w;
	    const x2 = x + x,
	      y2 = y + y,
	      z2 = z + z;
	    const xx = x * x2,
	      xy = x * y2,
	      xz = x * z2;
	    const yy = y * y2,
	      yz = y * z2,
	      zz = z * z2;
	    const wx = w * x2,
	      wy = w * y2,
	      wz = w * z2;
	    const sx = scale.x,
	      sy = scale.y,
	      sz = scale.z;
	    te[0] = (1 - (yy + zz)) * sx;
	    te[1] = (xy + wz) * sx;
	    te[2] = (xz - wy) * sx;
	    te[3] = 0;
	    te[4] = (xy - wz) * sy;
	    te[5] = (1 - (xx + zz)) * sy;
	    te[6] = (yz + wx) * sy;
	    te[7] = 0;
	    te[8] = (xz + wy) * sz;
	    te[9] = (yz - wx) * sz;
	    te[10] = (1 - (xx + yy)) * sz;
	    te[11] = 0;
	    te[12] = position.x;
	    te[13] = position.y;
	    te[14] = position.z;
	    te[15] = 1;
	    return this;
	  }

	  /**
	   * Decomposes this matrix into its position, rotation and scale components
	   * and provides the result in the given objects.
	   *
	   * Note: Not all matrices are decomposable in this way. For example, if an
	   * object has a non-uniformly scaled parent, then the object's world matrix
	   * may not be decomposable, and this method may not be appropriate.
	   *
	   * @param {Vector3} position - The position vector.
	   * @param {Quaternion} quaternion - The rotation as a Quaternion.
	   * @param {Vector3} scale - The scale vector.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  decompose(position, quaternion, scale) {
	    const te = this.elements;
	    let sx = _v1$1.set(te[0], te[1], te[2]).length();
	    const sy = _v1$1.set(te[4], te[5], te[6]).length();
	    const sz = _v1$1.set(te[8], te[9], te[10]).length();

	    // if determine is negative, we need to invert one scale
	    const det = this.determinant();
	    if (det < 0) sx = -sx;
	    position.x = te[12];
	    position.y = te[13];
	    position.z = te[14];

	    // scale the rotation part
	    _m1$2.copy(this);
	    const invSX = 1 / sx;
	    const invSY = 1 / sy;
	    const invSZ = 1 / sz;
	    _m1$2.elements[0] *= invSX;
	    _m1$2.elements[1] *= invSX;
	    _m1$2.elements[2] *= invSX;
	    _m1$2.elements[4] *= invSY;
	    _m1$2.elements[5] *= invSY;
	    _m1$2.elements[6] *= invSY;
	    _m1$2.elements[8] *= invSZ;
	    _m1$2.elements[9] *= invSZ;
	    _m1$2.elements[10] *= invSZ;
	    quaternion.setFromRotationMatrix(_m1$2);
	    scale.x = sx;
	    scale.y = sy;
	    scale.z = sz;
	    return this;
	  }

	  /**
	   * Creates a perspective projection matrix. This is used internally by
	   * {@link PerspectiveCamera#updateProjectionMatrix}.
	  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
	   * @param {number} right - Right boundary of the viewing frustum at the near plane.
	   * @param {number} top - Top boundary of the viewing frustum at the near plane.
	   * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
	   * @param {number} near - The distance from the camera to the near plane.
	   * @param {number} far - The distance from the camera to the far plane.
	   * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
	   * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {
	    const te = this.elements;
	    const x = 2 * near / (right - left);
	    const y = 2 * near / (top - bottom);
	    const a = (right + left) / (right - left);
	    const b = (top + bottom) / (top - bottom);
	    let c, d;
	    if (reversedDepth) {
	      c = near / (far - near);
	      d = far * near / (far - near);
	    } else {
	      if (coordinateSystem === WebGLCoordinateSystem) {
	        c = -(far + near) / (far - near);
	        d = -2 * far * near / (far - near);
	      } else if (coordinateSystem === WebGPUCoordinateSystem) {
	        c = -far / (far - near);
	        d = -far * near / (far - near);
	      } else {
	        throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem);
	      }
	    }
	    te[0] = x;
	    te[4] = 0;
	    te[8] = a;
	    te[12] = 0;
	    te[1] = 0;
	    te[5] = y;
	    te[9] = b;
	    te[13] = 0;
	    te[2] = 0;
	    te[6] = 0;
	    te[10] = c;
	    te[14] = d;
	    te[3] = 0;
	    te[7] = 0;
	    te[11] = -1;
	    te[15] = 0;
	    return this;
	  }

	  /**
	   * Creates a orthographic projection matrix. This is used internally by
	   * {@link OrthographicCamera#updateProjectionMatrix}.
	  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
	   * @param {number} right - Right boundary of the viewing frustum at the near plane.
	   * @param {number} top - Top boundary of the viewing frustum at the near plane.
	   * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
	   * @param {number} near - The distance from the camera to the near plane.
	   * @param {number} far - The distance from the camera to the far plane.
	   * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
	   * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {
	    const te = this.elements;
	    const x = 2 / (right - left);
	    const y = 2 / (top - bottom);
	    const a = -(right + left) / (right - left);
	    const b = -(top + bottom) / (top - bottom);
	    let c, d;
	    if (reversedDepth) {
	      c = 1 / (far - near);
	      d = far / (far - near);
	    } else {
	      if (coordinateSystem === WebGLCoordinateSystem) {
	        c = -2 / (far - near);
	        d = -(far + near) / (far - near);
	      } else if (coordinateSystem === WebGPUCoordinateSystem) {
	        c = -1 / (far - near);
	        d = -near / (far - near);
	      } else {
	        throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem);
	      }
	    }
	    te[0] = x;
	    te[4] = 0;
	    te[8] = 0;
	    te[12] = a;
	    te[1] = 0;
	    te[5] = y;
	    te[9] = 0;
	    te[13] = b;
	    te[2] = 0;
	    te[6] = 0;
	    te[10] = c;
	    te[14] = d;
	    te[3] = 0;
	    te[7] = 0;
	    te[11] = 0;
	    te[15] = 1;
	    return this;
	  }

	  /**
	   * Returns `true` if this matrix is equal with the given one.
	   *
	   * @param {Matrix4} matrix - The matrix to test for equality.
	   * @return {boolean} Whether this matrix is equal with the given one.
	   */
	  equals(matrix) {
	    const te = this.elements;
	    const me = matrix.elements;
	    for (let i = 0; i < 16; i++) {
	      if (te[i] !== me[i]) return false;
	    }
	    return true;
	  }

	  /**
	   * Sets the elements of the matrix from the given array.
	   *
	   * @param {Array<number>} array - The matrix elements in column-major order.
	   * @param {number} [offset=0] - Index of the first element in the array.
	   * @return {Matrix4} A reference to this matrix.
	   */
	  fromArray(array, offset = 0) {
	    for (let i = 0; i < 16; i++) {
	      this.elements[i] = array[i + offset];
	    }
	    return this;
	  }

	  /**
	   * Writes the elements of this matrix to the given array. If no array is provided,
	   * the method returns a new instance.
	   *
	   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
	   * @param {number} [offset=0] - Index of the first element in the array.
	   * @return {Array<number>} The matrix elements in column-major order.
	   */
	  toArray(array = [], offset = 0) {
	    const te = this.elements;
	    array[offset] = te[0];
	    array[offset + 1] = te[1];
	    array[offset + 2] = te[2];
	    array[offset + 3] = te[3];
	    array[offset + 4] = te[4];
	    array[offset + 5] = te[5];
	    array[offset + 6] = te[6];
	    array[offset + 7] = te[7];
	    array[offset + 8] = te[8];
	    array[offset + 9] = te[9];
	    array[offset + 10] = te[10];
	    array[offset + 11] = te[11];
	    array[offset + 12] = te[12];
	    array[offset + 13] = te[13];
	    array[offset + 14] = te[14];
	    array[offset + 15] = te[15];
	    return array;
	  }
	}
	const _v1$1 = /*@__PURE__*/new Vector3();
	const _m1$2 = /*@__PURE__*/new Matrix4();
	const _zero = /*@__PURE__*/new Vector3(0, 0, 0);
	const _one = /*@__PURE__*/new Vector3(1, 1, 1);
	const _x = /*@__PURE__*/new Vector3();
	const _y = /*@__PURE__*/new Vector3();
	const _z = /*@__PURE__*/new Vector3();

	const _matrix = /*@__PURE__*/new Matrix4();
	const _quaternion$1 = /*@__PURE__*/new Quaternion();

	/**
	 * A class representing Euler angles.
	 *
	 * Euler angles describe a rotational transformation by rotating an object on
	 * its various axes in specified amounts per axis, and a specified axis
	 * order.
	 *
	 * Iterating through an instance will yield its components (x, y, z,
	 * order) in the corresponding order.
	 *
	 * ```js
	 * const a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );
	 * const b = new THREE.Vector3( 1, 0, 1 );
	 * b.applyEuler(a);
	 * ```
	 */
	class Euler {
	  /**
	   * Constructs a new euler instance.
	   *
	   * @param {number} [x=0] - The angle of the x axis in radians.
	   * @param {number} [y=0] - The angle of the y axis in radians.
	   * @param {number} [z=0] - The angle of the z axis in radians.
	   * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
	   */
	  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
	    /**
	     * This flag can be used for type testing.
	     *
	     * @type {boolean}
	     * @readonly
	     * @default true
	     */
	    this.isEuler = true;
	    this._x = x;
	    this._y = y;
	    this._z = z;
	    this._order = order;
	  }

	  /**
	   * The angle of the x axis in radians.
	   *
	   * @type {number}
	   * @default 0
	   */
	  get x() {
	    return this._x;
	  }
	  set x(value) {
	    this._x = value;
	    this._onChangeCallback();
	  }

	  /**
	   * The angle of the y axis in radians.
	   *
	   * @type {number}
	   * @default 0
	   */
	  get y() {
	    return this._y;
	  }
	  set y(value) {
	    this._y = value;
	    this._onChangeCallback();
	  }

	  /**
	   * The angle of the z axis in radians.
	   *
	   * @type {number}
	   * @default 0
	   */
	  get z() {
	    return this._z;
	  }
	  set z(value) {
	    this._z = value;
	    this._onChangeCallback();
	  }

	  /**
	   * A string representing the order that the rotations are applied.
	   *
	   * @type {string}
	   * @default 'XYZ'
	   */
	  get order() {
	    return this._order;
	  }
	  set order(value) {
	    this._order = value;
	    this._onChangeCallback();
	  }

	  /**
	   * Sets the Euler components.
	   *
	   * @param {number} x - The angle of the x axis in radians.
	   * @param {number} y - The angle of the y axis in radians.
	   * @param {number} z - The angle of the z axis in radians.
	   * @param {string} [order] - A string representing the order that the rotations are applied.
	   * @return {Euler} A reference to this Euler instance.
	   */
	  set(x, y, z, order = this._order) {
	    this._x = x;
	    this._y = y;
	    this._z = z;
	    this._order = order;
	    this._onChangeCallback();
	    return this;
	  }

	  /**
	   * Returns a new Euler instance with copied values from this instance.
	   *
	   * @return {Euler} A clone of this instance.
	   */
	  clone() {
	    return new this.constructor(this._x, this._y, this._z, this._order);
	  }

	  /**
	   * Copies the values of the given Euler instance to this instance.
	   *
	   * @param {Euler} euler - The Euler instance to copy.
	   * @return {Euler} A reference to this Euler instance.
	   */
	  copy(euler) {
	    this._x = euler._x;
	    this._y = euler._y;
	    this._z = euler._z;
	    this._order = euler._order;
	    this._onChangeCallback();
	    return this;
	  }

	  /**
	   * Sets the angles of this Euler instance from a pure rotation matrix.
	   *
	   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
	   * @param {string} [order] - A string representing the order that the rotations are applied.
	   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
	   * @return {Euler} A reference to this Euler instance.
	   */
	  setFromRotationMatrix(m, order = this._order, update = true) {
	    const te = m.elements;
	    const m11 = te[0],
	      m12 = te[4],
	      m13 = te[8];
	    const m21 = te[1],
	      m22 = te[5],
	      m23 = te[9];
	    const m31 = te[2],
	      m32 = te[6],
	      m33 = te[10];
	    switch (order) {
	      case 'XYZ':
	        this._y = Math.asin(clamp(m13, -1, 1));
	        if (Math.abs(m13) < 0.9999999) {
	          this._x = Math.atan2(-m23, m33);
	          this._z = Math.atan2(-m12, m11);
	        } else {
	          this._x = Math.atan2(m32, m22);
	          this._z = 0;
	        }
	        break;
	      case 'YXZ':
	        this._x = Math.asin(-clamp(m23, -1, 1));
	        if (Math.abs(m23) < 0.9999999) {
	          this._y = Math.atan2(m13, m33);
	          this._z = Math.atan2(m21, m22);
	        } else {
	          this._y = Math.atan2(-m31, m11);
	          this._z = 0;
	        }
	        break;
	      case 'ZXY':
	        this._x = Math.asin(clamp(m32, -1, 1));
	        if (Math.abs(m32) < 0.9999999) {
	          this._y = Math.atan2(-m31, m33);
	          this._z = Math.atan2(-m12, m22);
	        } else {
	          this._y = 0;
	          this._z = Math.atan2(m21, m11);
	        }
	        break;
	      case 'ZYX':
	        this._y = Math.asin(-clamp(m31, -1, 1));
	        if (Math.abs(m31) < 0.9999999) {
	          this._x = Math.atan2(m32, m33);
	          this._z = Math.atan2(m21, m11);
	        } else {
	          this._x = 0;
	          this._z = Math.atan2(-m12, m22);
	        }
	        break;
	      case 'YZX':
	        this._z = Math.asin(clamp(m21, -1, 1));
	        if (Math.abs(m21) < 0.9999999) {
	          this._x = Math.atan2(-m23, m22);
	          this._y = Math.atan2(-m31, m11);
	        } else {
	          this._x = 0;
	          this._y = Math.atan2(m13, m33);
	        }
	        break;
	      case 'XZY':
	        this._z = Math.asin(-clamp(m12, -1, 1));
	        if (Math.abs(m12) < 0.9999999) {
	          this._x = Math.atan2(m32, m22);
	          this._y = Math.atan2(m13, m11);
	        } else {
	          this._x = Math.atan2(-m23, m33);
	          this._y = 0;
	        }
	        break;
	      default:
	        warn('Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
	    }
	    this._order = order;
	    if (update === true) this._onChangeCallback();
	    return this;
	  }

	  /**
	   * Sets the angles of this Euler instance from a normalized quaternion.
	   *
	   * @param {Quaternion} q - A normalized Quaternion.
	   * @param {string} [order] - A string representing the order that the rotations are applied.
	   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
	   * @return {Euler} A reference to this Euler instance.
	   */
	  setFromQuaternion(q, order, update) {
	    _matrix.makeRotationFromQuaternion(q);
	    return this.setFromRotationMatrix(_matrix, order, update);
	  }

	  /**
	   * Sets the angles of this Euler instance from the given vector.
	   *
	   * @param {Vector3} v - The vector.
	   * @param {string} [order] - A string representing the order that the rotations are applied.
	   * @return {Euler} A reference to this Euler instance.
	   */
	  setFromVector3(v, order = this._order) {
	    return this.set(v.x, v.y, v.z, order);
	  }

	  /**
	   * Resets the euler angle with a new order by creating a quaternion from this
	   * euler angle and then setting this euler angle with the quaternion and the
	   * new order.
	   *
	   * Warning: This discards revolution information.
	   *
	   * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
	   * @return {Euler} A reference to this Euler instance.
	   */
	  reorder(newOrder) {
	    _quaternion$1.setFromEuler(this);
	    return this.setFromQuaternion(_quaternion$1, newOrder);
	  }

	  /**
	   * Returns `true` if this Euler instance is equal with the given one.
	   *
	   * @param {Euler} euler - The Euler instance to test for equality.
	   * @return {boolean} Whether this Euler instance is equal with the given one.
	   */
	  equals(euler) {
	    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
	  }

	  /**
	   * Sets this Euler instance's components to values from the given array. The first three
	   * entries of the array are assign to the x,y and z components. An optional fourth entry
	   * defines the Euler order.
	   *
	   * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
	   * @return {Euler} A reference to this Euler instance.
	   */
	  fromArray(array) {
	    this._x = array[0];
	    this._y = array[1];
	    this._z = array[2];
	    if (array[3] !== undefined) this._order = array[3];
	    this._onChangeCallback();
	    return this;
	  }

	  /**
	   * Writes the components of this Euler instance to the given array. If no array is provided,
	   * the method returns a new instance.
	   *
	   * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
	   * @param {number} [offset=0] - Index of the first element in the array.
	   * @return {Array<number,number,number,string>} The Euler components.
	   */
	  toArray(array = [], offset = 0) {
	    array[offset] = this._x;
	    array[offset + 1] = this._y;
	    array[offset + 2] = this._z;
	    array[offset + 3] = this._order;
	    return array;
	  }
	  _onChange(callback) {
	    this._onChangeCallback = callback;
	    return this;
	  }
	  _onChangeCallback() {}
	  *[Symbol.iterator]() {
	    yield this._x;
	    yield this._y;
	    yield this._z;
	    yield this._order;
	  }
	}

	/**
	 * The default Euler angle order.
	 *
	 * @static
	 * @type {string}
	 * @default 'XYZ'
	 */
	Euler.DEFAULT_ORDER = 'XYZ';

	/**
	 * A layers object assigns an 3D object to 1 or more of 32
	 * layers numbered `0` to `31` - internally the layers are stored as a
	 * bit mask], and by default all 3D objects are a member of layer `0`.
	 *
	 * This can be used to control visibility - an object must share a layer with
	 * a camera to be visible when that camera's view is
	 * rendered.
	 *
	 * All classes that inherit from {@link Object3D} have an `layers` property which
	 * is an instance of this class.
	 */
	class Layers {
	  /**
	   * Constructs a new layers instance, with membership
	   * initially set to layer `0`.
	   */
	  constructor() {
	    /**
	     * A bit mask storing which of the 32 layers this layers object is currently
	     * a member of.
	     *
	     * @type {number}
	     */
	    this.mask = 1 | 0;
	  }

	  /**
	   * Sets membership to the given layer, and remove membership all other layers.
	   *
	   * @param {number} layer - The layer to set.
	   */
	  set(layer) {
	    this.mask = (1 << layer | 0) >>> 0;
	  }

	  /**
	   * Adds membership of the given layer.
	   *
	   * @param {number} layer - The layer to enable.
	   */
	  enable(layer) {
	    this.mask |= 1 << layer | 0;
	  }

	  /**
	   * Adds membership to all layers.
	   */
	  enableAll() {
	    this.mask = 0xffffffff | 0;
	  }

	  /**
	   * Toggles the membership of the given layer.
	   *
	   * @param {number} layer - The layer to toggle.
	   */
	  toggle(layer) {
	    this.mask ^= 1 << layer | 0;
	  }

	  /**
	   * Removes membership of the given layer.
	   *
	   * @param {number} layer - The layer to enable.
	   */
	  disable(layer) {
	    this.mask &= ~(1 << layer | 0);
	  }

	  /**
	   * Removes the membership from all layers.
	   */
	  disableAll() {
	    this.mask = 0;
	  }

	  /**
	   * Returns `true` if this and the given layers object have at least one
	   * layer in common.
	   *
	   * @param {Layers} layers - The layers to test.
	   * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
	   */
	  test(layers) {
	    return (this.mask & layers.mask) !== 0;
	  }

	  /**
	   * Returns `true` if the given layer is enabled.
	   *
	   * @param {number} layer - The layer to test.
	   * @return {boolean } Whether the given layer is enabled or not.
	   */
	  isEnabled(layer) {
	    return (this.mask & (1 << layer | 0)) !== 0;
	  }
	}

	/**
	 * Represents a 3x3 matrix.
	 *
	 * A Note on Row-Major and Column-Major Ordering:
	 *
	 * The constructor and {@link Matrix3#set} method take arguments in
	 * [row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
	 * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
	 * This means that calling:
	 * ```js
	 * const m = new THREE.Matrix();
	 * m.set( 11, 12, 13,
	 *        21, 22, 23,
	 *        31, 32, 33 );
	 * ```
	 * will result in the elements array containing:
	 * ```js
	 * m.elements = [ 11, 21, 31,
	 *                12, 22, 32,
	 *                13, 23, 33 ];
	 * ```
	 * and internally all calculations are performed using column-major ordering.
	 * However, as the actual ordering makes no difference mathematically and
	 * most people are used to thinking about matrices in row-major order, the
	 * three.js documentation shows matrices in row-major order. Just bear in
	 * mind that if you are reading the source code, you'll have to take the
	 * transpose of any matrices outlined here to make sense of the calculations.
	 */
	class Matrix3 {
	  /**
	   * Constructs a new 3x3 matrix. The arguments are supposed to be
	   * in row-major order. If no arguments are provided, the constructor
	   * initializes the matrix as an identity matrix.
	   *
	   * @param {number} [n11] - 1-1 matrix element.
	   * @param {number} [n12] - 1-2 matrix element.
	   * @param {number} [n13] - 1-3 matrix element.
	   * @param {number} [n21] - 2-1 matrix element.
	   * @param {number} [n22] - 2-2 matrix element.
	   * @param {number} [n23] - 2-3 matrix element.
	   * @param {number} [n31] - 3-1 matrix element.
	   * @param {number} [n32] - 3-2 matrix element.
	   * @param {number} [n33] - 3-3 matrix element.
	   */
	  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
	    /**
	     * This flag can be used for type testing.
	     *
	     * @type {boolean}
	     * @readonly
	     * @default true
	     */
	    Matrix3.prototype.isMatrix3 = true;

	    /**
	     * A column-major list of matrix values.
	     *
	     * @type {Array<number>}
	     */
	    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	    if (n11 !== undefined) {
	      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
	    }
	  }

	  /**
	   * Sets the elements of the matrix.The arguments are supposed to be
	   * in row-major order.
	   *
	   * @param {number} [n11] - 1-1 matrix element.
	   * @param {number} [n12] - 1-2 matrix element.
	   * @param {number} [n13] - 1-3 matrix element.
	   * @param {number} [n21] - 2-1 matrix element.
	   * @param {number} [n22] - 2-2 matrix element.
	   * @param {number} [n23] - 2-3 matrix element.
	   * @param {number} [n31] - 3-1 matrix element.
	   * @param {number} [n32] - 3-2 matrix element.
	   * @param {number} [n33] - 3-3 matrix element.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
	    const te = this.elements;
	    te[0] = n11;
	    te[1] = n21;
	    te[2] = n31;
	    te[3] = n12;
	    te[4] = n22;
	    te[5] = n32;
	    te[6] = n13;
	    te[7] = n23;
	    te[8] = n33;
	    return this;
	  }

	  /**
	   * Sets this matrix to the 3x3 identity matrix.
	   *
	   * @return {Matrix3} A reference to this matrix.
	   */
	  identity() {
	    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
	    return this;
	  }

	  /**
	   * Copies the values of the given matrix to this instance.
	   *
	   * @param {Matrix3} m - The matrix to copy.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  copy(m) {
	    const te = this.elements;
	    const me = m.elements;
	    te[0] = me[0];
	    te[1] = me[1];
	    te[2] = me[2];
	    te[3] = me[3];
	    te[4] = me[4];
	    te[5] = me[5];
	    te[6] = me[6];
	    te[7] = me[7];
	    te[8] = me[8];
	    return this;
	  }

	  /**
	   * Extracts the basis of this matrix into the three axis vectors provided.
	   *
	   * @param {Vector3} xAxis - The basis's x axis.
	   * @param {Vector3} yAxis - The basis's y axis.
	   * @param {Vector3} zAxis - The basis's z axis.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  extractBasis(xAxis, yAxis, zAxis) {
	    xAxis.setFromMatrix3Column(this, 0);
	    yAxis.setFromMatrix3Column(this, 1);
	    zAxis.setFromMatrix3Column(this, 2);
	    return this;
	  }

	  /**
	   * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
	   *
	   * @param {Matrix4} m - The 4x4 matrix.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  setFromMatrix4(m) {
	    const me = m.elements;
	    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
	    return this;
	  }

	  /**
	   * Post-multiplies this matrix by the given 3x3 matrix.
	   *
	   * @param {Matrix3} m - The matrix to multiply with.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  multiply(m) {
	    return this.multiplyMatrices(this, m);
	  }

	  /**
	   * Pre-multiplies this matrix by the given 3x3 matrix.
	   *
	   * @param {Matrix3} m - The matrix to multiply with.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  premultiply(m) {
	    return this.multiplyMatrices(m, this);
	  }

	  /**
	   * Multiples the given 3x3 matrices and stores the result
	   * in this matrix.
	   *
	   * @param {Matrix3} a - The first matrix.
	   * @param {Matrix3} b - The second matrix.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  multiplyMatrices(a, b) {
	    const ae = a.elements;
	    const be = b.elements;
	    const te = this.elements;
	    const a11 = ae[0],
	      a12 = ae[3],
	      a13 = ae[6];
	    const a21 = ae[1],
	      a22 = ae[4],
	      a23 = ae[7];
	    const a31 = ae[2],
	      a32 = ae[5],
	      a33 = ae[8];
	    const b11 = be[0],
	      b12 = be[3],
	      b13 = be[6];
	    const b21 = be[1],
	      b22 = be[4],
	      b23 = be[7];
	    const b31 = be[2],
	      b32 = be[5],
	      b33 = be[8];
	    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
	    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
	    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
	    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
	    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
	    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
	    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
	    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
	    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
	    return this;
	  }

	  /**
	   * Multiplies every component of the matrix by the given scalar.
	   *
	   * @param {number} s - The scalar.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  multiplyScalar(s) {
	    const te = this.elements;
	    te[0] *= s;
	    te[3] *= s;
	    te[6] *= s;
	    te[1] *= s;
	    te[4] *= s;
	    te[7] *= s;
	    te[2] *= s;
	    te[5] *= s;
	    te[8] *= s;
	    return this;
	  }

	  /**
	   * Computes and returns the determinant of this matrix.
	   *
	   * @return {number} The determinant.
	   */
	  determinant() {
	    const te = this.elements;
	    const a = te[0],
	      b = te[1],
	      c = te[2],
	      d = te[3],
	      e = te[4],
	      f = te[5],
	      g = te[6],
	      h = te[7],
	      i = te[8];
	    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	  }

	  /**
	   * Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
	   * You can not invert with a determinant of zero. If you attempt this, the method produces
	   * a zero matrix instead.
	   *
	   * @return {Matrix3} A reference to this matrix.
	   */
	  invert() {
	    const te = this.elements,
	      n11 = te[0],
	      n21 = te[1],
	      n31 = te[2],
	      n12 = te[3],
	      n22 = te[4],
	      n32 = te[5],
	      n13 = te[6],
	      n23 = te[7],
	      n33 = te[8],
	      t11 = n33 * n22 - n32 * n23,
	      t12 = n32 * n13 - n33 * n12,
	      t13 = n23 * n12 - n22 * n13,
	      det = n11 * t11 + n21 * t12 + n31 * t13;
	    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
	    const detInv = 1 / det;
	    te[0] = t11 * detInv;
	    te[1] = (n31 * n23 - n33 * n21) * detInv;
	    te[2] = (n32 * n21 - n31 * n22) * detInv;
	    te[3] = t12 * detInv;
	    te[4] = (n33 * n11 - n31 * n13) * detInv;
	    te[5] = (n31 * n12 - n32 * n11) * detInv;
	    te[6] = t13 * detInv;
	    te[7] = (n21 * n13 - n23 * n11) * detInv;
	    te[8] = (n22 * n11 - n21 * n12) * detInv;
	    return this;
	  }

	  /**
	   * Transposes this matrix in place.
	   *
	   * @return {Matrix3} A reference to this matrix.
	   */
	  transpose() {
	    let tmp;
	    const m = this.elements;
	    tmp = m[1];
	    m[1] = m[3];
	    m[3] = tmp;
	    tmp = m[2];
	    m[2] = m[6];
	    m[6] = tmp;
	    tmp = m[5];
	    m[5] = m[7];
	    m[7] = tmp;
	    return this;
	  }

	  /**
	   * Computes the normal matrix which is the inverse transpose of the upper
	   * left 3x3 portion of the given 4x4 matrix.
	   *
	   * @param {Matrix4} matrix4 - The 4x4 matrix.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  getNormalMatrix(matrix4) {
	    return this.setFromMatrix4(matrix4).invert().transpose();
	  }

	  /**
	   * Transposes this matrix into the supplied array, and returns itself unchanged.
	   *
	   * @param {Array<number>} r - An array to store the transposed matrix elements.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  transposeIntoArray(r) {
	    const m = this.elements;
	    r[0] = m[0];
	    r[1] = m[3];
	    r[2] = m[6];
	    r[3] = m[1];
	    r[4] = m[4];
	    r[5] = m[7];
	    r[6] = m[2];
	    r[7] = m[5];
	    r[8] = m[8];
	    return this;
	  }

	  /**
	   * Sets the UV transform matrix from offset, repeat, rotation, and center.
	   *
	   * @param {number} tx - Offset x.
	   * @param {number} ty - Offset y.
	   * @param {number} sx - Repeat x.
	   * @param {number} sy - Repeat y.
	   * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
	   * @param {number} cx - Center x of rotation.
	   * @param {number} cy - Center y of rotation
	   * @return {Matrix3} A reference to this matrix.
	   */
	  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
	    const c = Math.cos(rotation);
	    const s = Math.sin(rotation);
	    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
	    return this;
	  }

	  /**
	   * Scales this matrix with the given scalar values.
	   *
	   * @param {number} sx - The amount to scale in the X axis.
	   * @param {number} sy - The amount to scale in the Y axis.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  scale(sx, sy) {
	    this.premultiply(_m3.makeScale(sx, sy));
	    return this;
	  }

	  /**
	   * Rotates this matrix by the given angle.
	   *
	   * @param {number} theta - The rotation in radians.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  rotate(theta) {
	    this.premultiply(_m3.makeRotation(-theta));
	    return this;
	  }

	  /**
	   * Translates this matrix by the given scalar values.
	   *
	   * @param {number} tx - The amount to translate in the X axis.
	   * @param {number} ty - The amount to translate in the Y axis.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  translate(tx, ty) {
	    this.premultiply(_m3.makeTranslation(tx, ty));
	    return this;
	  }

	  // for 2D Transforms

	  /**
	   * Sets this matrix as a 2D translation transform.
	   *
	   * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
	   * @param {number} y - The amount to translate in the Y axis.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  makeTranslation(x, y) {
	    if (x.isVector2) {
	      this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
	    } else {
	      this.set(1, 0, x, 0, 1, y, 0, 0, 1);
	    }
	    return this;
	  }

	  /**
	   * Sets this matrix as a 2D rotational transformation.
	   *
	   * @param {number} theta - The rotation in radians.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  makeRotation(theta) {
	    // counterclockwise

	    const c = Math.cos(theta);
	    const s = Math.sin(theta);
	    this.set(c, -s, 0, s, c, 0, 0, 0, 1);
	    return this;
	  }

	  /**
	   * Sets this matrix as a 2D scale transform.
	   *
	   * @param {number} x - The amount to scale in the X axis.
	   * @param {number} y - The amount to scale in the Y axis.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  makeScale(x, y) {
	    this.set(x, 0, 0, 0, y, 0, 0, 0, 1);
	    return this;
	  }

	  /**
	   * Returns `true` if this matrix is equal with the given one.
	   *
	   * @param {Matrix3} matrix - The matrix to test for equality.
	   * @return {boolean} Whether this matrix is equal with the given one.
	   */
	  equals(matrix) {
	    const te = this.elements;
	    const me = matrix.elements;
	    for (let i = 0; i < 9; i++) {
	      if (te[i] !== me[i]) return false;
	    }
	    return true;
	  }

	  /**
	   * Sets the elements of the matrix from the given array.
	   *
	   * @param {Array<number>} array - The matrix elements in column-major order.
	   * @param {number} [offset=0] - Index of the first element in the array.
	   * @return {Matrix3} A reference to this matrix.
	   */
	  fromArray(array, offset = 0) {
	    for (let i = 0; i < 9; i++) {
	      this.elements[i] = array[i + offset];
	    }
	    return this;
	  }

	  /**
	   * Writes the elements of this matrix to the given array. If no array is provided,
	   * the method returns a new instance.
	   *
	   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
	   * @param {number} [offset=0] - Index of the first element in the array.
	   * @return {Array<number>} The matrix elements in column-major order.
	   */
	  toArray(array = [], offset = 0) {
	    const te = this.elements;
	    array[offset] = te[0];
	    array[offset + 1] = te[1];
	    array[offset + 2] = te[2];
	    array[offset + 3] = te[3];
	    array[offset + 4] = te[4];
	    array[offset + 5] = te[5];
	    array[offset + 6] = te[6];
	    array[offset + 7] = te[7];
	    array[offset + 8] = te[8];
	    return array;
	  }

	  /**
	   * Returns a matrix with copied values from this instance.
	   *
	   * @return {Matrix3} A clone of this instance.
	   */
	  clone() {
	    return new this.constructor().fromArray(this.elements);
	  }
	}
	const _m3 = /*@__PURE__*/new Matrix3();

	let _object3DId = 0;
	const _v1 = /*@__PURE__*/new Vector3();
	const _q1 = /*@__PURE__*/new Quaternion();
	const _m1$1 = /*@__PURE__*/new Matrix4();
	const _target = /*@__PURE__*/new Vector3();
	const _position = /*@__PURE__*/new Vector3();
	const _scale = /*@__PURE__*/new Vector3();
	const _quaternion = /*@__PURE__*/new Quaternion();
	const _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);
	const _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);
	const _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);

	/**
	 * Fires when the object has been added to its parent object.
	 *
	 * @event Object3D#added
	 * @type {Object}
	 */
	const _addedEvent = {
	  type: 'added'
	};

	/**
	 * Fires when the object has been removed from its parent object.
	 *
	 * @event Object3D#removed
	 * @type {Object}
	 */
	const _removedEvent = {
	  type: 'removed'
	};

	/**
	 * Fires when a new child object has been added.
	 *
	 * @event Object3D#childadded
	 * @type {Object}
	 */
	const _childaddedEvent = {
	  type: 'childadded',
	  child: null
	};

	/**
	 * Fires when a child object has been removed.
	 *
	 * @event Object3D#childremoved
	 * @type {Object}
	 */
	const _childremovedEvent = {
	  type: 'childremoved',
	  child: null
	};

	/**
	 * This is the base class for most objects in three.js and provides a set of
	 * properties and methods for manipulating objects in 3D space.
	 *
	 * @augments EventDispatcher
	 */
	class Object3D extends EventDispatcher {
	  /**
	   * Constructs a new 3D object.
	   */
	  constructor() {
	    super();

	    /**
	     * This flag can be used for type testing.
	     *
	     * @type {boolean}
	     * @readonly
	     * @default true
	     */
	    this.isObject3D = true;

	    /**
	     * The ID of the 3D object.
	     *
	     * @name Object3D#id
	     * @type {number}
	     * @readonly
	     */
	    Object.defineProperty(this, 'id', {
	      value: _object3DId++
	    });

	    /**
	     * The UUID of the 3D object.
	     *
	     * @type {string}
	     * @readonly
	     */
	    this.uuid = generateUUID();

	    /**
	     * The name of the 3D object.
	     *
	     * @type {string}
	     */
	    this.name = '';

	    /**
	     * The type property is used for detecting the object type
	     * in context of serialization/deserialization.
	     *
	     * @type {string}
	     * @readonly
	     */
	    this.type = 'Object3D';

	    /**
	     * A reference to the parent object.
	     *
	     * @type {?Object3D}
	     * @default null
	     */
	    this.parent = null;

	    /**
	     * An array holding the child 3D objects of this instance.
	     *
	     * @type {Array<Object3D>}
	     */
	    this.children = [];

	    /**
	     * Defines the `up` direction of the 3D object which influences
	     * the orientation via methods like {@link Object3D#lookAt}.
	     *
	     * The default values for all 3D objects is defined by `Object3D.DEFAULT_UP`.
	     *
	     * @type {Vector3}
	     */
	    this.up = Object3D.DEFAULT_UP.clone();
	    const position = new Vector3();
	    const rotation = new Euler();
	    const quaternion = new Quaternion();
	    const scale = new Vector3(1, 1, 1);
	    function onRotationChange() {
	      quaternion.setFromEuler(rotation, false);
	    }
	    function onQuaternionChange() {
	      rotation.setFromQuaternion(quaternion, undefined, false);
	    }
	    rotation._onChange(onRotationChange);
	    quaternion._onChange(onQuaternionChange);
	    Object.defineProperties(this, {
	      /**
	       * Represents the object's local position.
	       *
	       * @name Object3D#position
	       * @type {Vector3}
	       * @default (0,0,0)
	       */
	      position: {
	        configurable: true,
	        enumerable: true,
	        value: position
	      },
	      /**
	       * Represents the object's local rotation as Euler angles, in radians.
	       *
	       * @name Object3D#rotation
	       * @type {Euler}
	       * @default (0,0,0)
	       */
	      rotation: {
	        configurable: true,
	        enumerable: true,
	        value: rotation
	      },
	      /**
	       * Represents the object's local rotation as Quaternions.
	       *
	       * @name Object3D#quaternion
	       * @type {Quaternion}
	       */
	      quaternion: {
	        configurable: true,
	        enumerable: true,
	        value: quaternion
	      },
	      /**
	       * Represents the object's local scale.
	       *
	       * @name Object3D#scale
	       * @type {Vector3}
	       * @default (1,1,1)
	       */
	      scale: {
	        configurable: true,
	        enumerable: true,
	        value: scale
	      },
	      /**
	       * Represents the object's model-view matrix.
	       *
	       * @name Object3D#modelViewMatrix
	       * @type {Matrix4}
	       */
	      modelViewMatrix: {
	        value: new Matrix4()
	      },
	      /**
	       * Represents the object's normal matrix.
	       *
	       * @name Object3D#normalMatrix
	       * @type {Matrix3}
	       */
	      normalMatrix: {
	        value: new Matrix3()
	      }
	    });

	    /**
	     * Represents the object's transformation matrix in local space.
	     *
	     * @type {Matrix4}
	     */
	    this.matrix = new Matrix4();

	    /**
	     * Represents the object's transformation matrix in world space.
	     * If the 3D object has no parent, then it's identical to the local transformation matrix
	     *
	     * @type {Matrix4}
	     */
	    this.matrixWorld = new Matrix4();

	    /**
	     * When set to `true`, the engine automatically computes the local matrix from position,
	     * rotation and scale every frame.
	     *
	     * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_AUTO_UPDATE`.
	     *
	     * @type {boolean}
	     * @default true
	     */
	    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;

	    /**
	     * When set to `true`, the engine automatically computes the world matrix from the current local
	     * matrix and the object's transformation hierarchy.
	     *
	     * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE`.
	     *
	     * @type {boolean}
	     * @default true
	     */
	    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

	    /**
	     * When set to `true`, it calculates the world matrix in that frame and resets this property
	     * to `false`.
	     *
	     * @type {boolean}
	     * @default false
	     */
	    this.matrixWorldNeedsUpdate = false;

	    /**
	     * The layer membership of the 3D object. The 3D object is only visible if it has
	     * at least one layer in common with the camera in use. This property can also be
	     * used to filter out unwanted objects in ray-intersection tests when using {@link Raycaster}.
	     *
	     * @type {Layers}
	     */
	    this.layers = new Layers();

	    /**
	     * When set to `true`, the 3D object gets rendered.
	     *
	     * @type {boolean}
	     * @default true
	     */
	    this.visible = true;

	    /**
	     * When set to `true`, the 3D object gets rendered into shadow maps.
	     *
	     * @type {boolean}
	     * @default false
	     */
	    this.castShadow = false;

	    /**
	     * When set to `true`, the 3D object is affected by shadows in the scene.
	     *
	     * @type {boolean}
	     * @default false
	     */
	    this.receiveShadow = false;

	    /**
	     * When set to `true`, the 3D object is honored by view frustum culling.
	     *
	     * @type {boolean}
	     * @default true
	     */
	    this.frustumCulled = true;

	    /**
	     * This value allows the default rendering order of scene graph objects to be
	     * overridden although opaque and transparent objects remain sorted independently.
	     * When this property is set for an instance of {@link Group},all descendants
	     * objects will be sorted and rendered together. Sorting is from lowest to highest
	     * render order.
	     *
	     * @type {number}
	     * @default 0
	     */
	    this.renderOrder = 0;

	    /**
	     * An array holding the animation clips of the 3D object.
	     *
	     * @type {Array<AnimationClip>}
	     */
	    this.animations = [];

	    /**
	     * Custom depth material to be used when rendering to the depth map. Can only be used
	     * in context of meshes. When shadow-casting with a {@link DirectionalLight} or {@link SpotLight},
	     * if you are modifying vertex positions in the vertex shader you must specify a custom depth
	     * material for proper shadows.
	     *
	     * Only relevant in context of {@link WebGLRenderer}.
	     *
	     * @type {(Material|undefined)}
	     * @default undefined
	     */
	    this.customDepthMaterial = undefined;

	    /**
	     * Same as {@link Object3D#customDepthMaterial}, but used with {@link PointLight}.
	     *
	     * Only relevant in context of {@link WebGLRenderer}.
	     *
	     * @type {(Material|undefined)}
	     * @default undefined
	     */
	    this.customDistanceMaterial = undefined;

	    /**
	     * An object that can be used to store custom data about the 3D object. It
	     * should not hold references to functions as these will not be cloned.
	     *
	     * @type {Object}
	     */
	    this.userData = {};
	  }

	  /**
	   * A callback that is executed immediately before a 3D object is rendered to a shadow map.
	   *
	   * @param {Renderer|WebGLRenderer} renderer - The renderer.
	   * @param {Object3D} object - The 3D object.
	   * @param {Camera} camera - The camera that is used to render the scene.
	   * @param {Camera} shadowCamera - The shadow camera.
	   * @param {BufferGeometry} geometry - The 3D object's geometry.
	   * @param {Material} depthMaterial - The depth material.
	   * @param {Object} group - The geometry group data.
	   */
	  onBeforeShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}

	  /**
	   * A callback that is executed immediately after a 3D object is rendered to a shadow map.
	   *
	   * @param {Renderer|WebGLRenderer} renderer - The renderer.
	   * @param {Object3D} object - The 3D object.
	   * @param {Camera} camera - The camera that is used to render the scene.
	   * @param {Camera} shadowCamera - The shadow camera.
	   * @param {BufferGeometry} geometry - The 3D object's geometry.
	   * @param {Material} depthMaterial - The depth material.
	   * @param {Object} group - The geometry group data.
	   */
	  onAfterShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}

	  /**
	   * A callback that is executed immediately before a 3D object is rendered.
	   *
	   * @param {Renderer|WebGLRenderer} renderer - The renderer.
	   * @param {Object3D} object - The 3D object.
	   * @param {Camera} camera - The camera that is used to render the scene.
	   * @param {BufferGeometry} geometry - The 3D object's geometry.
	   * @param {Material} material - The 3D object's material.
	   * @param {Object} group - The geometry group data.
	   */
	  onBeforeRender(/* renderer, scene, camera, geometry, material, group */) {}

	  /**
	   * A callback that is executed immediately after a 3D object is rendered.
	   *
	   * @param {Renderer|WebGLRenderer} renderer - The renderer.
	   * @param {Object3D} object - The 3D object.
	   * @param {Camera} camera - The camera that is used to render the scene.
	   * @param {BufferGeometry} geometry - The 3D object's geometry.
	   * @param {Material} material - The 3D object's material.
	   * @param {Object} group - The geometry group data.
	   */
	  onAfterRender(/* renderer, scene, camera, geometry, material, group */) {}

	  /**
	   * Applies the given transformation matrix to the object and updates the object's position,
	   * rotation and scale.
	   *
	   * @param {Matrix4} matrix - The transformation matrix.
	   */
	  applyMatrix4(matrix) {
	    if (this.matrixAutoUpdate) this.updateMatrix();
	    this.matrix.premultiply(matrix);
	    this.matrix.decompose(this.position, this.quaternion, this.scale);
	  }

	  /**
	   * Applies a rotation represented by given the quaternion to the 3D object.
	   *
	   * @param {Quaternion} q - The quaternion.
	   * @return {Object3D} A reference to this instance.
	   */
	  applyQuaternion(q) {
	    this.quaternion.premultiply(q);
	    return this;
	  }

	  /**
	   * Sets the given rotation represented as an axis/angle couple to the 3D object.
	   *
	   * @param {Vector3} axis - The (normalized) axis vector.
	   * @param {number} angle - The angle in radians.
	   */
	  setRotationFromAxisAngle(axis, angle) {
	    // assumes axis is normalized

	    this.quaternion.setFromAxisAngle(axis, angle);
	  }

	  /**
	   * Sets the given rotation represented as Euler angles to the 3D object.
	   *
	   * @param {Euler} euler - The Euler angles.
	   */
	  setRotationFromEuler(euler) {
	    this.quaternion.setFromEuler(euler, true);
	  }

	  /**
	   * Sets the given rotation represented as rotation matrix to the 3D object.
	   *
	   * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
	   * a pure rotation matrix (i.e, unscaled).
	   */
	  setRotationFromMatrix(m) {
	    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

	    this.quaternion.setFromRotationMatrix(m);
	  }

	  /**
	   * Sets the given rotation represented as a Quaternion to the 3D object.
	   *
	   * @param {Quaternion} q - The Quaternion
	   */
	  setRotationFromQuaternion(q) {
	    // assumes q is normalized

	    this.quaternion.copy(q);
	  }

	  /**
	   * Rotates the 3D object along an axis in local space.
	   *
	   * @param {Vector3} axis - The (normalized) axis vector.
	   * @param {number} angle - The angle in radians.
	   * @return {Object3D} A reference to this instance.
	   */
	  rotateOnAxis(axis, angle) {
	    // rotate object on axis in object space
	    // axis is assumed to be normalized

	    _q1.setFromAxisAngle(axis, angle);
	    this.quaternion.multiply(_q1);
	    return this;
	  }

	  /**
	   * Rotates the 3D object along an axis in world space.
	   *
	   * @param {Vector3} axis - The (normalized) axis vector.
	   * @param {number} angle - The angle in radians.
	   * @return {Object3D} A reference to this instance.
	   */
	  rotateOnWorldAxis(axis, angle) {
	    // rotate object on axis in world space
	    // axis is assumed to be normalized
	    // method assumes no rotated parent

	    _q1.setFromAxisAngle(axis, angle);
	    this.quaternion.premultiply(_q1);
	    return this;
	  }

	  /**
	   * Rotates the 3D object around its X axis in local space.
	   *
	   * @param {number} angle - The angle in radians.
	   * @return {Object3D} A reference to this instance.
	   */
	  rotateX(angle) {
	    return this.rotateOnAxis(_xAxis, angle);
	  }

	  /**
	   * Rotates the 3D object around its Y axis in local space.
	   *
	   * @param {number} angle - The angle in radians.
	   * @return {Object3D} A reference to this instance.
	   */
	  rotateY(angle) {
	    return this.rotateOnAxis(_yAxis, angle);
	  }

	  /**
	   * Rotates the 3D object around its Z axis in local space.
	   *
	   * @param {number} angle - The angle in radians.
	   * @return {Object3D} A reference to this instance.
	   */
	  rotateZ(angle) {
	    return this.rotateOnAxis(_zAxis, angle);
	  }

	  /**
	   * Translate the 3D object by a distance along the given axis in local space.
	   *
	   * @param {Vector3} axis - The (normalized) axis vector.
	   * @param {number} distance - The distance in world units.
	   * @return {Object3D} A reference to this instance.
	   */
	  translateOnAxis(axis, distance) {
	    // translate object by distance along axis in object space
	    // axis is assumed to be normalized

	    _v1.copy(axis).applyQuaternion(this.quaternion);
	    this.position.add(_v1.multiplyScalar(distance));
	    return this;
	  }

	  /**
	   * Translate the 3D object by a distance along its X-axis in local space.
	   *
	   * @param {number} distance - The distance in world units.
	   * @return {Object3D} A reference to this instance.
	   */
	  translateX(distance) {
	    return this.translateOnAxis(_xAxis, distance);
	  }

	  /**
	   * Translate the 3D object by a distance along its Y-axis in local space.
	   *
	   * @param {number} distance - The distance in world units.
	   * @return {Object3D} A reference to this instance.
	   */
	  translateY(distance) {
	    return this.translateOnAxis(_yAxis, distance);
	  }

	  /**
	   * Translate the 3D object by a distance along its Z-axis in local space.
	   *
	   * @param {number} distance - The distance in world units.
	   * @return {Object3D} A reference to this instance.
	   */
	  translateZ(distance) {
	    return this.translateOnAxis(_zAxis, distance);
	  }

	  /**
	   * Converts the given vector from this 3D object's local space to world space.
	   *
	   * @param {Vector3} vector - The vector to convert.
	   * @return {Vector3} The converted vector.
	   */
	  localToWorld(vector) {
	    this.updateWorldMatrix(true, false);
	    return vector.applyMatrix4(this.matrixWorld);
	  }

	  /**
	   * Converts the given vector from this 3D object's word space to local space.
	   *
	   * @param {Vector3} vector - The vector to convert.
	   * @return {Vector3} The converted vector.
	   */
	  worldToLocal(vector) {
	    this.updateWorldMatrix(true, false);
	    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
	  }

	  /**
	   * Rotates the object to face a point in world space.
	   *
	   * This method does not support objects having non-uniformly-scaled parent(s).
	   *
	   * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
	   * @param {number} [y] - The y coordinate in world space.
	   * @param {number} [z] - The z coordinate in world space.
	   */
	  lookAt(x, y, z) {
	    // This method does not support objects having non-uniformly-scaled parent(s)

	    if (x.isVector3) {
	      _target.copy(x);
	    } else {
	      _target.set(x, y, z);
	    }
	    const parent = this.parent;
	    this.updateWorldMatrix(true, false);
	    _position.setFromMatrixPosition(this.matrixWorld);
	    if (this.isCamera || this.isLight) {
	      _m1$1.lookAt(_position, _target, this.up);
	    } else {
	      _m1$1.lookAt(_target, _position, this.up);
	    }
	    this.quaternion.setFromRotationMatrix(_m1$1);
	    if (parent) {
	      _m1$1.extractRotation(parent.matrixWorld);
	      _q1.setFromRotationMatrix(_m1$1);
	      this.quaternion.premultiply(_q1.invert());
	    }
	  }

	  /**
	   * Adds the given 3D object as a child to this 3D object. An arbitrary number of
	   * objects may be added. Any current parent on an object passed in here will be
	   * removed, since an object can have at most one parent.
	   *
	   * @fires Object3D#added
	   * @fires Object3D#childadded
	   * @param {Object3D} object - The 3D object to add.
	   * @return {Object3D} A reference to this instance.
	   */
	  add(object) {
	    if (arguments.length > 1) {
	      for (let i = 0; i < arguments.length; i++) {
	        this.add(arguments[i]);
	      }
	      return this;
	    }
	    if (object === this) {
	      error('Object3D.add: object can\'t be added as a child of itself.', object);
	      return this;
	    }
	    if (object && object.isObject3D) {
	      object.removeFromParent();
	      object.parent = this;
	      this.children.push(object);
	      object.dispatchEvent(_addedEvent);
	      _childaddedEvent.child = object;
	      this.dispatchEvent(_childaddedEvent);
	      _childaddedEvent.child = null;
	    } else {
	      error('Object3D.add: object not an instance of THREE.Object3D.', object);
	    }
	    return this;
	  }

	  /**
	   * Removes the given 3D object as child from this 3D object.
	   * An arbitrary number of objects may be removed.
	   *
	   * @fires Object3D#removed
	   * @fires Object3D#childremoved
	   * @param {Object3D} object - The 3D object to remove.
	   * @return {Object3D} A reference to this instance.
	   */
	  remove(object) {
	    if (arguments.length > 1) {
	      for (let i = 0; i < arguments.length; i++) {
	        this.remove(arguments[i]);
	      }
	      return this;
	    }
	    const index = this.children.indexOf(object);
	    if (index !== -1) {
	      object.parent = null;
	      this.children.splice(index, 1);
	      object.dispatchEvent(_removedEvent);
	      _childremovedEvent.child = object;
	      this.dispatchEvent(_childremovedEvent);
	      _childremovedEvent.child = null;
	    }
	    return this;
	  }

	  /**
	   * Removes this 3D object from its current parent.
	   *
	   * @fires Object3D#removed
	   * @fires Object3D#childremoved
	   * @return {Object3D} A reference to this instance.
	   */
	  removeFromParent() {
	    const parent = this.parent;
	    if (parent !== null) {
	      parent.remove(this);
	    }
	    return this;
	  }

	  /**
	   * Removes all child objects.
	   *
	   * @fires Object3D#removed
	   * @fires Object3D#childremoved
	   * @return {Object3D} A reference to this instance.
	   */
	  clear() {
	    return this.remove(...this.children);
	  }

	  /**
	   * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
	   * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
	   *
	   * @fires Object3D#added
	   * @fires Object3D#childadded
	   * @param {Object3D} object - The 3D object to attach.
	   * @return {Object3D} A reference to this instance.
	   */
	  attach(object) {
	    // adds object as a child of this, while maintaining the object's world transform

	    // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

	    this.updateWorldMatrix(true, false);
	    _m1$1.copy(this.matrixWorld).invert();
	    if (object.parent !== null) {
	      object.parent.updateWorldMatrix(true, false);
	      _m1$1.multiply(object.parent.matrixWorld);
	    }
	    object.applyMatrix4(_m1$1);
	    object.removeFromParent();
	    object.parent = this;
	    this.children.push(object);
	    object.updateWorldMatrix(false, true);
	    object.dispatchEvent(_addedEvent);
	    _childaddedEvent.child = object;
	    this.dispatchEvent(_childaddedEvent);
	    _childaddedEvent.child = null;
	    return this;
	  }

	  /**
	   * Searches through the 3D object and its children, starting with the 3D object
	   * itself, and returns the first with a matching ID.
	   *
	   * @param {number} id - The id.
	   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
	   */
	  getObjectById(id) {
	    return this.getObjectByProperty('id', id);
	  }

	  /**
	   * Searches through the 3D object and its children, starting with the 3D object
	   * itself, and returns the first with a matching name.
	   *
	   * @param {string} name - The name.
	   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
	   */
	  getObjectByName(name) {
	    return this.getObjectByProperty('name', name);
	  }

	  /**
	   * Searches through the 3D object and its children, starting with the 3D object
	   * itself, and returns the first with a matching property value.
	   *
	   * @param {string} name - The name of the property.
	   * @param {any} value - The value.
	   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
	   */
	  getObjectByProperty(name, value) {
	    if (this[name] === value) return this;
	    for (let i = 0, l = this.children.length; i < l; i++) {
	      const child = this.children[i];
	      const object = child.getObjectByProperty(name, value);
	      if (object !== undefined) {
	        return object;
	      }
	    }
	    return undefined;
	  }

	  /**
	   * Searches through the 3D object and its children, starting with the 3D object
	   * itself, and returns all 3D objects with a matching property value.
	   *
	   * @param {string} name - The name of the property.
	   * @param {any} value - The value.
	   * @param {Array<Object3D>} result - The method stores the result in this array.
	   * @return {Array<Object3D>} The found 3D objects.
	   */
	  getObjectsByProperty(name, value, result = []) {
	    if (this[name] === value) result.push(this);
	    const children = this.children;
	    for (let i = 0, l = children.length; i < l; i++) {
	      children[i].getObjectsByProperty(name, value, result);
	    }
	    return result;
	  }

	  /**
	   * Returns a vector representing the position of the 3D object in world space.
	   *
	   * @param {Vector3} target - The target vector the result is stored to.
	   * @return {Vector3} The 3D object's position in world space.
	   */
	  getWorldPosition(target) {
	    this.updateWorldMatrix(true, false);
	    return target.setFromMatrixPosition(this.matrixWorld);
	  }

	  /**
	   * Returns a Quaternion representing the position of the 3D object in world space.
	   *
	   * @param {Quaternion} target - The target Quaternion the result is stored to.
	   * @return {Quaternion} The 3D object's rotation in world space.
	   */
	  getWorldQuaternion(target) {
	    this.updateWorldMatrix(true, false);
	    this.matrixWorld.decompose(_position, target, _scale);
	    return target;
	  }

	  /**
	   * Returns a vector representing the scale of the 3D object in world space.
	   *
	   * @param {Vector3} target - The target vector the result is stored to.
	   * @return {Vector3} The 3D object's scale in world space.
	   */
	  getWorldScale(target) {
	    this.updateWorldMatrix(true, false);
	    this.matrixWorld.decompose(_position, _quaternion, target);
	    return target;
	  }

	  /**
	   * Returns a vector representing the ("look") direction of the 3D object in world space.
	   *
	   * @param {Vector3} target - The target vector the result is stored to.
	   * @return {Vector3} The 3D object's direction in world space.
	   */
	  getWorldDirection(target) {
	    this.updateWorldMatrix(true, false);
	    const e = this.matrixWorld.elements;
	    return target.set(e[8], e[9], e[10]).normalize();
	  }

	  /**
	   * Abstract method to get intersections between a casted ray and this
	   * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
	   * implement this method in order to use raycasting.
	   *
	   * @abstract
	   * @param {Raycaster} raycaster - The raycaster.
	   * @param {Array<Object>} intersects - An array holding the result of the method.
	   */
	  raycast(/* raycaster, intersects */) {}

	  /**
	   * Executes the callback on this 3D object and all descendants.
	   *
	   * Note: Modifying the scene graph inside the callback is discouraged.
	   *
	   * @param {Function} callback - A callback function that allows to process the current 3D object.
	   */
	  traverse(callback) {
	    callback(this);
	    const children = this.children;
	    for (let i = 0, l = children.length; i < l; i++) {
	      children[i].traverse(callback);
	    }
	  }

	  /**
	   * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
	   * Descendants of invisible 3D objects are not traversed.
	   *
	   * Note: Modifying the scene graph inside the callback is discouraged.
	   *
	   * @param {Function} callback - A callback function that allows to process the current 3D object.
	   */
	  traverseVisible(callback) {
	    if (this.visible === false) return;
	    callback(this);
	    const children = this.children;
	    for (let i = 0, l = children.length; i < l; i++) {
	      children[i].traverseVisible(callback);
	    }
	  }

	  /**
	   * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
	   *
	   * Note: Modifying the scene graph inside the callback is discouraged.
	   *
	   * @param {Function} callback - A callback function that allows to process the current 3D object.
	   */
	  traverseAncestors(callback) {
	    const parent = this.parent;
	    if (parent !== null) {
	      callback(parent);
	      parent.traverseAncestors(callback);
	    }
	  }

	  /**
	   * Updates the transformation matrix in local space by computing it from the current
	   * position, rotation and scale values.
	   */
	  updateMatrix() {
	    this.matrix.compose(this.position, this.quaternion, this.scale);
	    this.matrixWorldNeedsUpdate = true;
	  }

	  /**
	   * Updates the transformation matrix in world space of this 3D objects and its descendants.
	   *
	   * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
	   * local space. The computation of the local and world matrix can be controlled with the
	   * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
	   * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
	   *
	   * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
	   * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
	   */
	  updateMatrixWorld(force) {
	    if (this.matrixAutoUpdate) this.updateMatrix();
	    if (this.matrixWorldNeedsUpdate || force) {
	      if (this.matrixWorldAutoUpdate === true) {
	        if (this.parent === null) {
	          this.matrixWorld.copy(this.matrix);
	        } else {
	          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
	        }
	      }
	      this.matrixWorldNeedsUpdate = false;
	      force = true;
	    }

	    // make sure descendants are updated if required

	    const children = this.children;
	    for (let i = 0, l = children.length; i < l; i++) {
	      const child = children[i];
	      child.updateMatrixWorld(force);
	    }
	  }

	  /**
	   * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
	   * update of ancestor and descendant nodes.
	   *
	   * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
	   * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
	   */
	  updateWorldMatrix(updateParents, updateChildren) {
	    const parent = this.parent;
	    if (updateParents === true && parent !== null) {
	      parent.updateWorldMatrix(true, false);
	    }
	    if (this.matrixAutoUpdate) this.updateMatrix();
	    if (this.matrixWorldAutoUpdate === true) {
	      if (this.parent === null) {
	        this.matrixWorld.copy(this.matrix);
	      } else {
	        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
	      }
	    }

	    // make sure descendants are updated

	    if (updateChildren === true) {
	      const children = this.children;
	      for (let i = 0, l = children.length; i < l; i++) {
	        const child = children[i];
	        child.updateWorldMatrix(false, true);
	      }
	    }
	  }

	  /**
	   * Serializes the 3D object into JSON.
	   *
	   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	   * @return {Object} A JSON object representing the serialized 3D object.
	   * @see {@link ObjectLoader#parse}
	   */
	  toJSON(meta) {
	    // meta is a string when called from JSON.stringify
	    const isRootObject = meta === undefined || typeof meta === 'string';
	    const output = {};

	    // meta is a hash used to collect geometries, materials.
	    // not providing it implies that this is the root object
	    // being serialized.
	    if (isRootObject) {
	      // initialize meta obj
	      meta = {
	        geometries: {},
	        materials: {},
	        textures: {},
	        images: {},
	        shapes: {},
	        skeletons: {},
	        animations: {},
	        nodes: {}
	      };
	      output.metadata = {
	        version: 4.7,
	        type: 'Object',
	        generator: 'Object3D.toJSON'
	      };
	    }

	    // standard Object3D serialization

	    const object = {};
	    object.uuid = this.uuid;
	    object.type = this.type;
	    if (this.name !== '') object.name = this.name;
	    if (this.castShadow === true) object.castShadow = true;
	    if (this.receiveShadow === true) object.receiveShadow = true;
	    if (this.visible === false) object.visible = false;
	    if (this.frustumCulled === false) object.frustumCulled = false;
	    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
	    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
	    object.layers = this.layers.mask;
	    object.matrix = this.matrix.toArray();
	    object.up = this.up.toArray();
	    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

	    // object specific properties

	    if (this.isInstancedMesh) {
	      object.type = 'InstancedMesh';
	      object.count = this.count;
	      object.instanceMatrix = this.instanceMatrix.toJSON();
	      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
	    }
	    if (this.isBatchedMesh) {
	      object.type = 'BatchedMesh';
	      object.perObjectFrustumCulled = this.perObjectFrustumCulled;
	      object.sortObjects = this.sortObjects;
	      object.drawRanges = this._drawRanges;
	      object.reservedRanges = this._reservedRanges;
	      object.geometryInfo = this._geometryInfo.map(info => ({
	        ...info,
	        boundingBox: info.boundingBox ? info.boundingBox.toJSON() : undefined,
	        boundingSphere: info.boundingSphere ? info.boundingSphere.toJSON() : undefined
	      }));
	      object.instanceInfo = this._instanceInfo.map(info => ({
	        ...info
	      }));
	      object.availableInstanceIds = this._availableInstanceIds.slice();
	      object.availableGeometryIds = this._availableGeometryIds.slice();
	      object.nextIndexStart = this._nextIndexStart;
	      object.nextVertexStart = this._nextVertexStart;
	      object.geometryCount = this._geometryCount;
	      object.maxInstanceCount = this._maxInstanceCount;
	      object.maxVertexCount = this._maxVertexCount;
	      object.maxIndexCount = this._maxIndexCount;
	      object.geometryInitialized = this._geometryInitialized;
	      object.matricesTexture = this._matricesTexture.toJSON(meta);
	      object.indirectTexture = this._indirectTexture.toJSON(meta);
	      if (this._colorsTexture !== null) {
	        object.colorsTexture = this._colorsTexture.toJSON(meta);
	      }
	      if (this.boundingSphere !== null) {
	        object.boundingSphere = this.boundingSphere.toJSON();
	      }
	      if (this.boundingBox !== null) {
	        object.boundingBox = this.boundingBox.toJSON();
	      }
	    }

	    //

	    function serialize(library, element) {
	      if (library[element.uuid] === undefined) {
	        library[element.uuid] = element.toJSON(meta);
	      }
	      return element.uuid;
	    }
	    if (this.isScene) {
	      if (this.background) {
	        if (this.background.isColor) {
	          object.background = this.background.toJSON();
	        } else if (this.background.isTexture) {
	          object.background = this.background.toJSON(meta).uuid;
	        }
	      }
	      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
	        object.environment = this.environment.toJSON(meta).uuid;
	      }
	    } else if (this.isMesh || this.isLine || this.isPoints) {
	      object.geometry = serialize(meta.geometries, this.geometry);
	      const parameters = this.geometry.parameters;
	      if (parameters !== undefined && parameters.shapes !== undefined) {
	        const shapes = parameters.shapes;
	        if (Array.isArray(shapes)) {
	          for (let i = 0, l = shapes.length; i < l; i++) {
	            const shape = shapes[i];
	            serialize(meta.shapes, shape);
	          }
	        } else {
	          serialize(meta.shapes, shapes);
	        }
	      }
	    }
	    if (this.isSkinnedMesh) {
	      object.bindMode = this.bindMode;
	      object.bindMatrix = this.bindMatrix.toArray();
	      if (this.skeleton !== undefined) {
	        serialize(meta.skeletons, this.skeleton);
	        object.skeleton = this.skeleton.uuid;
	      }
	    }
	    if (this.material !== undefined) {
	      if (Array.isArray(this.material)) {
	        const uuids = [];
	        for (let i = 0, l = this.material.length; i < l; i++) {
	          uuids.push(serialize(meta.materials, this.material[i]));
	        }
	        object.material = uuids;
	      } else {
	        object.material = serialize(meta.materials, this.material);
	      }
	    }

	    //

	    if (this.children.length > 0) {
	      object.children = [];
	      for (let i = 0; i < this.children.length; i++) {
	        object.children.push(this.children[i].toJSON(meta).object);
	      }
	    }

	    //

	    if (this.animations.length > 0) {
	      object.animations = [];
	      for (let i = 0; i < this.animations.length; i++) {
	        const animation = this.animations[i];
	        object.animations.push(serialize(meta.animations, animation));
	      }
	    }
	    if (isRootObject) {
	      const geometries = extractFromCache(meta.geometries);
	      const materials = extractFromCache(meta.materials);
	      const textures = extractFromCache(meta.textures);
	      const images = extractFromCache(meta.images);
	      const shapes = extractFromCache(meta.shapes);
	      const skeletons = extractFromCache(meta.skeletons);
	      const animations = extractFromCache(meta.animations);
	      const nodes = extractFromCache(meta.nodes);
	      if (geometries.length > 0) output.geometries = geometries;
	      if (materials.length > 0) output.materials = materials;
	      if (textures.length > 0) output.textures = textures;
	      if (images.length > 0) output.images = images;
	      if (shapes.length > 0) output.shapes = shapes;
	      if (skeletons.length > 0) output.skeletons = skeletons;
	      if (animations.length > 0) output.animations = animations;
	      if (nodes.length > 0) output.nodes = nodes;
	    }
	    output.object = object;
	    return output;

	    // extract data from the cache hash
	    // remove metadata on each item
	    // and return as array
	    function extractFromCache(cache) {
	      const values = [];
	      for (const key in cache) {
	        const data = cache[key];
	        delete data.metadata;
	        values.push(data);
	      }
	      return values;
	    }
	  }

	  /**
	   * Returns a new 3D object with copied values from this instance.
	   *
	   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
	   * @return {Object3D} A clone of this instance.
	   */
	  clone(recursive) {
	    return new this.constructor().copy(this, recursive);
	  }

	  /**
	   * Copies the values of the given 3D object to this instance.
	   *
	   * @param {Object3D} source - The 3D object to copy.
	   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
	   * @return {Object3D} A reference to this instance.
	   */
	  copy(source, recursive = true) {
	    this.name = source.name;
	    this.up.copy(source.up);
	    this.position.copy(source.position);
	    this.rotation.order = source.rotation.order;
	    this.quaternion.copy(source.quaternion);
	    this.scale.copy(source.scale);
	    this.matrix.copy(source.matrix);
	    this.matrixWorld.copy(source.matrixWorld);
	    this.matrixAutoUpdate = source.matrixAutoUpdate;
	    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
	    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
	    this.layers.mask = source.layers.mask;
	    this.visible = source.visible;
	    this.castShadow = source.castShadow;
	    this.receiveShadow = source.receiveShadow;
	    this.frustumCulled = source.frustumCulled;
	    this.renderOrder = source.renderOrder;
	    this.animations = source.animations.slice();
	    this.userData = JSON.parse(JSON.stringify(source.userData));
	    if (recursive === true) {
	      for (let i = 0; i < source.children.length; i++) {
	        const child = source.children[i];
	        this.add(child.clone());
	      }
	    }
	    return this;
	  }
	}

	/**
	 * The default up direction for objects, also used as the default
	 * position for {@link DirectionalLight} and {@link HemisphereLight}.
	 *
	 * @static
	 * @type {Vector3}
	 * @default (0,1,0)
	 */
	Object3D.DEFAULT_UP = /*@__PURE__*/new Vector3(0, 1, 0);

	/**
	 * The default setting for {@link Object3D#matrixAutoUpdate} for
	 * newly created 3D objects.
	 *
	 * @static
	 * @type {boolean}
	 * @default true
	 */
	Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;

	/**
	 * The default setting for {@link Object3D#matrixWorldAutoUpdate} for
	 * newly created 3D objects.
	 *
	 * @static
	 * @type {boolean}
	 * @default true
	 */
	Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

	let _id = 0;
	const _m1 = /*@__PURE__*/new Matrix4();
	const _obj = /*@__PURE__*/new Object3D();
	const _offset = /*@__PURE__*/new Vector3();
	const _box = /*@__PURE__*/new Box3();
	const _boxMorphTargets = /*@__PURE__*/new Box3();
	const _vector = /*@__PURE__*/new Vector3();

	/**
	 * A representation of mesh, line, or point geometry. Includes vertex
	 * positions, face indices, normals, colors, UVs, and custom attributes
	 * within buffers, reducing the cost of passing all this data to the GPU.
	 *
	 * ```js
	 * const geometry = new THREE.BufferGeometry();
	 * // create a simple square shape. We duplicate the top left and bottom right
	 * // vertices because each vertex needs to appear once per triangle.
	 * const vertices = new Float32Array( [
	 * 	-1.0, -1.0,  1.0, // v0
	 * 	 1.0, -1.0,  1.0, // v1
	 * 	 1.0,  1.0,  1.0, // v2
	 *
	 * 	 1.0,  1.0,  1.0, // v3
	 * 	-1.0,  1.0,  1.0, // v4
	 * 	-1.0, -1.0,  1.0  // v5
	 * ] );
	 * // itemSize = 3 because there are 3 values (components) per vertex
	 * geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	 * const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
	 * const mesh = new THREE.Mesh( geometry, material );
	 * ```
	 *
	 * @augments EventDispatcher
	 */
	class BufferGeometry extends EventDispatcher {
	  /**
	   * Constructs a new geometry.
	   */
	  constructor() {
	    super();

	    /**
	     * This flag can be used for type testing.
	     *
	     * @type {boolean}
	     * @readonly
	     * @default true
	     */
	    this.isBufferGeometry = true;

	    /**
	     * The ID of the geometry.
	     *
	     * @name BufferGeometry#id
	     * @type {number}
	     * @readonly
	     */
	    Object.defineProperty(this, 'id', {
	      value: _id++
	    });

	    /**
	     * The UUID of the geometry.
	     *
	     * @type {string}
	     * @readonly
	     */
	    this.uuid = generateUUID();

	    /**
	     * The name of the geometry.
	     *
	     * @type {string}
	     */
	    this.name = '';
	    this.type = 'BufferGeometry';

	    /**
	     * Allows for vertices to be re-used across multiple triangles; this is
	     * called using "indexed triangles". Each triangle is associated with the
	     * indices of three vertices. This attribute therefore stores the index of
	     * each vertex for each triangular face. If this attribute is not set, the
	     * renderer assumes that each three contiguous positions represent a single triangle.
	     *
	     * @type {?BufferAttribute}
	     * @default null
	     */
	    this.index = null;

	    /**
	     * A (storage) buffer attribute which was generated with a compute shader and
	     * now defines indirect draw calls.
	     *
	     * Can only be used with {@link WebGPURenderer} and a WebGPU backend.
	     *
	     * @type {?BufferAttribute}
	     * @default null
	     */
	    this.indirect = null;

	    /**
	     * This dictionary has as id the name of the attribute to be set and as value
	     * the buffer attribute to set it to. Rather than accessing this property directly,
	     * use `setAttribute()` and `getAttribute()` to access attributes of this geometry.
	     *
	     * @type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}
	     */
	    this.attributes = {};

	    /**
	     * This dictionary holds the morph targets of the geometry.
	     *
	     * Note: Once the geometry has been rendered, the morph attribute data cannot
	     * be changed. You will have to call `dispose()?, and create a new geometry instance.
	     *
	     * @type {Object}
	     */
	    this.morphAttributes = {};

	    /**
	     * Used to control the morph target behavior; when set to `true`, the morph
	     * target data is treated as relative offsets, rather than as absolute
	     * positions/normals.
	     *
	     * @type {boolean}
	     * @default false
	     */
	    this.morphTargetsRelative = false;

	    /**
	     * Split the geometry into groups, each of which will be rendered in a
	     * separate draw call. This allows an array of materials to be used with the geometry.
	     *
	     * Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.
	     *
	     * Every vertex and index must belong to exactly one group — groups must not share vertices or
	     * indices, and must not leave vertices or indices unused.
	     *
	     * @type {Array<Object>}
	     */
	    this.groups = [];

	    /**
	     * Bounding box for the geometry which can be calculated with `computeBoundingBox()`.
	     *
	     * @type {?Box3}
	     * @default null
	     */
	    this.boundingBox = null;

	    /**
	     * Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.
	     *
	     * @type {?Sphere}
	     * @default null
	     */
	    this.boundingSphere = null;

	    /**
	     * Determines the part of the geometry to render. This should not be set directly,
	     * instead use `setDrawRange()`.
	     *
	     * @type {{start:number,count:number}}
	     */
	    this.drawRange = {
	      start: 0,
	      count: Infinity
	    };

	    /**
	     * An object that can be used to store custom data about the geometry.
	     * It should not hold references to functions as these will not be cloned.
	     *
	     * @type {Object}
	     */
	    this.userData = {};
	  }

	  /**
	   * Returns the index of this geometry.
	   *
	   * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
	   */
	  getIndex() {
	    return this.index;
	  }

	  /**
	   * Sets the given index to this geometry.
	   *
	   * @param {Array<number>|BufferAttribute} index - The index to set.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  setIndex(index) {
	    if (Array.isArray(index)) {
	      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
	    } else {
	      this.index = index;
	    }
	    return this;
	  }

	  /**
	   * Sets the given indirect attribute to this geometry.
	   *
	   * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  setIndirect(indirect) {
	    this.indirect = indirect;
	    return this;
	  }

	  /**
	   * Returns the indirect attribute of this geometry.
	   *
	   * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
	   */
	  getIndirect() {
	    return this.indirect;
	  }

	  /**
	   * Returns the buffer attribute for the given name.
	   *
	   * @param {string} name - The attribute name.
	   * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
	   * Returns `undefined` if not attribute has been found.
	   */
	  getAttribute(name) {
	    return this.attributes[name];
	  }

	  /**
	   * Sets the given attribute for the given name.
	   *
	   * @param {string} name - The attribute name.
	   * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  setAttribute(name, attribute) {
	    this.attributes[name] = attribute;
	    return this;
	  }

	  /**
	   * Deletes the attribute for the given name.
	   *
	   * @param {string} name - The attribute name to delete.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  deleteAttribute(name) {
	    delete this.attributes[name];
	    return this;
	  }

	  /**
	   * Returns `true` if this geometry has an attribute for the given name.
	   *
	   * @param {string} name - The attribute name.
	   * @return {boolean} Whether this geometry has an attribute for the given name or not.
	   */
	  hasAttribute(name) {
	    return this.attributes[name] !== undefined;
	  }

	  /**
	   * Adds a group to this geometry.
	   *
	   * @param {number} start - The first element in this draw call. That is the first
	   * vertex for non-indexed geometry, otherwise the first triangle index.
	   * @param {number} count - Specifies how many vertices (or indices) are part of this group.
	   * @param {number} [materialIndex=0] - The material array index to use.
	   */
	  addGroup(start, count, materialIndex = 0) {
	    this.groups.push({
	      start: start,
	      count: count,
	      materialIndex: materialIndex
	    });
	  }

	  /**
	   * Clears all groups.
	   */
	  clearGroups() {
	    this.groups = [];
	  }

	  /**
	   * Sets the draw range for this geometry.
	   *
	   * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
	   * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
	   * For indexed BufferGeometry, `count` is the number of indices to render.
	   */
	  setDrawRange(start, count) {
	    this.drawRange.start = start;
	    this.drawRange.count = count;
	  }

	  /**
	   * Applies the given 4x4 transformation matrix to the geometry.
	   *
	   * @param {Matrix4} matrix - The matrix to apply.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  applyMatrix4(matrix) {
	    const position = this.attributes.position;
	    if (position !== undefined) {
	      position.applyMatrix4(matrix);
	      position.needsUpdate = true;
	    }
	    const normal = this.attributes.normal;
	    if (normal !== undefined) {
	      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
	      normal.applyNormalMatrix(normalMatrix);
	      normal.needsUpdate = true;
	    }
	    const tangent = this.attributes.tangent;
	    if (tangent !== undefined) {
	      tangent.transformDirection(matrix);
	      tangent.needsUpdate = true;
	    }
	    if (this.boundingBox !== null) {
	      this.computeBoundingBox();
	    }
	    if (this.boundingSphere !== null) {
	      this.computeBoundingSphere();
	    }
	    return this;
	  }

	  /**
	   * Applies the rotation represented by the Quaternion to the geometry.
	   *
	   * @param {Quaternion} q - The Quaternion to apply.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  applyQuaternion(q) {
	    _m1.makeRotationFromQuaternion(q);
	    this.applyMatrix4(_m1);
	    return this;
	  }

	  /**
	   * Rotates the geometry about the X axis. This is typically done as a one time
	   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
	   * real-time mesh rotation.
	   *
	   * @param {number} angle - The angle in radians.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  rotateX(angle) {
	    // rotate geometry around world x-axis

	    _m1.makeRotationX(angle);
	    this.applyMatrix4(_m1);
	    return this;
	  }

	  /**
	   * Rotates the geometry about the Y axis. This is typically done as a one time
	   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
	   * real-time mesh rotation.
	   *
	   * @param {number} angle - The angle in radians.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  rotateY(angle) {
	    // rotate geometry around world y-axis

	    _m1.makeRotationY(angle);
	    this.applyMatrix4(_m1);
	    return this;
	  }

	  /**
	   * Rotates the geometry about the Z axis. This is typically done as a one time
	   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
	   * real-time mesh rotation.
	   *
	   * @param {number} angle - The angle in radians.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  rotateZ(angle) {
	    // rotate geometry around world z-axis

	    _m1.makeRotationZ(angle);
	    this.applyMatrix4(_m1);
	    return this;
	  }

	  /**
	   * Translates the geometry. This is typically done as a one time
	   * operation, and not during a loop. Use {@link Object3D#position} for typical
	   * real-time mesh rotation.
	   *
	   * @param {number} x - The x offset.
	   * @param {number} y - The y offset.
	   * @param {number} z - The z offset.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  translate(x, y, z) {
	    // translate geometry

	    _m1.makeTranslation(x, y, z);
	    this.applyMatrix4(_m1);
	    return this;
	  }

	  /**
	   * Scales the geometry. This is typically done as a one time
	   * operation, and not during a loop. Use {@link Object3D#scale} for typical
	   * real-time mesh rotation.
	   *
	   * @param {number} x - The x scale.
	   * @param {number} y - The y scale.
	   * @param {number} z - The z scale.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  scale(x, y, z) {
	    // scale geometry

	    _m1.makeScale(x, y, z);
	    this.applyMatrix4(_m1);
	    return this;
	  }

	  /**
	   * Rotates the geometry to face a point in 3D space. This is typically done as a one time
	   * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
	   * real-time mesh rotation.
	   *
	   * @param {Vector3} vector - The target point.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  lookAt(vector) {
	    _obj.lookAt(vector);
	    _obj.updateMatrix();
	    this.applyMatrix4(_obj.matrix);
	    return this;
	  }

	  /**
	   * Center the geometry based on its bounding box.
	   *
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  center() {
	    this.computeBoundingBox();
	    this.boundingBox.getCenter(_offset).negate();
	    this.translate(_offset.x, _offset.y, _offset.z);
	    return this;
	  }

	  /**
	   * Defines a geometry by creating a `position` attribute based on the given array of points. The array
	   * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
	   * set to `0`.
	   *
	   * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
	   * data from the array. The length of the array must match the vertex count.
	   *
	   * @param {Array<Vector2>|Array<Vector3>} points - The points.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  setFromPoints(points) {
	    const positionAttribute = this.getAttribute('position');
	    if (positionAttribute === undefined) {
	      const position = [];
	      for (let i = 0, l = points.length; i < l; i++) {
	        const point = points[i];
	        position.push(point.x, point.y, point.z || 0);
	      }
	      this.setAttribute('position', new Float32BufferAttribute(position, 3));
	    } else {
	      const l = Math.min(points.length, positionAttribute.count); // make sure data do not exceed buffer size

	      for (let i = 0; i < l; i++) {
	        const point = points[i];
	        positionAttribute.setXYZ(i, point.x, point.y, point.z || 0);
	      }
	      if (points.length > positionAttribute.count) {
	        warn('BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.');
	      }
	      positionAttribute.needsUpdate = true;
	    }
	    return this;
	  }

	  /**
	   * Computes the bounding box of the geometry, and updates the `boundingBox` member.
	   * The bounding box is not computed by the engine; it must be computed by your app.
	   * You may need to recompute the bounding box if the geometry vertices are modified.
	   */
	  computeBoundingBox() {
	    if (this.boundingBox === null) {
	      this.boundingBox = new Box3();
	    }
	    const position = this.attributes.position;
	    const morphAttributesPosition = this.morphAttributes.position;
	    if (position && position.isGLBufferAttribute) {
	      error('BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this);
	      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
	      return;
	    }
	    if (position !== undefined) {
	      this.boundingBox.setFromBufferAttribute(position);

	      // process morph attributes if present

	      if (morphAttributesPosition) {
	        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
	          const morphAttribute = morphAttributesPosition[i];
	          _box.setFromBufferAttribute(morphAttribute);
	          if (this.morphTargetsRelative) {
	            _vector.addVectors(this.boundingBox.min, _box.min);
	            this.boundingBox.expandByPoint(_vector);
	            _vector.addVectors(this.boundingBox.max, _box.max);
	            this.boundingBox.expandByPoint(_vector);
	          } else {
	            this.boundingBox.expandByPoint(_box.min);
	            this.boundingBox.expandByPoint(_box.max);
	          }
	        }
	      }
	    } else {
	      this.boundingBox.makeEmpty();
	    }
	    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
	      error('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
	    }
	  }

	  /**
	   * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
	   * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
	   * You may need to recompute the bounding sphere if the geometry vertices are modified.
	   */
	  computeBoundingSphere() {
	    if (this.boundingSphere === null) {
	      this.boundingSphere = new Sphere();
	    }
	    const position = this.attributes.position;
	    const morphAttributesPosition = this.morphAttributes.position;
	    if (position && position.isGLBufferAttribute) {
	      error('BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this);
	      this.boundingSphere.set(new Vector3(), Infinity);
	      return;
	    }
	    if (position) {
	      // first, find the center of the bounding sphere

	      const center = this.boundingSphere.center;
	      _box.setFromBufferAttribute(position);

	      // process morph attributes if present

	      if (morphAttributesPosition) {
	        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
	          const morphAttribute = morphAttributesPosition[i];
	          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
	          if (this.morphTargetsRelative) {
	            _vector.addVectors(_box.min, _boxMorphTargets.min);
	            _box.expandByPoint(_vector);
	            _vector.addVectors(_box.max, _boxMorphTargets.max);
	            _box.expandByPoint(_vector);
	          } else {
	            _box.expandByPoint(_boxMorphTargets.min);
	            _box.expandByPoint(_boxMorphTargets.max);
	          }
	        }
	      }
	      _box.getCenter(center);

	      // second, try to find a boundingSphere with a radius smaller than the
	      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

	      let maxRadiusSq = 0;
	      for (let i = 0, il = position.count; i < il; i++) {
	        _vector.fromBufferAttribute(position, i);
	        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
	      }

	      // process morph attributes if present

	      if (morphAttributesPosition) {
	        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
	          const morphAttribute = morphAttributesPosition[i];
	          const morphTargetsRelative = this.morphTargetsRelative;
	          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
	            _vector.fromBufferAttribute(morphAttribute, j);
	            if (morphTargetsRelative) {
	              _offset.fromBufferAttribute(position, j);
	              _vector.add(_offset);
	            }
	            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
	          }
	        }
	      }
	      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
	      if (isNaN(this.boundingSphere.radius)) {
	        error('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
	      }
	    }
	  }

	  /**
	   * Calculates and adds a tangent attribute to this geometry.
	   *
	   * The computation is only supported for indexed geometries and if position, normal, and uv attributes
	   * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
	   * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
	   */
	  computeTangents() {
	    const index = this.index;
	    const attributes = this.attributes;

	    // based on http://www.terathon.com/code/tangent.html
	    // (per vertex tangents)

	    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
	      error('BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
	      return;
	    }
	    const positionAttribute = attributes.position;
	    const normalAttribute = attributes.normal;
	    const uvAttribute = attributes.uv;
	    if (this.hasAttribute('tangent') === false) {
	      this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
	    }
	    const tangentAttribute = this.getAttribute('tangent');
	    const tan1 = [],
	      tan2 = [];
	    for (let i = 0; i < positionAttribute.count; i++) {
	      tan1[i] = new Vector3();
	      tan2[i] = new Vector3();
	    }
	    const vA = new Vector3(),
	      vB = new Vector3(),
	      vC = new Vector3(),
	      uvA = new Vector2(),
	      uvB = new Vector2(),
	      uvC = new Vector2(),
	      sdir = new Vector3(),
	      tdir = new Vector3();
	    function handleTriangle(a, b, c) {
	      vA.fromBufferAttribute(positionAttribute, a);
	      vB.fromBufferAttribute(positionAttribute, b);
	      vC.fromBufferAttribute(positionAttribute, c);
	      uvA.fromBufferAttribute(uvAttribute, a);
	      uvB.fromBufferAttribute(uvAttribute, b);
	      uvC.fromBufferAttribute(uvAttribute, c);
	      vB.sub(vA);
	      vC.sub(vA);
	      uvB.sub(uvA);
	      uvC.sub(uvA);
	      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);

	      // silently ignore degenerate uv triangles having coincident or colinear vertices

	      if (!isFinite(r)) return;
	      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
	      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
	      tan1[a].add(sdir);
	      tan1[b].add(sdir);
	      tan1[c].add(sdir);
	      tan2[a].add(tdir);
	      tan2[b].add(tdir);
	      tan2[c].add(tdir);
	    }
	    let groups = this.groups;
	    if (groups.length === 0) {
	      groups = [{
	        start: 0,
	        count: index.count
	      }];
	    }
	    for (let i = 0, il = groups.length; i < il; ++i) {
	      const group = groups[i];
	      const start = group.start;
	      const count = group.count;
	      for (let j = start, jl = start + count; j < jl; j += 3) {
	        handleTriangle(index.getX(j + 0), index.getX(j + 1), index.getX(j + 2));
	      }
	    }
	    const tmp = new Vector3(),
	      tmp2 = new Vector3();
	    const n = new Vector3(),
	      n2 = new Vector3();
	    function handleVertex(v) {
	      n.fromBufferAttribute(normalAttribute, v);
	      n2.copy(n);
	      const t = tan1[v];

	      // Gram-Schmidt orthogonalize

	      tmp.copy(t);
	      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();

	      // Calculate handedness

	      tmp2.crossVectors(n2, t);
	      const test = tmp2.dot(tan2[v]);
	      const w = test < 0.0 ? -1 : 1.0;
	      tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);
	    }
	    for (let i = 0, il = groups.length; i < il; ++i) {
	      const group = groups[i];
	      const start = group.start;
	      const count = group.count;
	      for (let j = start, jl = start + count; j < jl; j += 3) {
	        handleVertex(index.getX(j + 0));
	        handleVertex(index.getX(j + 1));
	        handleVertex(index.getX(j + 2));
	      }
	    }
	  }

	  /**
	   * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
	   * each vertex normal to be the average of the face normals of the faces that share that vertex.
	   * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
	   * to be the same as the face normal.
	   */
	  computeVertexNormals() {
	    const index = this.index;
	    const positionAttribute = this.getAttribute('position');
	    if (positionAttribute !== undefined) {
	      let normalAttribute = this.getAttribute('normal');
	      if (normalAttribute === undefined) {
	        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
	        this.setAttribute('normal', normalAttribute);
	      } else {
	        // reset existing normals to zero

	        for (let i = 0, il = normalAttribute.count; i < il; i++) {
	          normalAttribute.setXYZ(i, 0, 0, 0);
	        }
	      }
	      const pA = new Vector3(),
	        pB = new Vector3(),
	        pC = new Vector3();
	      const nA = new Vector3(),
	        nB = new Vector3(),
	        nC = new Vector3();
	      const cb = new Vector3(),
	        ab = new Vector3();

	      // indexed elements

	      if (index) {
	        for (let i = 0, il = index.count; i < il; i += 3) {
	          const vA = index.getX(i + 0);
	          const vB = index.getX(i + 1);
	          const vC = index.getX(i + 2);
	          pA.fromBufferAttribute(positionAttribute, vA);
	          pB.fromBufferAttribute(positionAttribute, vB);
	          pC.fromBufferAttribute(positionAttribute, vC);
	          cb.subVectors(pC, pB);
	          ab.subVectors(pA, pB);
	          cb.cross(ab);
	          nA.fromBufferAttribute(normalAttribute, vA);
	          nB.fromBufferAttribute(normalAttribute, vB);
	          nC.fromBufferAttribute(normalAttribute, vC);
	          nA.add(cb);
	          nB.add(cb);
	          nC.add(cb);
	          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
	          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
	          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
	        }
	      } else {
	        // non-indexed elements (unconnected triangle soup)

	        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
	          pA.fromBufferAttribute(positionAttribute, i + 0);
	          pB.fromBufferAttribute(positionAttribute, i + 1);
	          pC.fromBufferAttribute(positionAttribute, i + 2);
	          cb.subVectors(pC, pB);
	          ab.subVectors(pA, pB);
	          cb.cross(ab);
	          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
	          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
	          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
	        }
	      }
	      this.normalizeNormals();
	      normalAttribute.needsUpdate = true;
	    }
	  }

	  /**
	   * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
	   * correct lighting on the geometry surfaces.
	   */
	  normalizeNormals() {
	    const normals = this.attributes.normal;
	    for (let i = 0, il = normals.count; i < il; i++) {
	      _vector.fromBufferAttribute(normals, i);
	      _vector.normalize();
	      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);
	    }
	  }

	  /**
	   * Return a new non-index version of this indexed geometry. If the geometry
	   * is already non-indexed, the method is a NOOP.
	   *
	   * @return {BufferGeometry} The non-indexed version of this indexed geometry.
	   */
	  toNonIndexed() {
	    function convertBufferAttribute(attribute, indices) {
	      const array = attribute.array;
	      const itemSize = attribute.itemSize;
	      const normalized = attribute.normalized;
	      const array2 = new array.constructor(indices.length * itemSize);
	      let index = 0,
	        index2 = 0;
	      for (let i = 0, l = indices.length; i < l; i++) {
	        if (attribute.isInterleavedBufferAttribute) {
	          index = indices[i] * attribute.data.stride + attribute.offset;
	        } else {
	          index = indices[i] * itemSize;
	        }
	        for (let j = 0; j < itemSize; j++) {
	          array2[index2++] = array[index++];
	        }
	      }
	      return new BufferAttribute(array2, itemSize, normalized);
	    }

	    //

	    if (this.index === null) {
	      warn('BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
	      return this;
	    }
	    const geometry2 = new BufferGeometry();
	    const indices = this.index.array;
	    const attributes = this.attributes;

	    // attributes

	    for (const name in attributes) {
	      const attribute = attributes[name];
	      const newAttribute = convertBufferAttribute(attribute, indices);
	      geometry2.setAttribute(name, newAttribute);
	    }

	    // morph attributes

	    const morphAttributes = this.morphAttributes;
	    for (const name in morphAttributes) {
	      const morphArray = [];
	      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

	      for (let i = 0, il = morphAttribute.length; i < il; i++) {
	        const attribute = morphAttribute[i];
	        const newAttribute = convertBufferAttribute(attribute, indices);
	        morphArray.push(newAttribute);
	      }
	      geometry2.morphAttributes[name] = morphArray;
	    }
	    geometry2.morphTargetsRelative = this.morphTargetsRelative;

	    // groups

	    const groups = this.groups;
	    for (let i = 0, l = groups.length; i < l; i++) {
	      const group = groups[i];
	      geometry2.addGroup(group.start, group.count, group.materialIndex);
	    }
	    return geometry2;
	  }

	  /**
	   * Serializes the geometry into JSON.
	   *
	   * @return {Object} A JSON object representing the serialized geometry.
	   */
	  toJSON() {
	    const data = {
	      metadata: {
	        version: 4.7,
	        type: 'BufferGeometry',
	        generator: 'BufferGeometry.toJSON'
	      }
	    };

	    // standard BufferGeometry serialization

	    data.uuid = this.uuid;
	    data.type = this.type;
	    if (this.name !== '') data.name = this.name;
	    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
	    if (this.parameters !== undefined) {
	      const parameters = this.parameters;
	      for (const key in parameters) {
	        if (parameters[key] !== undefined) data[key] = parameters[key];
	      }
	      return data;
	    }

	    // for simplicity the code assumes attributes are not shared across geometries, see #15811

	    data.data = {
	      attributes: {}
	    };
	    const index = this.index;
	    if (index !== null) {
	      data.data.index = {
	        type: index.array.constructor.name,
	        array: Array.prototype.slice.call(index.array)
	      };
	    }
	    const attributes = this.attributes;
	    for (const key in attributes) {
	      const attribute = attributes[key];
	      data.data.attributes[key] = attribute.toJSON(data.data);
	    }
	    const morphAttributes = {};
	    let hasMorphAttributes = false;
	    for (const key in this.morphAttributes) {
	      const attributeArray = this.morphAttributes[key];
	      const array = [];
	      for (let i = 0, il = attributeArray.length; i < il; i++) {
	        const attribute = attributeArray[i];
	        array.push(attribute.toJSON(data.data));
	      }
	      if (array.length > 0) {
	        morphAttributes[key] = array;
	        hasMorphAttributes = true;
	      }
	    }
	    if (hasMorphAttributes) {
	      data.data.morphAttributes = morphAttributes;
	      data.data.morphTargetsRelative = this.morphTargetsRelative;
	    }
	    const groups = this.groups;
	    if (groups.length > 0) {
	      data.data.groups = JSON.parse(JSON.stringify(groups));
	    }
	    const boundingSphere = this.boundingSphere;
	    if (boundingSphere !== null) {
	      data.data.boundingSphere = boundingSphere.toJSON();
	    }
	    return data;
	  }

	  /**
	   * Returns a new geometry with copied values from this instance.
	   *
	   * @return {BufferGeometry} A clone of this instance.
	   */
	  clone() {
	    return new this.constructor().copy(this);
	  }

	  /**
	   * Copies the values of the given geometry to this instance.
	   *
	   * @param {BufferGeometry} source - The geometry to copy.
	   * @return {BufferGeometry} A reference to this instance.
	   */
	  copy(source) {
	    // reset

	    this.index = null;
	    this.attributes = {};
	    this.morphAttributes = {};
	    this.groups = [];
	    this.boundingBox = null;
	    this.boundingSphere = null;

	    // used for storing cloned, shared data

	    const data = {};

	    // name

	    this.name = source.name;

	    // index

	    const index = source.index;
	    if (index !== null) {
	      this.setIndex(index.clone());
	    }

	    // attributes

	    const attributes = source.attributes;
	    for (const name in attributes) {
	      const attribute = attributes[name];
	      this.setAttribute(name, attribute.clone(data));
	    }

	    // morph attributes

	    const morphAttributes = source.morphAttributes;
	    for (const name in morphAttributes) {
	      const array = [];
	      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

	      for (let i = 0, l = morphAttribute.length; i < l; i++) {
	        array.push(morphAttribute[i].clone(data));
	      }
	      this.morphAttributes[name] = array;
	    }
	    this.morphTargetsRelative = source.morphTargetsRelative;

	    // groups

	    const groups = source.groups;
	    for (let i = 0, l = groups.length; i < l; i++) {
	      const group = groups[i];
	      this.addGroup(group.start, group.count, group.materialIndex);
	    }

	    // bounding box

	    const boundingBox = source.boundingBox;
	    if (boundingBox !== null) {
	      this.boundingBox = boundingBox.clone();
	    }

	    // bounding sphere

	    const boundingSphere = source.boundingSphere;
	    if (boundingSphere !== null) {
	      this.boundingSphere = boundingSphere.clone();
	    }

	    // draw range

	    this.drawRange.start = source.drawRange.start;
	    this.drawRange.count = source.drawRange.count;

	    // user data

	    this.userData = source.userData;
	    return this;
	  }

	  /**
	   * Frees the GPU-related resources allocated by this instance. Call this
	   * method whenever this instance is no longer used in your app.
	   *
	   * @fires BufferGeometry#dispose
	   */
	  dispose() {
	    this.dispatchEvent({
	      type: 'dispose'
	    });
	  }
	}

	/**
	 * A geometry class for a rectangular cuboid with a given width, height, and depth.
	 * On creation, the cuboid is centred on the origin, with each edge parallel to one
	 * of the axes.
	 *
	 * ```js
	 * const geometry = new THREE.BoxGeometry( 1, 1, 1 );
	 * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
	 * const cube = new THREE.Mesh( geometry, material );
	 * scene.add( cube );
	 * ```
	 *
	 * @augments BufferGeometry
	 * @demo scenes/geometry-browser.html#BoxGeometry
	 */
	class BoxGeometry extends BufferGeometry {
	  /**
	   * Constructs a new box geometry.
	   *
	   * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
	   * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
	   * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
	   * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
	   * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
	   * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
	   */
	  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
	    super();
	    this.type = 'BoxGeometry';

	    /**
	     * Holds the constructor parameters that have been
	     * used to generate the geometry. Any modification
	     * after instantiation does not change the geometry.
	     *
	     * @type {Object}
	     */
	    this.parameters = {
	      width: width,
	      height: height,
	      depth: depth,
	      widthSegments: widthSegments,
	      heightSegments: heightSegments,
	      depthSegments: depthSegments
	    };
	    const scope = this;

	    // segments

	    widthSegments = Math.floor(widthSegments);
	    heightSegments = Math.floor(heightSegments);
	    depthSegments = Math.floor(depthSegments);

	    // buffers

	    const indices = [];
	    const vertices = [];
	    const normals = [];
	    const uvs = [];

	    // helper variables

	    let numberOfVertices = 0;
	    let groupStart = 0;

	    // build each side of the box geometry

	    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
	    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
	    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
	    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
	    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
	    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz

	    // build geometry

	    this.setIndex(indices);
	    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
	    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
	    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
	    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
	      const segmentWidth = width / gridX;
	      const segmentHeight = height / gridY;
	      const widthHalf = width / 2;
	      const heightHalf = height / 2;
	      const depthHalf = depth / 2;
	      const gridX1 = gridX + 1;
	      const gridY1 = gridY + 1;
	      let vertexCounter = 0;
	      let groupCount = 0;
	      const vector = new Vector3();

	      // generate vertices, normals and uvs

	      for (let iy = 0; iy < gridY1; iy++) {
	        const y = iy * segmentHeight - heightHalf;
	        for (let ix = 0; ix < gridX1; ix++) {
	          const x = ix * segmentWidth - widthHalf;

	          // set values to correct vector component

	          vector[u] = x * udir;
	          vector[v] = y * vdir;
	          vector[w] = depthHalf;

	          // now apply vector to vertex buffer

	          vertices.push(vector.x, vector.y, vector.z);

	          // set values to correct vector component

	          vector[u] = 0;
	          vector[v] = 0;
	          vector[w] = depth > 0 ? 1 : -1;

	          // now apply vector to normal buffer

	          normals.push(vector.x, vector.y, vector.z);

	          // uvs

	          uvs.push(ix / gridX);
	          uvs.push(1 - iy / gridY);

	          // counters

	          vertexCounter += 1;
	        }
	      }

	      // indices

	      // 1. you need three indices to draw a single face
	      // 2. a single segment consists of two faces
	      // 3. so we need to generate six (2*3) indices per segment

	      for (let iy = 0; iy < gridY; iy++) {
	        for (let ix = 0; ix < gridX; ix++) {
	          const a = numberOfVertices + ix + gridX1 * iy;
	          const b = numberOfVertices + ix + gridX1 * (iy + 1);
	          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
	          const d = numberOfVertices + (ix + 1) + gridX1 * iy;

	          // faces

	          indices.push(a, b, d);
	          indices.push(b, c, d);

	          // increase counter

	          groupCount += 6;
	        }
	      }

	      // add a group to the geometry. this will ensure multi material support

	      scope.addGroup(groupStart, groupCount, materialIndex);

	      // calculate new start value for groups

	      groupStart += groupCount;

	      // update total number of vertices

	      numberOfVertices += vertexCounter;
	    }
	  }
	  copy(source) {
	    super.copy(source);
	    this.parameters = Object.assign({}, source.parameters);
	    return this;
	  }

	  /**
	   * Factory method for creating an instance of this class from the given
	   * JSON object.
	   *
	   * @param {Object} data - A JSON object representing the serialized geometry.
	   * @return {BoxGeometry} A new instance.
	   */
	  static fromJSON(data) {
	    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
	  }
	}

	var lib$1 = {};

	// Unique ID creation requires a high quality random # generator. In the browser we therefore
	// require the crypto API and do not support built-in fallback to lower quality random number
	// generators (like Math.random()).
	var getRandomValues;
	var rnds8 = new Uint8Array(16);
	function rng() {
	  // lazy load so that environments that need to polyfill have a chance to do so
	  if (!getRandomValues) {
	    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
	    // find the complete implementation of crypto (msCrypto) on IE11.
	    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
	    if (!getRandomValues) {
	      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
	    }
	  }
	  return getRandomValues(rnds8);
	}

	var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

	function validate(uuid) {
	  return typeof uuid === 'string' && REGEX.test(uuid);
	}

	/**
	 * Convert array of 16 byte values to UUID string format of the form:
	 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	 */

	var byteToHex = [];
	for (var i$2 = 0; i$2 < 256; ++i$2) {
	  byteToHex.push((i$2 + 0x100).toString(16).substr(1));
	}
	function stringify(arr) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	  // Note: Be careful editing this code!  It's been tuned for performance
	  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
	  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
	  // of the following:
	  // - One or more input array values don't map to a hex octet (leading to
	  // "undefined" in the uuid)
	  // - Invalid input values for the RFC `version` or `variant` fields

	  if (!validate(uuid)) {
	    throw TypeError('Stringified UUID is invalid');
	  }
	  return uuid;
	}

	//
	// Inspired by https://github.com/LiosK/UUID.js
	// and http://docs.python.org/library/uuid.html

	var _nodeId;
	var _clockseq; // Previous uuid creation time

	var _lastMSecs = 0;
	var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

	function v1(options, buf, offset) {
	  var i = buf && offset || 0;
	  var b = buf || new Array(16);
	  options = options || {};
	  var node = options.node || _nodeId;
	  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
	  // specified.  We do this lazily to minimize issues related to insufficient
	  // system entropy.  See #189

	  if (node == null || clockseq == null) {
	    var seedBytes = options.random || (options.rng || rng)();
	    if (node == null) {
	      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
	    }
	    if (clockseq == null) {
	      // Per 4.2.2, randomize (14 bit) clockseq
	      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
	    }
	  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.

	  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
	  // cycle to simulate higher resolution clock

	  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

	  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

	  if (dt < 0 && options.clockseq === undefined) {
	    clockseq = clockseq + 1 & 0x3fff;
	  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	  // time interval

	  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
	    nsecs = 0;
	  } // Per 4.2.1.2 Throw error if too many uuids are requested

	  if (nsecs >= 10000) {
	    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
	  }
	  _lastMSecs = msecs;
	  _lastNSecs = nsecs;
	  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

	  msecs += 12219292800000; // `time_low`

	  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	  b[i++] = tl >>> 24 & 0xff;
	  b[i++] = tl >>> 16 & 0xff;
	  b[i++] = tl >>> 8 & 0xff;
	  b[i++] = tl & 0xff; // `time_mid`

	  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
	  b[i++] = tmh >>> 8 & 0xff;
	  b[i++] = tmh & 0xff; // `time_high_and_version`

	  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

	  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

	  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

	  b[i++] = clockseq & 0xff; // `node`

	  for (var n = 0; n < 6; ++n) {
	    b[i + n] = node[n];
	  }
	  return buf || stringify(b);
	}

	function parse(uuid) {
	  if (!validate(uuid)) {
	    throw TypeError('Invalid UUID');
	  }
	  var v;
	  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

	  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
	  arr[1] = v >>> 16 & 0xff;
	  arr[2] = v >>> 8 & 0xff;
	  arr[3] = v & 0xff; // Parse ........-####-....-....-............

	  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
	  arr[5] = v & 0xff; // Parse ........-....-####-....-............

	  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
	  arr[7] = v & 0xff; // Parse ........-....-....-####-............

	  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
	  arr[9] = v & 0xff; // Parse ........-....-....-....-############
	  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

	  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
	  arr[11] = v / 0x100000000 & 0xff;
	  arr[12] = v >>> 24 & 0xff;
	  arr[13] = v >>> 16 & 0xff;
	  arr[14] = v >>> 8 & 0xff;
	  arr[15] = v & 0xff;
	  return arr;
	}

	function stringToBytes(str) {
	  str = unescape(encodeURIComponent(str)); // UTF8 escape

	  var bytes = [];
	  for (var i = 0; i < str.length; ++i) {
	    bytes.push(str.charCodeAt(i));
	  }
	  return bytes;
	}
	var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
	var URL$1 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
	function v35 (name, version, hashfunc) {
	  function generateUUID(value, namespace, buf, offset) {
	    if (typeof value === 'string') {
	      value = stringToBytes(value);
	    }
	    if (typeof namespace === 'string') {
	      namespace = parse(namespace);
	    }
	    if (namespace.length !== 16) {
	      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
	    } // Compute hash of namespace and value, Per 4.3
	    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
	    // hashfunc([...namespace, ... value])`

	    var bytes = new Uint8Array(16 + value.length);
	    bytes.set(namespace);
	    bytes.set(value, namespace.length);
	    bytes = hashfunc(bytes);
	    bytes[6] = bytes[6] & 0x0f | version;
	    bytes[8] = bytes[8] & 0x3f | 0x80;
	    if (buf) {
	      offset = offset || 0;
	      for (var i = 0; i < 16; ++i) {
	        buf[offset + i] = bytes[i];
	      }
	      return buf;
	    }
	    return stringify(bytes);
	  } // Function#name is not settable on some platforms (#270)

	  try {
	    generateUUID.name = name; // eslint-disable-next-line no-empty
	  } catch (err) {} // For CommonJS default export support

	  generateUUID.DNS = DNS;
	  generateUUID.URL = URL$1;
	  return generateUUID;
	}

	/*
	 * Browser-compatible JavaScript MD5
	 *
	 * Modification of JavaScript MD5
	 * https://github.com/blueimp/JavaScript-MD5
	 *
	 * Copyright 2011, Sebastian Tschan
	 * https://blueimp.net
	 *
	 * Licensed under the MIT license:
	 * https://opensource.org/licenses/MIT
	 *
	 * Based on
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	function md5(bytes) {
	  if (typeof bytes === 'string') {
	    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

	    bytes = new Uint8Array(msg.length);
	    for (var i = 0; i < msg.length; ++i) {
	      bytes[i] = msg.charCodeAt(i);
	    }
	  }
	  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
	}
	/*
	 * Convert an array of little-endian words to an array of bytes
	 */

	function md5ToHexEncodedArray(input) {
	  var output = [];
	  var length32 = input.length * 32;
	  var hexTab = '0123456789abcdef';
	  for (var i = 0; i < length32; i += 8) {
	    var x = input[i >> 5] >>> i % 32 & 0xff;
	    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
	    output.push(hex);
	  }
	  return output;
	}
	/**
	 * Calculate output length with padding and bit length
	 */

	function getOutputLength(inputLength8) {
	  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
	}
	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length.
	 */

	function wordsToMd5(x, len) {
	  /* append padding */
	  x[len >> 5] |= 0x80 << len % 32;
	  x[getOutputLength(len) - 1] = len;
	  var a = 1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d = 271733878;
	  for (var i = 0; i < x.length; i += 16) {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;
	    a = md5ff(a, b, c, d, x[i], 7, -680876936);
	    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
	    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
	    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
	    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
	    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
	    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
	    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
	    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
	    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
	    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
	    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
	    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
	    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
	    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
	    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
	    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
	    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
	    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
	    b = md5gg(b, c, d, a, x[i], 20, -373897302);
	    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
	    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
	    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
	    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
	    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
	    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
	    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
	    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
	    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
	    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
	    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
	    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
	    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
	    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
	    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
	    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
	    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
	    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
	    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
	    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
	    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
	    d = md5hh(d, a, b, c, x[i], 11, -358537222);
	    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
	    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
	    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
	    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
	    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
	    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
	    a = md5ii(a, b, c, d, x[i], 6, -198630844);
	    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
	    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
	    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
	    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
	    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
	    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
	    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
	    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
	    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
	    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
	    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
	    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
	    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
	    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
	    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
	    a = safeAdd(a, olda);
	    b = safeAdd(b, oldb);
	    c = safeAdd(c, oldc);
	    d = safeAdd(d, oldd);
	  }
	  return [a, b, c, d];
	}
	/*
	 * Convert an array bytes to an array of little-endian words
	 * Characters >255 have their high-byte silently ignored.
	 */

	function bytesToWords(input) {
	  if (input.length === 0) {
	    return [];
	  }
	  var length8 = input.length * 8;
	  var output = new Uint32Array(getOutputLength(length8));
	  for (var i = 0; i < length8; i += 8) {
	    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
	  }
	  return output;
	}
	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */

	function safeAdd(x, y) {
	  var lsw = (x & 0xffff) + (y & 0xffff);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return msw << 16 | lsw & 0xffff;
	}
	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */

	function bitRotateLeft(num, cnt) {
	  return num << cnt | num >>> 32 - cnt;
	}
	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */

	function md5cmn(q, a, b, x, s, t) {
	  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
	}
	function md5ff(a, b, c, d, x, s, t) {
	  return md5cmn(b & c | ~b & d, a, b, x, s, t);
	}
	function md5gg(a, b, c, d, x, s, t) {
	  return md5cmn(b & d | c & ~d, a, b, x, s, t);
	}
	function md5hh(a, b, c, d, x, s, t) {
	  return md5cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5ii(a, b, c, d, x, s, t) {
	  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
	}

	var v3 = v35('v3', 0x30, md5);

	function v4(options, buf, offset) {
	  options = options || {};
	  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

	  rnds[6] = rnds[6] & 0x0f | 0x40;
	  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

	  if (buf) {
	    offset = offset || 0;
	    for (var i = 0; i < 16; ++i) {
	      buf[offset + i] = rnds[i];
	    }
	    return buf;
	  }
	  return stringify(rnds);
	}

	// Adapted from Chris Veness' SHA1 code at
	// http://www.movable-type.co.uk/scripts/sha1.html
	function f$2(s, x, y, z) {
	  switch (s) {
	    case 0:
	      return x & y ^ ~x & z;
	    case 1:
	      return x ^ y ^ z;
	    case 2:
	      return x & y ^ x & z ^ y & z;
	    case 3:
	      return x ^ y ^ z;
	  }
	}
	function ROTL(x, n) {
	  return x << n | x >>> 32 - n;
	}
	function sha1(bytes) {
	  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
	  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
	  if (typeof bytes === 'string') {
	    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

	    bytes = [];
	    for (var i = 0; i < msg.length; ++i) {
	      bytes.push(msg.charCodeAt(i));
	    }
	  } else if (!Array.isArray(bytes)) {
	    // Convert Array-like to Array
	    bytes = Array.prototype.slice.call(bytes);
	  }
	  bytes.push(0x80);
	  var l = bytes.length / 4 + 2;
	  var N = Math.ceil(l / 16);
	  var M = new Array(N);
	  for (var _i = 0; _i < N; ++_i) {
	    var arr = new Uint32Array(16);
	    for (var j = 0; j < 16; ++j) {
	      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
	    }
	    M[_i] = arr;
	  }
	  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
	  M[N - 1][14] = Math.floor(M[N - 1][14]);
	  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
	  for (var _i2 = 0; _i2 < N; ++_i2) {
	    var W = new Uint32Array(80);
	    for (var t = 0; t < 16; ++t) {
	      W[t] = M[_i2][t];
	    }
	    for (var _t = 16; _t < 80; ++_t) {
	      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
	    }
	    var a = H[0];
	    var b = H[1];
	    var c = H[2];
	    var d = H[3];
	    var e = H[4];
	    for (var _t2 = 0; _t2 < 80; ++_t2) {
	      var s = Math.floor(_t2 / 20);
	      var T = ROTL(a, 5) + f$2(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
	      e = d;
	      d = c;
	      c = ROTL(b, 30) >>> 0;
	      b = a;
	      a = T;
	    }
	    H[0] = H[0] + a >>> 0;
	    H[1] = H[1] + b >>> 0;
	    H[2] = H[2] + c >>> 0;
	    H[3] = H[3] + d >>> 0;
	    H[4] = H[4] + e >>> 0;
	  }
	  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
	}

	var v5 = v35('v5', 0x50, sha1);

	var nil = '00000000-0000-0000-0000-000000000000';

	function version(uuid) {
	  if (!validate(uuid)) {
	    throw TypeError('Invalid UUID');
	  }
	  return parseInt(uuid.substr(14, 1), 16);
	}

	var esmBrowser = /*#__PURE__*/Object.freeze({
		__proto__: null,
		NIL: nil,
		parse: parse,
		stringify: stringify,
		v1: v1,
		v3: v3,
		v4: v4,
		v5: v5,
		validate: validate,
		version: version
	});

	var BigInteger = {exports: {}};

	var hasRequiredBigInteger;
	function requireBigInteger() {
	  if (hasRequiredBigInteger) return BigInteger.exports;
	  hasRequiredBigInteger = 1;
	  (function (module) {
	    var bigInt = function (undefined$1) {

	      var BASE = 1e7,
	        LOG_BASE = 7,
	        MAX_INT = 9007199254740992,
	        MAX_INT_ARR = smallToArray(MAX_INT),
	        DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
	      var supportsNativeBigInt = typeof BigInt === "function";
	      function Integer(v, radix, alphabet, caseSensitive) {
	        if (typeof v === "undefined") return Integer[0];
	        if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
	        return parseValue(v);
	      }
	      function BigInteger(value, sign) {
	        this.value = value;
	        this.sign = sign;
	        this.isSmall = false;
	      }
	      BigInteger.prototype = Object.create(Integer.prototype);
	      function SmallInteger(value) {
	        this.value = value;
	        this.sign = value < 0;
	        this.isSmall = true;
	      }
	      SmallInteger.prototype = Object.create(Integer.prototype);
	      function NativeBigInt(value) {
	        this.value = value;
	      }
	      NativeBigInt.prototype = Object.create(Integer.prototype);
	      function isPrecise(n) {
	        return -MAX_INT < n && n < MAX_INT;
	      }
	      function smallToArray(n) {
	        // For performance reasons doesn't reference BASE, need to change this function if BASE changes
	        if (n < 1e7) return [n];
	        if (n < 1e14) return [n % 1e7, Math.floor(n / 1e7)];
	        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
	      }
	      function arrayToSmall(arr) {
	        // If BASE changes this function may need to change
	        trim(arr);
	        var length = arr.length;
	        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
	          switch (length) {
	            case 0:
	              return 0;
	            case 1:
	              return arr[0];
	            case 2:
	              return arr[0] + arr[1] * BASE;
	            default:
	              return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
	          }
	        }
	        return arr;
	      }
	      function trim(v) {
	        var i = v.length;
	        while (v[--i] === 0);
	        v.length = i + 1;
	      }
	      function createArray(length) {
	        // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
	        var x = new Array(length);
	        var i = -1;
	        while (++i < length) {
	          x[i] = 0;
	        }
	        return x;
	      }
	      function truncate(n) {
	        if (n > 0) return Math.floor(n);
	        return Math.ceil(n);
	      }
	      function add(a, b) {
	        // assumes a and b are arrays with a.length >= b.length
	        var l_a = a.length,
	          l_b = b.length,
	          r = new Array(l_a),
	          carry = 0,
	          base = BASE,
	          sum,
	          i;
	        for (i = 0; i < l_b; i++) {
	          sum = a[i] + b[i] + carry;
	          carry = sum >= base ? 1 : 0;
	          r[i] = sum - carry * base;
	        }
	        while (i < l_a) {
	          sum = a[i] + carry;
	          carry = sum === base ? 1 : 0;
	          r[i++] = sum - carry * base;
	        }
	        if (carry > 0) r.push(carry);
	        return r;
	      }
	      function addAny(a, b) {
	        if (a.length >= b.length) return add(a, b);
	        return add(b, a);
	      }
	      function addSmall(a, carry) {
	        // assumes a is array, carry is number with 0 <= carry < MAX_INT
	        var l = a.length,
	          r = new Array(l),
	          base = BASE,
	          sum,
	          i;
	        for (i = 0; i < l; i++) {
	          sum = a[i] - base + carry;
	          carry = Math.floor(sum / base);
	          r[i] = sum - carry * base;
	          carry += 1;
	        }
	        while (carry > 0) {
	          r[i++] = carry % base;
	          carry = Math.floor(carry / base);
	        }
	        return r;
	      }
	      BigInteger.prototype.add = function (v) {
	        var n = parseValue(v);
	        if (this.sign !== n.sign) {
	          return this.subtract(n.negate());
	        }
	        var a = this.value,
	          b = n.value;
	        if (n.isSmall) {
	          return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
	        }
	        return new BigInteger(addAny(a, b), this.sign);
	      };
	      BigInteger.prototype.plus = BigInteger.prototype.add;
	      SmallInteger.prototype.add = function (v) {
	        var n = parseValue(v);
	        var a = this.value;
	        if (a < 0 !== n.sign) {
	          return this.subtract(n.negate());
	        }
	        var b = n.value;
	        if (n.isSmall) {
	          if (isPrecise(a + b)) return new SmallInteger(a + b);
	          b = smallToArray(Math.abs(b));
	        }
	        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
	      };
	      SmallInteger.prototype.plus = SmallInteger.prototype.add;
	      NativeBigInt.prototype.add = function (v) {
	        return new NativeBigInt(this.value + parseValue(v).value);
	      };
	      NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
	      function subtract(a, b) {
	        // assumes a and b are arrays with a >= b
	        var a_l = a.length,
	          b_l = b.length,
	          r = new Array(a_l),
	          borrow = 0,
	          base = BASE,
	          i,
	          difference;
	        for (i = 0; i < b_l; i++) {
	          difference = a[i] - borrow - b[i];
	          if (difference < 0) {
	            difference += base;
	            borrow = 1;
	          } else borrow = 0;
	          r[i] = difference;
	        }
	        for (i = b_l; i < a_l; i++) {
	          difference = a[i] - borrow;
	          if (difference < 0) difference += base;else {
	            r[i++] = difference;
	            break;
	          }
	          r[i] = difference;
	        }
	        for (; i < a_l; i++) {
	          r[i] = a[i];
	        }
	        trim(r);
	        return r;
	      }
	      function subtractAny(a, b, sign) {
	        var value;
	        if (compareAbs(a, b) >= 0) {
	          value = subtract(a, b);
	        } else {
	          value = subtract(b, a);
	          sign = !sign;
	        }
	        value = arrayToSmall(value);
	        if (typeof value === "number") {
	          if (sign) value = -value;
	          return new SmallInteger(value);
	        }
	        return new BigInteger(value, sign);
	      }
	      function subtractSmall(a, b, sign) {
	        // assumes a is array, b is number with 0 <= b < MAX_INT
	        var l = a.length,
	          r = new Array(l),
	          carry = -b,
	          base = BASE,
	          i,
	          difference;
	        for (i = 0; i < l; i++) {
	          difference = a[i] + carry;
	          carry = Math.floor(difference / base);
	          difference %= base;
	          r[i] = difference < 0 ? difference + base : difference;
	        }
	        r = arrayToSmall(r);
	        if (typeof r === "number") {
	          if (sign) r = -r;
	          return new SmallInteger(r);
	        }
	        return new BigInteger(r, sign);
	      }
	      BigInteger.prototype.subtract = function (v) {
	        var n = parseValue(v);
	        if (this.sign !== n.sign) {
	          return this.add(n.negate());
	        }
	        var a = this.value,
	          b = n.value;
	        if (n.isSmall) return subtractSmall(a, Math.abs(b), this.sign);
	        return subtractAny(a, b, this.sign);
	      };
	      BigInteger.prototype.minus = BigInteger.prototype.subtract;
	      SmallInteger.prototype.subtract = function (v) {
	        var n = parseValue(v);
	        var a = this.value;
	        if (a < 0 !== n.sign) {
	          return this.add(n.negate());
	        }
	        var b = n.value;
	        if (n.isSmall) {
	          return new SmallInteger(a - b);
	        }
	        return subtractSmall(b, Math.abs(a), a >= 0);
	      };
	      SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
	      NativeBigInt.prototype.subtract = function (v) {
	        return new NativeBigInt(this.value - parseValue(v).value);
	      };
	      NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
	      BigInteger.prototype.negate = function () {
	        return new BigInteger(this.value, !this.sign);
	      };
	      SmallInteger.prototype.negate = function () {
	        var sign = this.sign;
	        var small = new SmallInteger(-this.value);
	        small.sign = !sign;
	        return small;
	      };
	      NativeBigInt.prototype.negate = function () {
	        return new NativeBigInt(-this.value);
	      };
	      BigInteger.prototype.abs = function () {
	        return new BigInteger(this.value, false);
	      };
	      SmallInteger.prototype.abs = function () {
	        return new SmallInteger(Math.abs(this.value));
	      };
	      NativeBigInt.prototype.abs = function () {
	        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
	      };
	      function multiplyLong(a, b) {
	        var a_l = a.length,
	          b_l = b.length,
	          l = a_l + b_l,
	          r = createArray(l),
	          base = BASE,
	          product,
	          carry,
	          i,
	          a_i,
	          b_j;
	        for (i = 0; i < a_l; ++i) {
	          a_i = a[i];
	          for (var j = 0; j < b_l; ++j) {
	            b_j = b[j];
	            product = a_i * b_j + r[i + j];
	            carry = Math.floor(product / base);
	            r[i + j] = product - carry * base;
	            r[i + j + 1] += carry;
	          }
	        }
	        trim(r);
	        return r;
	      }
	      function multiplySmall(a, b) {
	        // assumes a is array, b is number with |b| < BASE
	        var l = a.length,
	          r = new Array(l),
	          base = BASE,
	          carry = 0,
	          product,
	          i;
	        for (i = 0; i < l; i++) {
	          product = a[i] * b + carry;
	          carry = Math.floor(product / base);
	          r[i] = product - carry * base;
	        }
	        while (carry > 0) {
	          r[i++] = carry % base;
	          carry = Math.floor(carry / base);
	        }
	        return r;
	      }
	      function shiftLeft(x, n) {
	        var r = [];
	        while (n-- > 0) r.push(0);
	        return r.concat(x);
	      }
	      function multiplyKaratsuba(x, y) {
	        var n = Math.max(x.length, y.length);
	        if (n <= 30) return multiplyLong(x, y);
	        n = Math.ceil(n / 2);
	        var b = x.slice(n),
	          a = x.slice(0, n),
	          d = y.slice(n),
	          c = y.slice(0, n);
	        var ac = multiplyKaratsuba(a, c),
	          bd = multiplyKaratsuba(b, d),
	          abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
	        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
	        trim(product);
	        return product;
	      }

	      // The following function is derived from a surface fit of a graph plotting the performance difference
	      // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
	      function useKaratsuba(l1, l2) {
	        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
	      }
	      BigInteger.prototype.multiply = function (v) {
	        var n = parseValue(v),
	          a = this.value,
	          b = n.value,
	          sign = this.sign !== n.sign,
	          abs;
	        if (n.isSmall) {
	          if (b === 0) return Integer[0];
	          if (b === 1) return this;
	          if (b === -1) return this.negate();
	          abs = Math.abs(b);
	          if (abs < BASE) {
	            return new BigInteger(multiplySmall(a, abs), sign);
	          }
	          b = smallToArray(abs);
	        }
	        if (useKaratsuba(a.length, b.length))
	          // Karatsuba is only faster for certain array sizes
	          return new BigInteger(multiplyKaratsuba(a, b), sign);
	        return new BigInteger(multiplyLong(a, b), sign);
	      };
	      BigInteger.prototype.times = BigInteger.prototype.multiply;
	      function multiplySmallAndArray(a, b, sign) {
	        // a >= 0
	        if (a < BASE) {
	          return new BigInteger(multiplySmall(b, a), sign);
	        }
	        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
	      }
	      SmallInteger.prototype._multiplyBySmall = function (a) {
	        if (isPrecise(a.value * this.value)) {
	          return new SmallInteger(a.value * this.value);
	        }
	        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
	      };
	      BigInteger.prototype._multiplyBySmall = function (a) {
	        if (a.value === 0) return Integer[0];
	        if (a.value === 1) return this;
	        if (a.value === -1) return this.negate();
	        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
	      };
	      SmallInteger.prototype.multiply = function (v) {
	        return parseValue(v)._multiplyBySmall(this);
	      };
	      SmallInteger.prototype.times = SmallInteger.prototype.multiply;
	      NativeBigInt.prototype.multiply = function (v) {
	        return new NativeBigInt(this.value * parseValue(v).value);
	      };
	      NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
	      function square(a) {
	        //console.assert(2 * BASE * BASE < MAX_INT);
	        var l = a.length,
	          r = createArray(l + l),
	          base = BASE,
	          product,
	          carry,
	          i,
	          a_i,
	          a_j;
	        for (i = 0; i < l; i++) {
	          a_i = a[i];
	          carry = 0 - a_i * a_i;
	          for (var j = i; j < l; j++) {
	            a_j = a[j];
	            product = 2 * (a_i * a_j) + r[i + j] + carry;
	            carry = Math.floor(product / base);
	            r[i + j] = product - carry * base;
	          }
	          r[i + l] = carry;
	        }
	        trim(r);
	        return r;
	      }
	      BigInteger.prototype.square = function () {
	        return new BigInteger(square(this.value), false);
	      };
	      SmallInteger.prototype.square = function () {
	        var value = this.value * this.value;
	        if (isPrecise(value)) return new SmallInteger(value);
	        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
	      };
	      NativeBigInt.prototype.square = function (v) {
	        return new NativeBigInt(this.value * this.value);
	      };
	      function divMod1(a, b) {
	        // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
	        var a_l = a.length,
	          b_l = b.length,
	          base = BASE,
	          result = createArray(b.length),
	          divisorMostSignificantDigit = b[b_l - 1],
	          // normalization
	          lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
	          remainder = multiplySmall(a, lambda),
	          divisor = multiplySmall(b, lambda),
	          quotientDigit,
	          shift,
	          carry,
	          borrow,
	          i,
	          l,
	          q;
	        if (remainder.length <= a_l) remainder.push(0);
	        divisor.push(0);
	        divisorMostSignificantDigit = divisor[b_l - 1];
	        for (shift = a_l - b_l; shift >= 0; shift--) {
	          quotientDigit = base - 1;
	          if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
	            quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
	          }
	          // quotientDigit <= base - 1
	          carry = 0;
	          borrow = 0;
	          l = divisor.length;
	          for (i = 0; i < l; i++) {
	            carry += quotientDigit * divisor[i];
	            q = Math.floor(carry / base);
	            borrow += remainder[shift + i] - (carry - q * base);
	            carry = q;
	            if (borrow < 0) {
	              remainder[shift + i] = borrow + base;
	              borrow = -1;
	            } else {
	              remainder[shift + i] = borrow;
	              borrow = 0;
	            }
	          }
	          while (borrow !== 0) {
	            quotientDigit -= 1;
	            carry = 0;
	            for (i = 0; i < l; i++) {
	              carry += remainder[shift + i] - base + divisor[i];
	              if (carry < 0) {
	                remainder[shift + i] = carry + base;
	                carry = 0;
	              } else {
	                remainder[shift + i] = carry;
	                carry = 1;
	              }
	            }
	            borrow += carry;
	          }
	          result[shift] = quotientDigit;
	        }
	        // denormalization
	        remainder = divModSmall(remainder, lambda)[0];
	        return [arrayToSmall(result), arrayToSmall(remainder)];
	      }
	      function divMod2(a, b) {
	        // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
	        // Performs faster than divMod1 on larger input sizes.
	        var a_l = a.length,
	          b_l = b.length,
	          result = [],
	          part = [],
	          base = BASE,
	          guess,
	          xlen,
	          highx,
	          highy,
	          check;
	        while (a_l) {
	          part.unshift(a[--a_l]);
	          trim(part);
	          if (compareAbs(part, b) < 0) {
	            result.push(0);
	            continue;
	          }
	          xlen = part.length;
	          highx = part[xlen - 1] * base + part[xlen - 2];
	          highy = b[b_l - 1] * base + b[b_l - 2];
	          if (xlen > b_l) {
	            highx = (highx + 1) * base;
	          }
	          guess = Math.ceil(highx / highy);
	          do {
	            check = multiplySmall(b, guess);
	            if (compareAbs(check, part) <= 0) break;
	            guess--;
	          } while (guess);
	          result.push(guess);
	          part = subtract(part, check);
	        }
	        result.reverse();
	        return [arrayToSmall(result), arrayToSmall(part)];
	      }
	      function divModSmall(value, lambda) {
	        var length = value.length,
	          quotient = createArray(length),
	          base = BASE,
	          i,
	          q,
	          remainder,
	          divisor;
	        remainder = 0;
	        for (i = length - 1; i >= 0; --i) {
	          divisor = remainder * base + value[i];
	          q = truncate(divisor / lambda);
	          remainder = divisor - q * lambda;
	          quotient[i] = q | 0;
	        }
	        return [quotient, remainder | 0];
	      }
	      function divModAny(self, v) {
	        var value,
	          n = parseValue(v);
	        if (supportsNativeBigInt) {
	          return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];
	        }
	        var a = self.value,
	          b = n.value;
	        var quotient;
	        if (b === 0) throw new Error("Cannot divide by zero");
	        if (self.isSmall) {
	          if (n.isSmall) {
	            return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
	          }
	          return [Integer[0], self];
	        }
	        if (n.isSmall) {
	          if (b === 1) return [self, Integer[0]];
	          if (b == -1) return [self.negate(), Integer[0]];
	          var abs = Math.abs(b);
	          if (abs < BASE) {
	            value = divModSmall(a, abs);
	            quotient = arrayToSmall(value[0]);
	            var remainder = value[1];
	            if (self.sign) remainder = -remainder;
	            if (typeof quotient === "number") {
	              if (self.sign !== n.sign) quotient = -quotient;
	              return [new SmallInteger(quotient), new SmallInteger(remainder)];
	            }
	            return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
	          }
	          b = smallToArray(abs);
	        }
	        var comparison = compareAbs(a, b);
	        if (comparison === -1) return [Integer[0], self];
	        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

	        // divMod1 is faster on smaller input sizes
	        if (a.length + b.length <= 200) value = divMod1(a, b);else value = divMod2(a, b);
	        quotient = value[0];
	        var qSign = self.sign !== n.sign,
	          mod = value[1],
	          mSign = self.sign;
	        if (typeof quotient === "number") {
	          if (qSign) quotient = -quotient;
	          quotient = new SmallInteger(quotient);
	        } else quotient = new BigInteger(quotient, qSign);
	        if (typeof mod === "number") {
	          if (mSign) mod = -mod;
	          mod = new SmallInteger(mod);
	        } else mod = new BigInteger(mod, mSign);
	        return [quotient, mod];
	      }
	      BigInteger.prototype.divmod = function (v) {
	        var result = divModAny(this, v);
	        return {
	          quotient: result[0],
	          remainder: result[1]
	        };
	      };
	      NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
	      BigInteger.prototype.divide = function (v) {
	        return divModAny(this, v)[0];
	      };
	      NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {
	        return new NativeBigInt(this.value / parseValue(v).value);
	      };
	      SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
	      BigInteger.prototype.mod = function (v) {
	        return divModAny(this, v)[1];
	      };
	      NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {
	        return new NativeBigInt(this.value % parseValue(v).value);
	      };
	      SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
	      BigInteger.prototype.pow = function (v) {
	        var n = parseValue(v),
	          a = this.value,
	          b = n.value,
	          value,
	          x,
	          y;
	        if (b === 0) return Integer[1];
	        if (a === 0) return Integer[0];
	        if (a === 1) return Integer[1];
	        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
	        if (n.sign) {
	          return Integer[0];
	        }
	        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
	        if (this.isSmall) {
	          if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));
	        }
	        x = this;
	        y = Integer[1];
	        while (true) {
	          if (b & 1 === 1) {
	            y = y.times(x);
	            --b;
	          }
	          if (b === 0) break;
	          b /= 2;
	          x = x.square();
	        }
	        return y;
	      };
	      SmallInteger.prototype.pow = BigInteger.prototype.pow;
	      NativeBigInt.prototype.pow = function (v) {
	        var n = parseValue(v);
	        var a = this.value,
	          b = n.value;
	        var _0 = BigInt(0),
	          _1 = BigInt(1),
	          _2 = BigInt(2);
	        if (b === _0) return Integer[1];
	        if (a === _0) return Integer[0];
	        if (a === _1) return Integer[1];
	        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
	        if (n.isNegative()) return new NativeBigInt(_0);
	        var x = this;
	        var y = Integer[1];
	        while (true) {
	          if ((b & _1) === _1) {
	            y = y.times(x);
	            --b;
	          }
	          if (b === _0) break;
	          b /= _2;
	          x = x.square();
	        }
	        return y;
	      };
	      BigInteger.prototype.modPow = function (exp, mod) {
	        exp = parseValue(exp);
	        mod = parseValue(mod);
	        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
	        var r = Integer[1],
	          base = this.mod(mod);
	        if (exp.isNegative()) {
	          exp = exp.multiply(Integer[-1]);
	          base = base.modInv(mod);
	        }
	        while (exp.isPositive()) {
	          if (base.isZero()) return Integer[0];
	          if (exp.isOdd()) r = r.multiply(base).mod(mod);
	          exp = exp.divide(2);
	          base = base.square().mod(mod);
	        }
	        return r;
	      };
	      NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
	      function compareAbs(a, b) {
	        if (a.length !== b.length) {
	          return a.length > b.length ? 1 : -1;
	        }
	        for (var i = a.length - 1; i >= 0; i--) {
	          if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
	        }
	        return 0;
	      }
	      BigInteger.prototype.compareAbs = function (v) {
	        var n = parseValue(v),
	          a = this.value,
	          b = n.value;
	        if (n.isSmall) return 1;
	        return compareAbs(a, b);
	      };
	      SmallInteger.prototype.compareAbs = function (v) {
	        var n = parseValue(v),
	          a = Math.abs(this.value),
	          b = n.value;
	        if (n.isSmall) {
	          b = Math.abs(b);
	          return a === b ? 0 : a > b ? 1 : -1;
	        }
	        return -1;
	      };
	      NativeBigInt.prototype.compareAbs = function (v) {
	        var a = this.value;
	        var b = parseValue(v).value;
	        a = a >= 0 ? a : -a;
	        b = b >= 0 ? b : -b;
	        return a === b ? 0 : a > b ? 1 : -1;
	      };
	      BigInteger.prototype.compare = function (v) {
	        // See discussion about comparison with Infinity:
	        // https://github.com/peterolson/BigInteger.js/issues/61
	        if (v === Infinity) {
	          return -1;
	        }
	        if (v === -Infinity) {
	          return 1;
	        }
	        var n = parseValue(v),
	          a = this.value,
	          b = n.value;
	        if (this.sign !== n.sign) {
	          return n.sign ? 1 : -1;
	        }
	        if (n.isSmall) {
	          return this.sign ? -1 : 1;
	        }
	        return compareAbs(a, b) * (this.sign ? -1 : 1);
	      };
	      BigInteger.prototype.compareTo = BigInteger.prototype.compare;
	      SmallInteger.prototype.compare = function (v) {
	        if (v === Infinity) {
	          return -1;
	        }
	        if (v === -Infinity) {
	          return 1;
	        }
	        var n = parseValue(v),
	          a = this.value,
	          b = n.value;
	        if (n.isSmall) {
	          return a == b ? 0 : a > b ? 1 : -1;
	        }
	        if (a < 0 !== n.sign) {
	          return a < 0 ? -1 : 1;
	        }
	        return a < 0 ? 1 : -1;
	      };
	      SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
	      NativeBigInt.prototype.compare = function (v) {
	        if (v === Infinity) {
	          return -1;
	        }
	        if (v === -Infinity) {
	          return 1;
	        }
	        var a = this.value;
	        var b = parseValue(v).value;
	        return a === b ? 0 : a > b ? 1 : -1;
	      };
	      NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
	      BigInteger.prototype.equals = function (v) {
	        return this.compare(v) === 0;
	      };
	      NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
	      BigInteger.prototype.notEquals = function (v) {
	        return this.compare(v) !== 0;
	      };
	      NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
	      BigInteger.prototype.greater = function (v) {
	        return this.compare(v) > 0;
	      };
	      NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
	      BigInteger.prototype.lesser = function (v) {
	        return this.compare(v) < 0;
	      };
	      NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
	      BigInteger.prototype.greaterOrEquals = function (v) {
	        return this.compare(v) >= 0;
	      };
	      NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
	      BigInteger.prototype.lesserOrEquals = function (v) {
	        return this.compare(v) <= 0;
	      };
	      NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
	      BigInteger.prototype.isEven = function () {
	        return (this.value[0] & 1) === 0;
	      };
	      SmallInteger.prototype.isEven = function () {
	        return (this.value & 1) === 0;
	      };
	      NativeBigInt.prototype.isEven = function () {
	        return (this.value & BigInt(1)) === BigInt(0);
	      };
	      BigInteger.prototype.isOdd = function () {
	        return (this.value[0] & 1) === 1;
	      };
	      SmallInteger.prototype.isOdd = function () {
	        return (this.value & 1) === 1;
	      };
	      NativeBigInt.prototype.isOdd = function () {
	        return (this.value & BigInt(1)) === BigInt(1);
	      };
	      BigInteger.prototype.isPositive = function () {
	        return !this.sign;
	      };
	      SmallInteger.prototype.isPositive = function () {
	        return this.value > 0;
	      };
	      NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
	      BigInteger.prototype.isNegative = function () {
	        return this.sign;
	      };
	      SmallInteger.prototype.isNegative = function () {
	        return this.value < 0;
	      };
	      NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
	      BigInteger.prototype.isUnit = function () {
	        return false;
	      };
	      SmallInteger.prototype.isUnit = function () {
	        return Math.abs(this.value) === 1;
	      };
	      NativeBigInt.prototype.isUnit = function () {
	        return this.abs().value === BigInt(1);
	      };
	      BigInteger.prototype.isZero = function () {
	        return false;
	      };
	      SmallInteger.prototype.isZero = function () {
	        return this.value === 0;
	      };
	      NativeBigInt.prototype.isZero = function () {
	        return this.value === BigInt(0);
	      };
	      BigInteger.prototype.isDivisibleBy = function (v) {
	        var n = parseValue(v);
	        if (n.isZero()) return false;
	        if (n.isUnit()) return true;
	        if (n.compareAbs(2) === 0) return this.isEven();
	        return this.mod(n).isZero();
	      };
	      NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
	      function isBasicPrime(v) {
	        var n = v.abs();
	        if (n.isUnit()) return false;
	        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
	        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
	        if (n.lesser(49)) return true;
	        // we don't know if it's prime: let the other functions figure it out
	      }
	      function millerRabinTest(n, a) {
	        var nPrev = n.prev(),
	          b = nPrev,
	          r = 0,
	          d,
	          i,
	          x;
	        while (b.isEven()) b = b.divide(2), r++;
	        next: for (i = 0; i < a.length; i++) {
	          if (n.lesser(a[i])) continue;
	          x = bigInt(a[i]).modPow(b, n);
	          if (x.isUnit() || x.equals(nPrev)) continue;
	          for (d = r - 1; d != 0; d--) {
	            x = x.square().mod(n);
	            if (x.isUnit()) return false;
	            if (x.equals(nPrev)) continue next;
	          }
	          return false;
	        }
	        return true;
	      }

	      // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
	      BigInteger.prototype.isPrime = function (strict) {
	        var isPrime = isBasicPrime(this);
	        if (isPrime !== undefined$1) return isPrime;
	        var n = this.abs();
	        var bits = n.bitLength();
	        if (bits <= 64) return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
	        var logN = Math.log(2) * bits.toJSNumber();
	        var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
	        for (var a = [], i = 0; i < t; i++) {
	          a.push(bigInt(i + 2));
	        }
	        return millerRabinTest(n, a);
	      };
	      NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
	      BigInteger.prototype.isProbablePrime = function (iterations, rng) {
	        var isPrime = isBasicPrime(this);
	        if (isPrime !== undefined$1) return isPrime;
	        var n = this.abs();
	        var t = iterations === undefined$1 ? 5 : iterations;
	        for (var a = [], i = 0; i < t; i++) {
	          a.push(bigInt.randBetween(2, n.minus(2), rng));
	        }
	        return millerRabinTest(n, a);
	      };
	      NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
	      BigInteger.prototype.modInv = function (n) {
	        var t = bigInt.zero,
	          newT = bigInt.one,
	          r = parseValue(n),
	          newR = this.abs(),
	          q,
	          lastT,
	          lastR;
	        while (!newR.isZero()) {
	          q = r.divide(newR);
	          lastT = t;
	          lastR = r;
	          t = newT;
	          r = newR;
	          newT = lastT.subtract(q.multiply(newT));
	          newR = lastR.subtract(q.multiply(newR));
	        }
	        if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
	        if (t.compare(0) === -1) {
	          t = t.add(n);
	        }
	        if (this.isNegative()) {
	          return t.negate();
	        }
	        return t;
	      };
	      NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
	      BigInteger.prototype.next = function () {
	        var value = this.value;
	        if (this.sign) {
	          return subtractSmall(value, 1, this.sign);
	        }
	        return new BigInteger(addSmall(value, 1), this.sign);
	      };
	      SmallInteger.prototype.next = function () {
	        var value = this.value;
	        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
	        return new BigInteger(MAX_INT_ARR, false);
	      };
	      NativeBigInt.prototype.next = function () {
	        return new NativeBigInt(this.value + BigInt(1));
	      };
	      BigInteger.prototype.prev = function () {
	        var value = this.value;
	        if (this.sign) {
	          return new BigInteger(addSmall(value, 1), true);
	        }
	        return subtractSmall(value, 1, this.sign);
	      };
	      SmallInteger.prototype.prev = function () {
	        var value = this.value;
	        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
	        return new BigInteger(MAX_INT_ARR, true);
	      };
	      NativeBigInt.prototype.prev = function () {
	        return new NativeBigInt(this.value - BigInt(1));
	      };
	      var powersOfTwo = [1];
	      while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
	      var powers2Length = powersOfTwo.length,
	        highestPower2 = powersOfTwo[powers2Length - 1];
	      function shift_isSmall(n) {
	        return Math.abs(n) <= BASE;
	      }
	      BigInteger.prototype.shiftLeft = function (v) {
	        var n = parseValue(v).toJSNumber();
	        if (!shift_isSmall(n)) {
	          throw new Error(String(n) + " is too large for shifting.");
	        }
	        if (n < 0) return this.shiftRight(-n);
	        var result = this;
	        if (result.isZero()) return result;
	        while (n >= powers2Length) {
	          result = result.multiply(highestPower2);
	          n -= powers2Length - 1;
	        }
	        return result.multiply(powersOfTwo[n]);
	      };
	      NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
	      BigInteger.prototype.shiftRight = function (v) {
	        var remQuo;
	        var n = parseValue(v).toJSNumber();
	        if (!shift_isSmall(n)) {
	          throw new Error(String(n) + " is too large for shifting.");
	        }
	        if (n < 0) return this.shiftLeft(-n);
	        var result = this;
	        while (n >= powers2Length) {
	          if (result.isZero() || result.isNegative() && result.isUnit()) return result;
	          remQuo = divModAny(result, highestPower2);
	          result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
	          n -= powers2Length - 1;
	        }
	        remQuo = divModAny(result, powersOfTwo[n]);
	        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
	      };
	      NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
	      function bitwise(x, y, fn) {
	        y = parseValue(y);
	        var xSign = x.isNegative(),
	          ySign = y.isNegative();
	        var xRem = xSign ? x.not() : x,
	          yRem = ySign ? y.not() : y;
	        var xDigit = 0,
	          yDigit = 0;
	        var xDivMod = null,
	          yDivMod = null;
	        var result = [];
	        while (!xRem.isZero() || !yRem.isZero()) {
	          xDivMod = divModAny(xRem, highestPower2);
	          xDigit = xDivMod[1].toJSNumber();
	          if (xSign) {
	            xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
	          }
	          yDivMod = divModAny(yRem, highestPower2);
	          yDigit = yDivMod[1].toJSNumber();
	          if (ySign) {
	            yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
	          }
	          xRem = xDivMod[0];
	          yRem = yDivMod[0];
	          result.push(fn(xDigit, yDigit));
	        }
	        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
	        for (var i = result.length - 1; i >= 0; i -= 1) {
	          sum = sum.multiply(highestPower2).add(bigInt(result[i]));
	        }
	        return sum;
	      }
	      BigInteger.prototype.not = function () {
	        return this.negate().prev();
	      };
	      NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
	      BigInteger.prototype.and = function (n) {
	        return bitwise(this, n, function (a, b) {
	          return a & b;
	        });
	      };
	      NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
	      BigInteger.prototype.or = function (n) {
	        return bitwise(this, n, function (a, b) {
	          return a | b;
	        });
	      };
	      NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
	      BigInteger.prototype.xor = function (n) {
	        return bitwise(this, n, function (a, b) {
	          return a ^ b;
	        });
	      };
	      NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
	      var LOBMASK_I = 1 << 30,
	        LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
	      function roughLOB(n) {
	        // get lowestOneBit (rough)
	        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
	        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
	        var v = n.value,
	          x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
	        return x & -x;
	      }
	      function integerLogarithm(value, base) {
	        if (base.compareTo(value) <= 0) {
	          var tmp = integerLogarithm(value, base.square(base));
	          var p = tmp.p;
	          var e = tmp.e;
	          var t = p.multiply(base);
	          return t.compareTo(value) <= 0 ? {
	            p: t,
	            e: e * 2 + 1
	          } : {
	            p: p,
	            e: e * 2
	          };
	        }
	        return {
	          p: bigInt(1),
	          e: 0
	        };
	      }
	      BigInteger.prototype.bitLength = function () {
	        var n = this;
	        if (n.compareTo(bigInt(0)) < 0) {
	          n = n.negate().subtract(bigInt(1));
	        }
	        if (n.compareTo(bigInt(0)) === 0) {
	          return bigInt(0);
	        }
	        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
	      };
	      NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
	      function max(a, b) {
	        a = parseValue(a);
	        b = parseValue(b);
	        return a.greater(b) ? a : b;
	      }
	      function min(a, b) {
	        a = parseValue(a);
	        b = parseValue(b);
	        return a.lesser(b) ? a : b;
	      }
	      function gcd(a, b) {
	        a = parseValue(a).abs();
	        b = parseValue(b).abs();
	        if (a.equals(b)) return a;
	        if (a.isZero()) return b;
	        if (b.isZero()) return a;
	        var c = Integer[1],
	          d,
	          t;
	        while (a.isEven() && b.isEven()) {
	          d = min(roughLOB(a), roughLOB(b));
	          a = a.divide(d);
	          b = b.divide(d);
	          c = c.multiply(d);
	        }
	        while (a.isEven()) {
	          a = a.divide(roughLOB(a));
	        }
	        do {
	          while (b.isEven()) {
	            b = b.divide(roughLOB(b));
	          }
	          if (a.greater(b)) {
	            t = b;
	            b = a;
	            a = t;
	          }
	          b = b.subtract(a);
	        } while (!b.isZero());
	        return c.isUnit() ? a : a.multiply(c);
	      }
	      function lcm(a, b) {
	        a = parseValue(a).abs();
	        b = parseValue(b).abs();
	        return a.divide(gcd(a, b)).multiply(b);
	      }
	      function randBetween(a, b, rng) {
	        a = parseValue(a);
	        b = parseValue(b);
	        var usedRNG = rng || Math.random;
	        var low = min(a, b),
	          high = max(a, b);
	        var range = high.subtract(low).add(1);
	        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
	        var digits = toBase(range, BASE).value;
	        var result = [],
	          restricted = true;
	        for (var i = 0; i < digits.length; i++) {
	          var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;
	          var digit = truncate(usedRNG() * top);
	          result.push(digit);
	          if (digit < digits[i]) restricted = false;
	        }
	        return low.add(Integer.fromArray(result, BASE, false));
	      }
	      var parseBase = function (text, base, alphabet, caseSensitive) {
	        alphabet = alphabet || DEFAULT_ALPHABET;
	        text = String(text);
	        if (!caseSensitive) {
	          text = text.toLowerCase();
	          alphabet = alphabet.toLowerCase();
	        }
	        var length = text.length;
	        var i;
	        var absBase = Math.abs(base);
	        var alphabetValues = {};
	        for (i = 0; i < alphabet.length; i++) {
	          alphabetValues[alphabet[i]] = i;
	        }
	        for (i = 0; i < length; i++) {
	          var c = text[i];
	          if (c === "-") continue;
	          if (c in alphabetValues) {
	            if (alphabetValues[c] >= absBase) {
	              if (c === "1" && absBase === 1) continue;
	              throw new Error(c + " is not a valid digit in base " + base + ".");
	            }
	          }
	        }
	        base = parseValue(base);
	        var digits = [];
	        var isNegative = text[0] === "-";
	        for (i = isNegative ? 1 : 0; i < text.length; i++) {
	          var c = text[i];
	          if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));else if (c === "<") {
	            var start = i;
	            do {
	              i++;
	            } while (text[i] !== ">" && i < text.length);
	            digits.push(parseValue(text.slice(start + 1, i)));
	          } else throw new Error(c + " is not a valid character");
	        }
	        return parseBaseFromArray(digits, base, isNegative);
	      };
	      function parseBaseFromArray(digits, base, isNegative) {
	        var val = Integer[0],
	          pow = Integer[1],
	          i;
	        for (i = digits.length - 1; i >= 0; i--) {
	          val = val.add(digits[i].times(pow));
	          pow = pow.times(base);
	        }
	        return isNegative ? val.negate() : val;
	      }
	      function stringify(digit, alphabet) {
	        alphabet = alphabet || DEFAULT_ALPHABET;
	        if (digit < alphabet.length) {
	          return alphabet[digit];
	        }
	        return "<" + digit + ">";
	      }
	      function toBase(n, base) {
	        base = bigInt(base);
	        if (base.isZero()) {
	          if (n.isZero()) return {
	            value: [0],
	            isNegative: false
	          };
	          throw new Error("Cannot convert nonzero numbers to base 0.");
	        }
	        if (base.equals(-1)) {
	          if (n.isZero()) return {
	            value: [0],
	            isNegative: false
	          };
	          if (n.isNegative()) return {
	            value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])),
	            isNegative: false
	          };
	          var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
	          arr.unshift([1]);
	          return {
	            value: [].concat.apply([], arr),
	            isNegative: false
	          };
	        }
	        var neg = false;
	        if (n.isNegative() && base.isPositive()) {
	          neg = true;
	          n = n.abs();
	        }
	        if (base.isUnit()) {
	          if (n.isZero()) return {
	            value: [0],
	            isNegative: false
	          };
	          return {
	            value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
	            isNegative: neg
	          };
	        }
	        var out = [];
	        var left = n,
	          divmod;
	        while (left.isNegative() || left.compareAbs(base) >= 0) {
	          divmod = left.divmod(base);
	          left = divmod.quotient;
	          var digit = divmod.remainder;
	          if (digit.isNegative()) {
	            digit = base.minus(digit).abs();
	            left = left.next();
	          }
	          out.push(digit.toJSNumber());
	        }
	        out.push(left.toJSNumber());
	        return {
	          value: out.reverse(),
	          isNegative: neg
	        };
	      }
	      function toBaseString(n, base, alphabet) {
	        var arr = toBase(n, base);
	        return (arr.isNegative ? "-" : "") + arr.value.map(function (x) {
	          return stringify(x, alphabet);
	        }).join('');
	      }
	      BigInteger.prototype.toArray = function (radix) {
	        return toBase(this, radix);
	      };
	      SmallInteger.prototype.toArray = function (radix) {
	        return toBase(this, radix);
	      };
	      NativeBigInt.prototype.toArray = function (radix) {
	        return toBase(this, radix);
	      };
	      BigInteger.prototype.toString = function (radix, alphabet) {
	        if (radix === undefined$1) radix = 10;
	        if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);
	        var v = this.value,
	          l = v.length,
	          str = String(v[--l]),
	          zeros = "0000000",
	          digit;
	        while (--l >= 0) {
	          digit = String(v[l]);
	          str += zeros.slice(digit.length) + digit;
	        }
	        var sign = this.sign ? "-" : "";
	        return sign + str;
	      };
	      SmallInteger.prototype.toString = function (radix, alphabet) {
	        if (radix === undefined$1) radix = 10;
	        if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);
	        return String(this.value);
	      };
	      NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
	      NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () {
	        return this.toString();
	      };
	      BigInteger.prototype.valueOf = function () {
	        return parseInt(this.toString(), 10);
	      };
	      BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
	      SmallInteger.prototype.valueOf = function () {
	        return this.value;
	      };
	      SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
	      NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {
	        return parseInt(this.toString(), 10);
	      };
	      function parseStringValue(v) {
	        if (isPrecise(+v)) {
	          var x = +v;
	          if (x === truncate(x)) return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
	          throw new Error("Invalid integer: " + v);
	        }
	        var sign = v[0] === "-";
	        if (sign) v = v.slice(1);
	        var split = v.split(/e/i);
	        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
	        if (split.length === 2) {
	          var exp = split[1];
	          if (exp[0] === "+") exp = exp.slice(1);
	          exp = +exp;
	          if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
	          var text = split[0];
	          var decimalPlace = text.indexOf(".");
	          if (decimalPlace >= 0) {
	            exp -= text.length - decimalPlace - 1;
	            text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
	          }
	          if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
	          text += new Array(exp + 1).join("0");
	          v = text;
	        }
	        var isValid = /^([0-9][0-9]*)$/.test(v);
	        if (!isValid) throw new Error("Invalid integer: " + v);
	        if (supportsNativeBigInt) {
	          return new NativeBigInt(BigInt(sign ? "-" + v : v));
	        }
	        var r = [],
	          max = v.length,
	          l = LOG_BASE,
	          min = max - l;
	        while (max > 0) {
	          r.push(+v.slice(min, max));
	          min -= l;
	          if (min < 0) min = 0;
	          max -= l;
	        }
	        trim(r);
	        return new BigInteger(r, sign);
	      }
	      function parseNumberValue(v) {
	        if (supportsNativeBigInt) {
	          return new NativeBigInt(BigInt(v));
	        }
	        if (isPrecise(v)) {
	          if (v !== truncate(v)) throw new Error(v + " is not an integer.");
	          return new SmallInteger(v);
	        }
	        return parseStringValue(v.toString());
	      }
	      function parseValue(v) {
	        if (typeof v === "number") {
	          return parseNumberValue(v);
	        }
	        if (typeof v === "string") {
	          return parseStringValue(v);
	        }
	        if (typeof v === "bigint") {
	          return new NativeBigInt(v);
	        }
	        return v;
	      }
	      // Pre-define numbers in range [-999,999]
	      for (var i = 0; i < 1000; i++) {
	        Integer[i] = parseValue(i);
	        if (i > 0) Integer[-i] = parseValue(-i);
	      }
	      // Backwards compatibility
	      Integer.one = Integer[1];
	      Integer.zero = Integer[0];
	      Integer.minusOne = Integer[-1];
	      Integer.max = max;
	      Integer.min = min;
	      Integer.gcd = gcd;
	      Integer.lcm = lcm;
	      Integer.isInstance = function (x) {
	        return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
	      };
	      Integer.randBetween = randBetween;
	      Integer.fromArray = function (digits, base, isNegative) {
	        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
	      };
	      return Integer;
	    }();

	    // Node.js check
	    if (module.hasOwnProperty("exports")) {
	      module.exports = bigInt;
	    }
	  })(BigInteger);
	  return BigInteger.exports;
	}

	var lib;
	var hasRequiredLib$1;
	function requireLib$1() {
	  if (hasRequiredLib$1) return lib;
	  hasRequiredLib$1 = 1;
	  const bigInt = requireBigInteger();
	  const knownBases = {
	    base64url: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_',
	    base64: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/',
	    base62: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
	    base58: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
	    // Bitcoin base58
	    base36: '0123456789abcdefghijklmnopqrstuvwxyz',
	    base32: '0123456789abcdefghjkmnpqrstvwxyz',
	    // Crockford's base32
	    base16: '0123456789abcdef',
	    base10: '0123456789',
	    base2: '01'
	  };
	  const caseSensitiveBases = {
	    base64url: true,
	    base64: true,
	    base62: true,
	    base58: true,
	    base36: false,
	    base32: false,
	    base16: false,
	    base10: true,
	    base2: true
	  };
	  class UuidEncoder {
	    /**
	     * @public
	     * @param [baseEncodingStr] A string containing all usable letters for encoding
	     * @constructor
	     */
	    constructor(baseEncodingStr = 'base36') {
	      this.setBaseEncodingStr(baseEncodingStr);
	    }

	    /**
	     * Set encoding base
	     * @param {string} baseEncodingStr A string containing all usable letters for encoding
	     * @public
	     */
	    setBaseEncodingStr(baseEncodingStr) {
	      this.encStr = UuidEncoder.resolveEncodingStr(baseEncodingStr);
	      this.isCaseSensitive = UuidEncoder.isCaseSensitiveBase(baseEncodingStr);
	      this.base = this.encStr.length;
	    }

	    /**
	     * @private
	     * @param {string} baseEncodingStr
	     * @returns {string}
	     */
	    static resolveEncodingStr(baseEncodingStr) {
	      return Object.prototype.hasOwnProperty.call(knownBases, baseEncodingStr) ? knownBases[baseEncodingStr] : baseEncodingStr;
	    }

	    /**
	     * @public
	     * @param baseEncodingStr
	     * @returns {boolean}
	     */
	    static isCaseSensitiveBase(baseEncodingStr) {
	      return Object.prototype.hasOwnProperty.call(caseSensitiveBases, baseEncodingStr) ? caseSensitiveBases[baseEncodingStr] : true;
	    }

	    /**
	     * Encode a UUID
	     * @param {string} uuid Properly formatted UUID
	     * @returns {string} Encoded UUID
	     * @public
	     */
	    encode(uuid) {
	      const cleanUuid = uuid.replace(/-/g, '');
	      const {
	        base,
	        encStr
	      } = this;
	      let iUuid = bigInt(cleanUuid, 16);
	      let str = '';
	      do {
	        str = encStr.substr(iUuid.mod(base).valueOf(), 1) + str;
	        iUuid = iUuid.divide(base);
	      } while (iUuid.greater(0));
	      return str;
	    }

	    /**
	     * Decode an encoded UUID
	     * @public
	     * @param {string} str Previously encoded string
	     * @returns {string} Properly formatted UUID
	     * @throws Throws an {Error} when encountering invalid data
	     */
	    decode(str) {
	      let iUuid = bigInt(0);
	      const {
	        base,
	        encStr
	      } = this;
	      const len = str.length;
	      const finalStr = this.isCaseSensitive ? str : str.toLowerCase();
	      for (let pos = 0; pos < len; pos += 1) {
	        const ch = finalStr.substr(pos, 1);
	        const encPos = encStr.indexOf(ch);
	        if (encPos < 0) {
	          throw new Error('Invalid encoded data');
	        }
	        iUuid = iUuid.add(encPos);
	        if (pos < len - 1) {
	          iUuid = iUuid.multiply(base);
	        }
	      }
	      const uuid = iUuid.toString(16).padStart(32, '0');
	      return `${uuid.substr(0, 8)}-${uuid.substr(8, 4)}-${uuid.substr(12, 4)}-${uuid.substr(16, 4)}-${uuid.substr(20)}`;
	    }
	  }
	  lib = UuidEncoder;
	  return lib;
	}

	var colorName;
	var hasRequiredColorName;
	function requireColorName() {
	  if (hasRequiredColorName) return colorName;
	  hasRequiredColorName = 1;
	  colorName = {
	    "aliceblue": [240, 248, 255],
	    "antiquewhite": [250, 235, 215],
	    "aqua": [0, 255, 255],
	    "aquamarine": [127, 255, 212],
	    "azure": [240, 255, 255],
	    "beige": [245, 245, 220],
	    "bisque": [255, 228, 196],
	    "black": [0, 0, 0],
	    "blanchedalmond": [255, 235, 205],
	    "blue": [0, 0, 255],
	    "blueviolet": [138, 43, 226],
	    "brown": [165, 42, 42],
	    "burlywood": [222, 184, 135],
	    "cadetblue": [95, 158, 160],
	    "chartreuse": [127, 255, 0],
	    "chocolate": [210, 105, 30],
	    "coral": [255, 127, 80],
	    "cornflowerblue": [100, 149, 237],
	    "cornsilk": [255, 248, 220],
	    "crimson": [220, 20, 60],
	    "cyan": [0, 255, 255],
	    "darkblue": [0, 0, 139],
	    "darkcyan": [0, 139, 139],
	    "darkgoldenrod": [184, 134, 11],
	    "darkgray": [169, 169, 169],
	    "darkgreen": [0, 100, 0],
	    "darkgrey": [169, 169, 169],
	    "darkkhaki": [189, 183, 107],
	    "darkmagenta": [139, 0, 139],
	    "darkolivegreen": [85, 107, 47],
	    "darkorange": [255, 140, 0],
	    "darkorchid": [153, 50, 204],
	    "darkred": [139, 0, 0],
	    "darksalmon": [233, 150, 122],
	    "darkseagreen": [143, 188, 143],
	    "darkslateblue": [72, 61, 139],
	    "darkslategray": [47, 79, 79],
	    "darkslategrey": [47, 79, 79],
	    "darkturquoise": [0, 206, 209],
	    "darkviolet": [148, 0, 211],
	    "deeppink": [255, 20, 147],
	    "deepskyblue": [0, 191, 255],
	    "dimgray": [105, 105, 105],
	    "dimgrey": [105, 105, 105],
	    "dodgerblue": [30, 144, 255],
	    "firebrick": [178, 34, 34],
	    "floralwhite": [255, 250, 240],
	    "forestgreen": [34, 139, 34],
	    "fuchsia": [255, 0, 255],
	    "gainsboro": [220, 220, 220],
	    "ghostwhite": [248, 248, 255],
	    "gold": [255, 215, 0],
	    "goldenrod": [218, 165, 32],
	    "gray": [128, 128, 128],
	    "green": [0, 128, 0],
	    "greenyellow": [173, 255, 47],
	    "grey": [128, 128, 128],
	    "honeydew": [240, 255, 240],
	    "hotpink": [255, 105, 180],
	    "indianred": [205, 92, 92],
	    "indigo": [75, 0, 130],
	    "ivory": [255, 255, 240],
	    "khaki": [240, 230, 140],
	    "lavender": [230, 230, 250],
	    "lavenderblush": [255, 240, 245],
	    "lawngreen": [124, 252, 0],
	    "lemonchiffon": [255, 250, 205],
	    "lightblue": [173, 216, 230],
	    "lightcoral": [240, 128, 128],
	    "lightcyan": [224, 255, 255],
	    "lightgoldenrodyellow": [250, 250, 210],
	    "lightgray": [211, 211, 211],
	    "lightgreen": [144, 238, 144],
	    "lightgrey": [211, 211, 211],
	    "lightpink": [255, 182, 193],
	    "lightsalmon": [255, 160, 122],
	    "lightseagreen": [32, 178, 170],
	    "lightskyblue": [135, 206, 250],
	    "lightslategray": [119, 136, 153],
	    "lightslategrey": [119, 136, 153],
	    "lightsteelblue": [176, 196, 222],
	    "lightyellow": [255, 255, 224],
	    "lime": [0, 255, 0],
	    "limegreen": [50, 205, 50],
	    "linen": [250, 240, 230],
	    "magenta": [255, 0, 255],
	    "maroon": [128, 0, 0],
	    "mediumaquamarine": [102, 205, 170],
	    "mediumblue": [0, 0, 205],
	    "mediumorchid": [186, 85, 211],
	    "mediumpurple": [147, 112, 219],
	    "mediumseagreen": [60, 179, 113],
	    "mediumslateblue": [123, 104, 238],
	    "mediumspringgreen": [0, 250, 154],
	    "mediumturquoise": [72, 209, 204],
	    "mediumvioletred": [199, 21, 133],
	    "midnightblue": [25, 25, 112],
	    "mintcream": [245, 255, 250],
	    "mistyrose": [255, 228, 225],
	    "moccasin": [255, 228, 181],
	    "navajowhite": [255, 222, 173],
	    "navy": [0, 0, 128],
	    "oldlace": [253, 245, 230],
	    "olive": [128, 128, 0],
	    "olivedrab": [107, 142, 35],
	    "orange": [255, 165, 0],
	    "orangered": [255, 69, 0],
	    "orchid": [218, 112, 214],
	    "palegoldenrod": [238, 232, 170],
	    "palegreen": [152, 251, 152],
	    "paleturquoise": [175, 238, 238],
	    "palevioletred": [219, 112, 147],
	    "papayawhip": [255, 239, 213],
	    "peachpuff": [255, 218, 185],
	    "peru": [205, 133, 63],
	    "pink": [255, 192, 203],
	    "plum": [221, 160, 221],
	    "powderblue": [176, 224, 230],
	    "purple": [128, 0, 128],
	    "rebeccapurple": [102, 51, 153],
	    "red": [255, 0, 0],
	    "rosybrown": [188, 143, 143],
	    "royalblue": [65, 105, 225],
	    "saddlebrown": [139, 69, 19],
	    "salmon": [250, 128, 114],
	    "sandybrown": [244, 164, 96],
	    "seagreen": [46, 139, 87],
	    "seashell": [255, 245, 238],
	    "sienna": [160, 82, 45],
	    "silver": [192, 192, 192],
	    "skyblue": [135, 206, 235],
	    "slateblue": [106, 90, 205],
	    "slategray": [112, 128, 144],
	    "slategrey": [112, 128, 144],
	    "snow": [255, 250, 250],
	    "springgreen": [0, 255, 127],
	    "steelblue": [70, 130, 180],
	    "tan": [210, 180, 140],
	    "teal": [0, 128, 128],
	    "thistle": [216, 191, 216],
	    "tomato": [255, 99, 71],
	    "turquoise": [64, 224, 208],
	    "violet": [238, 130, 238],
	    "wheat": [245, 222, 179],
	    "white": [255, 255, 255],
	    "whitesmoke": [245, 245, 245],
	    "yellow": [255, 255, 0],
	    "yellowgreen": [154, 205, 50]
	  };
	  return colorName;
	}

	/* MIT license */
	var conversions;
	var hasRequiredConversions;
	function requireConversions() {
	  if (hasRequiredConversions) return conversions;
	  hasRequiredConversions = 1;
	  /* eslint-disable no-mixed-operators */
	  const cssKeywords = requireColorName();

	  // NOTE: conversions should only return primitive values (i.e. arrays, or
	  //       values that give correct `typeof` results).
	  //       do not use box values types (i.e. Number(), String(), etc.)

	  const reverseKeywords = {};
	  for (const key of Object.keys(cssKeywords)) {
	    reverseKeywords[cssKeywords[key]] = key;
	  }
	  const convert = {
	    rgb: {
	      channels: 3,
	      labels: 'rgb'
	    },
	    hsl: {
	      channels: 3,
	      labels: 'hsl'
	    },
	    hsv: {
	      channels: 3,
	      labels: 'hsv'
	    },
	    hwb: {
	      channels: 3,
	      labels: 'hwb'
	    },
	    cmyk: {
	      channels: 4,
	      labels: 'cmyk'
	    },
	    xyz: {
	      channels: 3,
	      labels: 'xyz'
	    },
	    lab: {
	      channels: 3,
	      labels: 'lab'
	    },
	    lch: {
	      channels: 3,
	      labels: 'lch'
	    },
	    hex: {
	      channels: 1,
	      labels: ['hex']
	    },
	    keyword: {
	      channels: 1,
	      labels: ['keyword']
	    },
	    ansi16: {
	      channels: 1,
	      labels: ['ansi16']
	    },
	    ansi256: {
	      channels: 1,
	      labels: ['ansi256']
	    },
	    hcg: {
	      channels: 3,
	      labels: ['h', 'c', 'g']
	    },
	    apple: {
	      channels: 3,
	      labels: ['r16', 'g16', 'b16']
	    },
	    gray: {
	      channels: 1,
	      labels: ['gray']
	    }
	  };
	  conversions = convert;

	  // Hide .channels and .labels properties
	  for (const model of Object.keys(convert)) {
	    if (!('channels' in convert[model])) {
	      throw new Error('missing channels property: ' + model);
	    }
	    if (!('labels' in convert[model])) {
	      throw new Error('missing channel labels property: ' + model);
	    }
	    if (convert[model].labels.length !== convert[model].channels) {
	      throw new Error('channel and label counts mismatch: ' + model);
	    }
	    const {
	      channels,
	      labels
	    } = convert[model];
	    delete convert[model].channels;
	    delete convert[model].labels;
	    Object.defineProperty(convert[model], 'channels', {
	      value: channels
	    });
	    Object.defineProperty(convert[model], 'labels', {
	      value: labels
	    });
	  }
	  convert.rgb.hsl = function (rgb) {
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const min = Math.min(r, g, b);
	    const max = Math.max(r, g, b);
	    const delta = max - min;
	    let h;
	    let s;
	    if (max === min) {
	      h = 0;
	    } else if (r === max) {
	      h = (g - b) / delta;
	    } else if (g === max) {
	      h = 2 + (b - r) / delta;
	    } else if (b === max) {
	      h = 4 + (r - g) / delta;
	    }
	    h = Math.min(h * 60, 360);
	    if (h < 0) {
	      h += 360;
	    }
	    const l = (min + max) / 2;
	    if (max === min) {
	      s = 0;
	    } else if (l <= 0.5) {
	      s = delta / (max + min);
	    } else {
	      s = delta / (2 - max - min);
	    }
	    return [h, s * 100, l * 100];
	  };
	  convert.rgb.hsv = function (rgb) {
	    let rdif;
	    let gdif;
	    let bdif;
	    let h;
	    let s;
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const v = Math.max(r, g, b);
	    const diff = v - Math.min(r, g, b);
	    const diffc = function (c) {
	      return (v - c) / 6 / diff + 1 / 2;
	    };
	    if (diff === 0) {
	      h = 0;
	      s = 0;
	    } else {
	      s = diff / v;
	      rdif = diffc(r);
	      gdif = diffc(g);
	      bdif = diffc(b);
	      if (r === v) {
	        h = bdif - gdif;
	      } else if (g === v) {
	        h = 1 / 3 + rdif - bdif;
	      } else if (b === v) {
	        h = 2 / 3 + gdif - rdif;
	      }
	      if (h < 0) {
	        h += 1;
	      } else if (h > 1) {
	        h -= 1;
	      }
	    }
	    return [h * 360, s * 100, v * 100];
	  };
	  convert.rgb.hwb = function (rgb) {
	    const r = rgb[0];
	    const g = rgb[1];
	    let b = rgb[2];
	    const h = convert.rgb.hsl(rgb)[0];
	    const w = 1 / 255 * Math.min(r, Math.min(g, b));
	    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
	    return [h, w * 100, b * 100];
	  };
	  convert.rgb.cmyk = function (rgb) {
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const k = Math.min(1 - r, 1 - g, 1 - b);
	    const c = (1 - r - k) / (1 - k) || 0;
	    const m = (1 - g - k) / (1 - k) || 0;
	    const y = (1 - b - k) / (1 - k) || 0;
	    return [c * 100, m * 100, y * 100, k * 100];
	  };
	  function comparativeDistance(x, y) {
	    /*
	    	See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	    */
	    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
	  }
	  convert.rgb.keyword = function (rgb) {
	    const reversed = reverseKeywords[rgb];
	    if (reversed) {
	      return reversed;
	    }
	    let currentClosestDistance = Infinity;
	    let currentClosestKeyword;
	    for (const keyword of Object.keys(cssKeywords)) {
	      const value = cssKeywords[keyword];

	      // Compute comparative distance
	      const distance = comparativeDistance(rgb, value);

	      // Check if its less, if so set as closest
	      if (distance < currentClosestDistance) {
	        currentClosestDistance = distance;
	        currentClosestKeyword = keyword;
	      }
	    }
	    return currentClosestKeyword;
	  };
	  convert.keyword.rgb = function (keyword) {
	    return cssKeywords[keyword];
	  };
	  convert.rgb.xyz = function (rgb) {
	    let r = rgb[0] / 255;
	    let g = rgb[1] / 255;
	    let b = rgb[2] / 255;

	    // Assume sRGB
	    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
	    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
	    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
	    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
	    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
	    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
	    return [x * 100, y * 100, z * 100];
	  };
	  convert.rgb.lab = function (rgb) {
	    const xyz = convert.rgb.xyz(rgb);
	    let x = xyz[0];
	    let y = xyz[1];
	    let z = xyz[2];
	    x /= 95.047;
	    y /= 100;
	    z /= 108.883;
	    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
	    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
	    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
	    const l = 116 * y - 16;
	    const a = 500 * (x - y);
	    const b = 200 * (y - z);
	    return [l, a, b];
	  };
	  convert.hsl.rgb = function (hsl) {
	    const h = hsl[0] / 360;
	    const s = hsl[1] / 100;
	    const l = hsl[2] / 100;
	    let t2;
	    let t3;
	    let val;
	    if (s === 0) {
	      val = l * 255;
	      return [val, val, val];
	    }
	    if (l < 0.5) {
	      t2 = l * (1 + s);
	    } else {
	      t2 = l + s - l * s;
	    }
	    const t1 = 2 * l - t2;
	    const rgb = [0, 0, 0];
	    for (let i = 0; i < 3; i++) {
	      t3 = h + 1 / 3 * -(i - 1);
	      if (t3 < 0) {
	        t3++;
	      }
	      if (t3 > 1) {
	        t3--;
	      }
	      if (6 * t3 < 1) {
	        val = t1 + (t2 - t1) * 6 * t3;
	      } else if (2 * t3 < 1) {
	        val = t2;
	      } else if (3 * t3 < 2) {
	        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
	      } else {
	        val = t1;
	      }
	      rgb[i] = val * 255;
	    }
	    return rgb;
	  };
	  convert.hsl.hsv = function (hsl) {
	    const h = hsl[0];
	    let s = hsl[1] / 100;
	    let l = hsl[2] / 100;
	    let smin = s;
	    const lmin = Math.max(l, 0.01);
	    l *= 2;
	    s *= l <= 1 ? l : 2 - l;
	    smin *= lmin <= 1 ? lmin : 2 - lmin;
	    const v = (l + s) / 2;
	    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
	    return [h, sv * 100, v * 100];
	  };
	  convert.hsv.rgb = function (hsv) {
	    const h = hsv[0] / 60;
	    const s = hsv[1] / 100;
	    let v = hsv[2] / 100;
	    const hi = Math.floor(h) % 6;
	    const f = h - Math.floor(h);
	    const p = 255 * v * (1 - s);
	    const q = 255 * v * (1 - s * f);
	    const t = 255 * v * (1 - s * (1 - f));
	    v *= 255;
	    switch (hi) {
	      case 0:
	        return [v, t, p];
	      case 1:
	        return [q, v, p];
	      case 2:
	        return [p, v, t];
	      case 3:
	        return [p, q, v];
	      case 4:
	        return [t, p, v];
	      case 5:
	        return [v, p, q];
	    }
	  };
	  convert.hsv.hsl = function (hsv) {
	    const h = hsv[0];
	    const s = hsv[1] / 100;
	    const v = hsv[2] / 100;
	    const vmin = Math.max(v, 0.01);
	    let sl;
	    let l;
	    l = (2 - s) * v;
	    const lmin = (2 - s) * vmin;
	    sl = s * vmin;
	    sl /= lmin <= 1 ? lmin : 2 - lmin;
	    sl = sl || 0;
	    l /= 2;
	    return [h, sl * 100, l * 100];
	  };

	  // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
	  convert.hwb.rgb = function (hwb) {
	    const h = hwb[0] / 360;
	    let wh = hwb[1] / 100;
	    let bl = hwb[2] / 100;
	    const ratio = wh + bl;
	    let f;

	    // Wh + bl cant be > 1
	    if (ratio > 1) {
	      wh /= ratio;
	      bl /= ratio;
	    }
	    const i = Math.floor(6 * h);
	    const v = 1 - bl;
	    f = 6 * h - i;
	    if ((i & 0x01) !== 0) {
	      f = 1 - f;
	    }
	    const n = wh + f * (v - wh); // Linear interpolation

	    let r;
	    let g;
	    let b;
	    /* eslint-disable max-statements-per-line,no-multi-spaces */
	    switch (i) {
	      default:
	      case 6:
	      case 0:
	        r = v;
	        g = n;
	        b = wh;
	        break;
	      case 1:
	        r = n;
	        g = v;
	        b = wh;
	        break;
	      case 2:
	        r = wh;
	        g = v;
	        b = n;
	        break;
	      case 3:
	        r = wh;
	        g = n;
	        b = v;
	        break;
	      case 4:
	        r = n;
	        g = wh;
	        b = v;
	        break;
	      case 5:
	        r = v;
	        g = wh;
	        b = n;
	        break;
	    }
	    /* eslint-enable max-statements-per-line,no-multi-spaces */

	    return [r * 255, g * 255, b * 255];
	  };
	  convert.cmyk.rgb = function (cmyk) {
	    const c = cmyk[0] / 100;
	    const m = cmyk[1] / 100;
	    const y = cmyk[2] / 100;
	    const k = cmyk[3] / 100;
	    const r = 1 - Math.min(1, c * (1 - k) + k);
	    const g = 1 - Math.min(1, m * (1 - k) + k);
	    const b = 1 - Math.min(1, y * (1 - k) + k);
	    return [r * 255, g * 255, b * 255];
	  };
	  convert.xyz.rgb = function (xyz) {
	    const x = xyz[0] / 100;
	    const y = xyz[1] / 100;
	    const z = xyz[2] / 100;
	    let r;
	    let g;
	    let b;
	    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
	    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
	    b = x * 0.0557 + y * -0.204 + z * 1.0570;

	    // Assume sRGB
	    r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
	    g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
	    b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
	    r = Math.min(Math.max(0, r), 1);
	    g = Math.min(Math.max(0, g), 1);
	    b = Math.min(Math.max(0, b), 1);
	    return [r * 255, g * 255, b * 255];
	  };
	  convert.xyz.lab = function (xyz) {
	    let x = xyz[0];
	    let y = xyz[1];
	    let z = xyz[2];
	    x /= 95.047;
	    y /= 100;
	    z /= 108.883;
	    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
	    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
	    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
	    const l = 116 * y - 16;
	    const a = 500 * (x - y);
	    const b = 200 * (y - z);
	    return [l, a, b];
	  };
	  convert.lab.xyz = function (lab) {
	    const l = lab[0];
	    const a = lab[1];
	    const b = lab[2];
	    let x;
	    let y;
	    let z;
	    y = (l + 16) / 116;
	    x = a / 500 + y;
	    z = y - b / 200;
	    const y2 = y ** 3;
	    const x2 = x ** 3;
	    const z2 = z ** 3;
	    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
	    x *= 95.047;
	    y *= 100;
	    z *= 108.883;
	    return [x, y, z];
	  };
	  convert.lab.lch = function (lab) {
	    const l = lab[0];
	    const a = lab[1];
	    const b = lab[2];
	    let h;
	    const hr = Math.atan2(b, a);
	    h = hr * 360 / 2 / Math.PI;
	    if (h < 0) {
	      h += 360;
	    }
	    const c = Math.sqrt(a * a + b * b);
	    return [l, c, h];
	  };
	  convert.lch.lab = function (lch) {
	    const l = lch[0];
	    const c = lch[1];
	    const h = lch[2];
	    const hr = h / 360 * 2 * Math.PI;
	    const a = c * Math.cos(hr);
	    const b = c * Math.sin(hr);
	    return [l, a, b];
	  };
	  convert.rgb.ansi16 = function (args, saturation = null) {
	    const [r, g, b] = args;
	    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	    value = Math.round(value / 50);
	    if (value === 0) {
	      return 30;
	    }
	    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
	    if (value === 2) {
	      ansi += 60;
	    }
	    return ansi;
	  };
	  convert.hsv.ansi16 = function (args) {
	    // Optimization here; we already know the value and don't need to get
	    // it converted for us.
	    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
	  };
	  convert.rgb.ansi256 = function (args) {
	    const r = args[0];
	    const g = args[1];
	    const b = args[2];

	    // We use the extended greyscale palette here, with the exception of
	    // black and white. normal palette only has 4 greyscale shades.
	    if (r === g && g === b) {
	      if (r < 8) {
	        return 16;
	      }
	      if (r > 248) {
	        return 231;
	      }
	      return Math.round((r - 8) / 247 * 24) + 232;
	    }
	    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
	    return ansi;
	  };
	  convert.ansi16.rgb = function (args) {
	    let color = args % 10;

	    // Handle greyscale
	    if (color === 0 || color === 7) {
	      if (args > 50) {
	        color += 3.5;
	      }
	      color = color / 10.5 * 255;
	      return [color, color, color];
	    }
	    const mult = (~~(args > 50) + 1) * 0.5;
	    const r = (color & 1) * mult * 255;
	    const g = (color >> 1 & 1) * mult * 255;
	    const b = (color >> 2 & 1) * mult * 255;
	    return [r, g, b];
	  };
	  convert.ansi256.rgb = function (args) {
	    // Handle greyscale
	    if (args >= 232) {
	      const c = (args - 232) * 10 + 8;
	      return [c, c, c];
	    }
	    args -= 16;
	    let rem;
	    const r = Math.floor(args / 36) / 5 * 255;
	    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	    const b = rem % 6 / 5 * 255;
	    return [r, g, b];
	  };
	  convert.rgb.hex = function (args) {
	    const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
	    const string = integer.toString(16).toUpperCase();
	    return '000000'.substring(string.length) + string;
	  };
	  convert.hex.rgb = function (args) {
	    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	    if (!match) {
	      return [0, 0, 0];
	    }
	    let colorString = match[0];
	    if (match[0].length === 3) {
	      colorString = colorString.split('').map(char => {
	        return char + char;
	      }).join('');
	    }
	    const integer = parseInt(colorString, 16);
	    const r = integer >> 16 & 0xFF;
	    const g = integer >> 8 & 0xFF;
	    const b = integer & 0xFF;
	    return [r, g, b];
	  };
	  convert.rgb.hcg = function (rgb) {
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const max = Math.max(Math.max(r, g), b);
	    const min = Math.min(Math.min(r, g), b);
	    const chroma = max - min;
	    let grayscale;
	    let hue;
	    if (chroma < 1) {
	      grayscale = min / (1 - chroma);
	    } else {
	      grayscale = 0;
	    }
	    if (chroma <= 0) {
	      hue = 0;
	    } else if (max === r) {
	      hue = (g - b) / chroma % 6;
	    } else if (max === g) {
	      hue = 2 + (b - r) / chroma;
	    } else {
	      hue = 4 + (r - g) / chroma;
	    }
	    hue /= 6;
	    hue %= 1;
	    return [hue * 360, chroma * 100, grayscale * 100];
	  };
	  convert.hsl.hcg = function (hsl) {
	    const s = hsl[1] / 100;
	    const l = hsl[2] / 100;
	    const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
	    let f = 0;
	    if (c < 1.0) {
	      f = (l - 0.5 * c) / (1.0 - c);
	    }
	    return [hsl[0], c * 100, f * 100];
	  };
	  convert.hsv.hcg = function (hsv) {
	    const s = hsv[1] / 100;
	    const v = hsv[2] / 100;
	    const c = s * v;
	    let f = 0;
	    if (c < 1.0) {
	      f = (v - c) / (1 - c);
	    }
	    return [hsv[0], c * 100, f * 100];
	  };
	  convert.hcg.rgb = function (hcg) {
	    const h = hcg[0] / 360;
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    if (c === 0.0) {
	      return [g * 255, g * 255, g * 255];
	    }
	    const pure = [0, 0, 0];
	    const hi = h % 1 * 6;
	    const v = hi % 1;
	    const w = 1 - v;
	    let mg = 0;

	    /* eslint-disable max-statements-per-line */
	    switch (Math.floor(hi)) {
	      case 0:
	        pure[0] = 1;
	        pure[1] = v;
	        pure[2] = 0;
	        break;
	      case 1:
	        pure[0] = w;
	        pure[1] = 1;
	        pure[2] = 0;
	        break;
	      case 2:
	        pure[0] = 0;
	        pure[1] = 1;
	        pure[2] = v;
	        break;
	      case 3:
	        pure[0] = 0;
	        pure[1] = w;
	        pure[2] = 1;
	        break;
	      case 4:
	        pure[0] = v;
	        pure[1] = 0;
	        pure[2] = 1;
	        break;
	      default:
	        pure[0] = 1;
	        pure[1] = 0;
	        pure[2] = w;
	    }
	    /* eslint-enable max-statements-per-line */

	    mg = (1.0 - c) * g;
	    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
	  };
	  convert.hcg.hsv = function (hcg) {
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    const v = c + g * (1.0 - c);
	    let f = 0;
	    if (v > 0.0) {
	      f = c / v;
	    }
	    return [hcg[0], f * 100, v * 100];
	  };
	  convert.hcg.hsl = function (hcg) {
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    const l = g * (1.0 - c) + 0.5 * c;
	    let s = 0;
	    if (l > 0.0 && l < 0.5) {
	      s = c / (2 * l);
	    } else if (l >= 0.5 && l < 1.0) {
	      s = c / (2 * (1 - l));
	    }
	    return [hcg[0], s * 100, l * 100];
	  };
	  convert.hcg.hwb = function (hcg) {
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    const v = c + g * (1.0 - c);
	    return [hcg[0], (v - c) * 100, (1 - v) * 100];
	  };
	  convert.hwb.hcg = function (hwb) {
	    const w = hwb[1] / 100;
	    const b = hwb[2] / 100;
	    const v = 1 - b;
	    const c = v - w;
	    let g = 0;
	    if (c < 1) {
	      g = (v - c) / (1 - c);
	    }
	    return [hwb[0], c * 100, g * 100];
	  };
	  convert.apple.rgb = function (apple) {
	    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
	  };
	  convert.rgb.apple = function (rgb) {
	    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
	  };
	  convert.gray.rgb = function (args) {
	    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
	  };
	  convert.gray.hsl = function (args) {
	    return [0, 0, args[0]];
	  };
	  convert.gray.hsv = convert.gray.hsl;
	  convert.gray.hwb = function (gray) {
	    return [0, 100, gray[0]];
	  };
	  convert.gray.cmyk = function (gray) {
	    return [0, 0, 0, gray[0]];
	  };
	  convert.gray.lab = function (gray) {
	    return [gray[0], 0, 0];
	  };
	  convert.gray.hex = function (gray) {
	    const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	    const integer = (val << 16) + (val << 8) + val;
	    const string = integer.toString(16).toUpperCase();
	    return '000000'.substring(string.length) + string;
	  };
	  convert.rgb.gray = function (rgb) {
	    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	    return [val / 255 * 100];
	  };
	  return conversions;
	}

	var route;
	var hasRequiredRoute;
	function requireRoute() {
	  if (hasRequiredRoute) return route;
	  hasRequiredRoute = 1;
	  const conversions = requireConversions();

	  /*
	  	This function routes a model to all other models.
	  		all functions that are routed have a property `.conversion` attached
	  	to the returned synthetic function. This property is an array
	  	of strings, each with the steps in between the 'from' and 'to'
	  	color models (inclusive).
	  		conversions that are not possible simply are not included.
	  */

	  function buildGraph() {
	    const graph = {};
	    // https://jsperf.com/object-keys-vs-for-in-with-closure/3
	    const models = Object.keys(conversions);
	    for (let len = models.length, i = 0; i < len; i++) {
	      graph[models[i]] = {
	        // http://jsperf.com/1-vs-infinity
	        // micro-opt, but this is simple.
	        distance: -1,
	        parent: null
	      };
	    }
	    return graph;
	  }

	  // https://en.wikipedia.org/wiki/Breadth-first_search
	  function deriveBFS(fromModel) {
	    const graph = buildGraph();
	    const queue = [fromModel]; // Unshift -> queue -> pop

	    graph[fromModel].distance = 0;
	    while (queue.length) {
	      const current = queue.pop();
	      const adjacents = Object.keys(conversions[current]);
	      for (let len = adjacents.length, i = 0; i < len; i++) {
	        const adjacent = adjacents[i];
	        const node = graph[adjacent];
	        if (node.distance === -1) {
	          node.distance = graph[current].distance + 1;
	          node.parent = current;
	          queue.unshift(adjacent);
	        }
	      }
	    }
	    return graph;
	  }
	  function link(from, to) {
	    return function (args) {
	      return to(from(args));
	    };
	  }
	  function wrapConversion(toModel, graph) {
	    const path = [graph[toModel].parent, toModel];
	    let fn = conversions[graph[toModel].parent][toModel];
	    let cur = graph[toModel].parent;
	    while (graph[cur].parent) {
	      path.unshift(graph[cur].parent);
	      fn = link(conversions[graph[cur].parent][cur], fn);
	      cur = graph[cur].parent;
	    }
	    fn.conversion = path;
	    return fn;
	  }
	  route = function (fromModel) {
	    const graph = deriveBFS(fromModel);
	    const conversion = {};
	    const models = Object.keys(graph);
	    for (let len = models.length, i = 0; i < len; i++) {
	      const toModel = models[i];
	      const node = graph[toModel];
	      if (node.parent === null) {
	        // No possible conversion, or this node is the source model.
	        continue;
	      }
	      conversion[toModel] = wrapConversion(toModel, graph);
	    }
	    return conversion;
	  };
	  return route;
	}

	var colorConvert;
	var hasRequiredColorConvert;
	function requireColorConvert() {
	  if (hasRequiredColorConvert) return colorConvert;
	  hasRequiredColorConvert = 1;
	  const conversions = requireConversions();
	  const route = requireRoute();
	  const convert = {};
	  const models = Object.keys(conversions);
	  function wrapRaw(fn) {
	    const wrappedFn = function (...args) {
	      const arg0 = args[0];
	      if (arg0 === undefined || arg0 === null) {
	        return arg0;
	      }
	      if (arg0.length > 1) {
	        args = arg0;
	      }
	      return fn(args);
	    };

	    // Preserve .conversion property if there is one
	    if ('conversion' in fn) {
	      wrappedFn.conversion = fn.conversion;
	    }
	    return wrappedFn;
	  }
	  function wrapRounded(fn) {
	    const wrappedFn = function (...args) {
	      const arg0 = args[0];
	      if (arg0 === undefined || arg0 === null) {
	        return arg0;
	      }
	      if (arg0.length > 1) {
	        args = arg0;
	      }
	      const result = fn(args);

	      // We're assuming the result is an array here.
	      // see notice in conversions.js; don't use box types
	      // in conversion functions.
	      if (typeof result === 'object') {
	        for (let len = result.length, i = 0; i < len; i++) {
	          result[i] = Math.round(result[i]);
	        }
	      }
	      return result;
	    };

	    // Preserve .conversion property if there is one
	    if ('conversion' in fn) {
	      wrappedFn.conversion = fn.conversion;
	    }
	    return wrappedFn;
	  }
	  models.forEach(fromModel => {
	    convert[fromModel] = {};
	    Object.defineProperty(convert[fromModel], 'channels', {
	      value: conversions[fromModel].channels
	    });
	    Object.defineProperty(convert[fromModel], 'labels', {
	      value: conversions[fromModel].labels
	    });
	    const routes = route(fromModel);
	    const routeModels = Object.keys(routes);
	    routeModels.forEach(toModel => {
	      const fn = routes[toModel];
	      convert[fromModel][toModel] = wrapRounded(fn);
	      convert[fromModel][toModel].raw = wrapRaw(fn);
	    });
	  });
	  colorConvert = convert;
	  return colorConvert;
	}

	var hasRequiredLib;
	function requireLib() {
	  if (hasRequiredLib) return lib$1;
	  hasRequiredLib = 1;
	  var __spreadArray = lib$1 && lib$1.__spreadArray || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	      if (ar || !(i in from)) {
	        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	        ar[i] = from[i];
	      }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	  };
	  Object.defineProperty(lib$1, "__esModule", {
	    value: true
	  });
	  lib$1.colorFromUuid = void 0;
	  var uuid_1 = esmBrowser;
	  var UuidEncoder = requireLib$1();
	  var convert = requireColorConvert();
	  var DEFAULT_COLOR_FORMAT = "hex";
	  var DEFAULT_IS_RAW = false;
	  var encoder = new UuidEncoder("base10");
	  /**
	   * Returns the generated color associated with the given uuid.
	   *
	   * @param uuid - The uuid for which to generate a color
	   * @param options - An optional object to configure the color generation, and attach callbacks that directly receive the generated color code or components in various formats
	   * @returns The generated color as a CSS `<color>` notation string
	   *
	   * @throws {@link https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/error | Error}
	   * This exception is thrown if the input uuid string is not a valid UUID.
	   *
	   * @public
	   */
	  function colorFromUuid(uuid, options) {
	    if (options === void 0) {
	      options = {};
	    }
	    if (!(0, uuid_1.validate)(uuid)) {
	      throw new Error("Given string is not a valid UUID.");
	    }
	    var encodedUuid = BigInt(encoder.encode(uuid));
	    var colorCode = Number(encodedUuid % BigInt(0x1000000));
	    var red = colorCode >> 16;
	    var green = colorCode >> 8 & 0xff;
	    var blue = colorCode & 0xff;
	    var receivers = {};
	    if (options.hasOwnProperty("receivers")) {
	      ["rgb", "hsl", "hex"].forEach(function (format) {
	        if (options.receivers.hasOwnProperty(format)) {
	          receivers[format] = options.receivers[format]; // link to callbacks
	        }
	      });
	    }
	    var isRaw = DEFAULT_IS_RAW;
	    if (options.hasOwnProperty("raw")) {
	      isRaw = options.raw;
	    }
	    var alpha;
	    if (options.hasOwnProperty("alpha")) {
	      alpha = Math.min(Math.max(options.alpha, 0), 1); // clamp to [0; 1]
	    }
	    if ("rgb" in receivers) {
	      if (alpha === undefined) {
	        receivers.rgb(red, green, blue);
	      } else {
	        receivers.rgb(red, green, blue, alpha);
	      }
	    }
	    if ("hsl" in receivers) {
	      var hsl = isRaw ? convert.rgb.hsl.raw(red, green, blue) : convert.rgb.hsl(red, green, blue);
	      if (alpha === undefined) {
	        receivers.hsl.apply(receivers, hsl);
	      } else {
	        receivers.hsl.apply(receivers, __spreadArray(__spreadArray([], hsl, true), [alpha], false));
	      }
	    }
	    if ("hex" in receivers) {
	      var hexColorCode = convert.rgb.hex(red, green, blue).toLowerCase();
	      if (alpha === undefined) {
	        receivers.hex(hexColorCode);
	      } else {
	        var hexAlphaCode = Math.floor(alpha * 255).toString(16);
	        receivers.hex(hexColorCode + hexAlphaCode);
	      }
	    }
	    var format = DEFAULT_COLOR_FORMAT;
	    if (options.hasOwnProperty("format")) {
	      format = options.format;
	    }
	    switch (format) {
	      case "rgb":
	        return alpha === undefined ? "rgb(".concat(red, ", ").concat(green, ", ").concat(blue, ")") : "rgb(".concat(red, ", ").concat(green, ", ").concat(blue, ", ").concat(alpha, ")");
	      case "hsl":
	        var hsl = isRaw ? convert.rgb.hsl.raw(red, green, blue) : convert.rgb.hsl(red, green, blue);
	        return alpha === undefined ? "hsl(".concat(hsl[0], ", ").concat(hsl[1], "%, ").concat(hsl[2], "%)") : "hsl(".concat(hsl[0], ", ").concat(hsl[1], "%, ").concat(hsl[2], "%, ").concat(alpha, ")");
	      default: // don't error
	      case "hex":
	        var hexColorCode = convert.rgb.hex(red, green, blue).toLowerCase();
	        var hexAlphaCode = Math.floor(alpha * 255).toString(16);
	        return alpha === undefined ? "#".concat(hexColorCode) : "#".concat(hexColorCode).concat(hexAlphaCode);
	    }
	  }
	  lib$1.colorFromUuid = colorFromUuid;
	  return lib$1;
	}

	var libExports = /*@__PURE__*/ requireLib();

	class CameraAnimation {
	  constructor(camera, controls, targetPosition, targetLookAt, duration) {
	    this.camera = camera;
	    this.controls = controls;
	    this.duration = duration;
	    this.startTime = Date.now();
	    this.startPosition = camera.position.clone();
	    this.startLookAt = controls.target.clone();
	    this.targetPosition = targetPosition.clone();
	    this.targetLookAt = targetLookAt.clone();
	    this.isActive = true;
	  }
	  update() {
	    if (!this.isActive) return false;
	    const elapsed = Date.now() - this.startTime;
	    const progress = Math.min(elapsed / this.duration, 1);

	    // Ease in-out cubic function for smooth animation
	    const easedProgress = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;

	    // Interpolate camera position using manual calculation
	    this.camera.position.x = this.startPosition.x + (this.targetPosition.x - this.startPosition.x) * easedProgress;
	    this.camera.position.y = this.startPosition.y + (this.targetPosition.y - this.startPosition.y) * easedProgress;
	    this.camera.position.z = this.startPosition.z + (this.targetPosition.z - this.startPosition.z) * easedProgress;

	    // Interpolate look-at target
	    this.controls.target.x = this.startLookAt.x + (this.targetLookAt.x - this.startLookAt.x) * easedProgress;
	    this.controls.target.y = this.startLookAt.y + (this.targetLookAt.y - this.startLookAt.y) * easedProgress;
	    this.controls.target.z = this.startLookAt.z + (this.targetLookAt.z - this.startLookAt.z) * easedProgress;
	    this.controls.update();
	    if (progress >= 1) {
	      this.isActive = false;
	      return false;
	    }
	    return true;
	  }
	  stop() {
	    this.isActive = false;
	  }
	}
	class Playground {
	  camera;
	  scene;
	  renderer;
	  cameraControls;
	  ambientLight;
	  light;

	  /**
	   * @type {[THREE.Mesh]}
	   */
	  boxes = [];

	  /**
	   * @type {[THREE.Mesh]}
	   */
	  items = [];

	  /**
	   * @type {Map<string, THREE.Mesh>}
	   */
	  boxMap = new Map();

	  /**
	   * @type {Map<string, THREE.Mesh>}
	   */
	  itemMap = new Map();
	  materials = {};
	  animationFrameId = null;
	  selectedBox = null;
	  onBoxSelect = null;
	  animationSpeed = 1;
	  showAnimation = true;
	  cameraAnimation = null;
	  boxList = [];
	  mouseDownPos = null;
	  isDragging = false;
	  constructor(container) {
	    this.camera = new PerspectiveCamera(45, container.offsetWidth / window.innerHeight, 1, 80000);
	    this.camera.position.set(-600, 550, 1300);
	    this.ambientLight = new AmbientLight(0x7c7c7c, 3.0);
	    this.light = new DirectionalLight(0xFFFFFF, 3.0);
	    this.light.position.set(0.32, 0.39, 0.7);
	    const canvasWidth = container.offsetWidth;
	    const canvasHeight = window.innerHeight;
	    this.renderer = new WebGLRenderer({
	      antialias: true,
	      alpha: true
	    });
	    this.renderer.setPixelRatio(window.devicePixelRatio);
	    this.renderer.setSize(canvasWidth, canvasHeight);
	    container.appendChild(this.renderer.domElement);
	    window.addEventListener('resize', e => this.onWindowResize(e, container));
	    window.addEventListener('keydown', e => this.onKeyboard(e));
	    this.cameraControls = new OrbitControls(this.camera, this.renderer.domElement);
	    this.cameraControls.addEventListener('change', () => this.renderer.render(this.scene, this.camera));

	    // Add click handler for box selection
	    this.raycaster = new Raycaster();
	    this.mouse = new Vector2$1();
	    const canvas = this.renderer.domElement;

	    // Track mouse down position to detect dragging
	    canvas.addEventListener('mousedown', e => {
	      this.mouseDownPos = {
	        x: e.clientX,
	        y: e.clientY
	      };
	      this.isDragging = false;
	    });

	    // Track mouse movement to detect dragging
	    canvas.addEventListener('mousemove', e => {
	      if (this.mouseDownPos) {
	        const dx = Math.abs(e.clientX - this.mouseDownPos.x);
	        const dy = Math.abs(e.clientY - this.mouseDownPos.y);
	        // If mouse moved more than 5 pixels, consider it a drag
	        if (dx > 5 || dy > 5) {
	          this.isDragging = true;
	        }
	      }
	    });

	    // Reset on mouse up
	    canvas.addEventListener('mouseup', () => {
	      this.mouseDownPos = null;
	    });

	    // Handle click - only if it wasn't a drag
	    canvas.addEventListener('click', e => {
	      // Only process click if it wasn't a drag
	      if (!this.isDragging) {
	        this.onCanvasClick(e);
	      }
	      this.isDragging = false;
	    });
	    this.materials['wireframe'] = new MeshBasicMaterial({
	      wireframe: true,
	      color: 0x888888,
	      transparent: true,
	      opacity: 0.5
	    });
	    this.materials['wireframe_selected'] = new MeshBasicMaterial({
	      wireframe: true,
	      color: 0x00ff00,
	      linewidth: 2
	    });
	    this.materials['flat'] = new MeshPhongMaterial({
	      specular: 0x000000,
	      flatShading: true,
	      side: DoubleSide
	    });
	    this.materials['smooth'] = new MeshLambertMaterial({
	      side: DoubleSide
	    });
	    this.materials['glossy'] = new MeshPhongMaterial({
	      side: DoubleSide
	    });
	    this.scene = new Scene();
	    this.scene.background = new Color(0x0a0a0a); // Very dark background

	    this.scene.add(this.ambientLight);
	    this.scene.add(this.light);
	    this.animate();
	  }
	  animate() {
	    this.animationFrameId = requestAnimationFrame(() => this.animate());

	    // Update camera animation if active
	    if (this.cameraAnimation) {
	      this.cameraAnimation.update();
	    }
	    this.cameraControls.update();
	    this.renderer.render(this.scene, this.camera);
	  }
	  render(request) {
	    if (request !== undefined && typeof request.boxes !== 'undefined' && request.boxes.length > 0) {
	      this.createObjects(request);
	    }
	  }
	  selectBox(boxId, animate = true) {
	    if (this.selectedBox) {
	      const oldBox = this.boxMap.get(this.selectedBox);
	      if (oldBox) {
	        oldBox.material = this.materials['wireframe'];
	      }
	    }
	    this.selectedBox = boxId;
	    const box = this.boxMap.get(boxId);
	    if (box) {
	      box.material = this.materials['wireframe_selected'];

	      // Calculate optimal camera position
	      const boxPosition = box.position.clone();
	      const boxData = box.userData.boxData;
	      Math.max(boxData.width, boxData.height, boxData.depth);

	      // Calculate optimal viewing angle
	      const diagonal = Math.sqrt(boxData.width * boxData.width + boxData.height * boxData.height + boxData.depth * boxData.depth);
	      const distance = diagonal * 1.5; // Optimal distance for viewing

	      // Calculate camera position with better angle
	      const angle = Math.PI / 4; // 45 degrees
	      const height = boxData.height * 0.7; // Slightly above center

	      const targetPosition = new Vector3$1(boxPosition.x + Math.cos(angle) * distance, boxPosition.y + height, boxPosition.z + Math.sin(angle) * distance);
	      const targetLookAt = new Vector3$1(boxPosition.x, boxPosition.y + boxData.height * 0.3, boxPosition.z);
	      if (animate && this.cameraAnimation) {
	        // Stop current animation
	        this.cameraAnimation.stop();
	      }
	      if (animate) {
	        // Animate camera movement
	        this.cameraAnimation = new CameraAnimation(this.camera, this.cameraControls, targetPosition, targetLookAt, 1000 // 1 second animation
	        );
	      } else {
	        // Instant move
	        this.camera.position.copy(targetPosition);
	        this.cameraControls.target.copy(targetLookAt);
	        this.cameraControls.update();
	      }
	    }
	    if (this.onBoxSelect) {
	      this.onBoxSelect(boxId);
	    }
	  }
	  selectNextBox() {
	    if (this.boxList.length === 0) return;
	    const currentIndex = this.boxList.findIndex(id => id === this.selectedBox);
	    const nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % this.boxList.length;
	    this.selectBox(this.boxList[nextIndex]);
	  }
	  selectPreviousBox() {
	    if (this.boxList.length === 0) return;
	    const currentIndex = this.boxList.findIndex(id => id === this.selectedBox);
	    const prevIndex = currentIndex === -1 ? this.boxList.length - 1 : (currentIndex - 1 + this.boxList.length) % this.boxList.length;
	    this.selectBox(this.boxList[prevIndex]);
	  }
	  onWindowResize(e, container) {
	    const canvasWidth = container.offsetWidth;
	    const canvasHeight = window.innerHeight;
	    this.renderer.setSize(canvasWidth, canvasHeight);
	    this.camera.aspect = canvasWidth / canvasHeight;
	    this.camera.updateProjectionMatrix();
	    this.render();
	  }
	  onKeyboard(e) {
	    // Navigation between boxes with Ctrl+Arrow keys
	    if (e.ctrlKey || e.metaKey) {
	      if (e.key === 'ArrowLeft') {
	        e.preventDefault();
	        this.selectPreviousBox();
	        return;
	      } else if (e.key === 'ArrowRight') {
	        e.preventDefault();
	        this.selectNextBox();
	        return;
	      }
	    }

	    // Camera movement with WASD or Arrow keys (without Ctrl)
	    const delta = 200;
	    switch (e.code) {
	      case "KeyA":
	        if (!e.ctrlKey && !e.metaKey) {
	          this.camera.position.set(this.camera.position.x - delta, this.camera.position.y, this.camera.position.z);
	        }
	        break;
	      case "KeyW":
	        if (!e.ctrlKey && !e.metaKey) {
	          this.camera.position.set(this.camera.position.x, this.camera.position.y, this.camera.position.z - delta);
	        }
	        break;
	      case "KeyD":
	        if (!e.ctrlKey && !e.metaKey) {
	          this.camera.position.set(this.camera.position.x + delta, this.camera.position.y, this.camera.position.z);
	        }
	        break;
	      case "KeyS":
	        if (!e.ctrlKey && !e.metaKey) {
	          this.camera.position.set(this.camera.position.x, this.camera.position.y, this.camera.position.z + delta);
	        }
	        break;
	    }
	    this.cameraControls.update();
	  }
	  onCanvasClick(event) {
	    const rect = this.renderer.domElement.getBoundingClientRect();
	    this.mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;
	    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
	    this.raycaster.setFromCamera(this.mouse, this.camera);
	    const intersects = this.raycaster.intersectObjects(this.boxes, true);
	    if (intersects.length > 0) {
	      // Find the box mesh (not the item mesh)
	      let boxMesh = intersects[0].object;
	      while (boxMesh && !this.boxMap.has(boxMesh.userData?.boxId)) {
	        boxMesh = boxMesh.parent;
	      }
	      if (boxMesh && boxMesh.userData?.boxId) {
	        this.selectBox(boxMesh.userData.boxId);
	      }
	    }
	  }
	  destroy() {
	    for (const item of this.items) {
	      item.geometry.dispose();
	      if (item.material) item.material.dispose();
	      this.scene.remove(item);
	    }
	    for (const box of this.boxes) {
	      box.geometry.dispose();
	      this.scene.remove(box);
	    }
	    this.boxes = [];
	    this.items = [];
	    this.boxMap.clear();
	    this.itemMap.clear();
	    this.selectedBox = null;
	  }
	  createObjects(request) {
	    this.destroy();

	    // Store box list for navigation
	    this.boxList = request.boxes.map(box => box.id);
	    const delta = 50;
	    let point = {
	      x: 0,
	      z: 0
	    };
	    let zMax = 0;

	    // Create boxes first
	    for (const box of request.boxes) {
	      const boxGeometry = new BoxGeometry(box.width, box.height, box.depth);
	      const boxMesh = new Mesh(boxGeometry, this.materials['wireframe']);
	      point.x += box.width / 2;
	      boxMesh.position.set(point.x, box.height / 2, point.z);
	      this.boxes = this.boxes.concat(boxMesh);
	      this.boxMap.set(box.id, boxMesh);
	      this.scene.add(boxMesh);

	      // Store box data for later use
	      boxMesh.userData = {
	        boxId: box.id,
	        boxData: box,
	        items: []
	      };

	      // Add items with animation
	      if (this.showAnimation) {
	        this.animateItemsIntoBox(boxMesh, box.items, box);
	      } else {
	        this.addItemsToBox(boxMesh, box.items, box);
	      }
	      point.x += box.width / 2 + delta;
	      zMax = Math.max(box.depth, zMax);
	    }

	    // Add unfit items
	    point = {
	      x: 0,
	      y: 0,
	      z: zMax + delta + 100
	    };
	    for (const item of request.items || []) {
	      const color = libExports.colorFromUuid(item.id);
	      const itemGeometry = new BoxGeometry(item.width, item.height, item.depth);
	      const itemMaterial = new MeshPhongMaterial({
	        color: color,
	        flatShading: true,
	        side: DoubleSide,
	        transparent: true,
	        opacity: 0.5
	      });
	      const itemMesh = new Mesh(itemGeometry, itemMaterial);
	      itemMesh.position.set(point.x + item.width / 2, item.height / 2, point.z);
	      this.items = this.items.concat(itemMesh);
	      this.itemMap.set(item.id, itemMesh);
	      this.scene.add(itemMesh);
	      point.x += item.width + delta;
	    }
	  }
	  addItemsToBox(boxMesh, items, boxData) {
	    for (const item of items) {
	      const color = libExports.colorFromUuid(item.id);
	      const itemGeometry = new BoxGeometry(item.width, item.height, item.depth);
	      const itemMaterial = new MeshPhongMaterial({
	        color: color,
	        flatShading: true,
	        side: DoubleSide,
	        transparent: true,
	        opacity: 0.9
	      });
	      const itemMesh = new Mesh(itemGeometry, itemMaterial);

	      // In boxpacker3, item.position is the bottom-left-front corner (pivot point)
	      // In Three.js, mesh position is the center of the geometry
	      // BoxGeometry center is at (0,0,0) in local coordinates
	      // So we need to convert from pivot point to center point
	      itemMesh.position.set(item.position.x + item.width / 2 - boxData.width / 2, item.position.y + item.height / 2 - boxData.height / 2, item.position.z + item.depth / 2 - boxData.depth / 2);
	      this.items = this.items.concat(itemMesh);
	      this.itemMap.set(item.id, itemMesh);
	      boxMesh.add(itemMesh);
	      boxMesh.userData.items.push(item);
	    }
	  }
	  animateItemsIntoBox(boxMesh, items, boxData) {
	    let delay = 0;
	    const itemDelay = 100 / this.animationSpeed;
	    for (const item of items) {
	      setTimeout(() => {
	        const color = libExports.colorFromUuid(item.id);
	        const itemGeometry = new BoxGeometry(item.width, item.height, item.depth);
	        const itemMaterial = new MeshPhongMaterial({
	          color: color,
	          flatShading: true,
	          side: DoubleSide,
	          transparent: true,
	          opacity: 0.9
	        });
	        const itemMesh = new Mesh(itemGeometry, itemMaterial);

	        // Start position (above the box)
	        const startY = boxData.height + item.height / 2 + 100;
	        // In boxpacker3, item.position is the bottom-left-front corner (pivot point)
	        // In Three.js, mesh position is the center of the geometry
	        // BoxGeometry center is at (0,0,0) in local coordinates
	        const finalX = item.position.x + item.width / 2 - boxData.width / 2;
	        const finalY = item.position.y + item.height / 2 - boxData.height / 2;
	        const finalZ = item.position.z + item.depth / 2 - boxData.depth / 2;
	        itemMesh.position.set(finalX, startY, finalZ);
	        itemMesh.scale.set(0.1, 0.1, 0.1);
	        this.items = this.items.concat(itemMesh);
	        this.itemMap.set(item.id, itemMesh);
	        boxMesh.add(itemMesh);
	        boxMesh.userData.items.push(item);

	        // Animate
	        const startTime = Date.now();
	        const duration = 800 / this.animationSpeed;
	        const animate = () => {
	          const elapsed = Date.now() - startTime;
	          const progress = Math.min(elapsed / duration, 1);
	          const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease out cubic

	          itemMesh.position.y = startY + (finalY - startY) * easeProgress;
	          itemMesh.scale.set(0.1 + (1 - 0.1) * easeProgress, 0.1 + (1 - 0.1) * easeProgress, 0.1 + (1 - 0.1) * easeProgress);
	          if (progress < 1) {
	            requestAnimationFrame(animate);
	          }
	        };
	        animate();
	      }, delay);
	      delay += itemDelay;
	    }
	  }
	}

	var n,
	  l$1,
	  u$1,
	  i$1,
	  r$1,
	  o$1,
	  e$1,
	  f$1,
	  c$1,
	  s$1,
	  a$1,
	  h$1,
	  p$1 = {},
	  v$1 = [],
	  y$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,
	  w$2 = Array.isArray;
	function d$1(n, l) {
	  for (var u in l) n[u] = l[u];
	  return n;
	}
	function g$2(n) {
	  n && n.parentNode && n.parentNode.removeChild(n);
	}
	function _$1(l, u, t) {
	  var i,
	    r,
	    o,
	    e = {};
	  for (o in u) "key" == o ? i = u[o] : "ref" == o ? r = u[o] : e[o] = u[o];
	  if (arguments.length > 2 && (e.children = arguments.length > 3 ? n.call(arguments, 2) : t), "function" == typeof l && null != l.defaultProps) for (o in l.defaultProps) void 0 === e[o] && (e[o] = l.defaultProps[o]);
	  return m$1(l, e, i, r, null);
	}
	function m$1(n, t, i, r, o) {
	  var e = {
	    type: n,
	    props: t,
	    key: i,
	    ref: r,
	    __k: null,
	    __: null,
	    __b: 0,
	    __e: null,
	    __c: null,
	    constructor: void 0,
	    __v: null == o ? ++u$1 : o,
	    __i: -1,
	    __u: 0
	  };
	  return null == o && null != l$1.vnode && l$1.vnode(e), e;
	}
	function b() {
	  return {
	    current: null
	  };
	}
	function k$2(n) {
	  return n.children;
	}
	function x$2(n, l) {
	  this.props = n, this.context = l;
	}
	function S(n, l) {
	  if (null == l) return n.__ ? S(n.__, n.__i + 1) : null;
	  for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
	  return "function" == typeof n.type ? S(n) : null;
	}
	function C$2(n) {
	  var l, u;
	  if (null != (n = n.__) && null != n.__c) {
	    for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
	      n.__e = n.__c.base = u.__e;
	      break;
	    }
	    return C$2(n);
	  }
	}
	function M$1(n) {
	  (!n.__d && (n.__d = true) && i$1.push(n) && !$$1.__r++ || r$1 != l$1.debounceRendering) && ((r$1 = l$1.debounceRendering) || o$1)($$1);
	}
	function $$1() {
	  for (var n, u, t, r, o, f, c, s = 1; i$1.length;) i$1.length > s && i$1.sort(e$1), n = i$1.shift(), s = i$1.length, n.__d && (t = void 0, r = void 0, o = (r = (u = n).__v).__e, f = [], c = [], u.__P && ((t = d$1({}, r)).__v = r.__v + 1, l$1.vnode && l$1.vnode(t), O$1(u.__P, t, r, u.__n, u.__P.namespaceURI, 32 & r.__u ? [o] : null, f, null == o ? S(r) : o, !!(32 & r.__u), c), t.__v = r.__v, t.__.__k[t.__i] = t, N$1(f, t, c), r.__e = r.__ = null, t.__e != o && C$2(t)));
	  $$1.__r = 0;
	}
	function I$1(n, l, u, t, i, r, o, e, f, c, s) {
	  var a,
	    h,
	    y,
	    w,
	    d,
	    g,
	    _,
	    m = t && t.__k || v$1,
	    b = l.length;
	  for (f = P$2(u, l, m, f, b), a = 0; a < b; a++) null != (y = u.__k[a]) && (h = -1 == y.__i ? p$1 : m[y.__i] || p$1, y.__i = a, g = O$1(n, y, h, i, r, o, e, f, c, s), w = y.__e, y.ref && h.ref != y.ref && (h.ref && B$2(h.ref, null, y), s.push(y.ref, y.__c || w, y)), null == d && null != w && (d = w), (_ = !!(4 & y.__u)) || h.__k === y.__k ? f = A$2(y, f, n, _) : "function" == typeof y.type && void 0 !== g ? f = g : w && (f = w.nextSibling), y.__u &= -7);
	  return u.__e = d, f;
	}
	function P$2(n, l, u, t, i) {
	  var r,
	    o,
	    e,
	    f,
	    c,
	    s = u.length,
	    a = s,
	    h = 0;
	  for (n.__k = new Array(i), r = 0; r < i; r++) null != (o = l[r]) && "boolean" != typeof o && "function" != typeof o ? (f = r + h, (o = n.__k[r] = "string" == typeof o || "number" == typeof o || "bigint" == typeof o || o.constructor == String ? m$1(null, o, null, null, null) : w$2(o) ? m$1(k$2, {
	    children: o
	  }, null, null, null) : null == o.constructor && o.__b > 0 ? m$1(o.type, o.props, o.key, o.ref ? o.ref : null, o.__v) : o).__ = n, o.__b = n.__b + 1, e = null, -1 != (c = o.__i = L$1(o, u, f, a)) && (a--, (e = u[c]) && (e.__u |= 2)), null == e || null == e.__v ? (-1 == c && (i > s ? h-- : i < s && h++), "function" != typeof o.type && (o.__u |= 4)) : c != f && (c == f - 1 ? h-- : c == f + 1 ? h++ : (c > f ? h-- : h++, o.__u |= 4))) : n.__k[r] = null;
	  if (a) for (r = 0; r < s; r++) null != (e = u[r]) && 0 == (2 & e.__u) && (e.__e == t && (t = S(e)), D$2(e, e));
	  return t;
	}
	function A$2(n, l, u, t) {
	  var i, r;
	  if ("function" == typeof n.type) {
	    for (i = n.__k, r = 0; i && r < i.length; r++) i[r] && (i[r].__ = n, l = A$2(i[r], l, u, t));
	    return l;
	  }
	  n.__e != l && (t && (l && n.type && !l.parentNode && (l = S(n)), u.insertBefore(n.__e, l || null)), l = n.__e);
	  do {
	    l = l && l.nextSibling;
	  } while (null != l && 8 == l.nodeType);
	  return l;
	}
	function H$1(n, l) {
	  return l = l || [], null == n || "boolean" == typeof n || (w$2(n) ? n.some(function (n) {
	    H$1(n, l);
	  }) : l.push(n)), l;
	}
	function L$1(n, l, u, t) {
	  var i,
	    r,
	    o,
	    e = n.key,
	    f = n.type,
	    c = l[u],
	    s = null != c && 0 == (2 & c.__u);
	  if (null === c && null == n.key || s && e == c.key && f == c.type) return u;
	  if (t > (s ? 1 : 0)) for (i = u - 1, r = u + 1; i >= 0 || r < l.length;) if (null != (c = l[o = i >= 0 ? i-- : r++]) && 0 == (2 & c.__u) && e == c.key && f == c.type) return o;
	  return -1;
	}
	function T$2(n, l, u) {
	  "-" == l[0] ? n.setProperty(l, null == u ? "" : u) : n[l] = null == u ? "" : "number" != typeof u || y$1.test(l) ? u : u + "px";
	}
	function j$2(n, l, u, t, i) {
	  var r, o;
	  n: if ("style" == l) {
	    if ("string" == typeof u) n.style.cssText = u;else {
	      if ("string" == typeof t && (n.style.cssText = t = ""), t) for (l in t) u && l in u || T$2(n.style, l, "");
	      if (u) for (l in u) t && u[l] == t[l] || T$2(n.style, l, u[l]);
	    }
	  } else if ("o" == l[0] && "n" == l[1]) r = l != (l = l.replace(f$1, "$1")), o = l.toLowerCase(), l = o in n || "onFocusOut" == l || "onFocusIn" == l ? o.slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + r] = u, u ? t ? u.u = t.u : (u.u = c$1, n.addEventListener(l, r ? a$1 : s$1, r)) : n.removeEventListener(l, r ? a$1 : s$1, r);else {
	    if ("http://www.w3.org/2000/svg" == i) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("width" != l && "height" != l && "href" != l && "list" != l && "form" != l && "tabIndex" != l && "download" != l && "rowSpan" != l && "colSpan" != l && "role" != l && "popover" != l && l in n) try {
	      n[l] = null == u ? "" : u;
	      break n;
	    } catch (n) {}
	    "function" == typeof u || (null == u || false === u && "-" != l[4] ? n.removeAttribute(l) : n.setAttribute(l, "popover" == l && 1 == u ? "" : u));
	  }
	}
	function F$2(n) {
	  return function (u) {
	    if (this.l) {
	      var t = this.l[u.type + n];
	      if (null == u.t) u.t = c$1++;else if (u.t < t.u) return;
	      return t(l$1.event ? l$1.event(u) : u);
	    }
	  };
	}
	function O$1(n, u, t, i, r, o, e, f, c, s) {
	  var a,
	    h,
	    p,
	    v,
	    y,
	    _,
	    m,
	    b,
	    S,
	    C,
	    M,
	    $,
	    P,
	    A,
	    H,
	    L,
	    T,
	    j = u.type;
	  if (null != u.constructor) return null;
	  128 & t.__u && (c = !!(32 & t.__u), o = [f = u.__e = t.__e]), (a = l$1.__b) && a(u);
	  n: if ("function" == typeof j) try {
	    if (b = u.props, S = "prototype" in j && j.prototype.render, C = (a = j.contextType) && i[a.__c], M = a ? C ? C.props.value : a.__ : i, t.__c ? m = (h = u.__c = t.__c).__ = h.__E : (S ? u.__c = h = new j(b, M) : (u.__c = h = new x$2(b, M), h.constructor = j, h.render = E$1), C && C.sub(h), h.props = b, h.state || (h.state = {}), h.context = M, h.__n = i, p = h.__d = !0, h.__h = [], h._sb = []), S && null == h.__s && (h.__s = h.state), S && null != j.getDerivedStateFromProps && (h.__s == h.state && (h.__s = d$1({}, h.__s)), d$1(h.__s, j.getDerivedStateFromProps(b, h.__s))), v = h.props, y = h.state, h.__v = u, p) S && null == j.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), S && null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
	      if (S && null == j.getDerivedStateFromProps && b !== v && null != h.componentWillReceiveProps && h.componentWillReceiveProps(b, M), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(b, h.__s, M) || u.__v == t.__v) {
	        for (u.__v != t.__v && (h.props = b, h.state = h.__s, h.__d = !1), u.__e = t.__e, u.__k = t.__k, u.__k.some(function (n) {
	          n && (n.__ = u);
	        }), $ = 0; $ < h._sb.length; $++) h.__h.push(h._sb[$]);
	        h._sb = [], h.__h.length && e.push(h);
	        break n;
	      }
	      null != h.componentWillUpdate && h.componentWillUpdate(b, h.__s, M), S && null != h.componentDidUpdate && h.__h.push(function () {
	        h.componentDidUpdate(v, y, _);
	      });
	    }
	    if (h.context = M, h.props = b, h.__P = n, h.__e = !1, P = l$1.__r, A = 0, S) {
	      for (h.state = h.__s, h.__d = !1, P && P(u), a = h.render(h.props, h.state, h.context), H = 0; H < h._sb.length; H++) h.__h.push(h._sb[H]);
	      h._sb = [];
	    } else do {
	      h.__d = !1, P && P(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
	    } while (h.__d && ++A < 25);
	    h.state = h.__s, null != h.getChildContext && (i = d$1(d$1({}, i), h.getChildContext())), S && !p && null != h.getSnapshotBeforeUpdate && (_ = h.getSnapshotBeforeUpdate(v, y)), L = a, null != a && a.type === k$2 && null == a.key && (L = V$1(a.props.children)), f = I$1(n, w$2(L) ? L : [L], u, t, i, r, o, e, f, c, s), h.base = u.__e, u.__u &= -161, h.__h.length && e.push(h), m && (h.__E = h.__ = null);
	  } catch (n) {
	    if (u.__v = null, c || null != o) {
	      if (n.then) {
	        for (u.__u |= c ? 160 : 128; f && 8 == f.nodeType && f.nextSibling;) f = f.nextSibling;
	        o[o.indexOf(f)] = null, u.__e = f;
	      } else {
	        for (T = o.length; T--;) g$2(o[T]);
	        z$2(u);
	      }
	    } else u.__e = t.__e, u.__k = t.__k, n.then || z$2(u);
	    l$1.__e(n, u, t);
	  } else null == o && u.__v == t.__v ? (u.__k = t.__k, u.__e = t.__e) : f = u.__e = q$2(t.__e, u, t, i, r, o, e, c, s);
	  return (a = l$1.diffed) && a(u), 128 & u.__u ? void 0 : f;
	}
	function z$2(n) {
	  n && n.__c && (n.__c.__e = true), n && n.__k && n.__k.forEach(z$2);
	}
	function N$1(n, u, t) {
	  for (var i = 0; i < t.length; i++) B$2(t[i], t[++i], t[++i]);
	  l$1.__c && l$1.__c(u, n), n.some(function (u) {
	    try {
	      n = u.__h, u.__h = [], n.some(function (n) {
	        n.call(u);
	      });
	    } catch (n) {
	      l$1.__e(n, u.__v);
	    }
	  });
	}
	function V$1(n) {
	  return "object" != typeof n || null == n || n.__b && n.__b > 0 ? n : w$2(n) ? n.map(V$1) : d$1({}, n);
	}
	function q$2(u, t, i, r, o, e, f, c, s) {
	  var a,
	    h,
	    v,
	    y,
	    d,
	    _,
	    m,
	    b = i.props,
	    k = t.props,
	    x = t.type;
	  if ("svg" == x ? o = "http://www.w3.org/2000/svg" : "math" == x ? o = "http://www.w3.org/1998/Math/MathML" : o || (o = "http://www.w3.org/1999/xhtml"), null != e) for (a = 0; a < e.length; a++) if ((d = e[a]) && "setAttribute" in d == !!x && (x ? d.localName == x : 3 == d.nodeType)) {
	    u = d, e[a] = null;
	    break;
	  }
	  if (null == u) {
	    if (null == x) return document.createTextNode(k);
	    u = document.createElementNS(o, x, k.is && k), c && (l$1.__m && l$1.__m(t, e), c = false), e = null;
	  }
	  if (null == x) b === k || c && u.data == k || (u.data = k);else {
	    if (e = e && n.call(u.childNodes), b = i.props || p$1, !c && null != e) for (b = {}, a = 0; a < u.attributes.length; a++) b[(d = u.attributes[a]).name] = d.value;
	    for (a in b) if (d = b[a], "children" == a) ;else if ("dangerouslySetInnerHTML" == a) v = d;else if (!(a in k)) {
	      if ("value" == a && "defaultValue" in k || "checked" == a && "defaultChecked" in k) continue;
	      j$2(u, a, null, d, o);
	    }
	    for (a in k) d = k[a], "children" == a ? y = d : "dangerouslySetInnerHTML" == a ? h = d : "value" == a ? _ = d : "checked" == a ? m = d : c && "function" != typeof d || b[a] === d || j$2(u, a, d, b[a], o);
	    if (h) c || v && (h.__html == v.__html || h.__html == u.innerHTML) || (u.innerHTML = h.__html), t.__k = [];else if (v && (u.innerHTML = ""), I$1("template" == t.type ? u.content : u, w$2(y) ? y : [y], t, i, r, "foreignObject" == x ? "http://www.w3.org/1999/xhtml" : o, e, f, e ? e[0] : i.__k && S(i, 0), c, s), null != e) for (a = e.length; a--;) g$2(e[a]);
	    c || (a = "value", "progress" == x && null == _ ? u.removeAttribute("value") : null != _ && (_ !== u[a] || "progress" == x && !_ || "option" == x && _ != b[a]) && j$2(u, a, _, b[a], o), a = "checked", null != m && m != u[a] && j$2(u, a, m, b[a], o));
	  }
	  return u;
	}
	function B$2(n, u, t) {
	  try {
	    if ("function" == typeof n) {
	      var i = "function" == typeof n.__u;
	      i && n.__u(), i && null == u || (n.__u = n(u));
	    } else n.current = u;
	  } catch (n) {
	    l$1.__e(n, t);
	  }
	}
	function D$2(n, u, t) {
	  var i, r;
	  if (l$1.unmount && l$1.unmount(n), (i = n.ref) && (i.current && i.current != n.__e || B$2(i, null, u)), null != (i = n.__c)) {
	    if (i.componentWillUnmount) try {
	      i.componentWillUnmount();
	    } catch (n) {
	      l$1.__e(n, u);
	    }
	    i.base = i.__P = null;
	  }
	  if (i = n.__k) for (r = 0; r < i.length; r++) i[r] && D$2(i[r], u, t || "function" != typeof n.type);
	  t || g$2(n.__e), n.__c = n.__ = n.__e = void 0;
	}
	function E$1(n, l, u) {
	  return this.constructor(n, u);
	}
	function G$1(u, t, i) {
	  var r, o, e, f;
	  t == document && (t = document.documentElement), l$1.__ && l$1.__(u, t), o = (r = "function" == typeof i) ? null : i && i.__k || t.__k, e = [], f = [], O$1(t, u = (!r && i || t).__k = _$1(k$2, null, [u]), o || p$1, p$1, t.namespaceURI, !r && i ? [i] : o ? null : t.firstChild ? n.call(t.childNodes) : null, e, !r && i ? i : o ? o.__e : t.firstChild, r, f), N$1(e, u, f);
	}
	function J$1(n, l) {
	  G$1(n, l, J$1);
	}
	function K$1(l, u, t) {
	  var i,
	    r,
	    o,
	    e,
	    f = d$1({}, l.props);
	  for (o in l.type && l.type.defaultProps && (e = l.type.defaultProps), u) "key" == o ? i = u[o] : "ref" == o ? r = u[o] : f[o] = void 0 === u[o] && null != e ? e[o] : u[o];
	  return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : t), m$1(l.type, f, i || l.key, r || l.ref, null);
	}
	function Q$1(n) {
	  function l(n) {
	    var u, t;
	    return this.getChildContext || (u = new Set(), (t = {})[l.__c] = this, this.getChildContext = function () {
	      return t;
	    }, this.componentWillUnmount = function () {
	      u = null;
	    }, this.shouldComponentUpdate = function (n) {
	      this.props.value != n.value && u.forEach(function (n) {
	        n.__e = true, M$1(n);
	      });
	    }, this.sub = function (n) {
	      u.add(n);
	      var l = n.componentWillUnmount;
	      n.componentWillUnmount = function () {
	        u && u.delete(n), l && l.call(n);
	      };
	    }), n.children;
	  }
	  return l.__c = "__cC" + h$1++, l.__ = n, l.Provider = l.__l = (l.Consumer = function (n, l) {
	    return n.children(l);
	  }).contextType = l, l;
	}
	n = v$1.slice, l$1 = {
	  __e: function (n, l, u, t) {
	    for (var i, r, o; l = l.__;) if ((i = l.__c) && !i.__) try {
	      if ((r = i.constructor) && null != r.getDerivedStateFromError && (i.setState(r.getDerivedStateFromError(n)), o = i.__d), null != i.componentDidCatch && (i.componentDidCatch(n, t || {}), o = i.__d), o) return i.__E = i;
	    } catch (l) {
	      n = l;
	    }
	    throw n;
	  }
	}, u$1 = 0, x$2.prototype.setState = function (n, l) {
	  var u;
	  u = null != this.__s && this.__s != this.state ? this.__s : this.__s = d$1({}, this.state), "function" == typeof n && (n = n(d$1({}, u), this.props)), n && d$1(u, n), null != n && this.__v && (l && this._sb.push(l), M$1(this));
	}, x$2.prototype.forceUpdate = function (n) {
	  this.__v && (this.__e = true, n && this.__h.push(n), M$1(this));
	}, x$2.prototype.render = k$2, i$1 = [], o$1 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e$1 = function (n, l) {
	  return n.__v.__b - l.__v.__b;
	}, $$1.__r = 0, f$1 = /(PointerCapture)$|Capture$/i, c$1 = 0, s$1 = F$2(false), a$1 = F$2(true), h$1 = 0;

	var t,
	  r,
	  u,
	  i,
	  o = 0,
	  f = [],
	  c = l$1,
	  e = c.__b,
	  a = c.__r,
	  v = c.diffed,
	  l = c.__c,
	  m = c.unmount,
	  s = c.__;
	function p(n, t) {
	  c.__h && c.__h(r, n, o || t), o = 0;
	  var u = r.__H || (r.__H = {
	    __: [],
	    __h: []
	  });
	  return n >= u.__.length && u.__.push({}), u.__[n];
	}
	function d(n) {
	  return o = 1, h(D$1, n);
	}
	function h(n, u, i) {
	  var o = p(t++, 2);
	  if (o.t = n, !o.__c && (o.__ = [i ? i(u) : D$1(void 0, u), function (n) {
	    var t = o.__N ? o.__N[0] : o.__[0],
	      r = o.t(t, n);
	    t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
	  }], o.__c = r, !r.__f)) {
	    var f = function (n, t, r) {
	      if (!o.__c.__H) return true;
	      var u = o.__c.__H.__.filter(function (n) {
	        return !!n.__c;
	      });
	      if (u.every(function (n) {
	        return !n.__N;
	      })) return !c || c.call(this, n, t, r);
	      var i = o.__c.props !== n;
	      return u.forEach(function (n) {
	        if (n.__N) {
	          var t = n.__[0];
	          n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = true);
	        }
	      }), c && c.call(this, n, t, r) || i;
	    };
	    r.__f = true;
	    var c = r.shouldComponentUpdate,
	      e = r.componentWillUpdate;
	    r.componentWillUpdate = function (n, t, r) {
	      if (this.__e) {
	        var u = c;
	        c = void 0, f(n, t, r), c = u;
	      }
	      e && e.call(this, n, t, r);
	    }, r.shouldComponentUpdate = f;
	  }
	  return o.__N || o.__;
	}
	function y(n, u) {
	  var i = p(t++, 3);
	  !c.__s && C$1(i.__H, u) && (i.__ = n, i.u = u, r.__H.__h.push(i));
	}
	function _(n, u) {
	  var i = p(t++, 4);
	  !c.__s && C$1(i.__H, u) && (i.__ = n, i.u = u, r.__h.push(i));
	}
	function A$1(n) {
	  return o = 5, T$1(function () {
	    return {
	      current: n
	    };
	  }, []);
	}
	function F$1(n, t, r) {
	  o = 6, _(function () {
	    if ("function" == typeof n) {
	      var r = n(t());
	      return function () {
	        n(null), r && "function" == typeof r && r();
	      };
	    }
	    if (n) return n.current = t(), function () {
	      return n.current = null;
	    };
	  }, null == r ? r : r.concat(n));
	}
	function T$1(n, r) {
	  var u = p(t++, 7);
	  return C$1(u.__H, r) && (u.__ = n(), u.__H = r, u.__h = n), u.__;
	}
	function q$1(n, t) {
	  return o = 8, T$1(function () {
	    return n;
	  }, t);
	}
	function x$1(n) {
	  var u = r.context[n.__c],
	    i = p(t++, 9);
	  return i.c = n, u ? (null == i.__ && (i.__ = true, u.sub(r)), u.props.value) : n.__;
	}
	function P$1(n, t) {
	  c.useDebugValue && c.useDebugValue(t ? t(n) : n);
	}
	function g$1() {
	  var n = p(t++, 11);
	  if (!n.__) {
	    for (var u = r.__v; null !== u && !u.__m && null !== u.__;) u = u.__;
	    var i = u.__m || (u.__m = [0, 0]);
	    n.__ = "P" + i[0] + "-" + i[1]++;
	  }
	  return n.__;
	}
	function j$1() {
	  for (var n; n = f.shift();) if (n.__P && n.__H) try {
	    n.__H.__h.forEach(z$1), n.__H.__h.forEach(B$1), n.__H.__h = [];
	  } catch (t) {
	    n.__H.__h = [], c.__e(t, n.__v);
	  }
	}
	c.__b = function (n) {
	  r = null, e && e(n);
	}, c.__ = function (n, t) {
	  n && t.__k && t.__k.__m && (n.__m = t.__k.__m), s && s(n, t);
	}, c.__r = function (n) {
	  a && a(n), t = 0;
	  var i = (r = n.__c).__H;
	  i && (u === r ? (i.__h = [], r.__h = [], i.__.forEach(function (n) {
	    n.__N && (n.__ = n.__N), n.u = n.__N = void 0;
	  })) : (i.__h.forEach(z$1), i.__h.forEach(B$1), i.__h = [], t = 0)), u = r;
	}, c.diffed = function (n) {
	  v && v(n);
	  var t = n.__c;
	  t && t.__H && (t.__H.__h.length && (1 !== f.push(t) && i === c.requestAnimationFrame || ((i = c.requestAnimationFrame) || w$1)(j$1)), t.__H.__.forEach(function (n) {
	    n.u && (n.__H = n.u), n.u = void 0;
	  })), u = r = null;
	}, c.__c = function (n, t) {
	  t.some(function (n) {
	    try {
	      n.__h.forEach(z$1), n.__h = n.__h.filter(function (n) {
	        return !n.__ || B$1(n);
	      });
	    } catch (r) {
	      t.some(function (n) {
	        n.__h && (n.__h = []);
	      }), t = [], c.__e(r, n.__v);
	    }
	  }), l && l(n, t);
	}, c.unmount = function (n) {
	  m && m(n);
	  var t,
	    r = n.__c;
	  r && r.__H && (r.__H.__.forEach(function (n) {
	    try {
	      z$1(n);
	    } catch (n) {
	      t = n;
	    }
	  }), r.__H = void 0, t && c.__e(t, r.__v));
	};
	var k$1 = "function" == typeof requestAnimationFrame;
	function w$1(n) {
	  var t,
	    r = function () {
	      clearTimeout(u), k$1 && cancelAnimationFrame(t), setTimeout(n);
	    },
	    u = setTimeout(r, 35);
	  k$1 && (t = requestAnimationFrame(r));
	}
	function z$1(n) {
	  var t = r,
	    u = n.__c;
	  "function" == typeof u && (n.__c = void 0, u()), r = t;
	}
	function B$1(n) {
	  var t = r;
	  n.__c = n.__(), r = t;
	}
	function C$1(n, t) {
	  return !n || n.length !== t.length || t.some(function (t, r) {
	    return t !== n[r];
	  });
	}
	function D$1(n, t) {
	  return "function" == typeof t ? t(n) : t;
	}

	function g(n, t) {
	  for (var e in t) n[e] = t[e];
	  return n;
	}
	function E(n, t) {
	  for (var e in n) if ("__source" !== e && !(e in t)) return true;
	  for (var r in t) if ("__source" !== r && n[r] !== t[r]) return true;
	  return false;
	}
	function C(n, t) {
	  var e = t(),
	    r = d({
	      t: {
	        __: e,
	        u: t
	      }
	    }),
	    u = r[0].t,
	    o = r[1];
	  return _(function () {
	    u.__ = e, u.u = t, x(u) && o({
	      t: u
	    });
	  }, [n, e, t]), y(function () {
	    return x(u) && o({
	      t: u
	    }), n(function () {
	      x(u) && o({
	        t: u
	      });
	    });
	  }, [n]), e;
	}
	function x(n) {
	  var t,
	    e,
	    r = n.u,
	    u = n.__;
	  try {
	    var o = r();
	    return !((t = u) === (e = o) && (0 !== t || 1 / t == 1 / e) || t != t && e != e);
	  } catch (n) {
	    return true;
	  }
	}
	function R(n) {
	  n();
	}
	function w(n) {
	  return n;
	}
	function k() {
	  return [false, R];
	}
	var I = _;
	function N(n, t) {
	  this.props = n, this.context = t;
	}
	function M(n, e) {
	  function r(n) {
	    var t = this.props.ref,
	      r = t == n.ref;
	    return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : E(this.props, n);
	  }
	  function u(e) {
	    return this.shouldComponentUpdate = r, _$1(n, e);
	  }
	  return u.displayName = "Memo(" + (n.displayName || n.name) + ")", u.prototype.isReactComponent = true, u.__f = true, u.type = n, u;
	}
	(N.prototype = new x$2()).isPureReactComponent = true, N.prototype.shouldComponentUpdate = function (n, t) {
	  return E(this.props, n) || E(this.state, t);
	};
	var T = l$1.__b;
	l$1.__b = function (n) {
	  n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), T && T(n);
	};
	var A = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
	function D(n) {
	  function t(t) {
	    var e = g({}, t);
	    return delete e.ref, n(e, t.ref || null);
	  }
	  return t.$$typeof = A, t.render = n, t.prototype.isReactComponent = t.__f = true, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
	}
	var L = function (n, t) {
	    return null == n ? null : H$1(H$1(n).map(t));
	  },
	  O = {
	    map: L,
	    forEach: L,
	    count: function (n) {
	      return n ? H$1(n).length : 0;
	    },
	    only: function (n) {
	      var t = H$1(n);
	      if (1 !== t.length) throw "Children.only";
	      return t[0];
	    },
	    toArray: H$1
	  },
	  F = l$1.__e;
	l$1.__e = function (n, t, e, r) {
	  if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
	  F(n, t, e, r);
	};
	var U = l$1.unmount;
	function V(n, t, e) {
	  return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
	    "function" == typeof n.__c && n.__c();
	  }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c.__e = true, n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
	    return V(n, t, e);
	  })), n;
	}
	function W(n, t, e) {
	  return n && e && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
	    return W(n, t, e);
	  }), n.__c && n.__c.__P === t && (n.__e && e.appendChild(n.__e), n.__c.__e = true, n.__c.__P = e)), n;
	}
	function P() {
	  this.__u = 0, this.o = null, this.__b = null;
	}
	function j(n) {
	  var t = n.__.__c;
	  return t && t.__a && t.__a(n);
	}
	function z(n) {
	  var e, r, u;
	  function o(o) {
	    if (e || (e = n()).then(function (n) {
	      r = n.default || n;
	    }, function (n) {
	      u = n;
	    }), u) throw u;
	    if (!r) throw e;
	    return _$1(r, o);
	  }
	  return o.displayName = "Lazy", o.__f = true, o;
	}
	function B() {
	  this.i = null, this.l = null;
	}
	l$1.unmount = function (n) {
	  var t = n.__c;
	  t && t.__R && t.__R(), t && 32 & n.__u && (n.type = null), U && U(n);
	}, (P.prototype = new x$2()).__c = function (n, t) {
	  var e = t.__c,
	    r = this;
	  null == r.o && (r.o = []), r.o.push(e);
	  var u = j(r.__v),
	    o = false,
	    i = function () {
	      o || (o = true, e.__R = null, u ? u(l) : l());
	    };
	  e.__R = i;
	  var l = function () {
	    if (! --r.__u) {
	      if (r.state.__a) {
	        var n = r.state.__a;
	        r.__v.__k[0] = W(n, n.__c.__P, n.__c.__O);
	      }
	      var t;
	      for (r.setState({
	        __a: r.__b = null
	      }); t = r.o.pop();) t.forceUpdate();
	    }
	  };
	  r.__u++ || 32 & t.__u || r.setState({
	    __a: r.__b = r.__v.__k[0]
	  }), n.then(i, i);
	}, P.prototype.componentWillUnmount = function () {
	  this.o = [];
	}, P.prototype.render = function (n, e) {
	  if (this.__b) {
	    if (this.__v.__k) {
	      var r = document.createElement("div"),
	        o = this.__v.__k[0].__c;
	      this.__v.__k[0] = V(this.__b, r, o.__O = o.__P);
	    }
	    this.__b = null;
	  }
	  var i = e.__a && _$1(k$2, null, n.fallback);
	  return i && (i.__u &= -33), [_$1(k$2, null, e.__a ? null : n.children), i];
	};
	var H = function (n, t, e) {
	  if (++e[1] === e[0] && n.l.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.l.size)) for (e = n.i; e;) {
	    for (; e.length > 3;) e.pop()();
	    if (e[1] < e[0]) break;
	    n.i = e = e[2];
	  }
	};
	function Z(n) {
	  return this.getChildContext = function () {
	    return n.context;
	  }, n.children;
	}
	function Y(n) {
	  var e = this,
	    r = n.h;
	  if (e.componentWillUnmount = function () {
	    G$1(null, e.v), e.v = null, e.h = null;
	  }, e.h && e.h !== r && e.componentWillUnmount(), !e.v) {
	    for (var u = e.__v; null !== u && !u.__m && null !== u.__;) u = u.__;
	    e.h = r, e.v = {
	      nodeType: 1,
	      parentNode: r,
	      childNodes: [],
	      __k: {
	        __m: u.__m
	      },
	      contains: function () {
	        return true;
	      },
	      insertBefore: function (n, t) {
	        this.childNodes.push(n), e.h.insertBefore(n, t);
	      },
	      removeChild: function (n) {
	        this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), e.h.removeChild(n);
	      }
	    };
	  }
	  G$1(_$1(Z, {
	    context: e.context
	  }, n.__v), e.v);
	}
	function $(n, e) {
	  var r = _$1(Y, {
	    __v: n,
	    h: e
	  });
	  return r.containerInfo = e, r;
	}
	(B.prototype = new x$2()).__a = function (n) {
	  var t = this,
	    e = j(t.__v),
	    r = t.l.get(n);
	  return r[0]++, function (u) {
	    var o = function () {
	      t.props.revealOrder ? (r.push(u), H(t, n, r)) : u();
	    };
	    e ? e(o) : o();
	  };
	}, B.prototype.render = function (n) {
	  this.i = null, this.l = new Map();
	  var t = H$1(n.children);
	  n.revealOrder && "b" === n.revealOrder[0] && t.reverse();
	  for (var e = t.length; e--;) this.l.set(t[e], this.i = [1, 0, this.i]);
	  return n.children;
	}, B.prototype.componentDidUpdate = B.prototype.componentDidMount = function () {
	  var n = this;
	  this.l.forEach(function (t, e) {
	    H(n, e, t);
	  });
	};
	var q = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
	  G = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
	  J = /^on(Ani|Tra|Tou|BeforeInp|Compo)/,
	  K = /[A-Z0-9]/g,
	  Q = "undefined" != typeof document,
	  X = function (n) {
	    return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n);
	  };
	function nn(n, t, e) {
	  return null == t.__k && (t.textContent = ""), G$1(n, t), "function" == typeof e && e(), n ? n.__c : null;
	}
	function tn(n, t, e) {
	  return J$1(n, t), "function" == typeof e && e(), n ? n.__c : null;
	}
	x$2.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
	  Object.defineProperty(x$2.prototype, t, {
	    configurable: true,
	    get: function () {
	      return this["UNSAFE_" + t];
	    },
	    set: function (n) {
	      Object.defineProperty(this, t, {
	        configurable: true,
	        writable: true,
	        value: n
	      });
	    }
	  });
	});
	var en = l$1.event;
	function rn() {}
	function un() {
	  return this.cancelBubble;
	}
	function on() {
	  return this.defaultPrevented;
	}
	l$1.event = function (n) {
	  return en && (n = en(n)), n.persist = rn, n.isPropagationStopped = un, n.isDefaultPrevented = on, n.nativeEvent = n;
	};
	var ln,
	  cn = {
	    enumerable: false,
	    configurable: true,
	    get: function () {
	      return this.class;
	    }
	  },
	  fn = l$1.vnode;
	l$1.vnode = function (n) {
	  "string" == typeof n.type && function (n) {
	    var t = n.props,
	      e = n.type,
	      u = {},
	      o = -1 === e.indexOf("-");
	    for (var i in t) {
	      var l = t[i];
	      if (!("value" === i && "defaultValue" in t && null == l || Q && "children" === i && "noscript" === e || "class" === i || "className" === i)) {
	        var c = i.toLowerCase();
	        "defaultValue" === i && "value" in t && null == t.value ? i = "value" : "download" === i && true === l ? l = "" : "translate" === c && "no" === l ? l = false : "o" === c[0] && "n" === c[1] ? "ondoubleclick" === c ? i = "ondblclick" : "onchange" !== c || "input" !== e && "textarea" !== e || X(t.type) ? "onfocus" === c ? i = "onfocusin" : "onblur" === c ? i = "onfocusout" : J.test(i) && (i = c) : c = i = "oninput" : o && G.test(i) ? i = i.replace(K, "-$&").toLowerCase() : null === l && (l = void 0), "oninput" === c && u[i = c] && (i = "oninputCapture"), u[i] = l;
	      }
	    }
	    "select" == e && u.multiple && Array.isArray(u.value) && (u.value = H$1(t.children).forEach(function (n) {
	      n.props.selected = -1 != u.value.indexOf(n.props.value);
	    })), "select" == e && null != u.defaultValue && (u.value = H$1(t.children).forEach(function (n) {
	      n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
	    })), t.class && !t.className ? (u.class = t.class, Object.defineProperty(u, "className", cn)) : (t.className && !t.class || t.class && t.className) && (u.class = u.className = t.className), n.props = u;
	  }(n), n.$$typeof = q, fn && fn(n);
	};
	var an = l$1.__r;
	l$1.__r = function (n) {
	  an && an(n), ln = n.__c;
	};
	var sn = l$1.diffed;
	l$1.diffed = function (n) {
	  sn && sn(n);
	  var t = n.props,
	    e = n.__e;
	  null != e && "textarea" === n.type && "value" in t && t.value !== e.value && (e.value = null == t.value ? "" : t.value), ln = null;
	};
	var hn = {
	    ReactCurrentDispatcher: {
	      current: {
	        readContext: function (n) {
	          return ln.__n[n.__c].props.value;
	        },
	        useCallback: q$1,
	        useContext: x$1,
	        useDebugValue: P$1,
	        useDeferredValue: w,
	        useEffect: y,
	        useId: g$1,
	        useImperativeHandle: F$1,
	        useInsertionEffect: I,
	        useLayoutEffect: _,
	        useMemo: T$1,
	        useReducer: h,
	        useRef: A$1,
	        useState: d,
	        useSyncExternalStore: C,
	        useTransition: k
	      }
	    }
	  };
	function dn(n) {
	  return _$1.bind(null, n);
	}
	function mn(n) {
	  return !!n && n.$$typeof === q;
	}
	function pn(n) {
	  return mn(n) && n.type === k$2;
	}
	function yn(n) {
	  return !!n && !!n.displayName && ("string" == typeof n.displayName || n.displayName instanceof String) && n.displayName.startsWith("Memo(");
	}
	function _n(n) {
	  return mn(n) ? K$1.apply(null, arguments) : n;
	}
	function bn(n) {
	  return !!n.__k && (G$1(null, n), true);
	}
	function Sn(n) {
	  return n && (n.base || 1 === n.nodeType && n) || null;
	}
	var gn = function (n, t) {
	    return n(t);
	  },
	  En = function (n, t) {
	    return n(t);
	  },
	  Cn = k$2,
	  xn = mn,
	  Rn = {
	    useState: d,
	    useId: g$1,
	    useReducer: h,
	    useEffect: y,
	    useLayoutEffect: _,
	    useInsertionEffect: I,
	    useTransition: k,
	    useDeferredValue: w,
	    useSyncExternalStore: C,
	    startTransition: R,
	    useRef: A$1,
	    useImperativeHandle: F$1,
	    useMemo: T$1,
	    useCallback: q$1,
	    useContext: x$1,
	    useDebugValue: P$1,
	    version: "18.3.1",
	    Children: O,
	    render: nn,
	    hydrate: tn,
	    unmountComponentAtNode: bn,
	    createPortal: $,
	    createElement: _$1,
	    createContext: Q$1,
	    createFactory: dn,
	    cloneElement: _n,
	    createRef: b,
	    Fragment: k$2,
	    isValidElement: mn,
	    isElement: xn,
	    isFragment: pn,
	    isMemo: yn,
	    findDOMNode: Sn,
	    Component: x$2,
	    PureComponent: N,
	    memo: M,
	    forwardRef: D,
	    flushSync: En,
	    unstable_batchedUpdates: gn,
	    StrictMode: Cn,
	    Suspense: P,
	    SuspenseList: B,
	    lazy: z,
	    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: hn
	  };

	/**
	 * Create a bound version of a function with a specified `this` context
	 *
	 * @param {Function} fn - The function to bind
	 * @param {*} thisArg - The value to be passed as the `this` parameter
	 * @returns {Function} A new function that will call the original function with the specified `this` context
	 */
	function bind(fn, thisArg) {
	  return function wrap() {
	    return fn.apply(thisArg, arguments);
	  };
	}

	// utils is a library of generic helper functions non-specific to axios

	const {
	  toString
	} = Object.prototype;
	const {
	  getPrototypeOf
	} = Object;
	const {
	  iterator,
	  toStringTag
	} = Symbol;
	const kindOf = (cache => thing => {
	  const str = toString.call(thing);
	  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
	})(Object.create(null));
	const kindOfTest = type => {
	  type = type.toLowerCase();
	  return thing => kindOf(thing) === type;
	};
	const typeOfTest = type => thing => typeof thing === type;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 *
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	const {
	  isArray
	} = Array;

	/**
	 * Determine if a value is undefined
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	const isUndefined = typeOfTest('undefined');

	/**
	 * Determine if a value is a Buffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Buffer, otherwise false
	 */
	function isBuffer(val) {
	  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	const isArrayBuffer = kindOfTest('ArrayBuffer');

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  let result;
	  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = val && val.buffer && isArrayBuffer(val.buffer);
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	const isString = typeOfTest('string');

	/**
	 * Determine if a value is a Function
	 *
	 * @param {*} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	const isFunction$1 = typeOfTest('function');

	/**
	 * Determine if a value is a Number
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	const isNumber = typeOfTest('number');

	/**
	 * Determine if a value is an Object
	 *
	 * @param {*} thing The value to test
	 *
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	const isObject = thing => thing !== null && typeof thing === 'object';

	/**
	 * Determine if a value is a Boolean
	 *
	 * @param {*} thing The value to test
	 * @returns {boolean} True if value is a Boolean, otherwise false
	 */
	const isBoolean = thing => thing === true || thing === false;

	/**
	 * Determine if a value is a plain Object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a plain Object, otherwise false
	 */
	const isPlainObject = val => {
	  if (kindOf(val) !== 'object') {
	    return false;
	  }
	  const prototype = getPrototypeOf(val);
	  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
	};

	/**
	 * Determine if a value is an empty object (safely handles Buffers)
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is an empty object, otherwise false
	 */
	const isEmptyObject = val => {
	  // Early return for non-objects or Buffers to prevent RangeError
	  if (!isObject(val) || isBuffer(val)) {
	    return false;
	  }
	  try {
	    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
	  } catch (e) {
	    // Fallback for any other objects that might cause RangeError with Object.keys()
	    return false;
	  }
	};

	/**
	 * Determine if a value is a Date
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	const isDate = kindOfTest('Date');

	/**
	 * Determine if a value is a File
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	const isFile = kindOfTest('File');

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	const isBlob = kindOfTest('Blob');

	/**
	 * Determine if a value is a FileList
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	const isFileList = kindOfTest('FileList');

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	const isStream = val => isObject(val) && isFunction$1(val.pipe);

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {*} thing The value to test
	 *
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	const isFormData = thing => {
	  let kind;
	  return thing && (typeof FormData === 'function' && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === 'formdata' ||
	  // detect form-data instance
	  kind === 'object' && isFunction$1(thing.toString) && thing.toString() === '[object FormData]'));
	};

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	const isURLSearchParams = kindOfTest('URLSearchParams');
	const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 *
	 * @returns {String} The String freed of excess whitespace
	 */
	const trim = str => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 *
	 * @param {Boolean} [allOwnKeys = false]
	 * @returns {any}
	 */
	function forEach(obj, fn, {
	  allOwnKeys = false
	} = {}) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }
	  let i;
	  let l;

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }
	  if (isArray(obj)) {
	    // Iterate over array values
	    for (i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Buffer check
	    if (isBuffer(obj)) {
	      return;
	    }

	    // Iterate over object keys
	    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
	    const len = keys.length;
	    let key;
	    for (i = 0; i < len; i++) {
	      key = keys[i];
	      fn.call(null, obj[key], key, obj);
	    }
	  }
	}
	function findKey(obj, key) {
	  if (isBuffer(obj)) {
	    return null;
	  }
	  key = key.toLowerCase();
	  const keys = Object.keys(obj);
	  let i = keys.length;
	  let _key;
	  while (i-- > 0) {
	    _key = keys[i];
	    if (key === _key.toLowerCase()) {
	      return _key;
	    }
	  }
	  return null;
	}
	const _global = (() => {
	  /*eslint no-undef:0*/
	  if (typeof globalThis !== "undefined") return globalThis;
	  return typeof self !== "undefined" ? self : typeof window !== 'undefined' ? window : global;
	})();
	const isContextDefined = context => !isUndefined(context) && context !== _global;

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 *
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */
	) {
	  const {
	    caseless,
	    skipUndefined
	  } = isContextDefined(this) && this || {};
	  const result = {};
	  const assignValue = (val, key) => {
	    const targetKey = caseless && findKey(result, key) || key;
	    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
	      result[targetKey] = merge(result[targetKey], val);
	    } else if (isPlainObject(val)) {
	      result[targetKey] = merge({}, val);
	    } else if (isArray(val)) {
	      result[targetKey] = val.slice();
	    } else if (!skipUndefined || !isUndefined(val)) {
	      result[targetKey] = val;
	    }
	  };
	  for (let i = 0, l = arguments.length; i < l; i++) {
	    arguments[i] && forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 *
	 * @param {Boolean} [allOwnKeys]
	 * @returns {Object} The resulting value of object a
	 */
	const extend = (a, b, thisArg, {
	  allOwnKeys
	} = {}) => {
	  forEach(b, (val, key) => {
	    if (thisArg && isFunction$1(val)) {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  }, {
	    allOwnKeys
	  });
	  return a;
	};

	/**
	 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
	 *
	 * @param {string} content with BOM
	 *
	 * @returns {string} content value without BOM
	 */
	const stripBOM = content => {
	  if (content.charCodeAt(0) === 0xFEFF) {
	    content = content.slice(1);
	  }
	  return content;
	};

	/**
	 * Inherit the prototype methods from one constructor into another
	 * @param {function} constructor
	 * @param {function} superConstructor
	 * @param {object} [props]
	 * @param {object} [descriptors]
	 *
	 * @returns {void}
	 */
	const inherits = (constructor, superConstructor, props, descriptors) => {
	  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
	  constructor.prototype.constructor = constructor;
	  Object.defineProperty(constructor, 'super', {
	    value: superConstructor.prototype
	  });
	  props && Object.assign(constructor.prototype, props);
	};

	/**
	 * Resolve object with deep prototype chain to a flat object
	 * @param {Object} sourceObj source object
	 * @param {Object} [destObj]
	 * @param {Function|Boolean} [filter]
	 * @param {Function} [propFilter]
	 *
	 * @returns {Object}
	 */
	const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
	  let props;
	  let i;
	  let prop;
	  const merged = {};
	  destObj = destObj || {};
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  if (sourceObj == null) return destObj;
	  do {
	    props = Object.getOwnPropertyNames(sourceObj);
	    i = props.length;
	    while (i-- > 0) {
	      prop = props[i];
	      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
	        destObj[prop] = sourceObj[prop];
	        merged[prop] = true;
	      }
	    }
	    sourceObj = filter !== false && getPrototypeOf(sourceObj);
	  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
	  return destObj;
	};

	/**
	 * Determines whether a string ends with the characters of a specified string
	 *
	 * @param {String} str
	 * @param {String} searchString
	 * @param {Number} [position= 0]
	 *
	 * @returns {boolean}
	 */
	const endsWith = (str, searchString, position) => {
	  str = String(str);
	  if (position === undefined || position > str.length) {
	    position = str.length;
	  }
	  position -= searchString.length;
	  const lastIndex = str.indexOf(searchString, position);
	  return lastIndex !== -1 && lastIndex === position;
	};

	/**
	 * Returns new array from array like object or null if failed
	 *
	 * @param {*} [thing]
	 *
	 * @returns {?Array}
	 */
	const toArray = thing => {
	  if (!thing) return null;
	  if (isArray(thing)) return thing;
	  let i = thing.length;
	  if (!isNumber(i)) return null;
	  const arr = new Array(i);
	  while (i-- > 0) {
	    arr[i] = thing[i];
	  }
	  return arr;
	};

	/**
	 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
	 * thing passed in is an instance of Uint8Array
	 *
	 * @param {TypedArray}
	 *
	 * @returns {Array}
	 */
	// eslint-disable-next-line func-names
	const isTypedArray = (TypedArray => {
	  // eslint-disable-next-line func-names
	  return thing => {
	    return TypedArray && thing instanceof TypedArray;
	  };
	})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

	/**
	 * For each entry in the object, call the function with the key and value.
	 *
	 * @param {Object<any, any>} obj - The object to iterate over.
	 * @param {Function} fn - The function to call for each entry.
	 *
	 * @returns {void}
	 */
	const forEachEntry = (obj, fn) => {
	  const generator = obj && obj[iterator];
	  const _iterator = generator.call(obj);
	  let result;
	  while ((result = _iterator.next()) && !result.done) {
	    const pair = result.value;
	    fn.call(obj, pair[0], pair[1]);
	  }
	};

	/**
	 * It takes a regular expression and a string, and returns an array of all the matches
	 *
	 * @param {string} regExp - The regular expression to match against.
	 * @param {string} str - The string to search.
	 *
	 * @returns {Array<boolean>}
	 */
	const matchAll = (regExp, str) => {
	  let matches;
	  const arr = [];
	  while ((matches = regExp.exec(str)) !== null) {
	    arr.push(matches);
	  }
	  return arr;
	};

	/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
	const isHTMLForm = kindOfTest('HTMLFormElement');
	const toCamelCase = str => {
	  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
	    return p1.toUpperCase() + p2;
	  });
	};

	/* Creating a function that will check if an object has a property. */
	const hasOwnProperty = (({
	  hasOwnProperty
	}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

	/**
	 * Determine if a value is a RegExp object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a RegExp object, otherwise false
	 */
	const isRegExp = kindOfTest('RegExp');
	const reduceDescriptors = (obj, reducer) => {
	  const descriptors = Object.getOwnPropertyDescriptors(obj);
	  const reducedDescriptors = {};
	  forEach(descriptors, (descriptor, name) => {
	    let ret;
	    if ((ret = reducer(descriptor, name, obj)) !== false) {
	      reducedDescriptors[name] = ret || descriptor;
	    }
	  });
	  Object.defineProperties(obj, reducedDescriptors);
	};

	/**
	 * Makes all methods read-only
	 * @param {Object} obj
	 */

	const freezeMethods = obj => {
	  reduceDescriptors(obj, (descriptor, name) => {
	    // skip restricted props in strict mode
	    if (isFunction$1(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
	      return false;
	    }
	    const value = obj[name];
	    if (!isFunction$1(value)) return;
	    descriptor.enumerable = false;
	    if ('writable' in descriptor) {
	      descriptor.writable = false;
	      return;
	    }
	    if (!descriptor.set) {
	      descriptor.set = () => {
	        throw Error('Can not rewrite read-only method \'' + name + '\'');
	      };
	    }
	  });
	};
	const toObjectSet = (arrayOrString, delimiter) => {
	  const obj = {};
	  const define = arr => {
	    arr.forEach(value => {
	      obj[value] = true;
	    });
	  };
	  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
	  return obj;
	};
	const noop = () => {};
	const toFiniteNumber = (value, defaultValue) => {
	  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
	};

	/**
	 * If the thing is a FormData object, return true, otherwise return false.
	 *
	 * @param {unknown} thing - The thing to check.
	 *
	 * @returns {boolean}
	 */
	function isSpecCompliantForm(thing) {
	  return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
	}
	const toJSONObject = obj => {
	  const stack = new Array(10);
	  const visit = (source, i) => {
	    if (isObject(source)) {
	      if (stack.indexOf(source) >= 0) {
	        return;
	      }

	      //Buffer check
	      if (isBuffer(source)) {
	        return source;
	      }
	      if (!('toJSON' in source)) {
	        stack[i] = source;
	        const target = isArray(source) ? [] : {};
	        forEach(source, (value, key) => {
	          const reducedValue = visit(value, i + 1);
	          !isUndefined(reducedValue) && (target[key] = reducedValue);
	        });
	        stack[i] = undefined;
	        return target;
	      }
	    }
	    return source;
	  };
	  return visit(obj, 0);
	};
	const isAsyncFn = kindOfTest('AsyncFunction');
	const isThenable = thing => thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);

	// original code
	// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

	const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
	  if (setImmediateSupported) {
	    return setImmediate;
	  }
	  return postMessageSupported ? ((token, callbacks) => {
	    _global.addEventListener("message", ({
	      source,
	      data
	    }) => {
	      if (source === _global && data === token) {
	        callbacks.length && callbacks.shift()();
	      }
	    }, false);
	    return cb => {
	      callbacks.push(cb);
	      _global.postMessage(token, "*");
	    };
	  })(`axios@${Math.random()}`, []) : cb => setTimeout(cb);
	})(typeof setImmediate === 'function', isFunction$1(_global.postMessage));
	const asap = typeof queueMicrotask !== 'undefined' ? queueMicrotask.bind(_global) : typeof process !== 'undefined' && process.nextTick || _setImmediate;

	// *********************

	const isIterable = thing => thing != null && isFunction$1(thing[iterator]);
	var utils$1 = {
	  isArray,
	  isArrayBuffer,
	  isBuffer,
	  isFormData,
	  isArrayBufferView,
	  isString,
	  isNumber,
	  isBoolean,
	  isObject,
	  isPlainObject,
	  isEmptyObject,
	  isReadableStream,
	  isRequest,
	  isResponse,
	  isHeaders,
	  isUndefined,
	  isDate,
	  isFile,
	  isBlob,
	  isRegExp,
	  isFunction: isFunction$1,
	  isStream,
	  isURLSearchParams,
	  isTypedArray,
	  isFileList,
	  forEach,
	  merge,
	  extend,
	  trim,
	  stripBOM,
	  inherits,
	  toFlatObject,
	  kindOf,
	  kindOfTest,
	  endsWith,
	  toArray,
	  forEachEntry,
	  matchAll,
	  isHTMLForm,
	  hasOwnProperty,
	  hasOwnProp: hasOwnProperty,
	  // an alias to avoid ESLint no-prototype-builtins detection
	  reduceDescriptors,
	  freezeMethods,
	  toObjectSet,
	  toCamelCase,
	  noop,
	  toFiniteNumber,
	  findKey,
	  global: _global,
	  isContextDefined,
	  isSpecCompliantForm,
	  toJSONObject,
	  isAsyncFn,
	  isThenable,
	  setImmediate: _setImmediate,
	  asap,
	  isIterable
	};

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [config] The config.
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 *
	 * @returns {Error} The created error.
	 */
	function AxiosError$1(message, code, config, request, response) {
	  Error.call(this);
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.message = message;
	  this.name = 'AxiosError';
	  code && (this.code = code);
	  config && (this.config = config);
	  request && (this.request = request);
	  if (response) {
	    this.response = response;
	    this.status = response.status ? response.status : null;
	  }
	}
	utils$1.inherits(AxiosError$1, Error, {
	  toJSON: function toJSON() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: utils$1.toJSONObject(this.config),
	      code: this.code,
	      status: this.status
	    };
	  }
	});
	const prototype$1 = AxiosError$1.prototype;
	const descriptors = {};
	['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED', 'ERR_NOT_SUPPORT', 'ERR_INVALID_URL'
	// eslint-disable-next-line func-names
	].forEach(code => {
	  descriptors[code] = {
	    value: code
	  };
	});
	Object.defineProperties(AxiosError$1, descriptors);
	Object.defineProperty(prototype$1, 'isAxiosError', {
	  value: true
	});

	// eslint-disable-next-line func-names
	AxiosError$1.from = (error, code, config, request, response, customProps) => {
	  const axiosError = Object.create(prototype$1);
	  utils$1.toFlatObject(error, axiosError, function filter(obj) {
	    return obj !== Error.prototype;
	  }, prop => {
	    return prop !== 'isAxiosError';
	  });
	  const msg = error && error.message ? error.message : 'Error';

	  // Prefer explicit code; otherwise copy the low-level error's code (e.g. ECONNREFUSED)
	  const errCode = code == null && error ? error.code : code;
	  AxiosError$1.call(axiosError, msg, errCode, config, request, response);

	  // Chain the original error on the standard field; non-enumerable to avoid JSON noise
	  if (error && axiosError.cause == null) {
	    Object.defineProperty(axiosError, 'cause', {
	      value: error,
	      configurable: true
	    });
	  }
	  axiosError.name = error && error.name || 'Error';
	  customProps && Object.assign(axiosError, customProps);
	  return axiosError;
	};

	// eslint-disable-next-line strict
	var httpAdapter = null;

	/**
	 * Determines if the given thing is a array or js object.
	 *
	 * @param {string} thing - The object or array to be visited.
	 *
	 * @returns {boolean}
	 */
	function isVisitable(thing) {
	  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
	}

	/**
	 * It removes the brackets from the end of a string
	 *
	 * @param {string} key - The key of the parameter.
	 *
	 * @returns {string} the key without the brackets.
	 */
	function removeBrackets(key) {
	  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
	}

	/**
	 * It takes a path, a key, and a boolean, and returns a string
	 *
	 * @param {string} path - The path to the current key.
	 * @param {string} key - The key of the current object being iterated over.
	 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
	 *
	 * @returns {string} The path to the current key.
	 */
	function renderKey(path, key, dots) {
	  if (!path) return key;
	  return path.concat(key).map(function each(token, i) {
	    // eslint-disable-next-line no-param-reassign
	    token = removeBrackets(token);
	    return !dots && i ? '[' + token + ']' : token;
	  }).join(dots ? '.' : '');
	}

	/**
	 * If the array is an array and none of its elements are visitable, then it's a flat array.
	 *
	 * @param {Array<any>} arr - The array to check
	 *
	 * @returns {boolean}
	 */
	function isFlatArray(arr) {
	  return utils$1.isArray(arr) && !arr.some(isVisitable);
	}
	const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
	  return /^is[A-Z]/.test(prop);
	});

	/**
	 * Convert a data object to FormData
	 *
	 * @param {Object} obj
	 * @param {?Object} [formData]
	 * @param {?Object} [options]
	 * @param {Function} [options.visitor]
	 * @param {Boolean} [options.metaTokens = true]
	 * @param {Boolean} [options.dots = false]
	 * @param {?Boolean} [options.indexes = false]
	 *
	 * @returns {Object}
	 **/

	/**
	 * It converts an object into a FormData object
	 *
	 * @param {Object<any, any>} obj - The object to convert to form data.
	 * @param {string} formData - The FormData object to append to.
	 * @param {Object<string, any>} options
	 *
	 * @returns
	 */
	function toFormData$1(obj, formData, options) {
	  if (!utils$1.isObject(obj)) {
	    throw new TypeError('target must be an object');
	  }

	  // eslint-disable-next-line no-param-reassign
	  formData = formData || new (FormData)();

	  // eslint-disable-next-line no-param-reassign
	  options = utils$1.toFlatObject(options, {
	    metaTokens: true,
	    dots: false,
	    indexes: false
	  }, false, function defined(option, source) {
	    // eslint-disable-next-line no-eq-null,eqeqeq
	    return !utils$1.isUndefined(source[option]);
	  });
	  const metaTokens = options.metaTokens;
	  // eslint-disable-next-line no-use-before-define
	  const visitor = options.visitor || defaultVisitor;
	  const dots = options.dots;
	  const indexes = options.indexes;
	  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
	  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
	  if (!utils$1.isFunction(visitor)) {
	    throw new TypeError('visitor must be a function');
	  }
	  function convertValue(value) {
	    if (value === null) return '';
	    if (utils$1.isDate(value)) {
	      return value.toISOString();
	    }
	    if (utils$1.isBoolean(value)) {
	      return value.toString();
	    }
	    if (!useBlob && utils$1.isBlob(value)) {
	      throw new AxiosError$1('Blob is not supported. Use a Buffer instead.');
	    }
	    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
	      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
	    }
	    return value;
	  }

	  /**
	   * Default visitor.
	   *
	   * @param {*} value
	   * @param {String|Number} key
	   * @param {Array<String|Number>} path
	   * @this {FormData}
	   *
	   * @returns {boolean} return true to visit the each prop of the value recursively
	   */
	  function defaultVisitor(value, key, path) {
	    let arr = value;
	    if (value && !path && typeof value === 'object') {
	      if (utils$1.endsWith(key, '{}')) {
	        // eslint-disable-next-line no-param-reassign
	        key = metaTokens ? key : key.slice(0, -2);
	        // eslint-disable-next-line no-param-reassign
	        value = JSON.stringify(value);
	      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))) {
	        // eslint-disable-next-line no-param-reassign
	        key = removeBrackets(key);
	        arr.forEach(function each(el, index) {
	          !(utils$1.isUndefined(el) || el === null) && formData.append(
	          // eslint-disable-next-line no-nested-ternary
	          indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + '[]', convertValue(el));
	        });
	        return false;
	      }
	    }
	    if (isVisitable(value)) {
	      return true;
	    }
	    formData.append(renderKey(path, key, dots), convertValue(value));
	    return false;
	  }
	  const stack = [];
	  const exposedHelpers = Object.assign(predicates, {
	    defaultVisitor,
	    convertValue,
	    isVisitable
	  });
	  function build(value, path) {
	    if (utils$1.isUndefined(value)) return;
	    if (stack.indexOf(value) !== -1) {
	      throw Error('Circular reference detected in ' + path.join('.'));
	    }
	    stack.push(value);
	    utils$1.forEach(value, function each(el, key) {
	      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers);
	      if (result === true) {
	        build(el, path ? path.concat(key) : [key]);
	      }
	    });
	    stack.pop();
	  }
	  if (!utils$1.isObject(obj)) {
	    throw new TypeError('data must be an object');
	  }
	  build(obj);
	  return formData;
	}

	/**
	 * It encodes a string by replacing all characters that are not in the unreserved set with
	 * their percent-encoded equivalents
	 *
	 * @param {string} str - The string to encode.
	 *
	 * @returns {string} The encoded string.
	 */
	function encode$1(str) {
	  const charMap = {
	    '!': '%21',
	    "'": '%27',
	    '(': '%28',
	    ')': '%29',
	    '~': '%7E',
	    '%20': '+',
	    '%00': '\x00'
	  };
	  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
	    return charMap[match];
	  });
	}

	/**
	 * It takes a params object and converts it to a FormData object
	 *
	 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
	 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
	 *
	 * @returns {void}
	 */
	function AxiosURLSearchParams(params, options) {
	  this._pairs = [];
	  params && toFormData$1(params, this, options);
	}
	const prototype = AxiosURLSearchParams.prototype;
	prototype.append = function append(name, value) {
	  this._pairs.push([name, value]);
	};
	prototype.toString = function toString(encoder) {
	  const _encode = encoder ? function (value) {
	    return encoder.call(this, value, encode$1);
	  } : encode$1;
	  return this._pairs.map(function each(pair) {
	    return _encode(pair[0]) + '=' + _encode(pair[1]);
	  }, '').join('&');
	};

	/**
	 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
	 * URI encoded counterparts
	 *
	 * @param {string} val The value to be encoded.
	 *
	 * @returns {string} The encoded value.
	 */
	function encode(val) {
	  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @param {?(object|Function)} options
	 *
	 * @returns {string} The formatted url
	 */
	function buildURL(url, params, options) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }
	  const _encode = options && options.encode || encode;
	  if (utils$1.isFunction(options)) {
	    options = {
	      serialize: options
	    };
	  }
	  const serializeFn = options && options.serialize;
	  let serializedParams;
	  if (serializeFn) {
	    serializedParams = serializeFn(params, options);
	  } else {
	    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
	  }
	  if (serializedParams) {
	    const hashmarkIndex = url.indexOf("#");
	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }
	  return url;
	}

	class InterceptorManager {
	  constructor() {
	    this.handlers = [];
	  }

	  /**
	   * Add a new interceptor to the stack
	   *
	   * @param {Function} fulfilled The function to handle `then` for a `Promise`
	   * @param {Function} rejected The function to handle `reject` for a `Promise`
	   *
	   * @return {Number} An ID used to remove interceptor later
	   */
	  use(fulfilled, rejected, options) {
	    this.handlers.push({
	      fulfilled,
	      rejected,
	      synchronous: options ? options.synchronous : false,
	      runWhen: options ? options.runWhen : null
	    });
	    return this.handlers.length - 1;
	  }

	  /**
	   * Remove an interceptor from the stack
	   *
	   * @param {Number} id The ID that was returned by `use`
	   *
	   * @returns {void}
	   */
	  eject(id) {
	    if (this.handlers[id]) {
	      this.handlers[id] = null;
	    }
	  }

	  /**
	   * Clear all interceptors from the stack
	   *
	   * @returns {void}
	   */
	  clear() {
	    if (this.handlers) {
	      this.handlers = [];
	    }
	  }

	  /**
	   * Iterate over all the registered interceptors
	   *
	   * This method is particularly useful for skipping over any
	   * interceptors that may have become `null` calling `eject`.
	   *
	   * @param {Function} fn The function to call for each interceptor
	   *
	   * @returns {void}
	   */
	  forEach(fn) {
	    utils$1.forEach(this.handlers, function forEachHandler(h) {
	      if (h !== null) {
	        fn(h);
	      }
	    });
	  }
	}

	var transitionalDefaults = {
	  silentJSONParsing: true,
	  forcedJSONParsing: true,
	  clarifyTimeoutError: false
	};

	var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

	var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

	var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

	var platform$1 = {
	  isBrowser: true,
	  classes: {
	    URLSearchParams: URLSearchParams$1,
	    FormData: FormData$1,
	    Blob: Blob$1
	  },
	  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
	};

	const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';
	const _navigator = typeof navigator === 'object' && navigator || undefined;

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 * nativescript
	 *  navigator.product -> 'NativeScript' or 'NS'
	 *
	 * @returns {boolean}
	 */
	const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

	/**
	 * Determine if we're running in a standard browser webWorker environment
	 *
	 * Although the `isStandardBrowserEnv` method indicates that
	 * `allows axios to run in a web worker`, the WebWorker will still be
	 * filtered out due to its judgment standard
	 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
	 * This leads to a problem when axios post `FormData` in webWorker
	 */
	const hasStandardBrowserWebWorkerEnv = (() => {
	  return typeof WorkerGlobalScope !== 'undefined' &&
	  // eslint-disable-next-line no-undef
	  self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';
	})();
	const origin = hasBrowserEnv && window.location.href || 'http://localhost';

	var utils = /*#__PURE__*/Object.freeze({
		__proto__: null,
		hasBrowserEnv: hasBrowserEnv,
		hasStandardBrowserEnv: hasStandardBrowserEnv,
		hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
		navigator: _navigator,
		origin: origin
	});

	var platform = {
	  ...utils,
	  ...platform$1
	};

	function toURLEncodedForm(data, options) {
	  return toFormData$1(data, new platform.classes.URLSearchParams(), {
	    visitor: function (value, key, path, helpers) {
	      if (platform.isNode && utils$1.isBuffer(value)) {
	        this.append(key, value.toString('base64'));
	        return false;
	      }
	      return helpers.defaultVisitor.apply(this, arguments);
	    },
	    ...options
	  });
	}

	/**
	 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
	 *
	 * @param {string} name - The name of the property to get.
	 *
	 * @returns An array of strings.
	 */
	function parsePropPath(name) {
	  // foo[x][y][z]
	  // foo.x.y.z
	  // foo-x-y-z
	  // foo x y z
	  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
	    return match[0] === '[]' ? '' : match[1] || match[0];
	  });
	}

	/**
	 * Convert an array to an object.
	 *
	 * @param {Array<any>} arr - The array to convert to an object.
	 *
	 * @returns An object with the same keys and values as the array.
	 */
	function arrayToObject(arr) {
	  const obj = {};
	  const keys = Object.keys(arr);
	  let i;
	  const len = keys.length;
	  let key;
	  for (i = 0; i < len; i++) {
	    key = keys[i];
	    obj[key] = arr[key];
	  }
	  return obj;
	}

	/**
	 * It takes a FormData object and returns a JavaScript object
	 *
	 * @param {string} formData The FormData object to convert to JSON.
	 *
	 * @returns {Object<string, any> | null} The converted object.
	 */
	function formDataToJSON(formData) {
	  function buildPath(path, value, target, index) {
	    let name = path[index++];
	    if (name === '__proto__') return true;
	    const isNumericKey = Number.isFinite(+name);
	    const isLast = index >= path.length;
	    name = !name && utils$1.isArray(target) ? target.length : name;
	    if (isLast) {
	      if (utils$1.hasOwnProp(target, name)) {
	        target[name] = [target[name], value];
	      } else {
	        target[name] = value;
	      }
	      return !isNumericKey;
	    }
	    if (!target[name] || !utils$1.isObject(target[name])) {
	      target[name] = [];
	    }
	    const result = buildPath(path, value, target[name], index);
	    if (result && utils$1.isArray(target[name])) {
	      target[name] = arrayToObject(target[name]);
	    }
	    return !isNumericKey;
	  }
	  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
	    const obj = {};
	    utils$1.forEachEntry(formData, (name, value) => {
	      buildPath(parsePropPath(name), value, obj, 0);
	    });
	    return obj;
	  }
	  return null;
	}

	/**
	 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
	 * of the input
	 *
	 * @param {any} rawValue - The value to be stringified.
	 * @param {Function} parser - A function that parses a string into a JavaScript object.
	 * @param {Function} encoder - A function that takes a value and returns a string.
	 *
	 * @returns {string} A stringified version of the rawValue.
	 */
	function stringifySafely(rawValue, parser, encoder) {
	  if (utils$1.isString(rawValue)) {
	    try {
	      (parser || JSON.parse)(rawValue);
	      return utils$1.trim(rawValue);
	    } catch (e) {
	      if (e.name !== 'SyntaxError') {
	        throw e;
	      }
	    }
	  }
	  return (encoder || JSON.stringify)(rawValue);
	}
	const defaults = {
	  transitional: transitionalDefaults,
	  adapter: ['xhr', 'http', 'fetch'],
	  transformRequest: [function transformRequest(data, headers) {
	    const contentType = headers.getContentType() || '';
	    const hasJSONContentType = contentType.indexOf('application/json') > -1;
	    const isObjectPayload = utils$1.isObject(data);
	    if (isObjectPayload && utils$1.isHTMLForm(data)) {
	      data = new FormData(data);
	    }
	    const isFormData = utils$1.isFormData(data);
	    if (isFormData) {
	      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
	    }
	    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
	      return data;
	    }
	    if (utils$1.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils$1.isURLSearchParams(data)) {
	      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
	      return data.toString();
	    }
	    let isFileList;
	    if (isObjectPayload) {
	      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
	        return toURLEncodedForm(data, this.formSerializer).toString();
	      }
	      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
	        const _FormData = this.env && this.env.FormData;
	        return toFormData$1(isFileList ? {
	          'files[]': data
	        } : data, _FormData && new _FormData(), this.formSerializer);
	      }
	    }
	    if (isObjectPayload || hasJSONContentType) {
	      headers.setContentType('application/json', false);
	      return stringifySafely(data);
	    }
	    return data;
	  }],
	  transformResponse: [function transformResponse(data) {
	    const transitional = this.transitional || defaults.transitional;
	    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
	    const JSONRequested = this.responseType === 'json';
	    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
	      return data;
	    }
	    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
	      const silentJSONParsing = transitional && transitional.silentJSONParsing;
	      const strictJSONParsing = !silentJSONParsing && JSONRequested;
	      try {
	        return JSON.parse(data, this.parseReviver);
	      } catch (e) {
	        if (strictJSONParsing) {
	          if (e.name === 'SyntaxError') {
	            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
	          }
	          throw e;
	        }
	      }
	    }
	    return data;
	  }],
	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,
	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',
	  maxContentLength: -1,
	  maxBodyLength: -1,
	  env: {
	    FormData: platform.classes.FormData,
	    Blob: platform.classes.Blob
	  },
	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  },
	  headers: {
	    common: {
	      'Accept': 'application/json, text/plain, */*',
	      'Content-Type': undefined
	    }
	  }
	};
	utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], method => {
	  defaults.headers[method] = {};
	});

	// RawAxiosHeaders whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	const ignoreDuplicateOf = utils$1.toObjectSet(['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']);

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} rawHeaders Headers needing to be parsed
	 *
	 * @returns {Object} Headers parsed into an object
	 */
	var parseHeaders = rawHeaders => {
	  const parsed = {};
	  let key;
	  let val;
	  let i;
	  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
	    i = line.indexOf(':');
	    key = line.substring(0, i).trim().toLowerCase();
	    val = line.substring(i + 1).trim();
	    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
	      return;
	    }
	    if (key === 'set-cookie') {
	      if (parsed[key]) {
	        parsed[key].push(val);
	      } else {
	        parsed[key] = [val];
	      }
	    } else {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });
	  return parsed;
	};

	const $internals = Symbol('internals');
	function normalizeHeader(header) {
	  return header && String(header).trim().toLowerCase();
	}
	function normalizeValue(value) {
	  if (value === false || value == null) {
	    return value;
	  }
	  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
	}
	function parseTokens(str) {
	  const tokens = Object.create(null);
	  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
	  let match;
	  while (match = tokensRE.exec(str)) {
	    tokens[match[1]] = match[2];
	  }
	  return tokens;
	}
	const isValidHeaderName = str => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
	function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
	  if (utils$1.isFunction(filter)) {
	    return filter.call(this, value, header);
	  }
	  if (isHeaderNameFilter) {
	    value = header;
	  }
	  if (!utils$1.isString(value)) return;
	  if (utils$1.isString(filter)) {
	    return value.indexOf(filter) !== -1;
	  }
	  if (utils$1.isRegExp(filter)) {
	    return filter.test(value);
	  }
	}
	function formatHeader(header) {
	  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
	    return char.toUpperCase() + str;
	  });
	}
	function buildAccessors(obj, header) {
	  const accessorName = utils$1.toCamelCase(' ' + header);
	  ['get', 'set', 'has'].forEach(methodName => {
	    Object.defineProperty(obj, methodName + accessorName, {
	      value: function (arg1, arg2, arg3) {
	        return this[methodName].call(this, header, arg1, arg2, arg3);
	      },
	      configurable: true
	    });
	  });
	}
	let AxiosHeaders$1 = class AxiosHeaders {
	  constructor(headers) {
	    headers && this.set(headers);
	  }
	  set(header, valueOrRewrite, rewrite) {
	    const self = this;
	    function setHeader(_value, _header, _rewrite) {
	      const lHeader = normalizeHeader(_header);
	      if (!lHeader) {
	        throw new Error('header name must be a non-empty string');
	      }
	      const key = utils$1.findKey(self, lHeader);
	      if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {
	        self[key || _header] = normalizeValue(_value);
	      }
	    }
	    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
	    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
	      setHeaders(header, valueOrRewrite);
	    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
	      setHeaders(parseHeaders(header), valueOrRewrite);
	    } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
	      let obj = {},
	        dest,
	        key;
	      for (const entry of header) {
	        if (!utils$1.isArray(entry)) {
	          throw TypeError('Object iterator must return a key-value pair');
	        }
	        obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
	      }
	      setHeaders(obj, valueOrRewrite);
	    } else {
	      header != null && setHeader(valueOrRewrite, header, rewrite);
	    }
	    return this;
	  }
	  get(header, parser) {
	    header = normalizeHeader(header);
	    if (header) {
	      const key = utils$1.findKey(this, header);
	      if (key) {
	        const value = this[key];
	        if (!parser) {
	          return value;
	        }
	        if (parser === true) {
	          return parseTokens(value);
	        }
	        if (utils$1.isFunction(parser)) {
	          return parser.call(this, value, key);
	        }
	        if (utils$1.isRegExp(parser)) {
	          return parser.exec(value);
	        }
	        throw new TypeError('parser must be boolean|regexp|function');
	      }
	    }
	  }
	  has(header, matcher) {
	    header = normalizeHeader(header);
	    if (header) {
	      const key = utils$1.findKey(this, header);
	      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
	    }
	    return false;
	  }
	  delete(header, matcher) {
	    const self = this;
	    let deleted = false;
	    function deleteHeader(_header) {
	      _header = normalizeHeader(_header);
	      if (_header) {
	        const key = utils$1.findKey(self, _header);
	        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
	          delete self[key];
	          deleted = true;
	        }
	      }
	    }
	    if (utils$1.isArray(header)) {
	      header.forEach(deleteHeader);
	    } else {
	      deleteHeader(header);
	    }
	    return deleted;
	  }
	  clear(matcher) {
	    const keys = Object.keys(this);
	    let i = keys.length;
	    let deleted = false;
	    while (i--) {
	      const key = keys[i];
	      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
	        delete this[key];
	        deleted = true;
	      }
	    }
	    return deleted;
	  }
	  normalize(format) {
	    const self = this;
	    const headers = {};
	    utils$1.forEach(this, (value, header) => {
	      const key = utils$1.findKey(headers, header);
	      if (key) {
	        self[key] = normalizeValue(value);
	        delete self[header];
	        return;
	      }
	      const normalized = format ? formatHeader(header) : String(header).trim();
	      if (normalized !== header) {
	        delete self[header];
	      }
	      self[normalized] = normalizeValue(value);
	      headers[normalized] = true;
	    });
	    return this;
	  }
	  concat(...targets) {
	    return this.constructor.concat(this, ...targets);
	  }
	  toJSON(asStrings) {
	    const obj = Object.create(null);
	    utils$1.forEach(this, (value, header) => {
	      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
	    });
	    return obj;
	  }
	  [Symbol.iterator]() {
	    return Object.entries(this.toJSON())[Symbol.iterator]();
	  }
	  toString() {
	    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
	  }
	  getSetCookie() {
	    return this.get("set-cookie") || [];
	  }
	  get [Symbol.toStringTag]() {
	    return 'AxiosHeaders';
	  }
	  static from(thing) {
	    return thing instanceof this ? thing : new this(thing);
	  }
	  static concat(first, ...targets) {
	    const computed = new this(first);
	    targets.forEach(target => computed.set(target));
	    return computed;
	  }
	  static accessor(header) {
	    const internals = this[$internals] = this[$internals] = {
	      accessors: {}
	    };
	    const accessors = internals.accessors;
	    const prototype = this.prototype;
	    function defineAccessor(_header) {
	      const lHeader = normalizeHeader(_header);
	      if (!accessors[lHeader]) {
	        buildAccessors(prototype, _header);
	        accessors[lHeader] = true;
	      }
	    }
	    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
	    return this;
	  }
	};
	AxiosHeaders$1.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

	// reserved names hotfix
	utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({
	  value
	}, key) => {
	  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
	  return {
	    get: () => value,
	    set(headerValue) {
	      this[mapped] = headerValue;
	    }
	  };
	});
	utils$1.freezeMethods(AxiosHeaders$1);

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Array|Function} fns A single function or Array of functions
	 * @param {?Object} response The response object
	 *
	 * @returns {*} The resulting transformed data
	 */
	function transformData(fns, response) {
	  const config = this || defaults;
	  const context = response || config;
	  const headers = AxiosHeaders$1.from(context.headers);
	  let data = context.data;
	  utils$1.forEach(fns, function transform(fn) {
	    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
	  });
	  headers.normalize();
	  return data;
	}

	function isCancel$1(value) {
	  return !!(value && value.__CANCEL__);
	}

	/**
	 * A `CanceledError` is an object that is thrown when an operation is canceled.
	 *
	 * @param {string=} message The message.
	 * @param {Object=} config The config.
	 * @param {Object=} request The request.
	 *
	 * @returns {CanceledError} The created error.
	 */
	function CanceledError$1(message, config, request) {
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  AxiosError$1.call(this, message == null ? 'canceled' : message, AxiosError$1.ERR_CANCELED, config, request);
	  this.name = 'CanceledError';
	}
	utils$1.inherits(CanceledError$1, AxiosError$1, {
	  __CANCEL__: true
	});

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 *
	 * @returns {object} The response.
	 */
	function settle(resolve, reject, response) {
	  const validateStatus = response.config.validateStatus;
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(new AxiosError$1('Request failed with status code ' + response.status, [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
	  }
	}

	function parseProtocol(url) {
	  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
	  return match && match[1] || '';
	}

	/**
	 * Calculate data maxRate
	 * @param {Number} [samplesCount= 10]
	 * @param {Number} [min= 1000]
	 * @returns {Function}
	 */
	function speedometer(samplesCount, min) {
	  samplesCount = samplesCount || 10;
	  const bytes = new Array(samplesCount);
	  const timestamps = new Array(samplesCount);
	  let head = 0;
	  let tail = 0;
	  let firstSampleTS;
	  min = min !== undefined ? min : 1000;
	  return function push(chunkLength) {
	    const now = Date.now();
	    const startedAt = timestamps[tail];
	    if (!firstSampleTS) {
	      firstSampleTS = now;
	    }
	    bytes[head] = chunkLength;
	    timestamps[head] = now;
	    let i = tail;
	    let bytesCount = 0;
	    while (i !== head) {
	      bytesCount += bytes[i++];
	      i = i % samplesCount;
	    }
	    head = (head + 1) % samplesCount;
	    if (head === tail) {
	      tail = (tail + 1) % samplesCount;
	    }
	    if (now - firstSampleTS < min) {
	      return;
	    }
	    const passed = startedAt && now - startedAt;
	    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
	  };
	}

	/**
	 * Throttle decorator
	 * @param {Function} fn
	 * @param {Number} freq
	 * @return {Function}
	 */
	function throttle(fn, freq) {
	  let timestamp = 0;
	  let threshold = 1000 / freq;
	  let lastArgs;
	  let timer;
	  const invoke = (args, now = Date.now()) => {
	    timestamp = now;
	    lastArgs = null;
	    if (timer) {
	      clearTimeout(timer);
	      timer = null;
	    }
	    fn(...args);
	  };
	  const throttled = (...args) => {
	    const now = Date.now();
	    const passed = now - timestamp;
	    if (passed >= threshold) {
	      invoke(args, now);
	    } else {
	      lastArgs = args;
	      if (!timer) {
	        timer = setTimeout(() => {
	          timer = null;
	          invoke(lastArgs);
	        }, threshold - passed);
	      }
	    }
	  };
	  const flush = () => lastArgs && invoke(lastArgs);
	  return [throttled, flush];
	}

	const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
	  let bytesNotified = 0;
	  const _speedometer = speedometer(50, 250);
	  return throttle(e => {
	    const loaded = e.loaded;
	    const total = e.lengthComputable ? e.total : undefined;
	    const progressBytes = loaded - bytesNotified;
	    const rate = _speedometer(progressBytes);
	    const inRange = loaded <= total;
	    bytesNotified = loaded;
	    const data = {
	      loaded,
	      total,
	      progress: total ? loaded / total : undefined,
	      bytes: progressBytes,
	      rate: rate ? rate : undefined,
	      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
	      event: e,
	      lengthComputable: total != null,
	      [isDownloadStream ? 'download' : 'upload']: true
	    };
	    listener(data);
	  }, freq);
	};
	const progressEventDecorator = (total, throttled) => {
	  const lengthComputable = total != null;
	  return [loaded => throttled[0]({
	    lengthComputable,
	    total,
	    loaded
	  }), throttled[1]];
	};
	const asyncDecorator = fn => (...args) => utils$1.asap(() => fn(...args));

	var isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => url => {
	  url = new URL(url, platform.origin);
	  return origin.protocol === url.protocol && origin.host === url.host && (isMSIE || origin.port === url.port);
	})(new URL(platform.origin), platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)) : () => true;

	var cookies = platform.hasStandardBrowserEnv ?
	// Standard browser envs support document.cookie
	{
	  write(name, value, expires, path, domain, secure, sameSite) {
	    if (typeof document === 'undefined') return;
	    const cookie = [`${name}=${encodeURIComponent(value)}`];
	    if (utils$1.isNumber(expires)) {
	      cookie.push(`expires=${new Date(expires).toUTCString()}`);
	    }
	    if (utils$1.isString(path)) {
	      cookie.push(`path=${path}`);
	    }
	    if (utils$1.isString(domain)) {
	      cookie.push(`domain=${domain}`);
	    }
	    if (secure === true) {
	      cookie.push('secure');
	    }
	    if (utils$1.isString(sameSite)) {
	      cookie.push(`SameSite=${sameSite}`);
	    }
	    document.cookie = cookie.join('; ');
	  },
	  read(name) {
	    if (typeof document === 'undefined') return null;
	    const match = document.cookie.match(new RegExp('(?:^|; )' + name + '=([^;]*)'));
	    return match ? decodeURIComponent(match[1]) : null;
	  },
	  remove(name) {
	    this.write(name, '', Date.now() - 86400000, '/');
	  }
	} :
	// Non-standard browser env (web workers, react-native) lack needed support.
	{
	  write() {},
	  read() {
	    return null;
	  },
	  remove() {}
	};

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 *
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
	}

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 *
	 * @returns {string} The combined URL
	 */
	function combineURLs(baseURL, relativeURL) {
	  return relativeURL ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
	}

	/**
	 * Creates a new URL by combining the baseURL with the requestedURL,
	 * only when the requestedURL is not already an absolute URL.
	 * If the requestURL is absolute, this function returns the requestedURL untouched.
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} requestedURL Absolute or relative URL to combine
	 *
	 * @returns {string} The combined full path
	 */
	function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
	  let isRelativeUrl = !isAbsoluteURL(requestedURL);
	  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
	    return combineURLs(baseURL, requestedURL);
	  }
	  return requestedURL;
	}

	const headersToObject = thing => thing instanceof AxiosHeaders$1 ? {
	  ...thing
	} : thing;

	/**
	 * Config-specific merge-function which creates a new config-object
	 * by merging two configuration objects together.
	 *
	 * @param {Object} config1
	 * @param {Object} config2
	 *
	 * @returns {Object} New object resulting from merging config2 to config1
	 */
	function mergeConfig$1(config1, config2) {
	  // eslint-disable-next-line no-param-reassign
	  config2 = config2 || {};
	  const config = {};
	  function getMergedValue(target, source, prop, caseless) {
	    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
	      return utils$1.merge.call({
	        caseless
	      }, target, source);
	    } else if (utils$1.isPlainObject(source)) {
	      return utils$1.merge({}, source);
	    } else if (utils$1.isArray(source)) {
	      return source.slice();
	    }
	    return source;
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDeepProperties(a, b, prop, caseless) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(a, b, prop, caseless);
	    } else if (!utils$1.isUndefined(a)) {
	      return getMergedValue(undefined, a, prop, caseless);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function valueFromConfig2(a, b) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(undefined, b);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function defaultToConfig2(a, b) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(undefined, b);
	    } else if (!utils$1.isUndefined(a)) {
	      return getMergedValue(undefined, a);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDirectKeys(a, b, prop) {
	    if (prop in config2) {
	      return getMergedValue(a, b);
	    } else if (prop in config1) {
	      return getMergedValue(undefined, a);
	    }
	  }
	  const mergeMap = {
	    url: valueFromConfig2,
	    method: valueFromConfig2,
	    data: valueFromConfig2,
	    baseURL: defaultToConfig2,
	    transformRequest: defaultToConfig2,
	    transformResponse: defaultToConfig2,
	    paramsSerializer: defaultToConfig2,
	    timeout: defaultToConfig2,
	    timeoutMessage: defaultToConfig2,
	    withCredentials: defaultToConfig2,
	    withXSRFToken: defaultToConfig2,
	    adapter: defaultToConfig2,
	    responseType: defaultToConfig2,
	    xsrfCookieName: defaultToConfig2,
	    xsrfHeaderName: defaultToConfig2,
	    onUploadProgress: defaultToConfig2,
	    onDownloadProgress: defaultToConfig2,
	    decompress: defaultToConfig2,
	    maxContentLength: defaultToConfig2,
	    maxBodyLength: defaultToConfig2,
	    beforeRedirect: defaultToConfig2,
	    transport: defaultToConfig2,
	    httpAgent: defaultToConfig2,
	    httpsAgent: defaultToConfig2,
	    cancelToken: defaultToConfig2,
	    socketPath: defaultToConfig2,
	    responseEncoding: defaultToConfig2,
	    validateStatus: mergeDirectKeys,
	    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
	  };
	  utils$1.forEach(Object.keys({
	    ...config1,
	    ...config2
	  }), function computeConfigValue(prop) {
	    const merge = mergeMap[prop] || mergeDeepProperties;
	    const configValue = merge(config1[prop], config2[prop], prop);
	    utils$1.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
	  });
	  return config;
	}

	var resolveConfig = config => {
	  const newConfig = mergeConfig$1({}, config);
	  let {
	    data,
	    withXSRFToken,
	    xsrfHeaderName,
	    xsrfCookieName,
	    headers,
	    auth
	  } = newConfig;
	  newConfig.headers = headers = AxiosHeaders$1.from(headers);
	  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

	  // HTTP basic authentication
	  if (auth) {
	    headers.set('Authorization', 'Basic ' + btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : '')));
	  }
	  if (utils$1.isFormData(data)) {
	    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
	      headers.setContentType(undefined); // browser handles it
	    } else if (utils$1.isFunction(data.getHeaders)) {
	      // Node.js FormData (like form-data package)
	      const formHeaders = data.getHeaders();
	      // Only set safe headers to avoid overwriting security headers
	      const allowedHeaders = ['content-type', 'content-length'];
	      Object.entries(formHeaders).forEach(([key, val]) => {
	        if (allowedHeaders.includes(key.toLowerCase())) {
	          headers.set(key, val);
	        }
	      });
	    }
	  }

	  // Add xsrf header
	  // This is only done if running in a standard browser environment.
	  // Specifically not if we're in a web worker, or react-native.

	  if (platform.hasStandardBrowserEnv) {
	    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
	    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
	      // Add xsrf header
	      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
	      if (xsrfValue) {
	        headers.set(xsrfHeaderName, xsrfValue);
	      }
	    }
	  }
	  return newConfig;
	};

	const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
	var xhrAdapter = isXHRAdapterSupported && function (config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    const _config = resolveConfig(config);
	    let requestData = _config.data;
	    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
	    let {
	      responseType,
	      onUploadProgress,
	      onDownloadProgress
	    } = _config;
	    let onCanceled;
	    let uploadThrottled, downloadThrottled;
	    let flushUpload, flushDownload;
	    function done() {
	      flushUpload && flushUpload(); // flush events
	      flushDownload && flushDownload(); // flush events

	      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
	      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
	    }
	    let request = new XMLHttpRequest();
	    request.open(_config.method.toUpperCase(), _config.url, true);

	    // Set the request timeout in MS
	    request.timeout = _config.timeout;
	    function onloadend() {
	      if (!request) {
	        return;
	      }
	      // Prepare the response
	      const responseHeaders = AxiosHeaders$1.from('getAllResponseHeaders' in request && request.getAllResponseHeaders());
	      const responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
	      const response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config,
	        request
	      };
	      settle(function _resolve(value) {
	        resolve(value);
	        done();
	      }, function _reject(err) {
	        reject(err);
	        done();
	      }, response);

	      // Clean up request
	      request = null;
	    }
	    if ('onloadend' in request) {
	      // Use onloadend if available
	      request.onloadend = onloadend;
	    } else {
	      // Listen for ready state to emulate onloadend
	      request.onreadystatechange = function handleLoad() {
	        if (!request || request.readyState !== 4) {
	          return;
	        }

	        // The request errored out and we didn't get a response, this will be
	        // handled by onerror instead
	        // With one exception: request that using file: protocol, most browsers
	        // will return status as 0 even though it's a successful request
	        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	          return;
	        }
	        // readystate handler is calling before onerror or ontimeout handlers,
	        // so we should call onloadend on the next 'tick'
	        setTimeout(onloadend);
	      };
	    }

	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }
	      reject(new AxiosError$1('Request aborted', AxiosError$1.ECONNABORTED, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError(event) {
	      // Browsers deliver a ProgressEvent in XHR onerror
	      // (message may be empty; when present, surface it)
	      // See https://developer.mozilla.org/docs/Web/API/XMLHttpRequest/error_event
	      const msg = event && event.message ? event.message : 'Network Error';
	      const err = new AxiosError$1(msg, AxiosError$1.ERR_NETWORK, config, request);
	      // attach the underlying event for consumers who want details
	      err.event = event || null;
	      reject(err);
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
	      const transitional = _config.transitional || transitionalDefaults;
	      if (_config.timeoutErrorMessage) {
	        timeoutErrorMessage = _config.timeoutErrorMessage;
	      }
	      reject(new AxiosError$1(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Remove Content-Type if data is undefined
	    requestData === undefined && requestHeaders.setContentType(null);

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
	        request.setRequestHeader(key, val);
	      });
	    }

	    // Add withCredentials to request if needed
	    if (!utils$1.isUndefined(_config.withCredentials)) {
	      request.withCredentials = !!_config.withCredentials;
	    }

	    // Add responseType to request if needed
	    if (responseType && responseType !== 'json') {
	      request.responseType = _config.responseType;
	    }

	    // Handle progress if needed
	    if (onDownloadProgress) {
	      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
	      request.addEventListener('progress', downloadThrottled);
	    }

	    // Not all browsers support upload events
	    if (onUploadProgress && request.upload) {
	      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
	      request.upload.addEventListener('progress', uploadThrottled);
	      request.upload.addEventListener('loadend', flushUpload);
	    }
	    if (_config.cancelToken || _config.signal) {
	      // Handle cancellation
	      // eslint-disable-next-line func-names
	      onCanceled = cancel => {
	        if (!request) {
	          return;
	        }
	        reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
	        request.abort();
	        request = null;
	      };
	      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
	      if (_config.signal) {
	        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
	      }
	    }
	    const protocol = parseProtocol(_config.url);
	    if (protocol && platform.protocols.indexOf(protocol) === -1) {
	      reject(new AxiosError$1('Unsupported protocol ' + protocol + ':', AxiosError$1.ERR_BAD_REQUEST, config));
	      return;
	    }

	    // Send the request
	    request.send(requestData || null);
	  });
	};

	const composeSignals = (signals, timeout) => {
	  const {
	    length
	  } = signals = signals ? signals.filter(Boolean) : [];
	  if (timeout || length) {
	    let controller = new AbortController();
	    let aborted;
	    const onabort = function (reason) {
	      if (!aborted) {
	        aborted = true;
	        unsubscribe();
	        const err = reason instanceof Error ? reason : this.reason;
	        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
	      }
	    };
	    let timer = timeout && setTimeout(() => {
	      timer = null;
	      onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
	    }, timeout);
	    const unsubscribe = () => {
	      if (signals) {
	        timer && clearTimeout(timer);
	        timer = null;
	        signals.forEach(signal => {
	          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
	        });
	        signals = null;
	      }
	    };
	    signals.forEach(signal => signal.addEventListener('abort', onabort));
	    const {
	      signal
	    } = controller;
	    signal.unsubscribe = () => utils$1.asap(unsubscribe);
	    return signal;
	  }
	};

	const streamChunk = function* (chunk, chunkSize) {
	  let len = chunk.byteLength;
	  if (len < chunkSize) {
	    yield chunk;
	    return;
	  }
	  let pos = 0;
	  let end;
	  while (pos < len) {
	    end = pos + chunkSize;
	    yield chunk.slice(pos, end);
	    pos = end;
	  }
	};
	const readBytes = async function* (iterable, chunkSize) {
	  for await (const chunk of readStream(iterable)) {
	    yield* streamChunk(chunk, chunkSize);
	  }
	};
	const readStream = async function* (stream) {
	  if (stream[Symbol.asyncIterator]) {
	    yield* stream;
	    return;
	  }
	  const reader = stream.getReader();
	  try {
	    for (;;) {
	      const {
	        done,
	        value
	      } = await reader.read();
	      if (done) {
	        break;
	      }
	      yield value;
	    }
	  } finally {
	    await reader.cancel();
	  }
	};
	const trackStream = (stream, chunkSize, onProgress, onFinish) => {
	  const iterator = readBytes(stream, chunkSize);
	  let bytes = 0;
	  let done;
	  let _onFinish = e => {
	    if (!done) {
	      done = true;
	      onFinish && onFinish(e);
	    }
	  };
	  return new ReadableStream({
	    async pull(controller) {
	      try {
	        const {
	          done,
	          value
	        } = await iterator.next();
	        if (done) {
	          _onFinish();
	          controller.close();
	          return;
	        }
	        let len = value.byteLength;
	        if (onProgress) {
	          let loadedBytes = bytes += len;
	          onProgress(loadedBytes);
	        }
	        controller.enqueue(new Uint8Array(value));
	      } catch (err) {
	        _onFinish(err);
	        throw err;
	      }
	    },
	    cancel(reason) {
	      _onFinish(reason);
	      return iterator.return();
	    }
	  }, {
	    highWaterMark: 2
	  });
	};

	const DEFAULT_CHUNK_SIZE = 64 * 1024;
	const {
	  isFunction
	} = utils$1;
	const globalFetchAPI = (({
	  Request,
	  Response
	}) => ({
	  Request,
	  Response
	}))(utils$1.global);
	const {
	  ReadableStream: ReadableStream$1,
	  TextEncoder
	} = utils$1.global;
	const test = (fn, ...args) => {
	  try {
	    return !!fn(...args);
	  } catch (e) {
	    return false;
	  }
	};
	const factory = env => {
	  env = utils$1.merge.call({
	    skipUndefined: true
	  }, globalFetchAPI, env);
	  const {
	    fetch: envFetch,
	    Request,
	    Response
	  } = env;
	  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === 'function';
	  const isRequestSupported = isFunction(Request);
	  const isResponseSupported = isFunction(Response);
	  if (!isFetchSupported) {
	    return false;
	  }
	  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
	  const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? (encoder => str => encoder.encode(str))(new TextEncoder()) : async str => new Uint8Array(await new Request(str).arrayBuffer()));
	  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
	    let duplexAccessed = false;
	    const hasContentType = new Request(platform.origin, {
	      body: new ReadableStream$1(),
	      method: 'POST',
	      get duplex() {
	        duplexAccessed = true;
	        return 'half';
	      }
	    }).headers.has('Content-Type');
	    return duplexAccessed && !hasContentType;
	  });
	  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response('').body));
	  const resolvers = {
	    stream: supportsResponseStream && (res => res.body)
	  };
	  isFetchSupported && (() => {
	    ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
	      !resolvers[type] && (resolvers[type] = (res, config) => {
	        let method = res && res[type];
	        if (method) {
	          return method.call(res);
	        }
	        throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
	      });
	    });
	  })();
	  const getBodyLength = async body => {
	    if (body == null) {
	      return 0;
	    }
	    if (utils$1.isBlob(body)) {
	      return body.size;
	    }
	    if (utils$1.isSpecCompliantForm(body)) {
	      const _request = new Request(platform.origin, {
	        method: 'POST',
	        body
	      });
	      return (await _request.arrayBuffer()).byteLength;
	    }
	    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
	      return body.byteLength;
	    }
	    if (utils$1.isURLSearchParams(body)) {
	      body = body + '';
	    }
	    if (utils$1.isString(body)) {
	      return (await encodeText(body)).byteLength;
	    }
	  };
	  const resolveBodyLength = async (headers, body) => {
	    const length = utils$1.toFiniteNumber(headers.getContentLength());
	    return length == null ? getBodyLength(body) : length;
	  };
	  return async config => {
	    let {
	      url,
	      method,
	      data,
	      signal,
	      cancelToken,
	      timeout,
	      onDownloadProgress,
	      onUploadProgress,
	      responseType,
	      headers,
	      withCredentials = 'same-origin',
	      fetchOptions
	    } = resolveConfig(config);
	    let _fetch = envFetch || fetch;
	    responseType = responseType ? (responseType + '').toLowerCase() : 'text';
	    let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
	    let request = null;
	    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
	      composedSignal.unsubscribe();
	    });
	    let requestContentLength;
	    try {
	      if (onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
	        let _request = new Request(url, {
	          method: 'POST',
	          body: data,
	          duplex: "half"
	        });
	        let contentTypeHeader;
	        if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
	          headers.setContentType(contentTypeHeader);
	        }
	        if (_request.body) {
	          const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));
	          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
	        }
	      }
	      if (!utils$1.isString(withCredentials)) {
	        withCredentials = withCredentials ? 'include' : 'omit';
	      }

	      // Cloudflare Workers throws when credentials are defined
	      // see https://github.com/cloudflare/workerd/issues/902
	      const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
	      const resolvedOptions = {
	        ...fetchOptions,
	        signal: composedSignal,
	        method: method.toUpperCase(),
	        headers: headers.normalize().toJSON(),
	        body: data,
	        duplex: "half",
	        credentials: isCredentialsSupported ? withCredentials : undefined
	      };
	      request = isRequestSupported && new Request(url, resolvedOptions);
	      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
	      const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');
	      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
	        const options = {};
	        ['status', 'statusText', 'headers'].forEach(prop => {
	          options[prop] = response[prop];
	        });
	        const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));
	        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];
	        response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
	          flush && flush();
	          unsubscribe && unsubscribe();
	        }), options);
	      }
	      responseType = responseType || 'text';
	      let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);
	      !isStreamResponse && unsubscribe && unsubscribe();
	      return await new Promise((resolve, reject) => {
	        settle(resolve, reject, {
	          data: responseData,
	          headers: AxiosHeaders$1.from(response.headers),
	          status: response.status,
	          statusText: response.statusText,
	          config,
	          request
	        });
	      });
	    } catch (err) {
	      unsubscribe && unsubscribe();
	      if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
	        throw Object.assign(new AxiosError$1('Network Error', AxiosError$1.ERR_NETWORK, config, request), {
	          cause: err.cause || err
	        });
	      }
	      throw AxiosError$1.from(err, err && err.code, config, request);
	    }
	  };
	};
	const seedCache = new Map();
	const getFetch = config => {
	  let env = config && config.env || {};
	  const {
	    fetch,
	    Request,
	    Response
	  } = env;
	  const seeds = [Request, Response, fetch];
	  let len = seeds.length,
	    i = len,
	    seed,
	    target,
	    map = seedCache;
	  while (i--) {
	    seed = seeds[i];
	    target = map.get(seed);
	    target === undefined && map.set(seed, target = i ? new Map() : factory(env));
	    map = target;
	  }
	  return target;
	};
	getFetch();

	/**
	 * Known adapters mapping.
	 * Provides environment-specific adapters for Axios:
	 * - `http` for Node.js
	 * - `xhr` for browsers
	 * - `fetch` for fetch API-based requests
	 * 
	 * @type {Object<string, Function|Object>}
	 */
	const knownAdapters = {
	  http: httpAdapter,
	  xhr: xhrAdapter,
	  fetch: {
	    get: getFetch
	  }
	};

	// Assign adapter names for easier debugging and identification
	utils$1.forEach(knownAdapters, (fn, value) => {
	  if (fn) {
	    try {
	      Object.defineProperty(fn, 'name', {
	        value
	      });
	    } catch (e) {
	      // eslint-disable-next-line no-empty
	    }
	    Object.defineProperty(fn, 'adapterName', {
	      value
	    });
	  }
	});

	/**
	 * Render a rejection reason string for unknown or unsupported adapters
	 * 
	 * @param {string} reason
	 * @returns {string}
	 */
	const renderReason = reason => `- ${reason}`;

	/**
	 * Check if the adapter is resolved (function, null, or false)
	 * 
	 * @param {Function|null|false} adapter
	 * @returns {boolean}
	 */
	const isResolvedHandle = adapter => utils$1.isFunction(adapter) || adapter === null || adapter === false;

	/**
	 * Get the first suitable adapter from the provided list.
	 * Tries each adapter in order until a supported one is found.
	 * Throws an AxiosError if no adapter is suitable.
	 * 
	 * @param {Array<string|Function>|string|Function} adapters - Adapter(s) by name or function.
	 * @param {Object} config - Axios request configuration
	 * @throws {AxiosError} If no suitable adapter is available
	 * @returns {Function} The resolved adapter function
	 */
	function getAdapter$1(adapters, config) {
	  adapters = utils$1.isArray(adapters) ? adapters : [adapters];
	  const {
	    length
	  } = adapters;
	  let nameOrAdapter;
	  let adapter;
	  const rejectedReasons = {};
	  for (let i = 0; i < length; i++) {
	    nameOrAdapter = adapters[i];
	    let id;
	    adapter = nameOrAdapter;
	    if (!isResolvedHandle(nameOrAdapter)) {
	      adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
	      if (adapter === undefined) {
	        throw new AxiosError$1(`Unknown adapter '${id}'`);
	      }
	    }
	    if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config)))) {
	      break;
	    }
	    rejectedReasons[id || '#' + i] = adapter;
	  }
	  if (!adapter) {
	    const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? 'is not supported by the environment' : 'is not available in the build'));
	    let s = length ? reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0]) : 'as no adapter specified';
	    throw new AxiosError$1(`There is no suitable adapter to dispatch the request ` + s, 'ERR_NOT_SUPPORT');
	  }
	  return adapter;
	}

	/**
	 * Exports Axios adapters and utility to resolve an adapter
	 */
	var adapters = {
	  /**
	   * Resolve an adapter from a list of adapter names or functions.
	   * @type {Function}
	   */
	  getAdapter: getAdapter$1,
	  /**
	   * Exposes all known adapters
	   * @type {Object<string, Function|Object>}
	   */
	  adapters: knownAdapters
	};

	/**
	 * Throws a `CanceledError` if cancellation has been requested.
	 *
	 * @param {Object} config The config that is to be used for the request
	 *
	 * @returns {void}
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	  if (config.signal && config.signal.aborted) {
	    throw new CanceledError$1(null, config);
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 *
	 * @returns {Promise} The Promise to be fulfilled
	 */
	function dispatchRequest(config) {
	  throwIfCancellationRequested(config);
	  config.headers = AxiosHeaders$1.from(config.headers);

	  // Transform request data
	  config.data = transformData.call(config, config.transformRequest);
	  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
	    config.headers.setContentType('application/x-www-form-urlencoded', false);
	  }
	  const adapter = adapters.getAdapter(config.adapter || defaults.adapter, config);
	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData.call(config, config.transformResponse, response);
	    response.headers = AxiosHeaders$1.from(response.headers);
	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel$1(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
	        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
	      }
	    }
	    return Promise.reject(reason);
	  });
	}

	const VERSION$1 = "1.13.2";

	const validators$1 = {};

	// eslint-disable-next-line func-names
	['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
	  validators$1[type] = function validator(thing) {
	    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
	  };
	});
	const deprecatedWarnings = {};

	/**
	 * Transitional option validator
	 *
	 * @param {function|boolean?} validator - set to false if the transitional option has been removed
	 * @param {string?} version - deprecated version / removed since version
	 * @param {string?} message - some message with additional info
	 *
	 * @returns {function}
	 */
	validators$1.transitional = function transitional(validator, version, message) {
	  function formatMessage(opt, desc) {
	    return '[Axios v' + VERSION$1 + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
	  }

	  // eslint-disable-next-line func-names
	  return (value, opt, opts) => {
	    if (validator === false) {
	      throw new AxiosError$1(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError$1.ERR_DEPRECATED);
	    }
	    if (version && !deprecatedWarnings[opt]) {
	      deprecatedWarnings[opt] = true;
	      // eslint-disable-next-line no-console
	      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
	    }
	    return validator ? validator(value, opt, opts) : true;
	  };
	};
	validators$1.spelling = function spelling(correctSpelling) {
	  return (value, opt) => {
	    // eslint-disable-next-line no-console
	    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
	    return true;
	  };
	};

	/**
	 * Assert object's properties type
	 *
	 * @param {object} options
	 * @param {object} schema
	 * @param {boolean?} allowUnknown
	 *
	 * @returns {object}
	 */

	function assertOptions(options, schema, allowUnknown) {
	  if (typeof options !== 'object') {
	    throw new AxiosError$1('options must be an object', AxiosError$1.ERR_BAD_OPTION_VALUE);
	  }
	  const keys = Object.keys(options);
	  let i = keys.length;
	  while (i-- > 0) {
	    const opt = keys[i];
	    const validator = schema[opt];
	    if (validator) {
	      const value = options[opt];
	      const result = value === undefined || validator(value, opt, options);
	      if (result !== true) {
	        throw new AxiosError$1('option ' + opt + ' must be ' + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
	      }
	      continue;
	    }
	    if (allowUnknown !== true) {
	      throw new AxiosError$1('Unknown option ' + opt, AxiosError$1.ERR_BAD_OPTION);
	    }
	  }
	}
	var validator = {
	  assertOptions,
	  validators: validators$1
	};

	const validators = validator.validators;

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 *
	 * @return {Axios} A new instance of Axios
	 */
	let Axios$1 = class Axios {
	  constructor(instanceConfig) {
	    this.defaults = instanceConfig || {};
	    this.interceptors = {
	      request: new InterceptorManager(),
	      response: new InterceptorManager()
	    };
	  }

	  /**
	   * Dispatch a request
	   *
	   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
	   * @param {?Object} config
	   *
	   * @returns {Promise} The Promise to be fulfilled
	   */
	  async request(configOrUrl, config) {
	    try {
	      return await this._request(configOrUrl, config);
	    } catch (err) {
	      if (err instanceof Error) {
	        let dummy = {};
	        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();

	        // slice off the Error: ... line
	        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
	        try {
	          if (!err.stack) {
	            err.stack = stack;
	            // match without the 2 top stack lines
	          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
	            err.stack += '\n' + stack;
	          }
	        } catch (e) {
	          // ignore the case where "stack" is an un-writable property
	        }
	      }
	      throw err;
	    }
	  }
	  _request(configOrUrl, config) {
	    /*eslint no-param-reassign:0*/
	    // Allow for axios('example/url'[, config]) a la fetch API
	    if (typeof configOrUrl === 'string') {
	      config = config || {};
	      config.url = configOrUrl;
	    } else {
	      config = configOrUrl || {};
	    }
	    config = mergeConfig$1(this.defaults, config);
	    const {
	      transitional,
	      paramsSerializer,
	      headers
	    } = config;
	    if (transitional !== undefined) {
	      validator.assertOptions(transitional, {
	        silentJSONParsing: validators.transitional(validators.boolean),
	        forcedJSONParsing: validators.transitional(validators.boolean),
	        clarifyTimeoutError: validators.transitional(validators.boolean)
	      }, false);
	    }
	    if (paramsSerializer != null) {
	      if (utils$1.isFunction(paramsSerializer)) {
	        config.paramsSerializer = {
	          serialize: paramsSerializer
	        };
	      } else {
	        validator.assertOptions(paramsSerializer, {
	          encode: validators.function,
	          serialize: validators.function
	        }, true);
	      }
	    }

	    // Set config.allowAbsoluteUrls
	    if (config.allowAbsoluteUrls !== undefined) ; else if (this.defaults.allowAbsoluteUrls !== undefined) {
	      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
	    } else {
	      config.allowAbsoluteUrls = true;
	    }
	    validator.assertOptions(config, {
	      baseUrl: validators.spelling('baseURL'),
	      withXsrfToken: validators.spelling('withXSRFToken')
	    }, true);

	    // Set config.method
	    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

	    // Flatten headers
	    let contextHeaders = headers && utils$1.merge(headers.common, headers[config.method]);
	    headers && utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], method => {
	      delete headers[method];
	    });
	    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

	    // filter out skipped interceptors
	    const requestInterceptorChain = [];
	    let synchronousRequestInterceptors = true;
	    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
	        return;
	      }
	      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
	      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
	    });
	    const responseInterceptorChain = [];
	    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
	    });
	    let promise;
	    let i = 0;
	    let len;
	    if (!synchronousRequestInterceptors) {
	      const chain = [dispatchRequest.bind(this), undefined];
	      chain.unshift(...requestInterceptorChain);
	      chain.push(...responseInterceptorChain);
	      len = chain.length;
	      promise = Promise.resolve(config);
	      while (i < len) {
	        promise = promise.then(chain[i++], chain[i++]);
	      }
	      return promise;
	    }
	    len = requestInterceptorChain.length;
	    let newConfig = config;
	    while (i < len) {
	      const onFulfilled = requestInterceptorChain[i++];
	      const onRejected = requestInterceptorChain[i++];
	      try {
	        newConfig = onFulfilled(newConfig);
	      } catch (error) {
	        onRejected.call(this, error);
	        break;
	      }
	    }
	    try {
	      promise = dispatchRequest.call(this, newConfig);
	    } catch (error) {
	      return Promise.reject(error);
	    }
	    i = 0;
	    len = responseInterceptorChain.length;
	    while (i < len) {
	      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
	    }
	    return promise;
	  }
	  getUri(config) {
	    config = mergeConfig$1(this.defaults, config);
	    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
	    return buildURL(fullPath, config.params, config.paramsSerializer);
	  }
	};

	// Provide aliases for supported request methods
	utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios$1.prototype[method] = function (url, config) {
	    return this.request(mergeConfig$1(config || {}, {
	      method,
	      url,
	      data: (config || {}).data
	    }));
	  };
	});
	utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/

	  function generateHTTPMethod(isForm) {
	    return function httpMethod(url, data, config) {
	      return this.request(mergeConfig$1(config || {}, {
	        method,
	        headers: isForm ? {
	          'Content-Type': 'multipart/form-data'
	        } : {},
	        url,
	        data
	      }));
	    };
	  }
	  Axios$1.prototype[method] = generateHTTPMethod();
	  Axios$1.prototype[method + 'Form'] = generateHTTPMethod(true);
	});

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @param {Function} executor The executor function.
	 *
	 * @returns {CancelToken}
	 */
	let CancelToken$1 = class CancelToken {
	  constructor(executor) {
	    if (typeof executor !== 'function') {
	      throw new TypeError('executor must be a function.');
	    }
	    let resolvePromise;
	    this.promise = new Promise(function promiseExecutor(resolve) {
	      resolvePromise = resolve;
	    });
	    const token = this;

	    // eslint-disable-next-line func-names
	    this.promise.then(cancel => {
	      if (!token._listeners) return;
	      let i = token._listeners.length;
	      while (i-- > 0) {
	        token._listeners[i](cancel);
	      }
	      token._listeners = null;
	    });

	    // eslint-disable-next-line func-names
	    this.promise.then = onfulfilled => {
	      let _resolve;
	      // eslint-disable-next-line func-names
	      const promise = new Promise(resolve => {
	        token.subscribe(resolve);
	        _resolve = resolve;
	      }).then(onfulfilled);
	      promise.cancel = function reject() {
	        token.unsubscribe(_resolve);
	      };
	      return promise;
	    };
	    executor(function cancel(message, config, request) {
	      if (token.reason) {
	        // Cancellation has already been requested
	        return;
	      }
	      token.reason = new CanceledError$1(message, config, request);
	      resolvePromise(token.reason);
	    });
	  }

	  /**
	   * Throws a `CanceledError` if cancellation has been requested.
	   */
	  throwIfRequested() {
	    if (this.reason) {
	      throw this.reason;
	    }
	  }

	  /**
	   * Subscribe to the cancel signal
	   */

	  subscribe(listener) {
	    if (this.reason) {
	      listener(this.reason);
	      return;
	    }
	    if (this._listeners) {
	      this._listeners.push(listener);
	    } else {
	      this._listeners = [listener];
	    }
	  }

	  /**
	   * Unsubscribe from the cancel signal
	   */

	  unsubscribe(listener) {
	    if (!this._listeners) {
	      return;
	    }
	    const index = this._listeners.indexOf(listener);
	    if (index !== -1) {
	      this._listeners.splice(index, 1);
	    }
	  }
	  toAbortSignal() {
	    const controller = new AbortController();
	    const abort = err => {
	      controller.abort(err);
	    };
	    this.subscribe(abort);
	    controller.signal.unsubscribe = () => this.unsubscribe(abort);
	    return controller.signal;
	  }

	  /**
	   * Returns an object that contains a new `CancelToken` and a function that, when called,
	   * cancels the `CancelToken`.
	   */
	  static source() {
	    let cancel;
	    const token = new CancelToken(function executor(c) {
	      cancel = c;
	    });
	    return {
	      token,
	      cancel
	    };
	  }
	};

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 *
	 * @returns {Function}
	 */
	function spread$1(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	}

	/**
	 * Determines whether the payload is an error thrown by Axios
	 *
	 * @param {*} payload The value to test
	 *
	 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
	 */
	function isAxiosError$1(payload) {
	  return utils$1.isObject(payload) && payload.isAxiosError === true;
	}

	const HttpStatusCode$1 = {
	  Continue: 100,
	  SwitchingProtocols: 101,
	  Processing: 102,
	  EarlyHints: 103,
	  Ok: 200,
	  Created: 201,
	  Accepted: 202,
	  NonAuthoritativeInformation: 203,
	  NoContent: 204,
	  ResetContent: 205,
	  PartialContent: 206,
	  MultiStatus: 207,
	  AlreadyReported: 208,
	  ImUsed: 226,
	  MultipleChoices: 300,
	  MovedPermanently: 301,
	  Found: 302,
	  SeeOther: 303,
	  NotModified: 304,
	  UseProxy: 305,
	  Unused: 306,
	  TemporaryRedirect: 307,
	  PermanentRedirect: 308,
	  BadRequest: 400,
	  Unauthorized: 401,
	  PaymentRequired: 402,
	  Forbidden: 403,
	  NotFound: 404,
	  MethodNotAllowed: 405,
	  NotAcceptable: 406,
	  ProxyAuthenticationRequired: 407,
	  RequestTimeout: 408,
	  Conflict: 409,
	  Gone: 410,
	  LengthRequired: 411,
	  PreconditionFailed: 412,
	  PayloadTooLarge: 413,
	  UriTooLong: 414,
	  UnsupportedMediaType: 415,
	  RangeNotSatisfiable: 416,
	  ExpectationFailed: 417,
	  ImATeapot: 418,
	  MisdirectedRequest: 421,
	  UnprocessableEntity: 422,
	  Locked: 423,
	  FailedDependency: 424,
	  TooEarly: 425,
	  UpgradeRequired: 426,
	  PreconditionRequired: 428,
	  TooManyRequests: 429,
	  RequestHeaderFieldsTooLarge: 431,
	  UnavailableForLegalReasons: 451,
	  InternalServerError: 500,
	  NotImplemented: 501,
	  BadGateway: 502,
	  ServiceUnavailable: 503,
	  GatewayTimeout: 504,
	  HttpVersionNotSupported: 505,
	  VariantAlsoNegotiates: 506,
	  InsufficientStorage: 507,
	  LoopDetected: 508,
	  NotExtended: 510,
	  NetworkAuthenticationRequired: 511,
	  WebServerIsDown: 521,
	  ConnectionTimedOut: 522,
	  OriginIsUnreachable: 523,
	  TimeoutOccurred: 524,
	  SslHandshakeFailed: 525,
	  InvalidSslCertificate: 526
	};
	Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
	  HttpStatusCode$1[value] = key;
	});

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 *
	 * @returns {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  const context = new Axios$1(defaultConfig);
	  const instance = bind(Axios$1.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils$1.extend(instance, Axios$1.prototype, context, {
	    allOwnKeys: true
	  });

	  // Copy context to instance
	  utils$1.extend(instance, context, null, {
	    allOwnKeys: true
	  });

	  // Factory for creating new instances
	  instance.create = function create(instanceConfig) {
	    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
	  };
	  return instance;
	}

	// Create the default instance to be exported
	const axios = createInstance(defaults);

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios$1;

	// Expose Cancel & CancelToken
	axios.CanceledError = CanceledError$1;
	axios.CancelToken = CancelToken$1;
	axios.isCancel = isCancel$1;
	axios.VERSION = VERSION$1;
	axios.toFormData = toFormData$1;

	// Expose AxiosError class
	axios.AxiosError = AxiosError$1;

	// alias for CanceledError for backward compatibility
	axios.Cancel = axios.CanceledError;

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = spread$1;

	// Expose isAxiosError
	axios.isAxiosError = isAxiosError$1;

	// Expose mergeConfig
	axios.mergeConfig = mergeConfig$1;
	axios.AxiosHeaders = AxiosHeaders$1;
	axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
	axios.getAdapter = adapters.getAdapter;
	axios.HttpStatusCode = HttpStatusCode$1;
	axios.default = axios;

	// This module is intended to unwrap Axios default export as named.
	// Keep top-level export same with static properties
	// so that it can keep same with es module or cjs
	const {
	  Axios,
	  AxiosError,
	  CanceledError,
	  isCancel,
	  CancelToken,
	  VERSION,
	  all,
	  Cancel,
	  isAxiosError,
	  spread,
	  toFormData,
	  AxiosHeaders,
	  HttpStatusCode,
	  formToJSON,
	  getAdapter,
	  mergeConfig
	} = axios;

	async function api (url, data) {
	  return await axios.post(url, data).then(resp => resp.data);
	}

	const datumValidate = /^(\d+);(\d+);(\d+);(\d+)$/;
	const boxType = 0;
	const itemType = 1;
	class Datum {
	  constructor(id, type, width, height, depth, weight) {
	    this.id = id;
	    this.type = type;
	    this.width = parseInt(width);
	    this.height = parseInt(height);
	    this.depth = parseInt(depth);
	    this.weight = parseInt(weight);
	    this.enabled = true;
	  }
	  toString() {
	    return this.width + 'x' + this.height + 'x' + this.depth + ' wg' + this.weight;
	  }
	  toExport() {
	    return [this.id, this.width, this.type, this.height, this.depth, this.weight].join(';');
	  }
	}

	// Packing strategies (matching boxpacker3 constants)
	const STRATEGIES = [{
	  value: 0,
	  name: 'Minimize Boxes',
	  description: 'Minimizes the number of boxes used'
	}, {
	  value: 1,
	  name: 'Greedy',
	  description: 'First-fit strategy with ascending item order'
	}, {
	  value: 2,
	  name: 'First Fit Decreasing (FFD)',
	  description: 'First-fit decreasing strategy'
	}, {
	  value: 3,
	  name: 'Best Fit',
	  description: 'Best-fit strategy'
	}, {
	  value: 4,
	  name: 'Best Fit Decreasing (BFD)',
	  description: 'Best-fit decreasing strategy'
	}];
	class ItemComponent extends Rn.Component {
	  state = {
	    hasError: false,
	    text: '',
	    type: itemType,
	    elements: [],
	    packResult: null,
	    selectedBox: null,
	    showAnimation: true,
	    animationSpeed: 1,
	    strategy: 0 // Default: Minimize Boxes
	  };
	  constructor() {
	    super(...arguments);
	    this.renderTimeout = null;
	    this.lastRenderElements = null;
	  }
	  async componentDidMount() {
	    let {
	      elements
	    } = this.state;
	    for (const box of await api('/bp3boxes', {})) {
	      elements = elements.concat(new Datum(box.id, boxType, box.width, box.height, box.depth, box.weight));
	    }
	    this.setState({
	      elements
	    });

	    // Setup box selection callback
	    this.props.playground.onBoxSelect = boxId => {
	      this.setState({
	        selectedBox: boxId
	      });
	    };
	    await this.playgroundRender(elements);
	    this.lastRenderElements = this.getElementsSnapshot(elements);
	  }
	  componentDidUpdate(prevProps, prevState) {
	    // Auto-recalculate when elements, strategy, or animation settings change
	    const elementsChanged = prevState.elements !== this.state.elements;
	    const strategyChanged = prevState.strategy !== this.state.strategy;
	    prevState.showAnimation !== this.state.showAnimation;

	    // Check if enabled state of elements changed
	    const elementsSnapshot = this.getElementsSnapshot(this.state.elements);
	    const enabledStateChanged = this.lastRenderElements !== elementsSnapshot;

	    // Only re-render if there are actual changes and we have elements
	    if ((elementsChanged || strategyChanged || enabledStateChanged) && this.state.elements.length > 0 && this.state.elements.filter(e => e.enabled).length > 0) {
	      // Debounce rapid updates
	      if (this.renderTimeout) {
	        clearTimeout(this.renderTimeout);
	      }
	      this.renderTimeout = setTimeout(() => {
	        this.playgroundRender(this.state.elements);
	        this.lastRenderElements = this.getElementsSnapshot(this.state.elements);
	      }, 300); // 300ms debounce
	    }
	  }
	  componentWillUnmount() {
	    // Cleanup timeout on unmount
	    if (this.renderTimeout) {
	      clearTimeout(this.renderTimeout);
	    }
	  }
	  getElementsSnapshot(elements) {
	    // Create a snapshot string for enabled elements to detect changes
	    return elements.filter(e => e.enabled).map(e => `${e.id}:${e.enabled}:${e.type}`).sort().join('|');
	  }
	  setText = e => {
	    this.setState({
	      text: e.target.value
	    });
	  };
	  setType = v => {
	    this.setState({
	      type: v
	    });
	  };
	  switchEnabled = id => {
	    const {
	      elements
	    } = this.state;
	    const element = elements.find(e => e.id === id);
	    if (element) {
	      element.enabled = !element.enabled;
	      // Create new array to trigger React update
	      this.setState({
	        elements: [...elements]
	      });
	      // ComponentDidUpdate will handle the re-render
	    }
	  };
	  addElement = () => {
	    let {
	      elements,
	      type,
	      text
	    } = this.state;
	    const matchResult = text.match(datumValidate);
	    if (matchResult === null) {
	      this.setState({
	        hasError: true
	      });
	      return;
	    }
	    const id = generateUUID();
	    const datum = new Datum(id, type, matchResult[1], matchResult[2], matchResult[3], matchResult[4]);
	    this.setState({
	      elements: elements.concat(datum),
	      text: '',
	      hasError: false
	    });
	    // ComponentDidUpdate will handle the re-render
	  };
	  playgroundRender = async elements => {
	    const items = elements.filter(e => e.enabled);

	    // Clear visualization first
	    this.props.playground.destroy();
	    const requestData = {
	      boxes: items.filter(i => i.type === boxType),
	      items: items.filter(i => i.type === itemType)
	    };

	    // Add strategy if not default
	    if (this.state.strategy !== 0) {
	      requestData.strategy = {
	        value: this.state.strategy
	      };
	    }
	    const packResult = await api('/bp3', requestData);
	    this.setState({
	      packResult,
	      selectedBox: null
	    });

	    // Update animation settings
	    this.props.playground.showAnimation = this.state.showAnimation;
	    this.props.playground.animationSpeed = this.state.animationSpeed;
	    this.props.playground.render(packResult);
	  };
	  setStrategy = e => {
	    const strategy = parseInt(e.target.value);
	    this.setState({
	      strategy
	    });
	    // ComponentDidUpdate will handle the re-render
	  };
	  selectBox = boxId => {
	    this.props.playground.selectBox(boxId);
	    this.setState({
	      selectedBox: boxId
	    });
	  };
	  toggleAnimation = () => {
	    const newValue = !this.state.showAnimation;
	    this.setState({
	      showAnimation: newValue
	    });
	    this.props.playground.showAnimation = newValue;
	    // ComponentDidUpdate will handle the re-render
	  };
	  setAnimationSpeed = e => {
	    const speed = parseFloat(e.target.value);
	    this.setState({
	      animationSpeed: speed
	    });
	    this.props.playground.animationSpeed = speed;
	    // ComponentDidUpdate will handle the re-render if needed
	  };
	  calculateBoxStats = box => {
	    const totalVolume = box.width * box.height * box.depth;
	    const usedVolume = box.items.reduce((sum, item) => {
	      return sum + item.width * item.height * item.depth;
	    }, 0);
	    const usedWeight = box.items.reduce((sum, item) => sum + item.weight, 0);
	    const utilization = totalVolume > 0 ? usedVolume / totalVolume * 100 : 0;
	    const weightUtilization = box.weight > 0 ? usedWeight / box.weight * 100 : 0;
	    return {
	      totalVolume: Math.round(totalVolume),
	      usedVolume: Math.round(usedVolume),
	      freeVolume: Math.round(totalVolume - usedVolume),
	      utilization: Math.round(utilization * 10) / 10,
	      usedWeight: Math.round(usedWeight),
	      weightUtilization: Math.round(weightUtilization * 10) / 10,
	      itemsCount: box.items.length
	    };
	  };
	  onImport = () => {
	    // Create file input element
	    const input = document.createElement('input');
	    input.type = 'file';
	    input.accept = '.csv';
	    input.style.display = 'none';
	    input.onchange = async e => {
	      const file = e.target.files[0];
	      if (!file) {
	        return;
	      }
	      try {
	        const text = await file.text();
	        const lines = text.split('\n').filter(line => line.trim());
	        if (lines.length === 0) {
	          alert('File is empty');
	          return;
	        }

	        // Skip header if present (check for common header patterns)
	        let startIndex = 0;
	        const firstLine = lines[0].trim().toLowerCase();
	        if (firstLine.includes('width') || firstLine.includes('height') || firstLine.includes('type') || firstLine.includes('id') || firstLine.includes('depth') || firstLine.includes('weight')) {
	          startIndex = 1;
	        }
	        const importedElements = [];
	        const errors = [];
	        for (let i = startIndex; i < lines.length; i++) {
	          const line = lines[i].trim();
	          if (!line || line.startsWith('#')) continue; // Skip empty lines and comments

	          const parts = line.split(/[;,\t]/).map(p => p.trim()).filter(p => p);

	          // Support both formats:
	          // Old: id;width;type;height;depth;weight (6 fields)
	          // New: width;height;depth;weight;type (5 fields) or type;width;height;depth;weight
	          if (parts.length < 4) {
	            errors.push(`Line ${i + 1}: insufficient data (expected at least 4 fields: width, height, depth, weight)`);
	            continue;
	          }
	          let widthNum, heightNum, depthNum, weightNum, typeNum;
	          if (parts.length === 5) {
	            // New simplified format: width;height;depth;weight;type
	            [widthNum, heightNum, depthNum, weightNum, typeNum] = parts.map(p => parseInt(p));
	          } else if (parts.length === 6) {
	            // Old format: id;width;type;height;depth;weight
	            const [id, width, type, height, depth, weight] = parts;
	            widthNum = parseInt(width);
	            heightNum = parseInt(height);
	            depthNum = parseInt(depth);
	            weightNum = parseInt(weight);
	            typeNum = parseInt(type);
	          } else {
	            // Try to auto-detect: assume first number is type if it's 0 or 1
	            const firstNum = parseInt(parts[0]);
	            if (firstNum === 0 || firstNum === 1) {
	              // Format: type;width;height;depth;weight
	              [typeNum, widthNum, heightNum, depthNum, weightNum] = parts.map(p => parseInt(p));
	            } else {
	              // Format: width;height;depth;weight (type defaults to itemType)
	              [widthNum, heightNum, depthNum, weightNum] = parts.map(p => parseInt(p));
	              typeNum = itemType; // Default to item if type not specified
	            }
	          }

	          // Validate data
	          if (isNaN(widthNum) || isNaN(heightNum) || isNaN(depthNum) || isNaN(weightNum)) {
	            errors.push(`Line ${i + 1}: invalid data format (expected numbers)`);
	            continue;
	          }
	          if (widthNum <= 0 || heightNum <= 0 || depthNum <= 0 || weightNum <= 0) {
	            errors.push(`Line ${i + 1}: dimensions and weight must be positive`);
	            continue;
	          }
	          if (typeNum === undefined || isNaN(typeNum)) {
	            typeNum = itemType; // Default to item
	          } else if (typeNum !== boxType && typeNum !== itemType) {
	            errors.push(`Line ${i + 1}: invalid type (must be 0 for boxes or 1 for items)`);
	            continue;
	          }

	          // Generate ID automatically
	          const elementId = generateUUID();
	          importedElements.push(new Datum(elementId, typeNum, widthNum, heightNum, depthNum, weightNum));
	        }
	        if (importedElements.length === 0) {
	          alert('Failed to import elements. Please check the file format.\n\nErrors:\n' + errors.join('\n'));
	          return;
	        }

	        // Clear any pending renders
	        if (this.renderTimeout) {
	          clearTimeout(this.renderTimeout);
	          this.renderTimeout = null;
	        }

	        // Replace all existing elements with imported ones (full cleanup)
	        // This includes boxes loaded from /bp3boxes endpoint
	        this.setState({
	          elements: importedElements,
	          packResult: null,
	          // Clear previous packing results
	          selectedBox: null // Clear selection
	        }, () => {
	          // Immediate render after import (no debounce)
	          this.playgroundRender(importedElements);
	          this.lastRenderElements = this.getElementsSnapshot(importedElements);
	        });

	        // Show import result
	        let message = `Imported elements: ${importedElements.length}`;
	        const boxesCount = importedElements.filter(e => e.type === boxType).length;
	        const itemsCount = importedElements.filter(e => e.type === itemType).length;
	        message += `\nBoxes: ${boxesCount}, Items: ${itemsCount}`;
	        if (errors.length > 0) {
	          message += `\nErrors: ${errors.length}`;
	        }
	        if (errors.length > 0 && errors.length <= 5) {
	          message += '\n\nErrors:\n' + errors.join('\n');
	        }
	        alert(message);
	      } catch (error) {
	        alert('Error reading file: ' + error.message);
	      } finally {
	        // Clean up
	        if (input.parentNode) {
	          document.body.removeChild(input);
	        }
	      }
	    };
	    document.body.appendChild(input);
	    input.click();
	  };
	  onExport = () => {
	    const {
	      elements
	    } = this.state;
	    if (elements.length === 0) {
	      alert('No elements to export');
	      return;
	    }

	    // Show confirmation dialog for export options
	    const exportAll = confirm('Export all elements? (Cancel - only enabled)');
	    const elementsToExport = exportAll ? elements : elements.filter(e => e.enabled);
	    if (elementsToExport.length === 0) {
	      alert('No elements to export');
	      return;
	    }
	    const csvContent = "data:text/csv;charset=utf-8," + "id;width;type;height;depth;weight\n" + elementsToExport.map(e => e.toExport()).join("\n");
	    const link = document.createElement("a");
	    link.setAttribute("href", encodeURI(csvContent));
	    link.setAttribute("download", `boxpacker3-export-${new Date().toISOString().split('T')[0]}.csv`);
	    link.click();
	  };
	  render({}, {
	    elements,
	    type,
	    text,
	    hasError,
	    packResult,
	    selectedBox,
	    showAnimation,
	    animationSpeed,
	    strategy
	  }) {
	    const selectedBoxData = packResult && selectedBox ? packResult.boxes.find(b => b.id === selectedBox) : null;
	    const selectedBoxStats = selectedBoxData ? this.calculateBoxStats(selectedBoxData) : null;
	    return /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        display: 'flex',
	        flexDirection: 'column',
	        height: '100%',
	        minHeight: '100vh',
	        overflowY: 'auto',
	        margin: 0,
	        padding: 0
	      }
	    }, /*#__PURE__*/Rn.createElement("nav", {
	      className: "panel",
	      style: {
	        flex: '0 0 auto'
	      }
	    }, /*#__PURE__*/Rn.createElement("p", {
	      className: "panel-heading field"
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "level"
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "level-left"
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "level-item"
	    }, /*#__PURE__*/Rn.createElement("p", {
	      className: "subtitle is-5",
	      style: {
	        margin: 0,
	        fontSize: '0.875rem',
	        color: '#ffffff',
	        fontWeight: 700
	      }
	    }, /*#__PURE__*/Rn.createElement("strong", {
	      style: {
	        color: '#ffffff'
	      }
	    }, "Settings")))), /*#__PURE__*/Rn.createElement("div", {
	      className: "level-right"
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "level-item"
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "field has-addons"
	    }, /*#__PURE__*/Rn.createElement("p", {
	      className: "control"
	    }, /*#__PURE__*/Rn.createElement("a", {
	      href: "#",
	      onClick: this.onImport,
	      className: "button is-info is-small",
	      title: "Import CSV file"
	    }, "Import")), /*#__PURE__*/Rn.createElement("p", {
	      className: "control"
	    }, /*#__PURE__*/Rn.createElement("a", {
	      href: "#",
	      onClick: this.onExport,
	      className: "button is-success is-small",
	      title: "Export to CSV"
	    }, "Export"))))))), /*#__PURE__*/Rn.createElement("form", {
	      onSubmit: this.addElement,
	      action: "javascript:"
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "panel-block"
	    }, /*#__PURE__*/Rn.createElement("p", {
	      className: "control has-icons-right"
	    }, /*#__PURE__*/Rn.createElement("input", {
	      value: text,
	      onInput: this.setText,
	      className: "input is-primary",
	      type: "text",
	      placeholder: "w;h;d;wg"
	    }), hasError && /*#__PURE__*/Rn.createElement("p", {
	      className: "help is-danger"
	    }, "Incorrect syntax"))), /*#__PURE__*/Rn.createElement("p", {
	      className: "panel-tabs"
	    }, /*#__PURE__*/Rn.createElement("a", {
	      href: "#",
	      className: type === boxType ? "is-active" : "",
	      onClick: () => this.setType(boxType)
	    }, "Boxes"), /*#__PURE__*/Rn.createElement("a", {
	      href: "#",
	      className: type === itemType ? "is-active" : "",
	      onClick: () => this.setType(itemType)
	    }, "Items"))), elements.filter(datum => datum.type === type).length === 0 ? /*#__PURE__*/Rn.createElement("div", {
	      className: "panel-block",
	      style: {
	        textAlign: 'center',
	        padding: '1.5rem',
	        color: '#bbb',
	        fontSize: '0.75rem'
	      }
	    }, /*#__PURE__*/Rn.createElement("p", null, "No ", type === boxType ? 'boxes' : 'items')) : elements.filter(datum => datum.type === type).map(datum => /*#__PURE__*/Rn.createElement("label", {
	      key: datum.id,
	      className: "panel-block",
	      style: {
	        cursor: 'pointer',
	        userSelect: 'none',
	        display: 'flex',
	        alignItems: 'center'
	      }
	    }, /*#__PURE__*/Rn.createElement("input", {
	      type: "checkbox",
	      checked: datum.enabled,
	      onChange: () => this.switchEnabled(datum.id),
	      style: {
	        marginRight: '0.75rem'
	      }
	    }), /*#__PURE__*/Rn.createElement("span", {
	      style: {
	        flex: 1,
	        fontFamily: 'monospace',
	        fontSize: '0.8125rem'
	      }
	    }, datum.toString()), !datum.enabled && /*#__PURE__*/Rn.createElement("span", {
	      className: "tag is-light",
	      style: {
	        fontSize: '0.7rem',
	        marginLeft: '0.5rem'
	      }
	    }, "OFF")))), /*#__PURE__*/Rn.createElement("nav", {
	      className: "panel",
	      style: {
	        flex: '0 0 auto'
	      }
	    }, /*#__PURE__*/Rn.createElement("p", {
	      className: "panel-heading"
	    }, /*#__PURE__*/Rn.createElement("strong", null, "Strategy")), /*#__PURE__*/Rn.createElement("div", {
	      className: "panel-block"
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "field",
	      style: {
	        width: '100%'
	      }
	    }, /*#__PURE__*/Rn.createElement("label", {
	      className: "label is-small"
	    }, "Strategy"), /*#__PURE__*/Rn.createElement("div", {
	      className: "select is-fullwidth"
	    }, /*#__PURE__*/Rn.createElement("select", {
	      value: strategy,
	      onChange: this.setStrategy
	    }, STRATEGIES.map(s => /*#__PURE__*/Rn.createElement("option", {
	      key: s.value,
	      value: s.value
	    }, s.name)))), /*#__PURE__*/Rn.createElement("p", {
	      className: "help"
	    }, STRATEGIES.find(s => s.value === strategy)?.description || '')))), packResult && /*#__PURE__*/Rn.createElement("nav", {
	      className: "panel",
	      style: {
	        flex: '0 0 auto'
	      }
	    }, /*#__PURE__*/Rn.createElement("p", {
	      className: "panel-heading"
	    }, /*#__PURE__*/Rn.createElement("strong", null, "Visualization")), /*#__PURE__*/Rn.createElement("div", {
	      className: "panel-block"
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "field",
	      style: {
	        width: '100%'
	      }
	    }, /*#__PURE__*/Rn.createElement("label", {
	      className: "checkbox"
	    }, /*#__PURE__*/Rn.createElement("input", {
	      type: "checkbox",
	      checked: showAnimation,
	      onChange: this.toggleAnimation,
	      style: {
	        marginRight: '0.5rem'
	      }
	    }), "Show animation"))), showAnimation && /*#__PURE__*/Rn.createElement("div", {
	      className: "panel-block"
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "field",
	      style: {
	        width: '100%'
	      }
	    }, /*#__PURE__*/Rn.createElement("label", {
	      className: "label is-small"
	    }, "Animation Speed"), /*#__PURE__*/Rn.createElement("input", {
	      className: "slider is-fullwidth is-small",
	      step: "0.1",
	      min: "0.1",
	      max: "3",
	      type: "range",
	      value: animationSpeed,
	      onChange: this.setAnimationSpeed
	    }), /*#__PURE__*/Rn.createElement("p", {
	      className: "help"
	    }, animationSpeed.toFixed(1), "x"))), /*#__PURE__*/Rn.createElement("div", {
	      className: "panel-block",
	      style: {
	        background: '#2a2a2a',
	        border: '1px solid #333',
	        fontSize: '0.75rem',
	        color: '#bbb'
	      }
	    }, /*#__PURE__*/Rn.createElement("p", {
	      className: "help",
	      style: {
	        margin: 0
	      }
	    }, "Click boxes in 3D or list to view details | Ctrl+\u2190/\u2192 to navigate"))), packResult && packResult.boxes && packResult.boxes.length > 0 && /*#__PURE__*/Rn.createElement("nav", {
	      className: "panel",
	      style: {
	        flex: '0 0 auto'
	      }
	    }, /*#__PURE__*/Rn.createElement("p", {
	      className: "panel-heading"
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "level",
	      style: {
	        margin: 0
	      }
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "level-left"
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "level-item"
	    }, /*#__PURE__*/Rn.createElement("strong", null, "Boxes (", packResult.boxes.length, ")"))), /*#__PURE__*/Rn.createElement("div", {
	      className: "level-right"
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "level-item"
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "field has-addons"
	    }, /*#__PURE__*/Rn.createElement("p", {
	      className: "control"
	    }, /*#__PURE__*/Rn.createElement("button", {
	      className: "button is-small is-info",
	      onClick: () => this.props.playground.selectPreviousBox(),
	      title: "Previous (Ctrl+\u2190)",
	      style: {
	        minWidth: '2rem',
	        padding: '0.25rem 0.5rem'
	      }
	    }, "\u25C0")), /*#__PURE__*/Rn.createElement("p", {
	      className: "control"
	    }, /*#__PURE__*/Rn.createElement("button", {
	      className: "button is-small is-info",
	      onClick: () => this.props.playground.selectNextBox(),
	      title: "Next (Ctrl+\u2192)",
	      style: {
	        minWidth: '2rem',
	        padding: '0.25rem 0.5rem'
	      }
	    }, "\u25B6"))))))), packResult.boxes.map((box, index) => {
	      const stats = this.calculateBoxStats(box);
	      const isSelected = selectedBox === box.id;
	      return /*#__PURE__*/Rn.createElement("a", {
	        key: box.id,
	        href: "#",
	        className: `panel-block ${isSelected ? 'is-active' : ''}`,
	        onClick: e => {
	          e.preventDefault();
	          this.selectBox(box.id);
	        }
	      }, /*#__PURE__*/Rn.createElement("div", {
	        style: {
	          width: '100%'
	        }
	      }, /*#__PURE__*/Rn.createElement("div", {
	        className: "level is-mobile",
	        style: {
	          marginBottom: '0.5rem'
	        }
	      }, /*#__PURE__*/Rn.createElement("div", {
	        className: "level-left"
	      }, /*#__PURE__*/Rn.createElement("div", {
	        className: "level-item",
	        style: {
	          fontFamily: 'monospace',
	          fontSize: '0.8125rem'
	        }
	      }, /*#__PURE__*/Rn.createElement("strong", null, "#", index + 1), " ", Math.round(box.width), "\xD7", Math.round(box.height), "\xD7", Math.round(box.depth), isSelected && /*#__PURE__*/Rn.createElement("span", {
	        className: "tag is-success",
	        style: {
	          marginLeft: '0.5rem',
	          fontSize: '0.7rem'
	        }
	      }, "ACTIVE"))), /*#__PURE__*/Rn.createElement("div", {
	        className: "level-right"
	      }, /*#__PURE__*/Rn.createElement("div", {
	        className: "level-item"
	      }, /*#__PURE__*/Rn.createElement("span", {
	        className: "tag is-info",
	        style: {
	          fontSize: '0.7rem'
	        }
	      }, stats.itemsCount)))), /*#__PURE__*/Rn.createElement("div", {
	        style: {
	          fontSize: '0.75rem',
	          fontFamily: 'monospace'
	        }
	      }, /*#__PURE__*/Rn.createElement("div", {
	        style: {
	          marginBottom: '0.5rem'
	        }
	      }, /*#__PURE__*/Rn.createElement("div", {
	        className: "level is-mobile",
	        style: {
	          marginBottom: '0.25rem'
	        }
	      }, /*#__PURE__*/Rn.createElement("div", {
	        className: "level-left"
	      }, /*#__PURE__*/Rn.createElement("span", {
	        style: {
	          color: '#bbb'
	        }
	      }, "VOL")), /*#__PURE__*/Rn.createElement("div", {
	        className: "level-right"
	      }, /*#__PURE__*/Rn.createElement("span", {
	        style: {
	          color: stats.utilization > 80 ? '#f14668' : stats.utilization > 60 ? '#ffa726' : '#48c774',
	          fontWeight: 600
	        }
	      }, stats.utilization.toFixed(1), "%"))), /*#__PURE__*/Rn.createElement("progress", {
	        className: "progress",
	        value: stats.utilization,
	        max: "100",
	        style: {
	          marginBottom: '0.25rem',
	          height: '3px'
	        }
	      }), /*#__PURE__*/Rn.createElement("div", {
	        style: {
	          color: '#bbb',
	          fontSize: '0.7rem'
	        }
	      }, stats.usedVolume.toLocaleString(), "/", stats.totalVolume.toLocaleString(), " mm\xB3")), /*#__PURE__*/Rn.createElement("div", null, /*#__PURE__*/Rn.createElement("div", {
	        className: "level is-mobile",
	        style: {
	          marginBottom: '0.25rem'
	        }
	      }, /*#__PURE__*/Rn.createElement("div", {
	        className: "level-left"
	      }, /*#__PURE__*/Rn.createElement("span", {
	        style: {
	          color: '#bbb'
	        }
	      }, "WGT")), /*#__PURE__*/Rn.createElement("div", {
	        className: "level-right"
	      }, /*#__PURE__*/Rn.createElement("span", {
	        style: {
	          color: stats.weightUtilization > 80 ? '#f14668' : stats.weightUtilization > 60 ? '#ffa726' : '#48c774',
	          fontWeight: 600
	        }
	      }, stats.weightUtilization.toFixed(1), "%"))), /*#__PURE__*/Rn.createElement("progress", {
	        className: "progress",
	        value: stats.weightUtilization,
	        max: "100",
	        style: {
	          height: '3px',
	          marginBottom: '0.25rem'
	        }
	      }), /*#__PURE__*/Rn.createElement("div", {
	        style: {
	          color: '#bbb',
	          fontSize: '0.7rem'
	        }
	      }, stats.usedWeight.toLocaleString(), "/", Math.round(box.weight).toLocaleString(), " g")))));
	    })), selectedBoxData && selectedBoxStats && /*#__PURE__*/Rn.createElement("nav", {
	      className: "panel",
	      style: {
	        flex: '0 0 auto'
	      }
	    }, /*#__PURE__*/Rn.createElement("p", {
	      className: "panel-heading"
	    }, /*#__PURE__*/Rn.createElement("strong", null, "Details")), /*#__PURE__*/Rn.createElement("div", {
	      className: "panel-block",
	      style: {
	        flexDirection: 'column',
	        alignItems: 'stretch',
	        padding: '1rem'
	      }
	    }, /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        fontFamily: 'monospace',
	        fontSize: '0.8125rem',
	        marginBottom: '1rem'
	      }
	    }, /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        marginBottom: '0.5rem'
	      }
	    }, /*#__PURE__*/Rn.createElement("span", {
	      style: {
	        color: '#bbb',
	        fontSize: '0.7rem',
	        textTransform: 'uppercase'
	      }
	    }, "Size"), /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        color: '#f0f0f0',
	        marginTop: '0.25rem'
	      }
	    }, Math.round(selectedBoxData.width), " \xD7 ", Math.round(selectedBoxData.height), " \xD7 ", Math.round(selectedBoxData.depth), " mm")), /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        marginBottom: '0.5rem'
	      }
	    }, /*#__PURE__*/Rn.createElement("span", {
	      style: {
	        color: '#bbb',
	        fontSize: '0.7rem',
	        textTransform: 'uppercase'
	      }
	    }, "Max Weight"), /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        color: '#f0f0f0',
	        marginTop: '0.25rem'
	      }
	    }, Math.round(selectedBoxData.weight).toLocaleString(), " g")), /*#__PURE__*/Rn.createElement("div", null, /*#__PURE__*/Rn.createElement("span", {
	      style: {
	        color: '#bbb',
	        fontSize: '0.7rem',
	        textTransform: 'uppercase'
	      }
	    }, "Items"), /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        color: '#f0f0f0',
	        marginTop: '0.25rem'
	      }
	    }, selectedBoxStats.itemsCount))), /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        borderTop: '1px solid #333',
	        paddingTop: '1rem',
	        marginTop: '1rem'
	      }
	    }, /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        marginBottom: '1rem'
	      }
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "level is-mobile",
	      style: {
	        marginBottom: '0.5rem'
	      }
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "level-left"
	    }, /*#__PURE__*/Rn.createElement("span", {
	      style: {
	        color: '#bbb',
	        fontSize: '0.7rem',
	        textTransform: 'uppercase'
	      }
	    }, "Volume")), /*#__PURE__*/Rn.createElement("div", {
	      className: "level-right"
	    }, /*#__PURE__*/Rn.createElement("span", {
	      style: {
	        color: selectedBoxStats.utilization > 80 ? '#f14668' : selectedBoxStats.utilization > 60 ? '#ffa726' : '#48c774',
	        fontFamily: 'monospace',
	        fontWeight: 600
	      }
	    }, selectedBoxStats.utilization.toFixed(1), "%"))), /*#__PURE__*/Rn.createElement("progress", {
	      className: "progress",
	      value: selectedBoxStats.utilization,
	      max: "100",
	      style: {
	        height: '3px',
	        marginBottom: '0.5rem'
	      }
	    }), /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        fontFamily: 'monospace',
	        fontSize: '0.7rem',
	        color: '#bbb'
	      }
	    }, selectedBoxStats.usedVolume.toLocaleString(), " / ", selectedBoxStats.totalVolume.toLocaleString(), " mm\xB3", /*#__PURE__*/Rn.createElement("br", null), "Free: ", selectedBoxStats.freeVolume.toLocaleString(), " mm\xB3")), /*#__PURE__*/Rn.createElement("div", null, /*#__PURE__*/Rn.createElement("div", {
	      className: "level is-mobile",
	      style: {
	        marginBottom: '0.5rem'
	      }
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "level-left"
	    }, /*#__PURE__*/Rn.createElement("span", {
	      style: {
	        color: '#bbb',
	        fontSize: '0.7rem',
	        textTransform: 'uppercase'
	      }
	    }, "Weight")), /*#__PURE__*/Rn.createElement("div", {
	      className: "level-right"
	    }, /*#__PURE__*/Rn.createElement("span", {
	      style: {
	        color: selectedBoxStats.weightUtilization > 80 ? '#f14668' : selectedBoxStats.weightUtilization > 60 ? '#ffa726' : '#48c774',
	        fontFamily: 'monospace',
	        fontWeight: 600
	      }
	    }, selectedBoxStats.weightUtilization.toFixed(1), "%"))), /*#__PURE__*/Rn.createElement("progress", {
	      className: "progress",
	      value: selectedBoxStats.weightUtilization,
	      max: "100",
	      style: {
	        height: '3px',
	        marginBottom: '0.5rem'
	      }
	    }), /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        fontFamily: 'monospace',
	        fontSize: '0.7rem',
	        color: '#bbb'
	      }
	    }, selectedBoxStats.usedWeight.toLocaleString(), " / ", Math.round(selectedBoxData.weight).toLocaleString(), " g"))), /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        borderTop: '1px solid #333',
	        paddingTop: '1rem',
	        marginTop: '1rem'
	      }
	    }, /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        color: '#bbb',
	        fontSize: '0.7rem',
	        textTransform: 'uppercase',
	        marginBottom: '0.75rem'
	      }
	    }, "Items (", selectedBoxData.items.length, ")"), /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        maxHeight: '200px',
	        overflowY: 'auto'
	      }
	    }, selectedBoxData.items.map((item, idx) => /*#__PURE__*/Rn.createElement("div", {
	      key: item.id,
	      className: "box",
	      style: {
	        marginBottom: '0.5rem'
	      }
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "level is-mobile",
	      style: {
	        marginBottom: '0.25rem'
	      }
	    }, /*#__PURE__*/Rn.createElement("div", {
	      className: "level-left"
	    }, /*#__PURE__*/Rn.createElement("span", {
	      style: {
	        color: '#4a9eff',
	        fontFamily: 'monospace'
	      }
	    }, "#", idx + 1), /*#__PURE__*/Rn.createElement("span", {
	      style: {
	        marginLeft: '0.5rem',
	        fontFamily: 'monospace'
	      }
	    }, Math.round(item.width), "\xD7", Math.round(item.height), "\xD7", Math.round(item.depth))), /*#__PURE__*/Rn.createElement("div", {
	      className: "level-right"
	    }, /*#__PURE__*/Rn.createElement("span", {
	      style: {
	        color: '#bbb',
	        fontFamily: 'monospace',
	        fontSize: '0.7rem'
	      }
	    }, Math.round(item.weight), "g"))), /*#__PURE__*/Rn.createElement("div", {
	      style: {
	        fontFamily: 'monospace',
	        fontSize: '0.7rem',
	        color: '#999'
	      }
	    }, "(", Math.round(item.position.x), ", ", Math.round(item.position.y), ", ", Math.round(item.position.z), ")"))))))), packResult && packResult.items && packResult.items.length > 0 && /*#__PURE__*/Rn.createElement("nav", {
	      className: "panel",
	      style: {
	        flex: '0 0 auto',
	        border: '1px solid #f14668'
	      }
	    }, /*#__PURE__*/Rn.createElement("p", {
	      className: "panel-heading",
	      style: {
	        background: '#2a1a1a',
	        borderBottomColor: '#f14668'
	      }
	    }, /*#__PURE__*/Rn.createElement("strong", null, "Unfit (", packResult.items.length, ")")), packResult.items.map(item => /*#__PURE__*/Rn.createElement("div", {
	      key: item.id,
	      className: "panel-block",
	      style: {
	        borderLeft: '2px solid #f14668',
	        fontFamily: 'monospace',
	        fontSize: '0.8125rem'
	      }
	    }, /*#__PURE__*/Rn.createElement("span", {
	      style: {
	        flex: 1,
	        color: '#f0f0f0'
	      }
	    }, Math.round(item.width), "\xD7", Math.round(item.height), "\xD7", Math.round(item.depth)), /*#__PURE__*/Rn.createElement("span", {
	      style: {
	        color: '#bbb',
	        marginLeft: '0.5rem',
	        fontSize: '0.75rem'
	      }
	    }, Math.round(item.weight), "g")))));
	  }
	}

	const playground = new Playground(document.getElementById('bp3'));
	Rn.render(/*#__PURE__*/Rn.createElement(ItemComponent, {
	  playground: playground
	}), document.getElementById('bp3-input'));

})();
//# sourceMappingURL=index.js.map
