(function () {
	'use strict';

	/**
	 * @license
	 * Copyright 2010-2024 Three.js Authors
	 * SPDX-License-Identifier: MIT
	 */const REVISION='171';const MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2};const TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3};const CullFaceNone=0;const CullFaceBack=1;const CullFaceFront=2;const PCFShadowMap=1;const PCFSoftShadowMap=2;const VSMShadowMap=3;const FrontSide=0;const BackSide=1;const DoubleSide=2;const NoBlending=0;const NormalBlending=1;const AdditiveBlending=2;const SubtractiveBlending=3;const MultiplyBlending=4;const CustomBlending=5;const AddEquation=100;const SubtractEquation=101;const ReverseSubtractEquation=102;const MinEquation=103;const MaxEquation=104;const ZeroFactor=200;const OneFactor=201;const SrcColorFactor=202;const OneMinusSrcColorFactor=203;const SrcAlphaFactor=204;const OneMinusSrcAlphaFactor=205;const DstAlphaFactor=206;const OneMinusDstAlphaFactor=207;const DstColorFactor=208;const OneMinusDstColorFactor=209;const SrcAlphaSaturateFactor=210;const ConstantColorFactor=211;const OneMinusConstantColorFactor=212;const ConstantAlphaFactor=213;const OneMinusConstantAlphaFactor=214;const NeverDepth=0;const AlwaysDepth=1;const LessDepth=2;const LessEqualDepth=3;const EqualDepth=4;const GreaterEqualDepth=5;const GreaterDepth=6;const NotEqualDepth=7;const MultiplyOperation=0;const MixOperation=1;const AddOperation=2;const NoToneMapping=0;const LinearToneMapping=1;const ReinhardToneMapping=2;const CineonToneMapping=3;const ACESFilmicToneMapping=4;const CustomToneMapping=5;const AgXToneMapping=6;const NeutralToneMapping=7;const UVMapping=300;const CubeReflectionMapping=301;const CubeRefractionMapping=302;const EquirectangularReflectionMapping=303;const EquirectangularRefractionMapping=304;const CubeUVReflectionMapping=306;const RepeatWrapping=1000;const ClampToEdgeWrapping=1001;const MirroredRepeatWrapping=1002;const NearestFilter=1003;const NearestMipmapNearestFilter=1004;const NearestMipmapLinearFilter=1005;const LinearFilter=1006;const LinearMipmapNearestFilter=1007;const LinearMipmapLinearFilter=1008;const UnsignedByteType=1009;const ByteType=1010;const ShortType=1011;const UnsignedShortType=1012;const IntType=1013;const UnsignedIntType=1014;const FloatType$1=1015;const HalfFloatType=1016;const UnsignedShort4444Type=1017;const UnsignedShort5551Type=1018;const UnsignedInt248Type=1020;const UnsignedInt5999Type=35902;const AlphaFormat=1021;const RGBFormat=1022;const RGBAFormat=1023;const LuminanceFormat=1024;const LuminanceAlphaFormat=1025;const DepthFormat=1026;const DepthStencilFormat=1027;const RedFormat=1028;const RedIntegerFormat=1029;const RGFormat=1030;const RGIntegerFormat=1031;const RGBAIntegerFormat=1033;const RGB_S3TC_DXT1_Format=33776;const RGBA_S3TC_DXT1_Format=33777;const RGBA_S3TC_DXT3_Format=33778;const RGBA_S3TC_DXT5_Format=33779;const RGB_PVRTC_4BPPV1_Format=35840;const RGB_PVRTC_2BPPV1_Format=35841;const RGBA_PVRTC_4BPPV1_Format=35842;const RGBA_PVRTC_2BPPV1_Format=35843;const RGB_ETC1_Format=36196;const RGB_ETC2_Format=37492;const RGBA_ETC2_EAC_Format=37496;const RGBA_ASTC_4x4_Format=37808;const RGBA_ASTC_5x4_Format=37809;const RGBA_ASTC_5x5_Format=37810;const RGBA_ASTC_6x5_Format=37811;const RGBA_ASTC_6x6_Format=37812;const RGBA_ASTC_8x5_Format=37813;const RGBA_ASTC_8x6_Format=37814;const RGBA_ASTC_8x8_Format=37815;const RGBA_ASTC_10x5_Format=37816;const RGBA_ASTC_10x6_Format=37817;const RGBA_ASTC_10x8_Format=37818;const RGBA_ASTC_10x10_Format=37819;const RGBA_ASTC_12x10_Format=37820;const RGBA_ASTC_12x12_Format=37821;const RGBA_BPTC_Format=36492;const RGB_BPTC_SIGNED_Format=36494;const RGB_BPTC_UNSIGNED_Format=36495;const RED_RGTC1_Format=36283;const SIGNED_RED_RGTC1_Format=36284;const RED_GREEN_RGTC2_Format=36285;const SIGNED_RED_GREEN_RGTC2_Format=36286;const BasicDepthPacking=3200;const RGBADepthPacking=3201;const TangentSpaceNormalMap=0;const ObjectSpaceNormalMap=1;// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
	const NoColorSpace='';const SRGBColorSpace='srgb';const LinearSRGBColorSpace='srgb-linear';const LinearTransfer='linear';const SRGBTransfer='srgb';const KeepStencilOp=7680;const AlwaysStencilFunc=519;const NeverCompare=512;const LessCompare=513;const EqualCompare=514;const LessEqualCompare=515;const GreaterCompare=516;const NotEqualCompare=517;const GreaterEqualCompare=518;const AlwaysCompare=519;const StaticDrawUsage$1=35044;const GLSL3='300 es';const WebGLCoordinateSystem$1=2000;const WebGPUCoordinateSystem$1=2001;/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */let EventDispatcher$1 = class EventDispatcher{addEventListener(type,listener){if(this._listeners===undefined)this._listeners={};const listeners=this._listeners;if(listeners[type]===undefined){listeners[type]=[];}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener);}}hasEventListener(type,listener){if(this._listeners===undefined)return false;const listeners=this._listeners;return listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;}removeEventListener(type,listener){if(this._listeners===undefined)return;const listeners=this._listeners;const listenerArray=listeners[type];if(listenerArray!==undefined){const index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1);}}}dispatchEvent(event){if(this._listeners===undefined)return;const listeners=this._listeners;const listenerArray=listeners[event.type];if(listenerArray!==undefined){event.target=this;// Make a copy, in case listeners are removed while iterating.
	const array=listenerArray.slice(0);for(let i=0,l=array.length;i<l;i++){array[i].call(this,event);}event.target=null;}}};const _lut$1=['00','01','02','03','04','05','06','07','08','09','0a','0b','0c','0d','0e','0f','10','11','12','13','14','15','16','17','18','19','1a','1b','1c','1d','1e','1f','20','21','22','23','24','25','26','27','28','29','2a','2b','2c','2d','2e','2f','30','31','32','33','34','35','36','37','38','39','3a','3b','3c','3d','3e','3f','40','41','42','43','44','45','46','47','48','49','4a','4b','4c','4d','4e','4f','50','51','52','53','54','55','56','57','58','59','5a','5b','5c','5d','5e','5f','60','61','62','63','64','65','66','67','68','69','6a','6b','6c','6d','6e','6f','70','71','72','73','74','75','76','77','78','79','7a','7b','7c','7d','7e','7f','80','81','82','83','84','85','86','87','88','89','8a','8b','8c','8d','8e','8f','90','91','92','93','94','95','96','97','98','99','9a','9b','9c','9d','9e','9f','a0','a1','a2','a3','a4','a5','a6','a7','a8','a9','aa','ab','ac','ad','ae','af','b0','b1','b2','b3','b4','b5','b6','b7','b8','b9','ba','bb','bc','bd','be','bf','c0','c1','c2','c3','c4','c5','c6','c7','c8','c9','ca','cb','cc','cd','ce','cf','d0','d1','d2','d3','d4','d5','d6','d7','d8','d9','da','db','dc','dd','de','df','e0','e1','e2','e3','e4','e5','e6','e7','e8','e9','ea','eb','ec','ed','ee','ef','f0','f1','f2','f3','f4','f5','f6','f7','f8','f9','fa','fb','fc','fd','fe','ff'];let _seed=1234567;const DEG2RAD=Math.PI/180;const RAD2DEG=180/Math.PI;// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
	function generateUUID$1(){const d0=Math.random()*0xffffffff|0;const d1=Math.random()*0xffffffff|0;const d2=Math.random()*0xffffffff|0;const d3=Math.random()*0xffffffff|0;const uuid=_lut$1[d0&0xff]+_lut$1[d0>>8&0xff]+_lut$1[d0>>16&0xff]+_lut$1[d0>>24&0xff]+'-'+_lut$1[d1&0xff]+_lut$1[d1>>8&0xff]+'-'+_lut$1[d1>>16&0x0f|0x40]+_lut$1[d1>>24&0xff]+'-'+_lut$1[d2&0x3f|0x80]+_lut$1[d2>>8&0xff]+'-'+_lut$1[d2>>16&0xff]+_lut$1[d2>>24&0xff]+_lut$1[d3&0xff]+_lut$1[d3>>8&0xff]+_lut$1[d3>>16&0xff]+_lut$1[d3>>24&0xff];// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();}function clamp$1(value,min,max){return Math.max(min,Math.min(max,value));}// compute euclidean modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation
	function euclideanModulo(n,m){return (n%m+m)%m;}// Linear mapping from range <a1, a2> to range <b1, b2>
	function mapLinear(x,a1,a2,b1,b2){return b1+(x-a1)*(b2-b1)/(a2-a1);}// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
	function inverseLerp(x,y,value){if(x!==y){return (value-x)/(y-x);}else {return 0;}}// https://en.wikipedia.org/wiki/Linear_interpolation
	function lerp(x,y,t){return (1-t)*x+t*y;}// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
	function damp(x,y,lambda,dt){return lerp(x,y,1-Math.exp(-lambda*dt));}// https://www.desmos.com/calculator/vcsjnyz7x4
	function pingpong(x,length=1){return length-Math.abs(euclideanModulo(x,length*2)-length);}// http://en.wikipedia.org/wiki/Smoothstep
	function smoothstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*(3-2*x);}function smootherstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*x*(x*(x*6-15)+10);}// Random integer from <low, high> interval
	function randInt(low,high){return low+Math.floor(Math.random()*(high-low+1));}// Random float from <low, high> interval
	function randFloat(low,high){return low+Math.random()*(high-low);}// Random float from <-range/2, range/2> interval
	function randFloatSpread(range){return range*(0.5-Math.random());}// Deterministic pseudo-random float in the interval [ 0, 1 ]
	function seededRandom(s){if(s!==undefined)_seed=s;// Mulberry32 generator
	let t=_seed+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296;}function degToRad(degrees){return degrees*DEG2RAD;}function radToDeg(radians){return radians*RAD2DEG;}function isPowerOfTwo(value){return (value&value-1)===0&&value!==0;}function ceilPowerOfTwo(value){return Math.pow(2,Math.ceil(Math.log(value)/Math.LN2));}function floorPowerOfTwo(value){return Math.pow(2,Math.floor(Math.log(value)/Math.LN2));}function setQuaternionFromProperEuler(q,a,b,c,order){// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians
	const cos=Math.cos;const sin=Math.sin;const c2=cos(b/2);const s2=sin(b/2);const c13=cos((a+c)/2);const s13=sin((a+c)/2);const c1_3=cos((a-c)/2);const s1_3=sin((a-c)/2);const c3_1=cos((c-a)/2);const s3_1=sin((c-a)/2);switch(order){case'XYX':q.set(c2*s13,s2*c1_3,s2*s1_3,c2*c13);break;case'YZY':q.set(s2*s1_3,c2*s13,s2*c1_3,c2*c13);break;case'ZXZ':q.set(s2*c1_3,s2*s1_3,c2*s13,c2*c13);break;case'XZX':q.set(c2*s13,s2*s3_1,s2*c3_1,c2*c13);break;case'YXY':q.set(s2*c3_1,c2*s13,s2*s3_1,c2*c13);break;case'ZYZ':q.set(s2*s3_1,s2*c3_1,c2*s13,c2*c13);break;default:console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: '+order);}}function denormalize$1(value,array){switch(array.constructor){case Float32Array:return value;case Uint32Array:return value/4294967295.0;case Uint16Array:return value/65535.0;case Uint8Array:return value/255.0;case Int32Array:return Math.max(value/2147483647.0,-1.0);case Int16Array:return Math.max(value/32767.0,-1.0);case Int8Array:return Math.max(value/127.0,-1.0);default:throw new Error('Invalid component type.');}}function normalize$1(value,array){switch(array.constructor){case Float32Array:return value;case Uint32Array:return Math.round(value*4294967295.0);case Uint16Array:return Math.round(value*65535.0);case Uint8Array:return Math.round(value*255.0);case Int32Array:return Math.round(value*2147483647.0);case Int16Array:return Math.round(value*32767.0);case Int8Array:return Math.round(value*127.0);default:throw new Error('Invalid component type.');}}const MathUtils={DEG2RAD:DEG2RAD,RAD2DEG:RAD2DEG,generateUUID:generateUUID$1,clamp:clamp$1,euclideanModulo:euclideanModulo,mapLinear:mapLinear,inverseLerp:inverseLerp,lerp:lerp,damp:damp,pingpong:pingpong,smoothstep:smoothstep,smootherstep:smootherstep,randInt:randInt,randFloat:randFloat,randFloatSpread:randFloatSpread,seededRandom:seededRandom,degToRad:degToRad,radToDeg:radToDeg,isPowerOfTwo:isPowerOfTwo,ceilPowerOfTwo:ceilPowerOfTwo,floorPowerOfTwo:floorPowerOfTwo,setQuaternionFromProperEuler:setQuaternionFromProperEuler,normalize:normalize$1,denormalize:denormalize$1};let Vector2$1 = class Vector2{constructor(x=0,y=0){Vector2.prototype.isVector2=true;this.x=x;this.y=y;}get width(){return this.x;}set width(value){this.x=value;}get height(){return this.y;}set height(value){this.y=value;}set(x,y){this.x=x;this.y=y;return this;}setScalar(scalar){this.x=scalar;this.y=scalar;return this;}setX(x){this.x=x;return this;}setY(y){this.y=y;return this;}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error('index is out of range: '+index);}return this;}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error('index is out of range: '+index);}}clone(){return new this.constructor(this.x,this.y);}copy(v){this.x=v.x;this.y=v.y;return this;}add(v){this.x+=v.x;this.y+=v.y;return this;}addScalar(s){this.x+=s;this.y+=s;return this;}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this;}addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;return this;}sub(v){this.x-=v.x;this.y-=v.y;return this;}subScalar(s){this.x-=s;this.y-=s;return this;}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this;}multiply(v){this.x*=v.x;this.y*=v.y;return this;}multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;return this;}divide(v){this.x/=v.x;this.y/=v.y;return this;}divideScalar(scalar){return this.multiplyScalar(1/scalar);}applyMatrix3(m){const x=this.x,y=this.y;const e=m.elements;this.x=e[0]*x+e[3]*y+e[6];this.y=e[1]*x+e[4]*y+e[7];return this;}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this;}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this;}clamp(min,max){// assumes min < max, componentwise
	this.x=clamp$1(this.x,min.x,max.x);this.y=clamp$1(this.y,min.y,max.y);return this;}clampScalar(minVal,maxVal){this.x=clamp$1(this.x,minVal,maxVal);this.y=clamp$1(this.y,minVal,maxVal);return this;}clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(clamp$1(length,min,max));}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this;}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this;}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this;}roundToZero(){this.x=Math.trunc(this.x);this.y=Math.trunc(this.y);return this;}negate(){this.x=-this.x;this.y=-this.y;return this;}dot(v){return this.x*v.x+this.y*v.y;}cross(v){return this.x*v.y-this.y*v.x;}lengthSq(){return this.x*this.x+this.y*this.y;}length(){return Math.sqrt(this.x*this.x+this.y*this.y);}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y);}normalize(){return this.divideScalar(this.length()||1);}angle(){// computes the angle in radians with respect to the positive x-axis
	const angle=Math.atan2(-this.y,-this.x)+Math.PI;return angle;}angleTo(v){const denominator=Math.sqrt(this.lengthSq()*v.lengthSq());if(denominator===0)return Math.PI/2;const theta=this.dot(v)/denominator;// clamp, to handle numerical problems
	return Math.acos(clamp$1(theta,-1,1));}distanceTo(v){return Math.sqrt(this.distanceToSquared(v));}distanceToSquared(v){const dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy;}manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y);}setLength(length){return this.normalize().multiplyScalar(length);}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;return this;}lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;return this;}equals(v){return v.x===this.x&&v.y===this.y;}fromArray(array,offset=0){this.x=array[offset];this.y=array[offset+1];return this;}toArray(array=[],offset=0){array[offset]=this.x;array[offset+1]=this.y;return array;}fromBufferAttribute(attribute,index){this.x=attribute.getX(index);this.y=attribute.getY(index);return this;}rotateAround(center,angle){const c=Math.cos(angle),s=Math.sin(angle);const x=this.x-center.x;const y=this.y-center.y;this.x=x*c-y*s+center.x;this.y=x*s+y*c+center.y;return this;}random(){this.x=Math.random();this.y=Math.random();return this;}*[Symbol.iterator](){yield this.x;yield this.y;}};let Matrix3$1 = class Matrix3{constructor(n11,n12,n13,n21,n22,n23,n31,n32,n33){Matrix3.prototype.isMatrix3=true;this.elements=[1,0,0,0,1,0,0,0,1];if(n11!==undefined){this.set(n11,n12,n13,n21,n22,n23,n31,n32,n33);}}set(n11,n12,n13,n21,n22,n23,n31,n32,n33){const te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this;}identity(){this.set(1,0,0,0,1,0,0,0,1);return this;}copy(m){const te=this.elements;const me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];return this;}extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrix3Column(this,0);yAxis.setFromMatrix3Column(this,1);zAxis.setFromMatrix3Column(this,2);return this;}setFromMatrix4(m){const me=m.elements;this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]);return this;}multiply(m){return this.multiplyMatrices(this,m);}premultiply(m){return this.multiplyMatrices(m,this);}multiplyMatrices(a,b){const ae=a.elements;const be=b.elements;const te=this.elements;const a11=ae[0],a12=ae[3],a13=ae[6];const a21=ae[1],a22=ae[4],a23=ae[7];const a31=ae[2],a32=ae[5],a33=ae[8];const b11=be[0],b12=be[3],b13=be[6];const b21=be[1],b22=be[4],b23=be[7];const b31=be[2],b32=be[5],b33=be[8];te[0]=a11*b11+a12*b21+a13*b31;te[3]=a11*b12+a12*b22+a13*b32;te[6]=a11*b13+a12*b23+a13*b33;te[1]=a21*b11+a22*b21+a23*b31;te[4]=a21*b12+a22*b22+a23*b32;te[7]=a21*b13+a22*b23+a23*b33;te[2]=a31*b11+a32*b21+a33*b31;te[5]=a31*b12+a32*b22+a33*b32;te[8]=a31*b13+a32*b23+a33*b33;return this;}multiplyScalar(s){const te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this;}determinant(){const te=this.elements;const a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;}invert(){const te=this.elements,n11=te[0],n21=te[1],n31=te[2],n12=te[3],n22=te[4],n32=te[5],n13=te[6],n23=te[7],n33=te[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0)return this.set(0,0,0,0,0,0,0,0,0);const detInv=1/det;te[0]=t11*detInv;te[1]=(n31*n23-n33*n21)*detInv;te[2]=(n32*n21-n31*n22)*detInv;te[3]=t12*detInv;te[4]=(n33*n11-n31*n13)*detInv;te[5]=(n31*n12-n32*n11)*detInv;te[6]=t13*detInv;te[7]=(n21*n13-n23*n11)*detInv;te[8]=(n22*n11-n21*n12)*detInv;return this;}transpose(){let tmp;const m=this.elements;tmp=m[1];m[1]=m[3];m[3]=tmp;tmp=m[2];m[2]=m[6];m[6]=tmp;tmp=m[5];m[5]=m[7];m[7]=tmp;return this;}getNormalMatrix(matrix4){return this.setFromMatrix4(matrix4).invert().transpose();}transposeIntoArray(r){const m=this.elements;r[0]=m[0];r[1]=m[3];r[2]=m[6];r[3]=m[1];r[4]=m[4];r[5]=m[7];r[6]=m[2];r[7]=m[5];r[8]=m[8];return this;}setUvTransform(tx,ty,sx,sy,rotation,cx,cy){const c=Math.cos(rotation);const s=Math.sin(rotation);this.set(sx*c,sx*s,-sx*(c*cx+s*cy)+cx+tx,-sy*s,sy*c,-sy*(-s*cx+c*cy)+cy+ty,0,0,1);return this;}//
	scale(sx,sy){this.premultiply(_m3$1.makeScale(sx,sy));return this;}rotate(theta){this.premultiply(_m3$1.makeRotation(-theta));return this;}translate(tx,ty){this.premultiply(_m3$1.makeTranslation(tx,ty));return this;}// for 2D Transforms
	makeTranslation(x,y){if(x.isVector2){this.set(1,0,x.x,0,1,x.y,0,0,1);}else {this.set(1,0,x,0,1,y,0,0,1);}return this;}makeRotation(theta){// counterclockwise
	const c=Math.cos(theta);const s=Math.sin(theta);this.set(c,-s,0,s,c,0,0,0,1);return this;}makeScale(x,y){this.set(x,0,0,0,y,0,0,0,1);return this;}//
	equals(matrix){const te=this.elements;const me=matrix.elements;for(let i=0;i<9;i++){if(te[i]!==me[i])return false;}return true;}fromArray(array,offset=0){for(let i=0;i<9;i++){this.elements[i]=array[i+offset];}return this;}toArray(array=[],offset=0){const te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];return array;}clone(){return new this.constructor().fromArray(this.elements);}};const _m3$1=/*@__PURE__*/new Matrix3$1();function arrayNeedsUint32$1(array){// assumes larger values usually on last
	for(let i=array.length-1;i>=0;--i){if(array[i]>=65535)return true;// account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
	}return false;}function createElementNS(name){return document.createElementNS('http://www.w3.org/1999/xhtml',name);}function createCanvasElement(){const canvas=createElementNS('canvas');canvas.style.display='block';return canvas;}const _cache={};function warnOnce(message){if(message in _cache)return;_cache[message]=true;console.warn(message);}function probeAsync(gl,sync,interval){return new Promise(function(resolve,reject){function probe(){switch(gl.clientWaitSync(sync,gl.SYNC_FLUSH_COMMANDS_BIT,0)){case gl.WAIT_FAILED:reject();break;case gl.TIMEOUT_EXPIRED:setTimeout(probe,interval);break;default:resolve();}}setTimeout(probe,interval);});}function toNormalizedProjectionMatrix(projectionMatrix){const m=projectionMatrix.elements;// Convert [-1, 1] to [0, 1] projection matrix
	m[2]=0.5*m[2]+0.5*m[3];m[6]=0.5*m[6]+0.5*m[7];m[10]=0.5*m[10]+0.5*m[11];m[14]=0.5*m[14]+0.5*m[15];}function toReversedProjectionMatrix(projectionMatrix){const m=projectionMatrix.elements;const isPerspectiveMatrix=m[11]===-1;// Reverse [0, 1] projection matrix
	if(isPerspectiveMatrix){m[10]=-m[10]-1;m[14]=-m[14];}else {m[10]=-m[10];m[14]=-m[14]+1;}}const LINEAR_REC709_TO_XYZ=/*@__PURE__*/new Matrix3$1().set(0.4123908,0.3575843,0.1804808,0.2126390,0.7151687,0.0721923,0.0193308,0.1191948,0.9505322);const XYZ_TO_LINEAR_REC709=/*@__PURE__*/new Matrix3$1().set(3.2409699,-1.5373832,-0.4986108,-0.9692436,1.8759675,0.0415551,0.0556301,-0.2039770,1.0569715);function createColorManagement(){const ColorManagement={enabled:true,workingColorSpace:LinearSRGBColorSpace,/**
			 * Implementations of supported color spaces.
			 *
			 * Required:
			 *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
			 *	- whitePoint: reference white [ x y ]
			 *	- transfer: transfer function (pre-defined)
			 *	- toXYZ: Matrix3 RGB to XYZ transform
			 *	- fromXYZ: Matrix3 XYZ to RGB transform
			 *	- luminanceCoefficients: RGB luminance coefficients
			 *
			 * Optional:
			 *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
			 *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
			 *
			 * Reference:
			 * - https://www.russellcottrell.com/photo/matrixCalculator.htm
			 */spaces:{},convert:function(color,sourceColorSpace,targetColorSpace){if(this.enabled===false||sourceColorSpace===targetColorSpace||!sourceColorSpace||!targetColorSpace){return color;}if(this.spaces[sourceColorSpace].transfer===SRGBTransfer){color.r=SRGBToLinear(color.r);color.g=SRGBToLinear(color.g);color.b=SRGBToLinear(color.b);}if(this.spaces[sourceColorSpace].primaries!==this.spaces[targetColorSpace].primaries){color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);}if(this.spaces[targetColorSpace].transfer===SRGBTransfer){color.r=LinearToSRGB(color.r);color.g=LinearToSRGB(color.g);color.b=LinearToSRGB(color.b);}return color;},fromWorkingColorSpace:function(color,targetColorSpace){return this.convert(color,this.workingColorSpace,targetColorSpace);},toWorkingColorSpace:function(color,sourceColorSpace){return this.convert(color,sourceColorSpace,this.workingColorSpace);},getPrimaries:function(colorSpace){return this.spaces[colorSpace].primaries;},getTransfer:function(colorSpace){if(colorSpace===NoColorSpace)return LinearTransfer;return this.spaces[colorSpace].transfer;},getLuminanceCoefficients:function(target,colorSpace=this.workingColorSpace){return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);},define:function(colorSpaces){Object.assign(this.spaces,colorSpaces);},// Internal APIs
	_getMatrix:function(targetMatrix,sourceColorSpace,targetColorSpace){return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);},_getDrawingBufferColorSpace:function(colorSpace){return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;},_getUnpackColorSpace:function(colorSpace=this.workingColorSpace){return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;}};/******************************************************************************
		 * sRGB definitions
		 */const REC709_PRIMARIES=[0.640,0.330,0.300,0.600,0.150,0.060];const REC709_LUMINANCE_COEFFICIENTS=[0.2126,0.7152,0.0722];const D65=[0.3127,0.3290];ColorManagement.define({[LinearSRGBColorSpace]:{primaries:REC709_PRIMARIES,whitePoint:D65,transfer:LinearTransfer,toXYZ:LINEAR_REC709_TO_XYZ,fromXYZ:XYZ_TO_LINEAR_REC709,luminanceCoefficients:REC709_LUMINANCE_COEFFICIENTS,workingColorSpaceConfig:{unpackColorSpace:SRGBColorSpace},outputColorSpaceConfig:{drawingBufferColorSpace:SRGBColorSpace}},[SRGBColorSpace]:{primaries:REC709_PRIMARIES,whitePoint:D65,transfer:SRGBTransfer,toXYZ:LINEAR_REC709_TO_XYZ,fromXYZ:XYZ_TO_LINEAR_REC709,luminanceCoefficients:REC709_LUMINANCE_COEFFICIENTS,outputColorSpaceConfig:{drawingBufferColorSpace:SRGBColorSpace}}});return ColorManagement;}const ColorManagement=/*@__PURE__*/createColorManagement();function SRGBToLinear(c){return c<0.04045?c*0.0773993808:Math.pow(c*0.9478672986+0.0521327014,2.4);}function LinearToSRGB(c){return c<0.0031308?c*12.92:1.055*Math.pow(c,0.41666)-0.055;}let _canvas;class ImageUtils{static getDataURL(image){if(/^data:/i.test(image.src)){return image.src;}if(typeof HTMLCanvasElement==='undefined'){return image.src;}let canvas;if(image instanceof HTMLCanvasElement){canvas=image;}else {if(_canvas===undefined)_canvas=createElementNS('canvas');_canvas.width=image.width;_canvas.height=image.height;const context=_canvas.getContext('2d');if(image instanceof ImageData){context.putImageData(image,0,0);}else {context.drawImage(image,0,0,image.width,image.height);}canvas=_canvas;}if(canvas.width>2048||canvas.height>2048){console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',image);return canvas.toDataURL('image/jpeg',0.6);}else {return canvas.toDataURL('image/png');}}static sRGBToLinear(image){if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){const canvas=createElementNS('canvas');canvas.width=image.width;canvas.height=image.height;const context=canvas.getContext('2d');context.drawImage(image,0,0,image.width,image.height);const imageData=context.getImageData(0,0,image.width,image.height);const data=imageData.data;for(let i=0;i<data.length;i++){data[i]=SRGBToLinear(data[i]/255)*255;}context.putImageData(imageData,0,0);return canvas;}else if(image.data){const data=image.data.slice(0);for(let i=0;i<data.length;i++){if(data instanceof Uint8Array||data instanceof Uint8ClampedArray){data[i]=Math.floor(SRGBToLinear(data[i]/255)*255);}else {// assuming float
	data[i]=SRGBToLinear(data[i]);}}return {data:data,width:image.width,height:image.height};}else {console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');return image;}}}let _sourceId=0;class Source{constructor(data=null){this.isSource=true;Object.defineProperty(this,'id',{value:_sourceId++});this.uuid=generateUUID$1();this.data=data;this.dataReady=true;this.version=0;}set needsUpdate(value){if(value===true)this.version++;}toJSON(meta){const isRootObject=meta===undefined||typeof meta==='string';if(!isRootObject&&meta.images[this.uuid]!==undefined){return meta.images[this.uuid];}const output={uuid:this.uuid,url:''};const data=this.data;if(data!==null){let url;if(Array.isArray(data)){// cube texture
	url=[];for(let i=0,l=data.length;i<l;i++){if(data[i].isDataTexture){url.push(serializeImage(data[i].image));}else {url.push(serializeImage(data[i]));}}}else {// texture
	url=serializeImage(data);}output.url=url;}if(!isRootObject){meta.images[this.uuid]=output;}return output;}}function serializeImage(image){if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){// default images
	return ImageUtils.getDataURL(image);}else {if(image.data){// images of DataTexture
	return {data:Array.from(image.data),width:image.width,height:image.height,type:image.data.constructor.name};}else {console.warn('THREE.Texture: Unable to serialize Texture.');return {};}}}let _textureId=0;class Texture extends EventDispatcher$1{constructor(image=Texture.DEFAULT_IMAGE,mapping=Texture.DEFAULT_MAPPING,wrapS=ClampToEdgeWrapping,wrapT=ClampToEdgeWrapping,magFilter=LinearFilter,minFilter=LinearMipmapLinearFilter,format=RGBAFormat,type=UnsignedByteType,anisotropy=Texture.DEFAULT_ANISOTROPY,colorSpace=NoColorSpace){super();this.isTexture=true;Object.defineProperty(this,'id',{value:_textureId++});this.uuid=generateUUID$1();this.name='';this.source=new Source(image);this.mipmaps=[];this.mapping=mapping;this.channel=0;this.wrapS=wrapS;this.wrapT=wrapT;this.magFilter=magFilter;this.minFilter=minFilter;this.anisotropy=anisotropy;this.format=format;this.internalFormat=null;this.type=type;this.offset=new Vector2$1(0,0);this.repeat=new Vector2$1(1,1);this.center=new Vector2$1(0,0);this.rotation=0;this.matrixAutoUpdate=true;this.matrix=new Matrix3$1();this.generateMipmaps=true;this.premultiplyAlpha=false;this.flipY=true;this.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	this.colorSpace=colorSpace;this.userData={};this.version=0;this.onUpdate=null;this.isRenderTargetTexture=false;// indicates whether a texture belongs to a render target or not
	this.pmremVersion=0;// indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)
	}get image(){return this.source.data;}set image(value=null){this.source.data=value;}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y);}clone(){return new this.constructor().copy(this);}copy(source){this.name=source.name;this.source=source.source;this.mipmaps=source.mipmaps.slice(0);this.mapping=source.mapping;this.channel=source.channel;this.wrapS=source.wrapS;this.wrapT=source.wrapT;this.magFilter=source.magFilter;this.minFilter=source.minFilter;this.anisotropy=source.anisotropy;this.format=source.format;this.internalFormat=source.internalFormat;this.type=source.type;this.offset.copy(source.offset);this.repeat.copy(source.repeat);this.center.copy(source.center);this.rotation=source.rotation;this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrix.copy(source.matrix);this.generateMipmaps=source.generateMipmaps;this.premultiplyAlpha=source.premultiplyAlpha;this.flipY=source.flipY;this.unpackAlignment=source.unpackAlignment;this.colorSpace=source.colorSpace;this.userData=JSON.parse(JSON.stringify(source.userData));this.needsUpdate=true;return this;}toJSON(meta){const isRootObject=meta===undefined||typeof meta==='string';if(!isRootObject&&meta.textures[this.uuid]!==undefined){return meta.textures[this.uuid];}const output={metadata:{version:4.6,type:'Texture',generator:'Texture.toJSON'},uuid:this.uuid,name:this.name,image:this.source.toJSON(meta).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(Object.keys(this.userData).length>0)output.userData=this.userData;if(!isRootObject){meta.textures[this.uuid]=output;}return output;}dispose(){this.dispatchEvent({type:'dispose'});}transformUv(uv){if(this.mapping!==UVMapping)return uv;uv.applyMatrix3(this.matrix);if(uv.x<0||uv.x>1){switch(this.wrapS){case RepeatWrapping:uv.x=uv.x-Math.floor(uv.x);break;case ClampToEdgeWrapping:uv.x=uv.x<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.x)%2)===1){uv.x=Math.ceil(uv.x)-uv.x;}else {uv.x=uv.x-Math.floor(uv.x);}break;}}if(uv.y<0||uv.y>1){switch(this.wrapT){case RepeatWrapping:uv.y=uv.y-Math.floor(uv.y);break;case ClampToEdgeWrapping:uv.y=uv.y<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.y)%2)===1){uv.y=Math.ceil(uv.y)-uv.y;}else {uv.y=uv.y-Math.floor(uv.y);}break;}}if(this.flipY){uv.y=1-uv.y;}return uv;}set needsUpdate(value){if(value===true){this.version++;this.source.needsUpdate=true;}}set needsPMREMUpdate(value){if(value===true){this.pmremVersion++;}}}Texture.DEFAULT_IMAGE=null;Texture.DEFAULT_MAPPING=UVMapping;Texture.DEFAULT_ANISOTROPY=1;class Vector4{constructor(x=0,y=0,z=0,w=1){Vector4.prototype.isVector4=true;this.x=x;this.y=y;this.z=z;this.w=w;}get width(){return this.z;}set width(value){this.z=value;}get height(){return this.w;}set height(value){this.w=value;}set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this;}setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;this.w=scalar;return this;}setX(x){this.x=x;return this;}setY(y){this.y=y;return this;}setZ(z){this.z=z;return this;}setW(w){this.w=w;return this;}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error('index is out of range: '+index);}return this;}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error('index is out of range: '+index);}}clone(){return new this.constructor(this.x,this.y,this.z,this.w);}copy(v){this.x=v.x;this.y=v.y;this.z=v.z;this.w=v.w!==undefined?v.w:1;return this;}add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this;}addScalar(s){this.x+=s;this.y+=s;this.z+=s;this.w+=s;return this;}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this;}addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;this.w+=v.w*s;return this;}sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this;}subScalar(s){this.x-=s;this.y-=s;this.z-=s;this.w-=s;return this;}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this;}multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;this.w*=v.w;return this;}multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;return this;}applyMatrix4(m){const x=this.x,y=this.y,z=this.z,w=this.w;const e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;return this;}divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;this.w/=v.w;return this;}divideScalar(scalar){return this.multiplyScalar(1/scalar);}setAxisAngleFromQuaternion(q){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	// q is assumed to be normalized
	this.w=2*Math.acos(q.w);const s=Math.sqrt(1-q.w*q.w);if(s<0.0001){this.x=1;this.y=0;this.z=0;}else {this.x=q.x/s;this.y=q.y/s;this.z=q.z/s;}return this;}setAxisAngleFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	let angle,x,y,z;// variables for result
	const epsilon=0.01,// margin to allow for rounding errors
	epsilon2=0.1,// margin to distinguish between 0 and 180 degrees
	te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<epsilon&&Math.abs(m13-m31)<epsilon&&Math.abs(m23-m32)<epsilon){// singularity found
	// first check for identity matrix which must have +1 for all terms
	// in leading diagonal and zero in other terms
	if(Math.abs(m12+m21)<epsilon2&&Math.abs(m13+m31)<epsilon2&&Math.abs(m23+m32)<epsilon2&&Math.abs(m11+m22+m33-3)<epsilon2){// this singularity is identity matrix so angle = 0
	this.set(1,0,0,0);return this;// zero angle, arbitrary axis
	}// otherwise this singularity is angle = 180
	angle=Math.PI;const xx=(m11+1)/2;const yy=(m22+1)/2;const zz=(m33+1)/2;const xy=(m12+m21)/4;const xz=(m13+m31)/4;const yz=(m23+m32)/4;if(xx>yy&&xx>zz){// m11 is the largest diagonal term
	if(xx<epsilon){x=0;y=0.707106781;z=0.707106781;}else {x=Math.sqrt(xx);y=xy/x;z=xz/x;}}else if(yy>zz){// m22 is the largest diagonal term
	if(yy<epsilon){x=0.707106781;y=0;z=0.707106781;}else {y=Math.sqrt(yy);x=xy/y;z=yz/y;}}else {// m33 is the largest diagonal term so base result on this
	if(zz<epsilon){x=0.707106781;y=0.707106781;z=0;}else {z=Math.sqrt(zz);x=xz/z;y=yz/z;}}this.set(x,y,z,angle);return this;// return 180 deg rotation
	}// as we have reached here there are no singularities so we can handle normally
	let s=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));// used to normalize
	if(Math.abs(s)<0.001)s=1;// prevent divide by zero, should not happen if matrix is orthogonal and should be
	// caught by singularity test above, but I've left it in just in case
	this.x=(m32-m23)/s;this.y=(m13-m31)/s;this.z=(m21-m12)/s;this.w=Math.acos((m11+m22+m33-1)/2);return this;}setFromMatrixPosition(m){const e=m.elements;this.x=e[12];this.y=e[13];this.z=e[14];this.w=e[15];return this;}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);this.w=Math.min(this.w,v.w);return this;}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);this.w=Math.max(this.w,v.w);return this;}clamp(min,max){// assumes min < max, componentwise
	this.x=clamp$1(this.x,min.x,max.x);this.y=clamp$1(this.y,min.y,max.y);this.z=clamp$1(this.z,min.z,max.z);this.w=clamp$1(this.w,min.w,max.w);return this;}clampScalar(minVal,maxVal){this.x=clamp$1(this.x,minVal,maxVal);this.y=clamp$1(this.y,minVal,maxVal);this.z=clamp$1(this.z,minVal,maxVal);this.w=clamp$1(this.w,minVal,maxVal);return this;}clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(clamp$1(length,min,max));}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this;}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this;}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this;}roundToZero(){this.x=Math.trunc(this.x);this.y=Math.trunc(this.y);this.z=Math.trunc(this.z);this.w=Math.trunc(this.w);return this;}negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this;}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);}normalize(){return this.divideScalar(this.length()||1);}setLength(length){return this.normalize().multiplyScalar(length);}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this;}lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;this.w=v1.w+(v2.w-v1.w)*alpha;return this;}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;}fromArray(array,offset=0){this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this;}toArray(array=[],offset=0){array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array;}fromBufferAttribute(attribute,index){this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);this.w=attribute.getW(index);return this;}random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();this.w=Math.random();return this;}*[Symbol.iterator](){yield this.x;yield this.y;yield this.z;yield this.w;}}/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/class RenderTarget extends EventDispatcher$1{constructor(width=1,height=1,options={}){super();this.isRenderTarget=true;this.width=width;this.height=height;this.depth=1;this.scissor=new Vector4(0,0,width,height);this.scissorTest=false;this.viewport=new Vector4(0,0,width,height);const image={width:width,height:height,depth:1};options=Object.assign({generateMipmaps:false,internalFormat:null,minFilter:LinearFilter,depthBuffer:true,stencilBuffer:false,resolveDepthBuffer:true,resolveStencilBuffer:true,depthTexture:null,samples:0,count:1},options);const texture=new Texture(image,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.colorSpace);texture.flipY=false;texture.generateMipmaps=options.generateMipmaps;texture.internalFormat=options.internalFormat;this.textures=[];const count=options.count;for(let i=0;i<count;i++){this.textures[i]=texture.clone();this.textures[i].isRenderTargetTexture=true;}this.depthBuffer=options.depthBuffer;this.stencilBuffer=options.stencilBuffer;this.resolveDepthBuffer=options.resolveDepthBuffer;this.resolveStencilBuffer=options.resolveStencilBuffer;this.depthTexture=options.depthTexture;this.samples=options.samples;}get texture(){return this.textures[0];}set texture(value){this.textures[0]=value;}setSize(width,height,depth=1){if(this.width!==width||this.height!==height||this.depth!==depth){this.width=width;this.height=height;this.depth=depth;for(let i=0,il=this.textures.length;i<il;i++){this.textures[i].image.width=width;this.textures[i].image.height=height;this.textures[i].image.depth=depth;}this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);}clone(){return new this.constructor().copy(this);}copy(source){this.width=source.width;this.height=source.height;this.depth=source.depth;this.scissor.copy(source.scissor);this.scissorTest=source.scissorTest;this.viewport.copy(source.viewport);this.textures.length=0;for(let i=0,il=source.textures.length;i<il;i++){this.textures[i]=source.textures[i].clone();this.textures[i].isRenderTargetTexture=true;}// ensure image object is not shared, see #20328
	const image=Object.assign({},source.texture.image);this.texture.source=new Source(image);this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;this.resolveDepthBuffer=source.resolveDepthBuffer;this.resolveStencilBuffer=source.resolveStencilBuffer;if(source.depthTexture!==null)this.depthTexture=source.depthTexture.clone();this.samples=source.samples;return this;}dispose(){this.dispatchEvent({type:'dispose'});}}class WebGLRenderTarget extends RenderTarget{constructor(width=1,height=1,options={}){super(width,height,options);this.isWebGLRenderTarget=true;}}class DataArrayTexture extends Texture{constructor(data=null,width=1,height=1,depth=1){super(null);this.isDataArrayTexture=true;this.image={data,width,height,depth};this.magFilter=NearestFilter;this.minFilter=NearestFilter;this.wrapR=ClampToEdgeWrapping;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;this.layerUpdates=new Set();}addLayerUpdate(layerIndex){this.layerUpdates.add(layerIndex);}clearLayerUpdates(){this.layerUpdates.clear();}}class Data3DTexture extends Texture{constructor(data=null,width=1,height=1,depth=1){// We're going to add .setXXX() methods for setting properties later.
	// Users can still set in DataTexture3D directly.
	//
	//	const texture = new THREE.DataTexture3D( data, width, height, depth );
	// 	texture.anisotropy = 16;
	//
	// See #14839
	super(null);this.isData3DTexture=true;this.image={data,width,height,depth};this.magFilter=NearestFilter;this.minFilter=NearestFilter;this.wrapR=ClampToEdgeWrapping;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;}}let Quaternion$1 = class Quaternion{constructor(x=0,y=0,z=0,w=1){this.isQuaternion=true;this._x=x;this._y=y;this._z=z;this._w=w;}static slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){// fuzz-free, array-based Quaternion SLERP operation
	let x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3];const x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(t===0){dst[dstOffset+0]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;return;}if(t===1){dst[dstOffset+0]=x1;dst[dstOffset+1]=y1;dst[dstOffset+2]=z1;dst[dstOffset+3]=w1;return;}if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){let s=1-t;const cos=x0*x1+y0*y1+z0*z1+w0*w1,dir=cos>=0?1:-1,sqrSin=1-cos*cos;// Skip the Slerp for tiny steps to avoid numeric problems:
	if(sqrSin>Number.EPSILON){const sin=Math.sqrt(sqrSin),len=Math.atan2(sin,cos*dir);s=Math.sin(s*len)/sin;t=Math.sin(t*len)/sin;}const tDir=t*dir;x0=x0*s+x1*tDir;y0=y0*s+y1*tDir;z0=z0*s+z1*tDir;w0=w0*s+w1*tDir;// Normalize in case we just did a lerp:
	if(s===1-t){const f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f;y0*=f;z0*=f;w0*=f;}}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;}static multiplyQuaternionsFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1){const x0=src0[srcOffset0];const y0=src0[srcOffset0+1];const z0=src0[srcOffset0+2];const w0=src0[srcOffset0+3];const x1=src1[srcOffset1];const y1=src1[srcOffset1+1];const z1=src1[srcOffset1+2];const w1=src1[srcOffset1+3];dst[dstOffset]=x0*w1+w0*x1+y0*z1-z0*y1;dst[dstOffset+1]=y0*w1+w0*y1+z0*x1-x0*z1;dst[dstOffset+2]=z0*w1+w0*z1+x0*y1-y0*x1;dst[dstOffset+3]=w0*w1-x0*x1-y0*y1-z0*z1;return dst;}get x(){return this._x;}set x(value){this._x=value;this._onChangeCallback();}get y(){return this._y;}set y(value){this._y=value;this._onChangeCallback();}get z(){return this._z;}set z(value){this._z=value;this._onChangeCallback();}get w(){return this._w;}set w(value){this._w=value;this._onChangeCallback();}set(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this._onChangeCallback();return this;}clone(){return new this.constructor(this._x,this._y,this._z,this._w);}copy(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this._onChangeCallback();return this;}setFromEuler(euler,update=true){const x=euler._x,y=euler._y,z=euler._z,order=euler._order;// http://www.mathworks.com/matlabcentral/fileexchange/
	// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
	//	content/SpinCalc.m
	const cos=Math.cos;const sin=Math.sin;const c1=cos(x/2);const c2=cos(y/2);const c3=cos(z/2);const s1=sin(x/2);const s2=sin(y/2);const s3=sin(z/2);switch(order){case'XYZ':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'YXZ':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;case'ZXY':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'ZYX':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;case'YZX':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'XZY':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;default:console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: '+order);}if(update===true)this._onChangeCallback();return this;}setFromAxisAngle(axis,angle){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	// assumes axis is normalized
	const halfAngle=angle/2,s=Math.sin(halfAngle);this._x=axis.x*s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(halfAngle);this._onChangeCallback();return this;}setFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	const te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33;if(trace>0){const s=0.5/Math.sqrt(trace+1.0);this._w=0.25/s;this._x=(m32-m23)*s;this._y=(m13-m31)*s;this._z=(m21-m12)*s;}else if(m11>m22&&m11>m33){const s=2.0*Math.sqrt(1.0+m11-m22-m33);this._w=(m32-m23)/s;this._x=0.25*s;this._y=(m12+m21)/s;this._z=(m13+m31)/s;}else if(m22>m33){const s=2.0*Math.sqrt(1.0+m22-m11-m33);this._w=(m13-m31)/s;this._x=(m12+m21)/s;this._y=0.25*s;this._z=(m23+m32)/s;}else {const s=2.0*Math.sqrt(1.0+m33-m11-m22);this._w=(m21-m12)/s;this._x=(m13+m31)/s;this._y=(m23+m32)/s;this._z=0.25*s;}this._onChangeCallback();return this;}setFromUnitVectors(vFrom,vTo){// assumes direction vectors vFrom and vTo are normalized
	let r=vFrom.dot(vTo)+1;if(r<Number.EPSILON){// vFrom and vTo point in opposite directions
	r=0;if(Math.abs(vFrom.x)>Math.abs(vFrom.z)){this._x=-vFrom.y;this._y=vFrom.x;this._z=0;this._w=r;}else {this._x=0;this._y=-vFrom.z;this._z=vFrom.y;this._w=r;}}else {// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
	this._x=vFrom.y*vTo.z-vFrom.z*vTo.y;this._y=vFrom.z*vTo.x-vFrom.x*vTo.z;this._z=vFrom.x*vTo.y-vFrom.y*vTo.x;this._w=r;}return this.normalize();}angleTo(q){return 2*Math.acos(Math.abs(clamp$1(this.dot(q),-1,1)));}rotateTowards(q,step){const angle=this.angleTo(q);if(angle===0)return this;const t=Math.min(1,step/angle);this.slerp(q,t);return this;}identity(){return this.set(0,0,0,1);}invert(){// quaternion is assumed to have unit length
	return this.conjugate();}conjugate(){this._x*=-1;this._y*=-1;this._z*=-1;this._onChangeCallback();return this;}dot(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);}normalize(){let l=this.length();if(l===0){this._x=0;this._y=0;this._z=0;this._w=1;}else {l=1/l;this._x=this._x*l;this._y=this._y*l;this._z=this._z*l;this._w=this._w*l;}this._onChangeCallback();return this;}multiply(q){return this.multiplyQuaternions(this,q);}premultiply(q){return this.multiplyQuaternions(q,this);}multiplyQuaternions(a,b){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	const qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;const qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;this._onChangeCallback();return this;}slerp(qb,t){if(t===0)return this;if(t===1)return this.copy(qb);const x=this._x,y=this._y,z=this._z,w=this._w;// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	let cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;if(cosHalfTheta<0){this._w=-qb._w;this._x=-qb._x;this._y=-qb._y;this._z=-qb._z;cosHalfTheta=-cosHalfTheta;}else {this.copy(qb);}if(cosHalfTheta>=1.0){this._w=w;this._x=x;this._y=y;this._z=z;return this;}const sqrSinHalfTheta=1.0-cosHalfTheta*cosHalfTheta;if(sqrSinHalfTheta<=Number.EPSILON){const s=1-t;this._w=s*w+t*this._w;this._x=s*x+t*this._x;this._y=s*y+t*this._y;this._z=s*z+t*this._z;this.normalize();// normalize calls _onChangeCallback()
	return this;}const sinHalfTheta=Math.sqrt(sqrSinHalfTheta);const halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);const ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t*halfTheta)/sinHalfTheta;this._w=w*ratioA+this._w*ratioB;this._x=x*ratioA+this._x*ratioB;this._y=y*ratioA+this._y*ratioB;this._z=z*ratioA+this._z*ratioB;this._onChangeCallback();return this;}slerpQuaternions(qa,qb,t){return this.copy(qa).slerp(qb,t);}random(){// sets this quaternion to a uniform random unit quaternnion
	// Ken Shoemake
	// Uniform random rotations
	// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.
	const theta1=2*Math.PI*Math.random();const theta2=2*Math.PI*Math.random();const x0=Math.random();const r1=Math.sqrt(1-x0);const r2=Math.sqrt(x0);return this.set(r1*Math.sin(theta1),r1*Math.cos(theta1),r2*Math.sin(theta2),r2*Math.cos(theta2));}equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;}fromArray(array,offset=0){this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this._onChangeCallback();return this;}toArray(array=[],offset=0){array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array;}fromBufferAttribute(attribute,index){this._x=attribute.getX(index);this._y=attribute.getY(index);this._z=attribute.getZ(index);this._w=attribute.getW(index);this._onChangeCallback();return this;}toJSON(){return this.toArray();}_onChange(callback){this._onChangeCallback=callback;return this;}_onChangeCallback(){}*[Symbol.iterator](){yield this._x;yield this._y;yield this._z;yield this._w;}};let Vector3$1 = class Vector3{constructor(x=0,y=0,z=0){Vector3.prototype.isVector3=true;this.x=x;this.y=y;this.z=z;}set(x,y,z){if(z===undefined)z=this.z;// sprite.scale.set(x,y)
	this.x=x;this.y=y;this.z=z;return this;}setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;return this;}setX(x){this.x=x;return this;}setY(y){this.y=y;return this;}setZ(z){this.z=z;return this;}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error('index is out of range: '+index);}return this;}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error('index is out of range: '+index);}}clone(){return new this.constructor(this.x,this.y,this.z);}copy(v){this.x=v.x;this.y=v.y;this.z=v.z;return this;}add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;}addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this;}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this;}addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;return this;}sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;}subScalar(s){this.x-=s;this.y-=s;this.z-=s;return this;}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this;}multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;return this;}multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;return this;}multiplyVectors(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this;}applyEuler(euler){return this.applyQuaternion(_quaternion$4.setFromEuler(euler));}applyAxisAngle(axis,angle){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis,angle));}applyMatrix3(m){const x=this.x,y=this.y,z=this.z;const e=m.elements;this.x=e[0]*x+e[3]*y+e[6]*z;this.y=e[1]*x+e[4]*y+e[7]*z;this.z=e[2]*x+e[5]*y+e[8]*z;return this;}applyNormalMatrix(m){return this.applyMatrix3(m).normalize();}applyMatrix4(m){const x=this.x,y=this.y,z=this.z;const e=m.elements;const w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);this.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w;this.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w;this.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w;return this;}applyQuaternion(q){// quaternion q is assumed to have unit length
	const vx=this.x,vy=this.y,vz=this.z;const qx=q.x,qy=q.y,qz=q.z,qw=q.w;// t = 2 * cross( q.xyz, v );
	const tx=2*(qy*vz-qz*vy);const ty=2*(qz*vx-qx*vz);const tz=2*(qx*vy-qy*vx);// v + q.w * t + cross( q.xyz, t );
	this.x=vx+qw*tx+qy*tz-qz*ty;this.y=vy+qw*ty+qz*tx-qx*tz;this.z=vz+qw*tz+qx*ty-qy*tx;return this;}project(camera){return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);}unproject(camera){return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);}transformDirection(m){// input: THREE.Matrix4 affine matrix
	// vector interpreted as a direction
	const x=this.x,y=this.y,z=this.z;const e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z;this.y=e[1]*x+e[5]*y+e[9]*z;this.z=e[2]*x+e[6]*y+e[10]*z;return this.normalize();}divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this;}divideScalar(scalar){return this.multiplyScalar(1/scalar);}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this;}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this;}clamp(min,max){// assumes min < max, componentwise
	this.x=clamp$1(this.x,min.x,max.x);this.y=clamp$1(this.y,min.y,max.y);this.z=clamp$1(this.z,min.z,max.z);return this;}clampScalar(minVal,maxVal){this.x=clamp$1(this.x,minVal,maxVal);this.y=clamp$1(this.y,minVal,maxVal);this.z=clamp$1(this.z,minVal,maxVal);return this;}clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(clamp$1(length,min,max));}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this;}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this;}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this;}roundToZero(){this.x=Math.trunc(this.x);this.y=Math.trunc(this.y);this.z=Math.trunc(this.z);return this;}negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z;}// TODO lengthSquared?
	lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z;}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);}normalize(){return this.divideScalar(this.length()||1);}setLength(length){return this.normalize().multiplyScalar(length);}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this;}lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;return this;}cross(v){return this.crossVectors(this,v);}crossVectors(a,b){const ax=a.x,ay=a.y,az=a.z;const bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;}projectOnVector(v){const denominator=v.lengthSq();if(denominator===0)return this.set(0,0,0);const scalar=v.dot(this)/denominator;return this.copy(v).multiplyScalar(scalar);}projectOnPlane(planeNormal){_vector$c.copy(this).projectOnVector(planeNormal);return this.sub(_vector$c);}reflect(normal){// reflect incident vector off plane orthogonal to normal
	// normal is assumed to have unit length
	return this.sub(_vector$c.copy(normal).multiplyScalar(2*this.dot(normal)));}angleTo(v){const denominator=Math.sqrt(this.lengthSq()*v.lengthSq());if(denominator===0)return Math.PI/2;const theta=this.dot(v)/denominator;// clamp, to handle numerical problems
	return Math.acos(clamp$1(theta,-1,1));}distanceTo(v){return Math.sqrt(this.distanceToSquared(v));}distanceToSquared(v){const dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz;}manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);}setFromSpherical(s){return this.setFromSphericalCoords(s.radius,s.phi,s.theta);}setFromSphericalCoords(radius,phi,theta){const sinPhiRadius=Math.sin(phi)*radius;this.x=sinPhiRadius*Math.sin(theta);this.y=Math.cos(phi)*radius;this.z=sinPhiRadius*Math.cos(theta);return this;}setFromCylindrical(c){return this.setFromCylindricalCoords(c.radius,c.theta,c.y);}setFromCylindricalCoords(radius,theta,y){this.x=radius*Math.sin(theta);this.y=y;this.z=radius*Math.cos(theta);return this;}setFromMatrixPosition(m){const e=m.elements;this.x=e[12];this.y=e[13];this.z=e[14];return this;}setFromMatrixScale(m){const sx=this.setFromMatrixColumn(m,0).length();const sy=this.setFromMatrixColumn(m,1).length();const sz=this.setFromMatrixColumn(m,2).length();this.x=sx;this.y=sy;this.z=sz;return this;}setFromMatrixColumn(m,index){return this.fromArray(m.elements,index*4);}setFromMatrix3Column(m,index){return this.fromArray(m.elements,index*3);}setFromEuler(e){this.x=e._x;this.y=e._y;this.z=e._z;return this;}setFromColor(c){this.x=c.r;this.y=c.g;this.z=c.b;return this;}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z;}fromArray(array,offset=0){this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];return this;}toArray(array=[],offset=0){array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array;}fromBufferAttribute(attribute,index){this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);return this;}random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();return this;}randomDirection(){// https://mathworld.wolfram.com/SpherePointPicking.html
	const theta=Math.random()*Math.PI*2;const u=Math.random()*2-1;const c=Math.sqrt(1-u*u);this.x=c*Math.cos(theta);this.y=u;this.z=c*Math.sin(theta);return this;}*[Symbol.iterator](){yield this.x;yield this.y;yield this.z;}};const _vector$c=/*@__PURE__*/new Vector3$1();const _quaternion$4=/*@__PURE__*/new Quaternion$1();let Box3$1 = class Box3{constructor(min=new Vector3$1(+Infinity,+Infinity,+Infinity),max=new Vector3$1(-Infinity,-Infinity,-Infinity)){this.isBox3=true;this.min=min;this.max=max;}set(min,max){this.min.copy(min);this.max.copy(max);return this;}setFromArray(array){this.makeEmpty();for(let i=0,il=array.length;i<il;i+=3){this.expandByPoint(_vector$b.fromArray(array,i));}return this;}setFromBufferAttribute(attribute){this.makeEmpty();for(let i=0,il=attribute.count;i<il;i++){this.expandByPoint(_vector$b.fromBufferAttribute(attribute,i));}return this;}setFromPoints(points){this.makeEmpty();for(let i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;}setFromCenterAndSize(center,size){const halfSize=_vector$b.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;}setFromObject(object,precise=false){this.makeEmpty();return this.expandByObject(object,precise);}clone(){return new this.constructor().copy(this);}copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;}makeEmpty(){this.min.x=this.min.y=this.min.z=+Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this;}isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;}getCenter(target){return this.isEmpty()?target.set(0,0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);}getSize(target){return this.isEmpty()?target.set(0,0,0):target.subVectors(this.max,this.min);}expandByPoint(point){this.min.min(point);this.max.max(point);return this;}expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;}expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;}expandByObject(object,precise=false){// Computes the world-axis-aligned bounding box of an object (including its children),
	// accounting for both the object's, and children's, world transforms
	object.updateWorldMatrix(false,false);const geometry=object.geometry;if(geometry!==undefined){const positionAttribute=geometry.getAttribute('position');// precise AABB computation based on vertex data requires at least a position attribute.
	// instancing isn't supported so far and uses the normal (conservative) code path.
	if(precise===true&&positionAttribute!==undefined&&object.isInstancedMesh!==true){for(let i=0,l=positionAttribute.count;i<l;i++){if(object.isMesh===true){object.getVertexPosition(i,_vector$b);}else {_vector$b.fromBufferAttribute(positionAttribute,i);}_vector$b.applyMatrix4(object.matrixWorld);this.expandByPoint(_vector$b);}}else {if(object.boundingBox!==undefined){// object-level bounding box
	if(object.boundingBox===null){object.computeBoundingBox();}_box$4.copy(object.boundingBox);}else {// geometry-level bounding box
	if(geometry.boundingBox===null){geometry.computeBoundingBox();}_box$4.copy(geometry.boundingBox);}_box$4.applyMatrix4(object.matrixWorld);this.union(_box$4);}}const children=object.children;for(let i=0,l=children.length;i<l;i++){this.expandByObject(children[i],precise);}return this;}containsPoint(point){return point.x>=this.min.x&&point.x<=this.max.x&&point.y>=this.min.y&&point.y<=this.max.y&&point.z>=this.min.z&&point.z<=this.max.z;}containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z;}getParameter(point,target){// This can potentially have a divide by zero if the box
	// has a size dimension of 0.
	return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z));}intersectsBox(box){// using 6 splitting planes to rule out intersections.
	return box.max.x>=this.min.x&&box.min.x<=this.max.x&&box.max.y>=this.min.y&&box.min.y<=this.max.y&&box.max.z>=this.min.z&&box.min.z<=this.max.z;}intersectsSphere(sphere){// Find the point on the AABB closest to the sphere center.
	this.clampPoint(sphere.center,_vector$b);// If that point is inside the sphere, the AABB and sphere intersect.
	return _vector$b.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;}intersectsPlane(plane){// We compute the minimum and maximum dot product values. If those values
	// are on the same side (back or front) of the plane, then there is no intersection.
	let min,max;if(plane.normal.x>0){min=plane.normal.x*this.min.x;max=plane.normal.x*this.max.x;}else {min=plane.normal.x*this.max.x;max=plane.normal.x*this.min.x;}if(plane.normal.y>0){min+=plane.normal.y*this.min.y;max+=plane.normal.y*this.max.y;}else {min+=plane.normal.y*this.max.y;max+=plane.normal.y*this.min.y;}if(plane.normal.z>0){min+=plane.normal.z*this.min.z;max+=plane.normal.z*this.max.z;}else {min+=plane.normal.z*this.max.z;max+=plane.normal.z*this.min.z;}return min<=-plane.constant&&max>=-plane.constant;}intersectsTriangle(triangle){if(this.isEmpty()){return false;}// compute box center and extents
	this.getCenter(_center$1);_extents$1.subVectors(this.max,_center$1);// translate triangle to aabb origin
	_v0$2.subVectors(triangle.a,_center$1);_v1$7.subVectors(triangle.b,_center$1);_v2$4.subVectors(triangle.c,_center$1);// compute edge vectors for triangle
	_f0$1.subVectors(_v1$7,_v0$2);_f1$1.subVectors(_v2$4,_v1$7);_f2$1.subVectors(_v0$2,_v2$4);// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
	// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
	// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
	let axes=[0,-_f0$1.z,_f0$1.y,0,-_f1$1.z,_f1$1.y,0,-_f2$1.z,_f2$1.y,_f0$1.z,0,-_f0$1.x,_f1$1.z,0,-_f1$1.x,_f2$1.z,0,-_f2$1.x,-_f0$1.y,_f0$1.x,0,-_f1$1.y,_f1$1.x,0,-_f2$1.y,_f2$1.x,0];if(!satForAxes$1(axes,_v0$2,_v1$7,_v2$4,_extents$1)){return false;}// test 3 face normals from the aabb
	axes=[1,0,0,0,1,0,0,0,1];if(!satForAxes$1(axes,_v0$2,_v1$7,_v2$4,_extents$1)){return false;}// finally testing the face normal of the triangle
	// use already existing triangle edge vectors here
	_triangleNormal$1.crossVectors(_f0$1,_f1$1);axes=[_triangleNormal$1.x,_triangleNormal$1.y,_triangleNormal$1.z];return satForAxes$1(axes,_v0$2,_v1$7,_v2$4,_extents$1);}clampPoint(point,target){return target.copy(point).clamp(this.min,this.max);}distanceToPoint(point){return this.clampPoint(point,_vector$b).distanceTo(point);}getBoundingSphere(target){if(this.isEmpty()){target.makeEmpty();}else {this.getCenter(target.center);target.radius=this.getSize(_vector$b).length()*0.5;}return target;}intersect(box){this.min.max(box.min);this.max.min(box.max);// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
	if(this.isEmpty())this.makeEmpty();return this;}union(box){this.min.min(box.min);this.max.max(box.max);return this;}applyMatrix4(matrix){// transform of empty box is an empty box.
	if(this.isEmpty())return this;// NOTE: I am using a binary pattern to specify all 2^3 combinations below
	_points$1[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000
	_points$1[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001
	_points$1[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010
	_points$1[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011
	_points$1[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100
	_points$1[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101
	_points$1[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110
	_points$1[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111
	this.setFromPoints(_points$1);return this;}translate(offset){this.min.add(offset);this.max.add(offset);return this;}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}};const _points$1=[/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1(),/*@__PURE__*/new Vector3$1()];const _vector$b=/*@__PURE__*/new Vector3$1();const _box$4=/*@__PURE__*/new Box3$1();// triangle centered vertices
	const _v0$2=/*@__PURE__*/new Vector3$1();const _v1$7=/*@__PURE__*/new Vector3$1();const _v2$4=/*@__PURE__*/new Vector3$1();// triangle edge vectors
	const _f0$1=/*@__PURE__*/new Vector3$1();const _f1$1=/*@__PURE__*/new Vector3$1();const _f2$1=/*@__PURE__*/new Vector3$1();const _center$1=/*@__PURE__*/new Vector3$1();const _extents$1=/*@__PURE__*/new Vector3$1();const _triangleNormal$1=/*@__PURE__*/new Vector3$1();const _testAxis$1=/*@__PURE__*/new Vector3$1();function satForAxes$1(axes,v0,v1,v2,extents){for(let i=0,j=axes.length-3;i<=j;i+=3){_testAxis$1.fromArray(axes,i);// project the aabb onto the separating axis
	const r=extents.x*Math.abs(_testAxis$1.x)+extents.y*Math.abs(_testAxis$1.y)+extents.z*Math.abs(_testAxis$1.z);// project all 3 vertices of the triangle onto the separating axis
	const p0=v0.dot(_testAxis$1);const p1=v1.dot(_testAxis$1);const p2=v2.dot(_testAxis$1);// actual test, basically see if either of the most extreme of the triangle points intersects r
	if(Math.max(-Math.max(p0,p1,p2),Math.min(p0,p1,p2))>r){// points of the projected triangle are outside the projected half-length of the aabb
	// the axis is separating and we can exit
	return false;}}return true;}const _box$3=/*@__PURE__*/new Box3$1();const _v1$6=/*@__PURE__*/new Vector3$1();const _v2$3=/*@__PURE__*/new Vector3$1();let Sphere$1 = class Sphere{constructor(center=new Vector3$1(),radius=-1){this.isSphere=true;this.center=center;this.radius=radius;}set(center,radius){this.center.copy(center);this.radius=radius;return this;}setFromPoints(points,optionalCenter){const center=this.center;if(optionalCenter!==undefined){center.copy(optionalCenter);}else {_box$3.setFromPoints(points).getCenter(center);}let maxRadiusSq=0;for(let i=0,il=points.length;i<il;i++){maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i]));}this.radius=Math.sqrt(maxRadiusSq);return this;}copy(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this;}isEmpty(){return this.radius<0;}makeEmpty(){this.center.set(0,0,0);this.radius=-1;return this;}containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius;}distanceToPoint(point){return point.distanceTo(this.center)-this.radius;}intersectsSphere(sphere){const radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;}intersectsBox(box){return box.intersectsSphere(this);}intersectsPlane(plane){return Math.abs(plane.distanceToPoint(this.center))<=this.radius;}clampPoint(point,target){const deltaLengthSq=this.center.distanceToSquared(point);target.copy(point);if(deltaLengthSq>this.radius*this.radius){target.sub(this.center).normalize();target.multiplyScalar(this.radius).add(this.center);}return target;}getBoundingBox(target){if(this.isEmpty()){// Empty sphere produces empty bounding box
	target.makeEmpty();return target;}target.set(this.center,this.center);target.expandByScalar(this.radius);return target;}applyMatrix4(matrix){this.center.applyMatrix4(matrix);this.radius=this.radius*matrix.getMaxScaleOnAxis();return this;}translate(offset){this.center.add(offset);return this;}expandByPoint(point){if(this.isEmpty()){this.center.copy(point);this.radius=0;return this;}_v1$6.subVectors(point,this.center);const lengthSq=_v1$6.lengthSq();if(lengthSq>this.radius*this.radius){// calculate the minimal sphere
	const length=Math.sqrt(lengthSq);const delta=(length-this.radius)*0.5;this.center.addScaledVector(_v1$6,delta/length);this.radius+=delta;}return this;}union(sphere){if(sphere.isEmpty()){return this;}if(this.isEmpty()){this.copy(sphere);return this;}if(this.center.equals(sphere.center)===true){this.radius=Math.max(this.radius,sphere.radius);}else {_v2$3.subVectors(sphere.center,this.center).setLength(sphere.radius);this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));}return this;}equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius;}clone(){return new this.constructor().copy(this);}};const _vector$a=/*@__PURE__*/new Vector3$1();const _segCenter=/*@__PURE__*/new Vector3$1();const _segDir=/*@__PURE__*/new Vector3$1();const _diff=/*@__PURE__*/new Vector3$1();const _edge1=/*@__PURE__*/new Vector3$1();const _edge2=/*@__PURE__*/new Vector3$1();const _normal$1=/*@__PURE__*/new Vector3$1();class Ray{constructor(origin=new Vector3$1(),direction=new Vector3$1(0,0,-1)){this.origin=origin;this.direction=direction;}set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this;}copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this;}at(t,target){return target.copy(this.origin).addScaledVector(this.direction,t);}lookAt(v){this.direction.copy(v).sub(this.origin).normalize();return this;}recast(t){this.origin.copy(this.at(t,_vector$a));return this;}closestPointToPoint(point,target){target.subVectors(point,this.origin);const directionDistance=target.dot(this.direction);if(directionDistance<0){return target.copy(this.origin);}return target.copy(this.origin).addScaledVector(this.direction,directionDistance);}distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point));}distanceSqToPoint(point){const directionDistance=_vector$a.subVectors(point,this.origin).dot(this.direction);// point behind the ray
	if(directionDistance<0){return this.origin.distanceToSquared(point);}_vector$a.copy(this.origin).addScaledVector(this.direction,directionDistance);return _vector$a.distanceToSquared(point);}distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
	// It returns the min distance between the ray and the segment
	// defined by v0 and v1
	// It can also set two optional targets :
	// - The closest point on the ray
	// - The closest point on the segment
	_segCenter.copy(v0).add(v1).multiplyScalar(0.5);_segDir.copy(v1).sub(v0).normalize();_diff.copy(this.origin).sub(_segCenter);const segExtent=v0.distanceTo(v1)*0.5;const a01=-this.direction.dot(_segDir);const b0=_diff.dot(this.direction);const b1=-_diff.dot(_segDir);const c=_diff.lengthSq();const det=Math.abs(1-a01*a01);let s0,s1,sqrDist,extDet;if(det>0){// The ray and segment are not parallel.
	s0=a01*b1-b0;s1=a01*b0-b1;extDet=segExtent*det;if(s0>=0){if(s1>=-extDet){if(s1<=extDet){// region 0
	// Minimum at interior points of ray and segment.
	const invDet=1/det;s0*=invDet;s1*=invDet;sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;}else {// region 1
	s1=segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else {// region 5
	s1=-segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else {if(s1<=-extDet){// region 4
	s0=Math.max(0,-(-a01*segExtent+b0));s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}else if(s1<=extDet){// region 3
	s0=0;s1=Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=s1*(s1+2*b1)+c;}else {// region 2
	s0=Math.max(0,-(a01*segExtent+b0));s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}}else {// Ray and segment are parallel.
	s1=a01>0?-segExtent:segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}if(optionalPointOnRay){optionalPointOnRay.copy(this.origin).addScaledVector(this.direction,s0);}if(optionalPointOnSegment){optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir,s1);}return sqrDist;}intersectSphere(sphere,target){_vector$a.subVectors(sphere.center,this.origin);const tca=_vector$a.dot(this.direction);const d2=_vector$a.dot(_vector$a)-tca*tca;const radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;const thc=Math.sqrt(radius2-d2);// t0 = first intersect point - entrance on front of sphere
	const t0=tca-thc;// t1 = second intersect point - exit point on back of sphere
	const t1=tca+thc;// test to see if t1 is behind the ray - if so, return null
	if(t1<0)return null;// test to see if t0 is behind the ray:
	// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
	// in order to always return an intersect point that is in front of the ray.
	if(t0<0)return this.at(t1,target);// else t0 is in front of the ray, so return the first collision point scaled by t0
	return this.at(t0,target);}intersectsSphere(sphere){return this.distanceSqToPoint(sphere.center)<=sphere.radius*sphere.radius;}distanceToPlane(plane){const denominator=plane.normal.dot(this.direction);if(denominator===0){// line is coplanar, return origin
	if(plane.distanceToPoint(this.origin)===0){return 0;}// Null is preferable to undefined since undefined means.... it is undefined
	return null;}const t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;// Return if the ray never intersects the plane
	return t>=0?t:null;}intersectPlane(plane,target){const t=this.distanceToPlane(plane);if(t===null){return null;}return this.at(t,target);}intersectsPlane(plane){// check if the ray lies on the plane first
	const distToPoint=plane.distanceToPoint(this.origin);if(distToPoint===0){return true;}const denominator=plane.normal.dot(this.direction);if(denominator*distToPoint<0){return true;}// ray origin is behind the plane (and is pointing behind it)
	return false;}intersectBox(box,target){let tmin,tmax,tymin,tymax,tzmin,tzmax;const invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z;const origin=this.origin;if(invdirx>=0){tmin=(box.min.x-origin.x)*invdirx;tmax=(box.max.x-origin.x)*invdirx;}else {tmin=(box.max.x-origin.x)*invdirx;tmax=(box.min.x-origin.x)*invdirx;}if(invdiry>=0){tymin=(box.min.y-origin.y)*invdiry;tymax=(box.max.y-origin.y)*invdiry;}else {tymin=(box.max.y-origin.y)*invdiry;tymax=(box.min.y-origin.y)*invdiry;}if(tmin>tymax||tymin>tmax)return null;if(tymin>tmin||isNaN(tmin))tmin=tymin;if(tymax<tmax||isNaN(tmax))tmax=tymax;if(invdirz>=0){tzmin=(box.min.z-origin.z)*invdirz;tzmax=(box.max.z-origin.z)*invdirz;}else {tzmin=(box.max.z-origin.z)*invdirz;tzmax=(box.min.z-origin.z)*invdirz;}if(tmin>tzmax||tzmin>tmax)return null;if(tzmin>tmin||tmin!==tmin)tmin=tzmin;if(tzmax<tmax||tmax!==tmax)tmax=tzmax;//return point closest to the ray (positive side)
	if(tmax<0)return null;return this.at(tmin>=0?tmin:tmax,target);}intersectsBox(box){return this.intersectBox(box,_vector$a)!==null;}intersectTriangle(a,b,c,backfaceCulling,target){// Compute the offset origin, edges, and normal.
	// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
	_edge1.subVectors(b,a);_edge2.subVectors(c,a);_normal$1.crossVectors(_edge1,_edge2);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
	// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
	//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
	//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
	//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
	let DdN=this.direction.dot(_normal$1);let sign;if(DdN>0){if(backfaceCulling)return null;sign=1;}else if(DdN<0){sign=-1;DdN=-DdN;}else {return null;}_diff.subVectors(this.origin,a);const DdQxE2=sign*this.direction.dot(_edge2.crossVectors(_diff,_edge2));// b1 < 0, no intersection
	if(DdQxE2<0){return null;}const DdE1xQ=sign*this.direction.dot(_edge1.cross(_diff));// b2 < 0, no intersection
	if(DdE1xQ<0){return null;}// b1+b2 > 1, no intersection
	if(DdQxE2+DdE1xQ>DdN){return null;}// Line intersects triangle, check if ray does.
	const QdN=-sign*_diff.dot(_normal$1);// t < 0, no intersection
	if(QdN<0){return null;}// Ray intersects triangle.
	return this.at(QdN/DdN,target);}applyMatrix4(matrix4){this.origin.applyMatrix4(matrix4);this.direction.transformDirection(matrix4);return this;}equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);}clone(){return new this.constructor().copy(this);}}let Matrix4$1 = class Matrix4{constructor(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){Matrix4.prototype.isMatrix4=true;this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];if(n11!==undefined){this.set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44);}}set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){const te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this;}identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this;}clone(){return new Matrix4().fromArray(this.elements);}copy(m){const te=this.elements;const me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];te[9]=me[9];te[10]=me[10];te[11]=me[11];te[12]=me[12];te[13]=me[13];te[14]=me[14];te[15]=me[15];return this;}copyPosition(m){const te=this.elements,me=m.elements;te[12]=me[12];te[13]=me[13];te[14]=me[14];return this;}setFromMatrix3(m){const me=m.elements;this.set(me[0],me[3],me[6],0,me[1],me[4],me[7],0,me[2],me[5],me[8],0,0,0,0,1);return this;}extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this;}makeBasis(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this;}extractRotation(m){// this method does not support reflection matrices
	const te=this.elements;const me=m.elements;const scaleX=1/_v1$5.setFromMatrixColumn(m,0).length();const scaleY=1/_v1$5.setFromMatrixColumn(m,1).length();const scaleZ=1/_v1$5.setFromMatrixColumn(m,2).length();te[0]=me[0]*scaleX;te[1]=me[1]*scaleX;te[2]=me[2]*scaleX;te[3]=0;te[4]=me[4]*scaleY;te[5]=me[5]*scaleY;te[6]=me[6]*scaleY;te[7]=0;te[8]=me[8]*scaleZ;te[9]=me[9]*scaleZ;te[10]=me[10]*scaleZ;te[11]=0;te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;}makeRotationFromEuler(euler){const te=this.elements;const x=euler.x,y=euler.y,z=euler.z;const a=Math.cos(x),b=Math.sin(x);const c=Math.cos(y),d=Math.sin(y);const e=Math.cos(z),f=Math.sin(z);if(euler.order==='XYZ'){const ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=-c*f;te[8]=d;te[1]=af+be*d;te[5]=ae-bf*d;te[9]=-b*c;te[2]=bf-ae*d;te[6]=be+af*d;te[10]=a*c;}else if(euler.order==='YXZ'){const ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b;te[4]=de*b-cf;te[8]=a*d;te[1]=a*f;te[5]=a*e;te[9]=-b;te[2]=cf*b-de;te[6]=df+ce*b;te[10]=a*c;}else if(euler.order==='ZXY'){const ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce-df*b;te[4]=-a*f;te[8]=de+cf*b;te[1]=cf+de*b;te[5]=a*e;te[9]=df-ce*b;te[2]=-a*d;te[6]=b;te[10]=a*c;}else if(euler.order==='ZYX'){const ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=be*d-af;te[8]=ae*d+bf;te[1]=c*f;te[5]=bf*d+ae;te[9]=af*d-be;te[2]=-d;te[6]=b*c;te[10]=a*c;}else if(euler.order==='YZX'){const ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=bd-ac*f;te[8]=bc*f+ad;te[1]=f;te[5]=a*e;te[9]=-b*e;te[2]=-d*e;te[6]=ad*f+bc;te[10]=ac-bd*f;}else if(euler.order==='XZY'){const ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=-f;te[8]=d*e;te[1]=ac*f+bd;te[5]=a*e;te[9]=ad*f-bc;te[2]=bc*f-ad;te[6]=b*e;te[10]=bd*f+ac;}// bottom row
	te[3]=0;te[7]=0;te[11]=0;// last column
	te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;}makeRotationFromQuaternion(q){return this.compose(_zero$1,q,_one$1);}lookAt(eye,target,up){const te=this.elements;_z$1.subVectors(eye,target);if(_z$1.lengthSq()===0){// eye and target are in the same position
	_z$1.z=1;}_z$1.normalize();_x$1.crossVectors(up,_z$1);if(_x$1.lengthSq()===0){// up and z are parallel
	if(Math.abs(up.z)===1){_z$1.x+=0.0001;}else {_z$1.z+=0.0001;}_z$1.normalize();_x$1.crossVectors(up,_z$1);}_x$1.normalize();_y$1.crossVectors(_z$1,_x$1);te[0]=_x$1.x;te[4]=_y$1.x;te[8]=_z$1.x;te[1]=_x$1.y;te[5]=_y$1.y;te[9]=_z$1.y;te[2]=_x$1.z;te[6]=_y$1.z;te[10]=_z$1.z;return this;}multiply(m){return this.multiplyMatrices(this,m);}premultiply(m){return this.multiplyMatrices(m,this);}multiplyMatrices(a,b){const ae=a.elements;const be=b.elements;const te=this.elements;const a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];const a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];const a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];const a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];const b11=be[0],b12=be[4],b13=be[8],b14=be[12];const b21=be[1],b22=be[5],b23=be[9],b24=be[13];const b31=be[2],b32=be[6],b33=be[10],b34=be[14];const b41=be[3],b42=be[7],b43=be[11],b44=be[15];te[0]=a11*b11+a12*b21+a13*b31+a14*b41;te[4]=a11*b12+a12*b22+a13*b32+a14*b42;te[8]=a11*b13+a12*b23+a13*b33+a14*b43;te[12]=a11*b14+a12*b24+a13*b34+a14*b44;te[1]=a21*b11+a22*b21+a23*b31+a24*b41;te[5]=a21*b12+a22*b22+a23*b32+a24*b42;te[9]=a21*b13+a22*b23+a23*b33+a24*b43;te[13]=a21*b14+a22*b24+a23*b34+a24*b44;te[2]=a31*b11+a32*b21+a33*b31+a34*b41;te[6]=a31*b12+a32*b22+a33*b32+a34*b42;te[10]=a31*b13+a32*b23+a33*b33+a34*b43;te[14]=a31*b14+a32*b24+a33*b34+a34*b44;te[3]=a41*b11+a42*b21+a43*b31+a44*b41;te[7]=a41*b12+a42*b22+a43*b32+a44*b42;te[11]=a41*b13+a42*b23+a43*b33+a44*b43;te[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this;}multiplyScalar(s){const te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this;}determinant(){const te=this.elements;const n11=te[0],n12=te[4],n13=te[8],n14=te[12];const n21=te[1],n22=te[5],n23=te[9],n24=te[13];const n31=te[2],n32=te[6],n33=te[10],n34=te[14];const n41=te[3],n42=te[7],n43=te[11],n44=te[15];//TODO: make this more efficient
	//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	return n41*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+n42*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+n43*(+n11*n24*n32-n11*n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+n44*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31);}transpose(){const te=this.elements;let tmp;tmp=te[1];te[1]=te[4];te[4]=tmp;tmp=te[2];te[2]=te[8];te[8]=tmp;tmp=te[6];te[6]=te[9];te[9]=tmp;tmp=te[3];te[3]=te[12];te[12]=tmp;tmp=te[7];te[7]=te[13];te[13]=tmp;tmp=te[11];te[11]=te[14];te[14]=tmp;return this;}setPosition(x,y,z){const te=this.elements;if(x.isVector3){te[12]=x.x;te[13]=x.y;te[14]=x.z;}else {te[12]=x;te[13]=y;te[14]=z;}return this;}invert(){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
	const te=this.elements,n11=te[0],n21=te[1],n31=te[2],n41=te[3],n12=te[4],n22=te[5],n32=te[6],n42=te[7],n13=te[8],n23=te[9],n33=te[10],n43=te[11],n14=te[12],n24=te[13],n34=te[14],n44=te[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;const det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const detInv=1/det;te[0]=t11*detInv;te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;te[4]=t12*detInv;te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;te[8]=t13*detInv;te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;te[12]=t14*detInv;te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this;}scale(v){const te=this.elements;const x=v.x,y=v.y,z=v.z;te[0]*=x;te[4]*=y;te[8]*=z;te[1]*=x;te[5]*=y;te[9]*=z;te[2]*=x;te[6]*=y;te[10]*=z;te[3]*=x;te[7]*=y;te[11]*=z;return this;}getMaxScaleOnAxis(){const te=this.elements;const scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];const scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];const scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));}makeTranslation(x,y,z){if(x.isVector3){this.set(1,0,0,x.x,0,1,0,x.y,0,0,1,x.z,0,0,0,1);}else {this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1);}return this;}makeRotationX(theta){const c=Math.cos(theta),s=Math.sin(theta);this.set(1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1);return this;}makeRotationY(theta){const c=Math.cos(theta),s=Math.sin(theta);this.set(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);return this;}makeRotationZ(theta){const c=Math.cos(theta),s=Math.sin(theta);this.set(c,-s,0,0,s,c,0,0,0,0,1,0,0,0,0,1);return this;}makeRotationAxis(axis,angle){// Based on http://www.gamedev.net/reference/articles/article1199.asp
	const c=Math.cos(angle);const s=Math.sin(angle);const t=1-c;const x=axis.x,y=axis.y,z=axis.z;const tx=t*x,ty=t*y;this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1);return this;}makeScale(x,y,z){this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);return this;}makeShear(xy,xz,yx,yz,zx,zy){this.set(1,yx,zx,0,xy,1,zy,0,xz,yz,1,0,0,0,0,1);return this;}compose(position,quaternion,scale){const te=this.elements;const x=quaternion._x,y=quaternion._y,z=quaternion._z,w=quaternion._w;const x2=x+x,y2=y+y,z2=z+z;const xx=x*x2,xy=x*y2,xz=x*z2;const yy=y*y2,yz=y*z2,zz=z*z2;const wx=w*x2,wy=w*y2,wz=w*z2;const sx=scale.x,sy=scale.y,sz=scale.z;te[0]=(1-(yy+zz))*sx;te[1]=(xy+wz)*sx;te[2]=(xz-wy)*sx;te[3]=0;te[4]=(xy-wz)*sy;te[5]=(1-(xx+zz))*sy;te[6]=(yz+wx)*sy;te[7]=0;te[8]=(xz+wy)*sz;te[9]=(yz-wx)*sz;te[10]=(1-(xx+yy))*sz;te[11]=0;te[12]=position.x;te[13]=position.y;te[14]=position.z;te[15]=1;return this;}decompose(position,quaternion,scale){const te=this.elements;let sx=_v1$5.set(te[0],te[1],te[2]).length();const sy=_v1$5.set(te[4],te[5],te[6]).length();const sz=_v1$5.set(te[8],te[9],te[10]).length();// if determine is negative, we need to invert one scale
	const det=this.determinant();if(det<0)sx=-sx;position.x=te[12];position.y=te[13];position.z=te[14];// scale the rotation part
	_m1$2$1.copy(this);const invSX=1/sx;const invSY=1/sy;const invSZ=1/sz;_m1$2$1.elements[0]*=invSX;_m1$2$1.elements[1]*=invSX;_m1$2$1.elements[2]*=invSX;_m1$2$1.elements[4]*=invSY;_m1$2$1.elements[5]*=invSY;_m1$2$1.elements[6]*=invSY;_m1$2$1.elements[8]*=invSZ;_m1$2$1.elements[9]*=invSZ;_m1$2$1.elements[10]*=invSZ;quaternion.setFromRotationMatrix(_m1$2$1);scale.x=sx;scale.y=sy;scale.z=sz;return this;}makePerspective(left,right,top,bottom,near,far,coordinateSystem=WebGLCoordinateSystem$1){const te=this.elements;const x=2*near/(right-left);const y=2*near/(top-bottom);const a=(right+left)/(right-left);const b=(top+bottom)/(top-bottom);let c,d;if(coordinateSystem===WebGLCoordinateSystem$1){c=-(far+near)/(far-near);d=-2*far*near/(far-near);}else if(coordinateSystem===WebGPUCoordinateSystem$1){c=-far/(far-near);d=-far*near/(far-near);}else {throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: '+coordinateSystem);}te[0]=x;te[4]=0;te[8]=a;te[12]=0;te[1]=0;te[5]=y;te[9]=b;te[13]=0;te[2]=0;te[6]=0;te[10]=c;te[14]=d;te[3]=0;te[7]=0;te[11]=-1;te[15]=0;return this;}makeOrthographic(left,right,top,bottom,near,far,coordinateSystem=WebGLCoordinateSystem$1){const te=this.elements;const w=1.0/(right-left);const h=1.0/(top-bottom);const p=1.0/(far-near);const x=(right+left)*w;const y=(top+bottom)*h;let z,zInv;if(coordinateSystem===WebGLCoordinateSystem$1){z=(far+near)*p;zInv=-2*p;}else if(coordinateSystem===WebGPUCoordinateSystem$1){z=near*p;zInv=-1*p;}else {throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: '+coordinateSystem);}te[0]=2*w;te[4]=0;te[8]=0;te[12]=-x;te[1]=0;te[5]=2*h;te[9]=0;te[13]=-y;te[2]=0;te[6]=0;te[10]=zInv;te[14]=-z;te[3]=0;te[7]=0;te[11]=0;te[15]=1;return this;}equals(matrix){const te=this.elements;const me=matrix.elements;for(let i=0;i<16;i++){if(te[i]!==me[i])return false;}return true;}fromArray(array,offset=0){for(let i=0;i<16;i++){this.elements[i]=array[i+offset];}return this;}toArray(array=[],offset=0){const te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];array[offset+9]=te[9];array[offset+10]=te[10];array[offset+11]=te[11];array[offset+12]=te[12];array[offset+13]=te[13];array[offset+14]=te[14];array[offset+15]=te[15];return array;}};const _v1$5=/*@__PURE__*/new Vector3$1();const _m1$2$1=/*@__PURE__*/new Matrix4$1();const _zero$1=/*@__PURE__*/new Vector3$1(0,0,0);const _one$1=/*@__PURE__*/new Vector3$1(1,1,1);const _x$1=/*@__PURE__*/new Vector3$1();const _y$1=/*@__PURE__*/new Vector3$1();const _z$1=/*@__PURE__*/new Vector3$1();const _matrix$2=/*@__PURE__*/new Matrix4$1();const _quaternion$3=/*@__PURE__*/new Quaternion$1();let Euler$1 = class Euler{constructor(x=0,y=0,z=0,order=Euler.DEFAULT_ORDER){this.isEuler=true;this._x=x;this._y=y;this._z=z;this._order=order;}get x(){return this._x;}set x(value){this._x=value;this._onChangeCallback();}get y(){return this._y;}set y(value){this._y=value;this._onChangeCallback();}get z(){return this._z;}set z(value){this._z=value;this._onChangeCallback();}get order(){return this._order;}set order(value){this._order=value;this._onChangeCallback();}set(x,y,z,order=this._order){this._x=x;this._y=y;this._z=z;this._order=order;this._onChangeCallback();return this;}clone(){return new this.constructor(this._x,this._y,this._z,this._order);}copy(euler){this._x=euler._x;this._y=euler._y;this._z=euler._z;this._order=euler._order;this._onChangeCallback();return this;}setFromRotationMatrix(m,order=this._order,update=true){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	const te=m.elements;const m11=te[0],m12=te[4],m13=te[8];const m21=te[1],m22=te[5],m23=te[9];const m31=te[2],m32=te[6],m33=te[10];switch(order){case'XYZ':this._y=Math.asin(clamp$1(m13,-1,1));if(Math.abs(m13)<0.9999999){this._x=Math.atan2(-m23,m33);this._z=Math.atan2(-m12,m11);}else {this._x=Math.atan2(m32,m22);this._z=0;}break;case'YXZ':this._x=Math.asin(-clamp$1(m23,-1,1));if(Math.abs(m23)<0.9999999){this._y=Math.atan2(m13,m33);this._z=Math.atan2(m21,m22);}else {this._y=Math.atan2(-m31,m11);this._z=0;}break;case'ZXY':this._x=Math.asin(clamp$1(m32,-1,1));if(Math.abs(m32)<0.9999999){this._y=Math.atan2(-m31,m33);this._z=Math.atan2(-m12,m22);}else {this._y=0;this._z=Math.atan2(m21,m11);}break;case'ZYX':this._y=Math.asin(-clamp$1(m31,-1,1));if(Math.abs(m31)<0.9999999){this._x=Math.atan2(m32,m33);this._z=Math.atan2(m21,m11);}else {this._x=0;this._z=Math.atan2(-m12,m22);}break;case'YZX':this._z=Math.asin(clamp$1(m21,-1,1));if(Math.abs(m21)<0.9999999){this._x=Math.atan2(-m23,m22);this._y=Math.atan2(-m31,m11);}else {this._x=0;this._y=Math.atan2(m13,m33);}break;case'XZY':this._z=Math.asin(-clamp$1(m12,-1,1));if(Math.abs(m12)<0.9999999){this._x=Math.atan2(m32,m22);this._y=Math.atan2(m13,m11);}else {this._x=Math.atan2(-m23,m33);this._y=0;}break;default:console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: '+order);}this._order=order;if(update===true)this._onChangeCallback();return this;}setFromQuaternion(q,order,update){_matrix$2.makeRotationFromQuaternion(q);return this.setFromRotationMatrix(_matrix$2,order,update);}setFromVector3(v,order=this._order){return this.set(v.x,v.y,v.z,order);}reorder(newOrder){// WARNING: this discards revolution information -bhouston
	_quaternion$3.setFromEuler(this);return this.setFromQuaternion(_quaternion$3,newOrder);}equals(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;}fromArray(array){this._x=array[0];this._y=array[1];this._z=array[2];if(array[3]!==undefined)this._order=array[3];this._onChangeCallback();return this;}toArray(array=[],offset=0){array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._order;return array;}_onChange(callback){this._onChangeCallback=callback;return this;}_onChangeCallback(){}*[Symbol.iterator](){yield this._x;yield this._y;yield this._z;yield this._order;}};Euler$1.DEFAULT_ORDER='XYZ';let Layers$1 = class Layers{constructor(){this.mask=1|0;}set(channel){this.mask=(1<<channel|0)>>>0;}enable(channel){this.mask|=1<<channel|0;}enableAll(){this.mask=0xffffffff|0;}toggle(channel){this.mask^=1<<channel|0;}disable(channel){this.mask&=~(1<<channel|0);}disableAll(){this.mask=0;}test(layers){return (this.mask&layers.mask)!==0;}isEnabled(channel){return (this.mask&(1<<channel|0))!==0;}};let _object3DId$1=0;const _v1$4=/*@__PURE__*/new Vector3$1();const _q1$1=/*@__PURE__*/new Quaternion$1();const _m1$1$2=/*@__PURE__*/new Matrix4$1();const _target$1=/*@__PURE__*/new Vector3$1();const _position$3=/*@__PURE__*/new Vector3$1();const _scale$2=/*@__PURE__*/new Vector3$1();const _quaternion$2$1=/*@__PURE__*/new Quaternion$1();const _xAxis$1=/*@__PURE__*/new Vector3$1(1,0,0);const _yAxis$1=/*@__PURE__*/new Vector3$1(0,1,0);const _zAxis$1=/*@__PURE__*/new Vector3$1(0,0,1);const _addedEvent$1={type:'added'};const _removedEvent$1={type:'removed'};const _childaddedEvent$1={type:'childadded',child:null};const _childremovedEvent$1={type:'childremoved',child:null};let Object3D$1 = class Object3D extends EventDispatcher$1{constructor(){super();this.isObject3D=true;Object.defineProperty(this,'id',{value:_object3DId$1++});this.uuid=generateUUID$1();this.name='';this.type='Object3D';this.parent=null;this.children=[];this.up=Object3D.DEFAULT_UP.clone();const position=new Vector3$1();const rotation=new Euler$1();const quaternion=new Quaternion$1();const scale=new Vector3$1(1,1,1);function onRotationChange(){quaternion.setFromEuler(rotation,false);}function onQuaternionChange(){rotation.setFromQuaternion(quaternion,undefined,false);}rotation._onChange(onRotationChange);quaternion._onChange(onQuaternionChange);Object.defineProperties(this,{position:{configurable:true,enumerable:true,value:position},rotation:{configurable:true,enumerable:true,value:rotation},quaternion:{configurable:true,enumerable:true,value:quaternion},scale:{configurable:true,enumerable:true,value:scale},modelViewMatrix:{value:new Matrix4$1()},normalMatrix:{value:new Matrix3$1()}});this.matrix=new Matrix4$1();this.matrixWorld=new Matrix4$1();this.matrixAutoUpdate=Object3D.DEFAULT_MATRIX_AUTO_UPDATE;this.matrixWorldAutoUpdate=Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;// checked by the renderer
	this.matrixWorldNeedsUpdate=false;this.layers=new Layers$1();this.visible=true;this.castShadow=false;this.receiveShadow=false;this.frustumCulled=true;this.renderOrder=0;this.animations=[];this.userData={};}onBeforeShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */){}onAfterShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */){}onBeforeRender(/* renderer, scene, camera, geometry, material, group */){}onAfterRender(/* renderer, scene, camera, geometry, material, group */){}applyMatrix4(matrix){if(this.matrixAutoUpdate)this.updateMatrix();this.matrix.premultiply(matrix);this.matrix.decompose(this.position,this.quaternion,this.scale);}applyQuaternion(q){this.quaternion.premultiply(q);return this;}setRotationFromAxisAngle(axis,angle){// assumes axis is normalized
	this.quaternion.setFromAxisAngle(axis,angle);}setRotationFromEuler(euler){this.quaternion.setFromEuler(euler,true);}setRotationFromMatrix(m){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	this.quaternion.setFromRotationMatrix(m);}setRotationFromQuaternion(q){// assumes q is normalized
	this.quaternion.copy(q);}rotateOnAxis(axis,angle){// rotate object on axis in object space
	// axis is assumed to be normalized
	_q1$1.setFromAxisAngle(axis,angle);this.quaternion.multiply(_q1$1);return this;}rotateOnWorldAxis(axis,angle){// rotate object on axis in world space
	// axis is assumed to be normalized
	// method assumes no rotated parent
	_q1$1.setFromAxisAngle(axis,angle);this.quaternion.premultiply(_q1$1);return this;}rotateX(angle){return this.rotateOnAxis(_xAxis$1,angle);}rotateY(angle){return this.rotateOnAxis(_yAxis$1,angle);}rotateZ(angle){return this.rotateOnAxis(_zAxis$1,angle);}translateOnAxis(axis,distance){// translate object by distance along axis in object space
	// axis is assumed to be normalized
	_v1$4.copy(axis).applyQuaternion(this.quaternion);this.position.add(_v1$4.multiplyScalar(distance));return this;}translateX(distance){return this.translateOnAxis(_xAxis$1,distance);}translateY(distance){return this.translateOnAxis(_yAxis$1,distance);}translateZ(distance){return this.translateOnAxis(_zAxis$1,distance);}localToWorld(vector){this.updateWorldMatrix(true,false);return vector.applyMatrix4(this.matrixWorld);}worldToLocal(vector){this.updateWorldMatrix(true,false);return vector.applyMatrix4(_m1$1$2.copy(this.matrixWorld).invert());}lookAt(x,y,z){// This method does not support objects having non-uniformly-scaled parent(s)
	if(x.isVector3){_target$1.copy(x);}else {_target$1.set(x,y,z);}const parent=this.parent;this.updateWorldMatrix(true,false);_position$3.setFromMatrixPosition(this.matrixWorld);if(this.isCamera||this.isLight){_m1$1$2.lookAt(_position$3,_target$1,this.up);}else {_m1$1$2.lookAt(_target$1,_position$3,this.up);}this.quaternion.setFromRotationMatrix(_m1$1$2);if(parent){_m1$1$2.extractRotation(parent.matrixWorld);_q1$1.setFromRotationMatrix(_m1$1$2);this.quaternion.premultiply(_q1$1.invert());}}add(object){if(arguments.length>1){for(let i=0;i<arguments.length;i++){this.add(arguments[i]);}return this;}if(object===this){console.error('THREE.Object3D.add: object can\'t be added as a child of itself.',object);return this;}if(object&&object.isObject3D){object.removeFromParent();object.parent=this;this.children.push(object);object.dispatchEvent(_addedEvent$1);_childaddedEvent$1.child=object;this.dispatchEvent(_childaddedEvent$1);_childaddedEvent$1.child=null;}else {console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.',object);}return this;}remove(object){if(arguments.length>1){for(let i=0;i<arguments.length;i++){this.remove(arguments[i]);}return this;}const index=this.children.indexOf(object);if(index!==-1){object.parent=null;this.children.splice(index,1);object.dispatchEvent(_removedEvent$1);_childremovedEvent$1.child=object;this.dispatchEvent(_childremovedEvent$1);_childremovedEvent$1.child=null;}return this;}removeFromParent(){const parent=this.parent;if(parent!==null){parent.remove(this);}return this;}clear(){return this.remove(...this.children);}attach(object){// adds object as a child of this, while maintaining the object's world transform
	// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
	this.updateWorldMatrix(true,false);_m1$1$2.copy(this.matrixWorld).invert();if(object.parent!==null){object.parent.updateWorldMatrix(true,false);_m1$1$2.multiply(object.parent.matrixWorld);}object.applyMatrix4(_m1$1$2);object.removeFromParent();object.parent=this;this.children.push(object);object.updateWorldMatrix(false,true);object.dispatchEvent(_addedEvent$1);_childaddedEvent$1.child=object;this.dispatchEvent(_childaddedEvent$1);_childaddedEvent$1.child=null;return this;}getObjectById(id){return this.getObjectByProperty('id',id);}getObjectByName(name){return this.getObjectByProperty('name',name);}getObjectByProperty(name,value){if(this[name]===value)return this;for(let i=0,l=this.children.length;i<l;i++){const child=this.children[i];const object=child.getObjectByProperty(name,value);if(object!==undefined){return object;}}return undefined;}getObjectsByProperty(name,value,result=[]){if(this[name]===value)result.push(this);const children=this.children;for(let i=0,l=children.length;i<l;i++){children[i].getObjectsByProperty(name,value,result);}return result;}getWorldPosition(target){this.updateWorldMatrix(true,false);return target.setFromMatrixPosition(this.matrixWorld);}getWorldQuaternion(target){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_position$3,target,_scale$2);return target;}getWorldScale(target){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_position$3,_quaternion$2$1,target);return target;}getWorldDirection(target){this.updateWorldMatrix(true,false);const e=this.matrixWorld.elements;return target.set(e[8],e[9],e[10]).normalize();}raycast(/* raycaster, intersects */){}traverse(callback){callback(this);const children=this.children;for(let i=0,l=children.length;i<l;i++){children[i].traverse(callback);}}traverseVisible(callback){if(this.visible===false)return;callback(this);const children=this.children;for(let i=0,l=children.length;i<l;i++){children[i].traverseVisible(callback);}}traverseAncestors(callback){const parent=this.parent;if(parent!==null){callback(parent);parent.traverseAncestors(callback);}}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=true;}updateMatrixWorld(force){if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldNeedsUpdate||force){if(this.matrixWorldAutoUpdate===true){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else {this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}}this.matrixWorldNeedsUpdate=false;force=true;}// make sure descendants are updated if required
	const children=this.children;for(let i=0,l=children.length;i<l;i++){const child=children[i];child.updateMatrixWorld(force);}}updateWorldMatrix(updateParents,updateChildren){const parent=this.parent;if(updateParents===true&&parent!==null){parent.updateWorldMatrix(true,false);}if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldAutoUpdate===true){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else {this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}}// make sure descendants are updated
	if(updateChildren===true){const children=this.children;for(let i=0,l=children.length;i<l;i++){const child=children[i];child.updateWorldMatrix(false,true);}}}toJSON(meta){// meta is a string when called from JSON.stringify
	const isRootObject=meta===undefined||typeof meta==='string';const output={};// meta is a hash used to collect geometries, materials.
	// not providing it implies that this is the root object
	// being serialized.
	if(isRootObject){// initialize meta obj
	meta={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}};output.metadata={version:4.6,type:'Object',generator:'Object3D.toJSON'};}// standard Object3D serialization
	const object={};object.uuid=this.uuid;object.type=this.type;if(this.name!=='')object.name=this.name;if(this.castShadow===true)object.castShadow=true;if(this.receiveShadow===true)object.receiveShadow=true;if(this.visible===false)object.visible=false;if(this.frustumCulled===false)object.frustumCulled=false;if(this.renderOrder!==0)object.renderOrder=this.renderOrder;if(Object.keys(this.userData).length>0)object.userData=this.userData;object.layers=this.layers.mask;object.matrix=this.matrix.toArray();object.up=this.up.toArray();if(this.matrixAutoUpdate===false)object.matrixAutoUpdate=false;// object specific properties
	if(this.isInstancedMesh){object.type='InstancedMesh';object.count=this.count;object.instanceMatrix=this.instanceMatrix.toJSON();if(this.instanceColor!==null)object.instanceColor=this.instanceColor.toJSON();}if(this.isBatchedMesh){object.type='BatchedMesh';object.perObjectFrustumCulled=this.perObjectFrustumCulled;object.sortObjects=this.sortObjects;object.drawRanges=this._drawRanges;object.reservedRanges=this._reservedRanges;object.visibility=this._visibility;object.active=this._active;object.bounds=this._bounds.map(bound=>({boxInitialized:bound.boxInitialized,boxMin:bound.box.min.toArray(),boxMax:bound.box.max.toArray(),sphereInitialized:bound.sphereInitialized,sphereRadius:bound.sphere.radius,sphereCenter:bound.sphere.center.toArray()}));object.maxInstanceCount=this._maxInstanceCount;object.maxVertexCount=this._maxVertexCount;object.maxIndexCount=this._maxIndexCount;object.geometryInitialized=this._geometryInitialized;object.geometryCount=this._geometryCount;object.matricesTexture=this._matricesTexture.toJSON(meta);if(this._colorsTexture!==null)object.colorsTexture=this._colorsTexture.toJSON(meta);if(this.boundingSphere!==null){object.boundingSphere={center:object.boundingSphere.center.toArray(),radius:object.boundingSphere.radius};}if(this.boundingBox!==null){object.boundingBox={min:object.boundingBox.min.toArray(),max:object.boundingBox.max.toArray()};}}//
	function serialize(library,element){if(library[element.uuid]===undefined){library[element.uuid]=element.toJSON(meta);}return element.uuid;}if(this.isScene){if(this.background){if(this.background.isColor){object.background=this.background.toJSON();}else if(this.background.isTexture){object.background=this.background.toJSON(meta).uuid;}}if(this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==true){object.environment=this.environment.toJSON(meta).uuid;}}else if(this.isMesh||this.isLine||this.isPoints){object.geometry=serialize(meta.geometries,this.geometry);const parameters=this.geometry.parameters;if(parameters!==undefined&&parameters.shapes!==undefined){const shapes=parameters.shapes;if(Array.isArray(shapes)){for(let i=0,l=shapes.length;i<l;i++){const shape=shapes[i];serialize(meta.shapes,shape);}}else {serialize(meta.shapes,shapes);}}}if(this.isSkinnedMesh){object.bindMode=this.bindMode;object.bindMatrix=this.bindMatrix.toArray();if(this.skeleton!==undefined){serialize(meta.skeletons,this.skeleton);object.skeleton=this.skeleton.uuid;}}if(this.material!==undefined){if(Array.isArray(this.material)){const uuids=[];for(let i=0,l=this.material.length;i<l;i++){uuids.push(serialize(meta.materials,this.material[i]));}object.material=uuids;}else {object.material=serialize(meta.materials,this.material);}}//
	if(this.children.length>0){object.children=[];for(let i=0;i<this.children.length;i++){object.children.push(this.children[i].toJSON(meta).object);}}//
	if(this.animations.length>0){object.animations=[];for(let i=0;i<this.animations.length;i++){const animation=this.animations[i];object.animations.push(serialize(meta.animations,animation));}}if(isRootObject){const geometries=extractFromCache(meta.geometries);const materials=extractFromCache(meta.materials);const textures=extractFromCache(meta.textures);const images=extractFromCache(meta.images);const shapes=extractFromCache(meta.shapes);const skeletons=extractFromCache(meta.skeletons);const animations=extractFromCache(meta.animations);const nodes=extractFromCache(meta.nodes);if(geometries.length>0)output.geometries=geometries;if(materials.length>0)output.materials=materials;if(textures.length>0)output.textures=textures;if(images.length>0)output.images=images;if(shapes.length>0)output.shapes=shapes;if(skeletons.length>0)output.skeletons=skeletons;if(animations.length>0)output.animations=animations;if(nodes.length>0)output.nodes=nodes;}output.object=object;return output;// extract data from the cache hash
	// remove metadata on each item
	// and return as array
	function extractFromCache(cache){const values=[];for(const key in cache){const data=cache[key];delete data.metadata;values.push(data);}return values;}}clone(recursive){return new this.constructor().copy(this,recursive);}copy(source,recursive=true){this.name=source.name;this.up.copy(source.up);this.position.copy(source.position);this.rotation.order=source.rotation.order;this.quaternion.copy(source.quaternion);this.scale.copy(source.scale);this.matrix.copy(source.matrix);this.matrixWorld.copy(source.matrixWorld);this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrixWorldAutoUpdate=source.matrixWorldAutoUpdate;this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;this.layers.mask=source.layers.mask;this.visible=source.visible;this.castShadow=source.castShadow;this.receiveShadow=source.receiveShadow;this.frustumCulled=source.frustumCulled;this.renderOrder=source.renderOrder;this.animations=source.animations.slice();this.userData=JSON.parse(JSON.stringify(source.userData));if(recursive===true){for(let i=0;i<source.children.length;i++){const child=source.children[i];this.add(child.clone());}}return this;}};Object3D$1.DEFAULT_UP=/*@__PURE__*/new Vector3$1(0,1,0);Object3D$1.DEFAULT_MATRIX_AUTO_UPDATE=true;Object3D$1.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=true;const _v0$1$1=/*@__PURE__*/new Vector3$1();const _v1$3$1=/*@__PURE__*/new Vector3$1();const _v2$2=/*@__PURE__*/new Vector3$1();const _v3$2=/*@__PURE__*/new Vector3$1();const _vab=/*@__PURE__*/new Vector3$1();const _vac=/*@__PURE__*/new Vector3$1();const _vbc=/*@__PURE__*/new Vector3$1();const _vap=/*@__PURE__*/new Vector3$1();const _vbp=/*@__PURE__*/new Vector3$1();const _vcp=/*@__PURE__*/new Vector3$1();const _v40=/*@__PURE__*/new Vector4();const _v41=/*@__PURE__*/new Vector4();const _v42=/*@__PURE__*/new Vector4();class Triangle{constructor(a=new Vector3$1(),b=new Vector3$1(),c=new Vector3$1()){this.a=a;this.b=b;this.c=c;}static getNormal(a,b,c,target){target.subVectors(c,b);_v0$1$1.subVectors(a,b);target.cross(_v0$1$1);const targetLengthSq=target.lengthSq();if(targetLengthSq>0){return target.multiplyScalar(1/Math.sqrt(targetLengthSq));}return target.set(0,0,0);}// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord(point,a,b,c,target){_v0$1$1.subVectors(c,a);_v1$3$1.subVectors(b,a);_v2$2.subVectors(point,a);const dot00=_v0$1$1.dot(_v0$1$1);const dot01=_v0$1$1.dot(_v1$3$1);const dot02=_v0$1$1.dot(_v2$2);const dot11=_v1$3$1.dot(_v1$3$1);const dot12=_v1$3$1.dot(_v2$2);const denom=dot00*dot11-dot01*dot01;// collinear or singular triangle
	if(denom===0){target.set(0,0,0);return null;}const invDenom=1/denom;const u=(dot11*dot02-dot01*dot12)*invDenom;const v=(dot00*dot12-dot01*dot02)*invDenom;// barycentric coordinates must always sum to 1
	return target.set(1-u-v,v,u);}static containsPoint(point,a,b,c){// if the triangle is degenerate then we can't contain a point
	if(this.getBarycoord(point,a,b,c,_v3$2)===null){return false;}return _v3$2.x>=0&&_v3$2.y>=0&&_v3$2.x+_v3$2.y<=1;}static getInterpolation(point,p1,p2,p3,v1,v2,v3,target){if(this.getBarycoord(point,p1,p2,p3,_v3$2)===null){target.x=0;target.y=0;if('z'in target)target.z=0;if('w'in target)target.w=0;return null;}target.setScalar(0);target.addScaledVector(v1,_v3$2.x);target.addScaledVector(v2,_v3$2.y);target.addScaledVector(v3,_v3$2.z);return target;}static getInterpolatedAttribute(attr,i1,i2,i3,barycoord,target){_v40.setScalar(0);_v41.setScalar(0);_v42.setScalar(0);_v40.fromBufferAttribute(attr,i1);_v41.fromBufferAttribute(attr,i2);_v42.fromBufferAttribute(attr,i3);target.setScalar(0);target.addScaledVector(_v40,barycoord.x);target.addScaledVector(_v41,barycoord.y);target.addScaledVector(_v42,barycoord.z);return target;}static isFrontFacing(a,b,c,direction){_v0$1$1.subVectors(c,b);_v1$3$1.subVectors(a,b);// strictly front facing
	return _v0$1$1.cross(_v1$3$1).dot(direction)<0?true:false;}set(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this;}setFromPointsAndIndices(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this;}setFromAttributeAndIndices(attribute,i0,i1,i2){this.a.fromBufferAttribute(attribute,i0);this.b.fromBufferAttribute(attribute,i1);this.c.fromBufferAttribute(attribute,i2);return this;}clone(){return new this.constructor().copy(this);}copy(triangle){this.a.copy(triangle.a);this.b.copy(triangle.b);this.c.copy(triangle.c);return this;}getArea(){_v0$1$1.subVectors(this.c,this.b);_v1$3$1.subVectors(this.a,this.b);return _v0$1$1.cross(_v1$3$1).length()*0.5;}getMidpoint(target){return target.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);}getNormal(target){return Triangle.getNormal(this.a,this.b,this.c,target);}getPlane(target){return target.setFromCoplanarPoints(this.a,this.b,this.c);}getBarycoord(point,target){return Triangle.getBarycoord(point,this.a,this.b,this.c,target);}getInterpolation(point,v1,v2,v3,target){return Triangle.getInterpolation(point,this.a,this.b,this.c,v1,v2,v3,target);}containsPoint(point){return Triangle.containsPoint(point,this.a,this.b,this.c);}isFrontFacing(direction){return Triangle.isFrontFacing(this.a,this.b,this.c,direction);}intersectsBox(box){return box.intersectsTriangle(this);}closestPointToPoint(p,target){const a=this.a,b=this.b,c=this.c;let v,w;// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
	// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
	// under the accompanying license; see chapter 5.1.5 for detailed explanation.
	// basically, we're distinguishing which of the voronoi regions of the triangle
	// the point lies in with the minimum amount of redundant computation.
	_vab.subVectors(b,a);_vac.subVectors(c,a);_vap.subVectors(p,a);const d1=_vab.dot(_vap);const d2=_vac.dot(_vap);if(d1<=0&&d2<=0){// vertex region of A; barycentric coords (1, 0, 0)
	return target.copy(a);}_vbp.subVectors(p,b);const d3=_vab.dot(_vbp);const d4=_vac.dot(_vbp);if(d3>=0&&d4<=d3){// vertex region of B; barycentric coords (0, 1, 0)
	return target.copy(b);}const vc=d1*d4-d3*d2;if(vc<=0&&d1>=0&&d3<=0){v=d1/(d1-d3);// edge region of AB; barycentric coords (1-v, v, 0)
	return target.copy(a).addScaledVector(_vab,v);}_vcp.subVectors(p,c);const d5=_vab.dot(_vcp);const d6=_vac.dot(_vcp);if(d6>=0&&d5<=d6){// vertex region of C; barycentric coords (0, 0, 1)
	return target.copy(c);}const vb=d5*d2-d1*d6;if(vb<=0&&d2>=0&&d6<=0){w=d2/(d2-d6);// edge region of AC; barycentric coords (1-w, 0, w)
	return target.copy(a).addScaledVector(_vac,w);}const va=d3*d6-d5*d4;if(va<=0&&d4-d3>=0&&d5-d6>=0){_vbc.subVectors(c,b);w=(d4-d3)/(d4-d3+(d5-d6));// edge region of BC; barycentric coords (0, 1-w, w)
	return target.copy(b).addScaledVector(_vbc,w);// edge region of BC
	}// face region
	const denom=1/(va+vb+vc);// u = va * denom
	v=vb*denom;w=vc*denom;return target.copy(a).addScaledVector(_vab,v).addScaledVector(_vac,w);}equals(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);}}const _colorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'rebeccapurple':0x663399,'red':0xFF0000,'rosybrown':0xBC8F8F,'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};const _hslA={h:0,s:0,l:0};const _hslB={h:0,s:0,l:0};function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*6*(2/3-t);return p;}class Color{constructor(r,g,b){this.isColor=true;this.r=1;this.g=1;this.b=1;return this.set(r,g,b);}set(r,g,b){if(g===undefined&&b===undefined){// r is THREE.Color, hex or string
	const value=r;if(value&&value.isColor){this.copy(value);}else if(typeof value==='number'){this.setHex(value);}else if(typeof value==='string'){this.setStyle(value);}}else {this.setRGB(r,g,b);}return this;}setScalar(scalar){this.r=scalar;this.g=scalar;this.b=scalar;return this;}setHex(hex,colorSpace=SRGBColorSpace){hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;ColorManagement.toWorkingColorSpace(this,colorSpace);return this;}setRGB(r,g,b,colorSpace=ColorManagement.workingColorSpace){this.r=r;this.g=g;this.b=b;ColorManagement.toWorkingColorSpace(this,colorSpace);return this;}setHSL(h,s,l,colorSpace=ColorManagement.workingColorSpace){// h,s,l ranges are in 0.0 - 1.0
	h=euclideanModulo(h,1);s=clamp$1(s,0,1);l=clamp$1(l,0,1);if(s===0){this.r=this.g=this.b=l;}else {const p=l<=0.5?l*(1+s):l+s-l*s;const q=2*l-p;this.r=hue2rgb(q,p,h+1/3);this.g=hue2rgb(q,p,h);this.b=hue2rgb(q,p,h-1/3);}ColorManagement.toWorkingColorSpace(this,colorSpace);return this;}setStyle(style,colorSpace=SRGBColorSpace){function handleAlpha(string){if(string===undefined)return;if(parseFloat(string)<1){console.warn('THREE.Color: Alpha component of '+style+' will be ignored.');}}let m;if(m=/^(\w+)\(([^\)]*)\)/.exec(style)){// rgb / hsl
	let color;const name=m[1];const components=m[2];switch(name){case'rgb':case'rgba':if(color=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// rgb(255,0,0) rgba(255,0,0,0.5)
	handleAlpha(color[4]);return this.setRGB(Math.min(255,parseInt(color[1],10))/255,Math.min(255,parseInt(color[2],10))/255,Math.min(255,parseInt(color[3],10))/255,colorSpace);}if(color=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
	handleAlpha(color[4]);return this.setRGB(Math.min(100,parseInt(color[1],10))/100,Math.min(100,parseInt(color[2],10))/100,Math.min(100,parseInt(color[3],10))/100,colorSpace);}break;case'hsl':case'hsla':if(color=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
	handleAlpha(color[4]);return this.setHSL(parseFloat(color[1])/360,parseFloat(color[2])/100,parseFloat(color[3])/100,colorSpace);}break;default:console.warn('THREE.Color: Unknown color model '+style);}}else if(m=/^\#([A-Fa-f\d]+)$/.exec(style)){// hex color
	const hex=m[1];const size=hex.length;if(size===3){// #ff0
	return this.setRGB(parseInt(hex.charAt(0),16)/15,parseInt(hex.charAt(1),16)/15,parseInt(hex.charAt(2),16)/15,colorSpace);}else if(size===6){// #ff0000
	return this.setHex(parseInt(hex,16),colorSpace);}else {console.warn('THREE.Color: Invalid hex color '+style);}}else if(style&&style.length>0){return this.setColorName(style,colorSpace);}return this;}setColorName(style,colorSpace=SRGBColorSpace){// color keywords
	const hex=_colorKeywords[style.toLowerCase()];if(hex!==undefined){// red
	this.setHex(hex,colorSpace);}else {// unknown color
	console.warn('THREE.Color: Unknown color '+style);}return this;}clone(){return new this.constructor(this.r,this.g,this.b);}copy(color){this.r=color.r;this.g=color.g;this.b=color.b;return this;}copySRGBToLinear(color){this.r=SRGBToLinear(color.r);this.g=SRGBToLinear(color.g);this.b=SRGBToLinear(color.b);return this;}copyLinearToSRGB(color){this.r=LinearToSRGB(color.r);this.g=LinearToSRGB(color.g);this.b=LinearToSRGB(color.b);return this;}convertSRGBToLinear(){this.copySRGBToLinear(this);return this;}convertLinearToSRGB(){this.copyLinearToSRGB(this);return this;}getHex(colorSpace=SRGBColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),colorSpace);return Math.round(clamp$1(_color.r*255,0,255))*65536+Math.round(clamp$1(_color.g*255,0,255))*256+Math.round(clamp$1(_color.b*255,0,255));}getHexString(colorSpace=SRGBColorSpace){return ('000000'+this.getHex(colorSpace).toString(16)).slice(-6);}getHSL(target,colorSpace=ColorManagement.workingColorSpace){// h,s,l ranges are in 0.0 - 1.0
	ColorManagement.fromWorkingColorSpace(_color.copy(this),colorSpace);const r=_color.r,g=_color.g,b=_color.b;const max=Math.max(r,g,b);const min=Math.min(r,g,b);let hue,saturation;const lightness=(min+max)/2.0;if(min===max){hue=0;saturation=0;}else {const delta=max-min;saturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);switch(max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4;break;}hue/=6;}target.h=hue;target.s=saturation;target.l=lightness;return target;}getRGB(target,colorSpace=ColorManagement.workingColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),colorSpace);target.r=_color.r;target.g=_color.g;target.b=_color.b;return target;}getStyle(colorSpace=SRGBColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),colorSpace);const r=_color.r,g=_color.g,b=_color.b;if(colorSpace!==SRGBColorSpace){// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
	return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;}return `rgb(${Math.round(r*255)},${Math.round(g*255)},${Math.round(b*255)})`;}offsetHSL(h,s,l){this.getHSL(_hslA);return this.setHSL(_hslA.h+h,_hslA.s+s,_hslA.l+l);}add(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;return this;}addColors(color1,color2){this.r=color1.r+color2.r;this.g=color1.g+color2.g;this.b=color1.b+color2.b;return this;}addScalar(s){this.r+=s;this.g+=s;this.b+=s;return this;}sub(color){this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);return this;}multiply(color){this.r*=color.r;this.g*=color.g;this.b*=color.b;return this;}multiplyScalar(s){this.r*=s;this.g*=s;this.b*=s;return this;}lerp(color,alpha){this.r+=(color.r-this.r)*alpha;this.g+=(color.g-this.g)*alpha;this.b+=(color.b-this.b)*alpha;return this;}lerpColors(color1,color2,alpha){this.r=color1.r+(color2.r-color1.r)*alpha;this.g=color1.g+(color2.g-color1.g)*alpha;this.b=color1.b+(color2.b-color1.b)*alpha;return this;}lerpHSL(color,alpha){this.getHSL(_hslA);color.getHSL(_hslB);const h=lerp(_hslA.h,_hslB.h,alpha);const s=lerp(_hslA.s,_hslB.s,alpha);const l=lerp(_hslA.l,_hslB.l,alpha);this.setHSL(h,s,l);return this;}setFromVector3(v){this.r=v.x;this.g=v.y;this.b=v.z;return this;}applyMatrix3(m){const r=this.r,g=this.g,b=this.b;const e=m.elements;this.r=e[0]*r+e[3]*g+e[6]*b;this.g=e[1]*r+e[4]*g+e[7]*b;this.b=e[2]*r+e[5]*g+e[8]*b;return this;}equals(c){return c.r===this.r&&c.g===this.g&&c.b===this.b;}fromArray(array,offset=0){this.r=array[offset];this.g=array[offset+1];this.b=array[offset+2];return this;}toArray(array=[],offset=0){array[offset]=this.r;array[offset+1]=this.g;array[offset+2]=this.b;return array;}fromBufferAttribute(attribute,index){this.r=attribute.getX(index);this.g=attribute.getY(index);this.b=attribute.getZ(index);return this;}toJSON(){return this.getHex();}*[Symbol.iterator](){yield this.r;yield this.g;yield this.b;}}const _color=/*@__PURE__*/new Color();Color.NAMES=_colorKeywords;let _materialId=0;class Material extends EventDispatcher$1{constructor(){super();this.isMaterial=true;Object.defineProperty(this,'id',{value:_materialId++});this.uuid=generateUUID$1();this.name='';this.type='Material';this.blending=NormalBlending;this.side=FrontSide;this.vertexColors=false;this.opacity=1;this.transparent=false;this.alphaHash=false;this.blendSrc=SrcAlphaFactor;this.blendDst=OneMinusSrcAlphaFactor;this.blendEquation=AddEquation;this.blendSrcAlpha=null;this.blendDstAlpha=null;this.blendEquationAlpha=null;this.blendColor=new Color(0,0,0);this.blendAlpha=0;this.depthFunc=LessEqualDepth;this.depthTest=true;this.depthWrite=true;this.stencilWriteMask=0xff;this.stencilFunc=AlwaysStencilFunc;this.stencilRef=0;this.stencilFuncMask=0xff;this.stencilFail=KeepStencilOp;this.stencilZFail=KeepStencilOp;this.stencilZPass=KeepStencilOp;this.stencilWrite=false;this.clippingPlanes=null;this.clipIntersection=false;this.clipShadows=false;this.shadowSide=null;this.colorWrite=true;this.precision=null;// override the renderer's default precision for this material
	this.polygonOffset=false;this.polygonOffsetFactor=0;this.polygonOffsetUnits=0;this.dithering=false;this.alphaToCoverage=false;this.premultipliedAlpha=false;this.forceSinglePass=false;this.visible=true;this.toneMapped=true;this.userData={};this.version=0;this._alphaTest=0;}get alphaTest(){return this._alphaTest;}set alphaTest(value){if(this._alphaTest>0!==value>0){this.version++;}this._alphaTest=value;}// onBeforeRender and onBeforeCompile only supported in WebGLRenderer
	onBeforeRender(/* renderer, scene, camera, geometry, object, group */){}onBeforeCompile(/* shaderobject, renderer */){}customProgramCacheKey(){return this.onBeforeCompile.toString();}setValues(values){if(values===undefined)return;for(const key in values){const newValue=values[key];if(newValue===undefined){console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);continue;}const currentValue=this[key];if(currentValue===undefined){console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);continue;}if(currentValue&&currentValue.isColor){currentValue.set(newValue);}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){currentValue.copy(newValue);}else {this[key]=newValue;}}}toJSON(meta){const isRootObject=meta===undefined||typeof meta==='string';if(isRootObject){meta={textures:{},images:{}};}const data={metadata:{version:4.6,type:'Material',generator:'Material.toJSON'}};// standard Material serialization
	data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.color&&this.color.isColor)data.color=this.color.getHex();if(this.roughness!==undefined)data.roughness=this.roughness;if(this.metalness!==undefined)data.metalness=this.metalness;if(this.sheen!==undefined)data.sheen=this.sheen;if(this.sheenColor&&this.sheenColor.isColor)data.sheenColor=this.sheenColor.getHex();if(this.sheenRoughness!==undefined)data.sheenRoughness=this.sheenRoughness;if(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();if(this.emissiveIntensity!==undefined&&this.emissiveIntensity!==1)data.emissiveIntensity=this.emissiveIntensity;if(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();if(this.specularIntensity!==undefined)data.specularIntensity=this.specularIntensity;if(this.specularColor&&this.specularColor.isColor)data.specularColor=this.specularColor.getHex();if(this.shininess!==undefined)data.shininess=this.shininess;if(this.clearcoat!==undefined)data.clearcoat=this.clearcoat;if(this.clearcoatRoughness!==undefined)data.clearcoatRoughness=this.clearcoatRoughness;if(this.clearcoatMap&&this.clearcoatMap.isTexture){data.clearcoatMap=this.clearcoatMap.toJSON(meta).uuid;}if(this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture){data.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(meta).uuid;}if(this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture){data.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(meta).uuid;data.clearcoatNormalScale=this.clearcoatNormalScale.toArray();}if(this.dispersion!==undefined)data.dispersion=this.dispersion;if(this.iridescence!==undefined)data.iridescence=this.iridescence;if(this.iridescenceIOR!==undefined)data.iridescenceIOR=this.iridescenceIOR;if(this.iridescenceThicknessRange!==undefined)data.iridescenceThicknessRange=this.iridescenceThicknessRange;if(this.iridescenceMap&&this.iridescenceMap.isTexture){data.iridescenceMap=this.iridescenceMap.toJSON(meta).uuid;}if(this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture){data.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(meta).uuid;}if(this.anisotropy!==undefined)data.anisotropy=this.anisotropy;if(this.anisotropyRotation!==undefined)data.anisotropyRotation=this.anisotropyRotation;if(this.anisotropyMap&&this.anisotropyMap.isTexture){data.anisotropyMap=this.anisotropyMap.toJSON(meta).uuid;}if(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;if(this.matcap&&this.matcap.isTexture)data.matcap=this.matcap.toJSON(meta).uuid;if(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;if(this.lightMap&&this.lightMap.isTexture){data.lightMap=this.lightMap.toJSON(meta).uuid;data.lightMapIntensity=this.lightMapIntensity;}if(this.aoMap&&this.aoMap.isTexture){data.aoMap=this.aoMap.toJSON(meta).uuid;data.aoMapIntensity=this.aoMapIntensity;}if(this.bumpMap&&this.bumpMap.isTexture){data.bumpMap=this.bumpMap.toJSON(meta).uuid;data.bumpScale=this.bumpScale;}if(this.normalMap&&this.normalMap.isTexture){data.normalMap=this.normalMap.toJSON(meta).uuid;data.normalMapType=this.normalMapType;data.normalScale=this.normalScale.toArray();}if(this.displacementMap&&this.displacementMap.isTexture){data.displacementMap=this.displacementMap.toJSON(meta).uuid;data.displacementScale=this.displacementScale;data.displacementBias=this.displacementBias;}if(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;if(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;if(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;if(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;if(this.specularIntensityMap&&this.specularIntensityMap.isTexture)data.specularIntensityMap=this.specularIntensityMap.toJSON(meta).uuid;if(this.specularColorMap&&this.specularColorMap.isTexture)data.specularColorMap=this.specularColorMap.toJSON(meta).uuid;if(this.envMap&&this.envMap.isTexture){data.envMap=this.envMap.toJSON(meta).uuid;if(this.combine!==undefined)data.combine=this.combine;}if(this.envMapRotation!==undefined)data.envMapRotation=this.envMapRotation.toArray();if(this.envMapIntensity!==undefined)data.envMapIntensity=this.envMapIntensity;if(this.reflectivity!==undefined)data.reflectivity=this.reflectivity;if(this.refractionRatio!==undefined)data.refractionRatio=this.refractionRatio;if(this.gradientMap&&this.gradientMap.isTexture){data.gradientMap=this.gradientMap.toJSON(meta).uuid;}if(this.transmission!==undefined)data.transmission=this.transmission;if(this.transmissionMap&&this.transmissionMap.isTexture)data.transmissionMap=this.transmissionMap.toJSON(meta).uuid;if(this.thickness!==undefined)data.thickness=this.thickness;if(this.thicknessMap&&this.thicknessMap.isTexture)data.thicknessMap=this.thicknessMap.toJSON(meta).uuid;if(this.attenuationDistance!==undefined&&this.attenuationDistance!==Infinity)data.attenuationDistance=this.attenuationDistance;if(this.attenuationColor!==undefined)data.attenuationColor=this.attenuationColor.getHex();if(this.size!==undefined)data.size=this.size;if(this.shadowSide!==null)data.shadowSide=this.shadowSide;if(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;if(this.blending!==NormalBlending)data.blending=this.blending;if(this.side!==FrontSide)data.side=this.side;if(this.vertexColors===true)data.vertexColors=true;if(this.opacity<1)data.opacity=this.opacity;if(this.transparent===true)data.transparent=true;if(this.blendSrc!==SrcAlphaFactor)data.blendSrc=this.blendSrc;if(this.blendDst!==OneMinusSrcAlphaFactor)data.blendDst=this.blendDst;if(this.blendEquation!==AddEquation)data.blendEquation=this.blendEquation;if(this.blendSrcAlpha!==null)data.blendSrcAlpha=this.blendSrcAlpha;if(this.blendDstAlpha!==null)data.blendDstAlpha=this.blendDstAlpha;if(this.blendEquationAlpha!==null)data.blendEquationAlpha=this.blendEquationAlpha;if(this.blendColor&&this.blendColor.isColor)data.blendColor=this.blendColor.getHex();if(this.blendAlpha!==0)data.blendAlpha=this.blendAlpha;if(this.depthFunc!==LessEqualDepth)data.depthFunc=this.depthFunc;if(this.depthTest===false)data.depthTest=this.depthTest;if(this.depthWrite===false)data.depthWrite=this.depthWrite;if(this.colorWrite===false)data.colorWrite=this.colorWrite;if(this.stencilWriteMask!==0xff)data.stencilWriteMask=this.stencilWriteMask;if(this.stencilFunc!==AlwaysStencilFunc)data.stencilFunc=this.stencilFunc;if(this.stencilRef!==0)data.stencilRef=this.stencilRef;if(this.stencilFuncMask!==0xff)data.stencilFuncMask=this.stencilFuncMask;if(this.stencilFail!==KeepStencilOp)data.stencilFail=this.stencilFail;if(this.stencilZFail!==KeepStencilOp)data.stencilZFail=this.stencilZFail;if(this.stencilZPass!==KeepStencilOp)data.stencilZPass=this.stencilZPass;if(this.stencilWrite===true)data.stencilWrite=this.stencilWrite;// rotation (SpriteMaterial)
	if(this.rotation!==undefined&&this.rotation!==0)data.rotation=this.rotation;if(this.polygonOffset===true)data.polygonOffset=true;if(this.polygonOffsetFactor!==0)data.polygonOffsetFactor=this.polygonOffsetFactor;if(this.polygonOffsetUnits!==0)data.polygonOffsetUnits=this.polygonOffsetUnits;if(this.linewidth!==undefined&&this.linewidth!==1)data.linewidth=this.linewidth;if(this.dashSize!==undefined)data.dashSize=this.dashSize;if(this.gapSize!==undefined)data.gapSize=this.gapSize;if(this.scale!==undefined)data.scale=this.scale;if(this.dithering===true)data.dithering=true;if(this.alphaTest>0)data.alphaTest=this.alphaTest;if(this.alphaHash===true)data.alphaHash=true;if(this.alphaToCoverage===true)data.alphaToCoverage=true;if(this.premultipliedAlpha===true)data.premultipliedAlpha=true;if(this.forceSinglePass===true)data.forceSinglePass=true;if(this.wireframe===true)data.wireframe=true;if(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;if(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;if(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;if(this.flatShading===true)data.flatShading=true;if(this.visible===false)data.visible=false;if(this.toneMapped===false)data.toneMapped=false;if(this.fog===false)data.fog=false;if(Object.keys(this.userData).length>0)data.userData=this.userData;// TODO: Copied from Object3D.toJSON
	function extractFromCache(cache){const values=[];for(const key in cache){const data=cache[key];delete data.metadata;values.push(data);}return values;}if(isRootObject){const textures=extractFromCache(meta.textures);const images=extractFromCache(meta.images);if(textures.length>0)data.textures=textures;if(images.length>0)data.images=images;}return data;}clone(){return new this.constructor().copy(this);}copy(source){this.name=source.name;this.blending=source.blending;this.side=source.side;this.vertexColors=source.vertexColors;this.opacity=source.opacity;this.transparent=source.transparent;this.blendSrc=source.blendSrc;this.blendDst=source.blendDst;this.blendEquation=source.blendEquation;this.blendSrcAlpha=source.blendSrcAlpha;this.blendDstAlpha=source.blendDstAlpha;this.blendEquationAlpha=source.blendEquationAlpha;this.blendColor.copy(source.blendColor);this.blendAlpha=source.blendAlpha;this.depthFunc=source.depthFunc;this.depthTest=source.depthTest;this.depthWrite=source.depthWrite;this.stencilWriteMask=source.stencilWriteMask;this.stencilFunc=source.stencilFunc;this.stencilRef=source.stencilRef;this.stencilFuncMask=source.stencilFuncMask;this.stencilFail=source.stencilFail;this.stencilZFail=source.stencilZFail;this.stencilZPass=source.stencilZPass;this.stencilWrite=source.stencilWrite;const srcPlanes=source.clippingPlanes;let dstPlanes=null;if(srcPlanes!==null){const n=srcPlanes.length;dstPlanes=new Array(n);for(let i=0;i!==n;++i){dstPlanes[i]=srcPlanes[i].clone();}}this.clippingPlanes=dstPlanes;this.clipIntersection=source.clipIntersection;this.clipShadows=source.clipShadows;this.shadowSide=source.shadowSide;this.colorWrite=source.colorWrite;this.precision=source.precision;this.polygonOffset=source.polygonOffset;this.polygonOffsetFactor=source.polygonOffsetFactor;this.polygonOffsetUnits=source.polygonOffsetUnits;this.dithering=source.dithering;this.alphaTest=source.alphaTest;this.alphaHash=source.alphaHash;this.alphaToCoverage=source.alphaToCoverage;this.premultipliedAlpha=source.premultipliedAlpha;this.forceSinglePass=source.forceSinglePass;this.visible=source.visible;this.toneMapped=source.toneMapped;this.userData=JSON.parse(JSON.stringify(source.userData));return this;}dispose(){this.dispatchEvent({type:'dispose'});}set needsUpdate(value){if(value===true)this.version++;}onBuild(/* shaderobject, renderer */){console.warn('Material: onBuild() has been removed.');// @deprecated, r166
	}}class MeshBasicMaterial extends Material{constructor(parameters){super();this.isMeshBasicMaterial=true;this.type='MeshBasicMaterial';this.color=new Color(0xffffff);// emissive
	this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.envMapRotation=new Euler$1();this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.fog=true;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapRotation.copy(source.envMapRotation);this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.fog=source.fog;return this;}}// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
	const _vector$9=/*@__PURE__*/new Vector3$1();const _vector2$1=/*@__PURE__*/new Vector2$1();let BufferAttribute$1 = class BufferAttribute{constructor(array,itemSize,normalized=false){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.isBufferAttribute=true;this.name='';this.array=array;this.itemSize=itemSize;this.count=array!==undefined?array.length/itemSize:0;this.normalized=normalized;this.usage=StaticDrawUsage$1;this.updateRanges=[];this.gpuType=FloatType$1;this.version=0;}onUploadCallback(){}set needsUpdate(value){if(value===true)this.version++;}setUsage(value){this.usage=value;return this;}addUpdateRange(start,count){this.updateRanges.push({start,count});}clearUpdateRanges(){this.updateRanges.length=0;}copy(source){this.name=source.name;this.array=new source.array.constructor(source.array);this.itemSize=source.itemSize;this.count=source.count;this.normalized=source.normalized;this.usage=source.usage;this.gpuType=source.gpuType;return this;}copyAt(index1,attribute,index2){index1*=this.itemSize;index2*=attribute.itemSize;for(let i=0,l=this.itemSize;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;}copyArray(array){this.array.set(array);return this;}applyMatrix3(m){if(this.itemSize===2){for(let i=0,l=this.count;i<l;i++){_vector2$1.fromBufferAttribute(this,i);_vector2$1.applyMatrix3(m);this.setXY(i,_vector2$1.x,_vector2$1.y);}}else if(this.itemSize===3){for(let i=0,l=this.count;i<l;i++){_vector$9.fromBufferAttribute(this,i);_vector$9.applyMatrix3(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}}return this;}applyMatrix4(m){for(let i=0,l=this.count;i<l;i++){_vector$9.fromBufferAttribute(this,i);_vector$9.applyMatrix4(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}applyNormalMatrix(m){for(let i=0,l=this.count;i<l;i++){_vector$9.fromBufferAttribute(this,i);_vector$9.applyNormalMatrix(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}transformDirection(m){for(let i=0,l=this.count;i<l;i++){_vector$9.fromBufferAttribute(this,i);_vector$9.transformDirection(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}set(value,offset=0){// Matching BufferAttribute constructor, do not normalize the array.
	this.array.set(value,offset);return this;}getComponent(index,component){let value=this.array[index*this.itemSize+component];if(this.normalized)value=denormalize$1(value,this.array);return value;}setComponent(index,component,value){if(this.normalized)value=normalize$1(value,this.array);this.array[index*this.itemSize+component]=value;return this;}getX(index){let x=this.array[index*this.itemSize];if(this.normalized)x=denormalize$1(x,this.array);return x;}setX(index,x){if(this.normalized)x=normalize$1(x,this.array);this.array[index*this.itemSize]=x;return this;}getY(index){let y=this.array[index*this.itemSize+1];if(this.normalized)y=denormalize$1(y,this.array);return y;}setY(index,y){if(this.normalized)y=normalize$1(y,this.array);this.array[index*this.itemSize+1]=y;return this;}getZ(index){let z=this.array[index*this.itemSize+2];if(this.normalized)z=denormalize$1(z,this.array);return z;}setZ(index,z){if(this.normalized)z=normalize$1(z,this.array);this.array[index*this.itemSize+2]=z;return this;}getW(index){let w=this.array[index*this.itemSize+3];if(this.normalized)w=denormalize$1(w,this.array);return w;}setW(index,w){if(this.normalized)w=normalize$1(w,this.array);this.array[index*this.itemSize+3]=w;return this;}setXY(index,x,y){index*=this.itemSize;if(this.normalized){x=normalize$1(x,this.array);y=normalize$1(y,this.array);}this.array[index+0]=x;this.array[index+1]=y;return this;}setXYZ(index,x,y,z){index*=this.itemSize;if(this.normalized){x=normalize$1(x,this.array);y=normalize$1(y,this.array);z=normalize$1(z,this.array);}this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;return this;}setXYZW(index,x,y,z,w){index*=this.itemSize;if(this.normalized){x=normalize$1(x,this.array);y=normalize$1(y,this.array);z=normalize$1(z,this.array);w=normalize$1(w,this.array);}this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;this.array[index+3]=w;return this;}onUpload(callback){this.onUploadCallback=callback;return this;}clone(){return new this.constructor(this.array,this.itemSize).copy(this);}toJSON(){const data={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};if(this.name!=='')data.name=this.name;if(this.usage!==StaticDrawUsage$1)data.usage=this.usage;return data;}};//
	let Uint16BufferAttribute$1 = class Uint16BufferAttribute extends BufferAttribute$1{constructor(array,itemSize,normalized){super(new Uint16Array(array),itemSize,normalized);}};let Uint32BufferAttribute$1 = class Uint32BufferAttribute extends BufferAttribute$1{constructor(array,itemSize,normalized){super(new Uint32Array(array),itemSize,normalized);}};let Float32BufferAttribute$1 = class Float32BufferAttribute extends BufferAttribute$1{constructor(array,itemSize,normalized){super(new Float32Array(array),itemSize,normalized);}};let _id$1$1=0;const _m1$4=/*@__PURE__*/new Matrix4$1();const _obj$1=/*@__PURE__*/new Object3D$1();const _offset$1=/*@__PURE__*/new Vector3$1();const _box$2$1=/*@__PURE__*/new Box3$1();const _boxMorphTargets$1=/*@__PURE__*/new Box3$1();const _vector$8=/*@__PURE__*/new Vector3$1();let BufferGeometry$1 = class BufferGeometry extends EventDispatcher$1{constructor(){super();this.isBufferGeometry=true;Object.defineProperty(this,'id',{value:_id$1$1++});this.uuid=generateUUID$1();this.name='';this.type='BufferGeometry';this.index=null;this.indirect=null;this.attributes={};this.morphAttributes={};this.morphTargetsRelative=false;this.groups=[];this.boundingBox=null;this.boundingSphere=null;this.drawRange={start:0,count:Infinity};this.userData={};}getIndex(){return this.index;}setIndex(index){if(Array.isArray(index)){this.index=new(arrayNeedsUint32$1(index)?Uint32BufferAttribute$1:Uint16BufferAttribute$1)(index,1);}else {this.index=index;}return this;}setIndirect(indirect){this.indirect=indirect;return this;}getIndirect(){return this.indirect;}getAttribute(name){return this.attributes[name];}setAttribute(name,attribute){this.attributes[name]=attribute;return this;}deleteAttribute(name){delete this.attributes[name];return this;}hasAttribute(name){return this.attributes[name]!==undefined;}addGroup(start,count,materialIndex=0){this.groups.push({start:start,count:count,materialIndex:materialIndex});}clearGroups(){this.groups=[];}setDrawRange(start,count){this.drawRange.start=start;this.drawRange.count=count;}applyMatrix4(matrix){const position=this.attributes.position;if(position!==undefined){position.applyMatrix4(matrix);position.needsUpdate=true;}const normal=this.attributes.normal;if(normal!==undefined){const normalMatrix=new Matrix3$1().getNormalMatrix(matrix);normal.applyNormalMatrix(normalMatrix);normal.needsUpdate=true;}const tangent=this.attributes.tangent;if(tangent!==undefined){tangent.transformDirection(matrix);tangent.needsUpdate=true;}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}return this;}applyQuaternion(q){_m1$4.makeRotationFromQuaternion(q);this.applyMatrix4(_m1$4);return this;}rotateX(angle){// rotate geometry around world x-axis
	_m1$4.makeRotationX(angle);this.applyMatrix4(_m1$4);return this;}rotateY(angle){// rotate geometry around world y-axis
	_m1$4.makeRotationY(angle);this.applyMatrix4(_m1$4);return this;}rotateZ(angle){// rotate geometry around world z-axis
	_m1$4.makeRotationZ(angle);this.applyMatrix4(_m1$4);return this;}translate(x,y,z){// translate geometry
	_m1$4.makeTranslation(x,y,z);this.applyMatrix4(_m1$4);return this;}scale(x,y,z){// scale geometry
	_m1$4.makeScale(x,y,z);this.applyMatrix4(_m1$4);return this;}lookAt(vector){_obj$1.lookAt(vector);_obj$1.updateMatrix();this.applyMatrix4(_obj$1.matrix);return this;}center(){this.computeBoundingBox();this.boundingBox.getCenter(_offset$1).negate();this.translate(_offset$1.x,_offset$1.y,_offset$1.z);return this;}setFromPoints(points){const positionAttribute=this.getAttribute('position');if(positionAttribute===undefined){const position=[];for(let i=0,l=points.length;i<l;i++){const point=points[i];position.push(point.x,point.y,point.z||0);}this.setAttribute('position',new Float32BufferAttribute$1(position,3));}else {const l=Math.min(points.length,positionAttribute.count);// make sure data do not exceed buffer size
	for(let i=0;i<l;i++){const point=points[i];positionAttribute.setXYZ(i,point.x,point.y,point.z||0);}if(points.length>positionAttribute.count){console.warn('THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.');}positionAttribute.needsUpdate=true;}return this;}computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3$1();}const position=this.attributes.position;const morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.',this);this.boundingBox.set(new Vector3$1(-Infinity,-Infinity,-Infinity),new Vector3$1(+Infinity,+Infinity,+Infinity));return;}if(position!==undefined){this.boundingBox.setFromBufferAttribute(position);// process morph attributes if present
	if(morphAttributesPosition){for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i];_box$2$1.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$8.addVectors(this.boundingBox.min,_box$2$1.min);this.boundingBox.expandByPoint(_vector$8);_vector$8.addVectors(this.boundingBox.max,_box$2$1.max);this.boundingBox.expandByPoint(_vector$8);}else {this.boundingBox.expandByPoint(_box$2$1.min);this.boundingBox.expandByPoint(_box$2$1.max);}}}}else {this.boundingBox.makeEmpty();}if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this);}}computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere$1();}const position=this.attributes.position;const morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.',this);this.boundingSphere.set(new Vector3$1(),Infinity);return;}if(position){// first, find the center of the bounding sphere
	const center=this.boundingSphere.center;_box$2$1.setFromBufferAttribute(position);// process morph attributes if present
	if(morphAttributesPosition){for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i];_boxMorphTargets$1.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$8.addVectors(_box$2$1.min,_boxMorphTargets$1.min);_box$2$1.expandByPoint(_vector$8);_vector$8.addVectors(_box$2$1.max,_boxMorphTargets$1.max);_box$2$1.expandByPoint(_vector$8);}else {_box$2$1.expandByPoint(_boxMorphTargets$1.min);_box$2$1.expandByPoint(_boxMorphTargets$1.max);}}}_box$2$1.getCenter(center);// second, try to find a boundingSphere with a radius smaller than the
	// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
	let maxRadiusSq=0;for(let i=0,il=position.count;i<il;i++){_vector$8.fromBufferAttribute(position,i);maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$8));}// process morph attributes if present
	if(morphAttributesPosition){for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i];const morphTargetsRelative=this.morphTargetsRelative;for(let j=0,jl=morphAttribute.count;j<jl;j++){_vector$8.fromBufferAttribute(morphAttribute,j);if(morphTargetsRelative){_offset$1.fromBufferAttribute(position,j);_vector$8.add(_offset$1);}maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$8));}}}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);if(isNaN(this.boundingSphere.radius)){console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this);}}}computeTangents(){const index=this.index;const attributes=this.attributes;// based on http://www.terathon.com/code/tangent.html
	// (per vertex tangents)
	if(index===null||attributes.position===undefined||attributes.normal===undefined||attributes.uv===undefined){console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');return;}const positionAttribute=attributes.position;const normalAttribute=attributes.normal;const uvAttribute=attributes.uv;if(this.hasAttribute('tangent')===false){this.setAttribute('tangent',new BufferAttribute$1(new Float32Array(4*positionAttribute.count),4));}const tangentAttribute=this.getAttribute('tangent');const tan1=[],tan2=[];for(let i=0;i<positionAttribute.count;i++){tan1[i]=new Vector3$1();tan2[i]=new Vector3$1();}const vA=new Vector3$1(),vB=new Vector3$1(),vC=new Vector3$1(),uvA=new Vector2$1(),uvB=new Vector2$1(),uvC=new Vector2$1(),sdir=new Vector3$1(),tdir=new Vector3$1();function handleTriangle(a,b,c){vA.fromBufferAttribute(positionAttribute,a);vB.fromBufferAttribute(positionAttribute,b);vC.fromBufferAttribute(positionAttribute,c);uvA.fromBufferAttribute(uvAttribute,a);uvB.fromBufferAttribute(uvAttribute,b);uvC.fromBufferAttribute(uvAttribute,c);vB.sub(vA);vC.sub(vA);uvB.sub(uvA);uvC.sub(uvA);const r=1.0/(uvB.x*uvC.y-uvC.x*uvB.y);// silently ignore degenerate uv triangles having coincident or colinear vertices
	if(!isFinite(r))return;sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC,-uvB.y).multiplyScalar(r);tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB,-uvC.x).multiplyScalar(r);tan1[a].add(sdir);tan1[b].add(sdir);tan1[c].add(sdir);tan2[a].add(tdir);tan2[b].add(tdir);tan2[c].add(tdir);}let groups=this.groups;if(groups.length===0){groups=[{start:0,count:index.count}];}for(let i=0,il=groups.length;i<il;++i){const group=groups[i];const start=group.start;const count=group.count;for(let j=start,jl=start+count;j<jl;j+=3){handleTriangle(index.getX(j+0),index.getX(j+1),index.getX(j+2));}}const tmp=new Vector3$1(),tmp2=new Vector3$1();const n=new Vector3$1(),n2=new Vector3$1();function handleVertex(v){n.fromBufferAttribute(normalAttribute,v);n2.copy(n);const t=tan1[v];// Gram-Schmidt orthogonalize
	tmp.copy(t);tmp.sub(n.multiplyScalar(n.dot(t))).normalize();// Calculate handedness
	tmp2.crossVectors(n2,t);const test=tmp2.dot(tan2[v]);const w=test<0.0?-1.0:1.0;tangentAttribute.setXYZW(v,tmp.x,tmp.y,tmp.z,w);}for(let i=0,il=groups.length;i<il;++i){const group=groups[i];const start=group.start;const count=group.count;for(let j=start,jl=start+count;j<jl;j+=3){handleVertex(index.getX(j+0));handleVertex(index.getX(j+1));handleVertex(index.getX(j+2));}}}computeVertexNormals(){const index=this.index;const positionAttribute=this.getAttribute('position');if(positionAttribute!==undefined){let normalAttribute=this.getAttribute('normal');if(normalAttribute===undefined){normalAttribute=new BufferAttribute$1(new Float32Array(positionAttribute.count*3),3);this.setAttribute('normal',normalAttribute);}else {// reset existing normals to zero
	for(let i=0,il=normalAttribute.count;i<il;i++){normalAttribute.setXYZ(i,0,0,0);}}const pA=new Vector3$1(),pB=new Vector3$1(),pC=new Vector3$1();const nA=new Vector3$1(),nB=new Vector3$1(),nC=new Vector3$1();const cb=new Vector3$1(),ab=new Vector3$1();// indexed elements
	if(index){for(let i=0,il=index.count;i<il;i+=3){const vA=index.getX(i+0);const vB=index.getX(i+1);const vC=index.getX(i+2);pA.fromBufferAttribute(positionAttribute,vA);pB.fromBufferAttribute(positionAttribute,vB);pC.fromBufferAttribute(positionAttribute,vC);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);nA.fromBufferAttribute(normalAttribute,vA);nB.fromBufferAttribute(normalAttribute,vB);nC.fromBufferAttribute(normalAttribute,vC);nA.add(cb);nB.add(cb);nC.add(cb);normalAttribute.setXYZ(vA,nA.x,nA.y,nA.z);normalAttribute.setXYZ(vB,nB.x,nB.y,nB.z);normalAttribute.setXYZ(vC,nC.x,nC.y,nC.z);}}else {// non-indexed elements (unconnected triangle soup)
	for(let i=0,il=positionAttribute.count;i<il;i+=3){pA.fromBufferAttribute(positionAttribute,i+0);pB.fromBufferAttribute(positionAttribute,i+1);pC.fromBufferAttribute(positionAttribute,i+2);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normalAttribute.setXYZ(i+0,cb.x,cb.y,cb.z);normalAttribute.setXYZ(i+1,cb.x,cb.y,cb.z);normalAttribute.setXYZ(i+2,cb.x,cb.y,cb.z);}}this.normalizeNormals();normalAttribute.needsUpdate=true;}}normalizeNormals(){const normals=this.attributes.normal;for(let i=0,il=normals.count;i<il;i++){_vector$8.fromBufferAttribute(normals,i);_vector$8.normalize();normals.setXYZ(i,_vector$8.x,_vector$8.y,_vector$8.z);}}toNonIndexed(){function convertBufferAttribute(attribute,indices){const array=attribute.array;const itemSize=attribute.itemSize;const normalized=attribute.normalized;const array2=new array.constructor(indices.length*itemSize);let index=0,index2=0;for(let i=0,l=indices.length;i<l;i++){if(attribute.isInterleavedBufferAttribute){index=indices[i]*attribute.data.stride+attribute.offset;}else {index=indices[i]*itemSize;}for(let j=0;j<itemSize;j++){array2[index2++]=array[index++];}}return new BufferAttribute$1(array2,itemSize,normalized);}//
	if(this.index===null){console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');return this;}const geometry2=new BufferGeometry();const indices=this.index.array;const attributes=this.attributes;// attributes
	for(const name in attributes){const attribute=attributes[name];const newAttribute=convertBufferAttribute(attribute,indices);geometry2.setAttribute(name,newAttribute);}// morph attributes
	const morphAttributes=this.morphAttributes;for(const name in morphAttributes){const morphArray=[];const morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes
	for(let i=0,il=morphAttribute.length;i<il;i++){const attribute=morphAttribute[i];const newAttribute=convertBufferAttribute(attribute,indices);morphArray.push(newAttribute);}geometry2.morphAttributes[name]=morphArray;}geometry2.morphTargetsRelative=this.morphTargetsRelative;// groups
	const groups=this.groups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i];geometry2.addGroup(group.start,group.count,group.materialIndex);}return geometry2;}toJSON(){const data={metadata:{version:4.6,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};// standard BufferGeometry serialization
	data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(Object.keys(this.userData).length>0)data.userData=this.userData;if(this.parameters!==undefined){const parameters=this.parameters;for(const key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}// for simplicity the code assumes attributes are not shared across geometries, see #15811
	data.data={attributes:{}};const index=this.index;if(index!==null){data.data.index={type:index.array.constructor.name,array:Array.prototype.slice.call(index.array)};}const attributes=this.attributes;for(const key in attributes){const attribute=attributes[key];data.data.attributes[key]=attribute.toJSON(data.data);}const morphAttributes={};let hasMorphAttributes=false;for(const key in this.morphAttributes){const attributeArray=this.morphAttributes[key];const array=[];for(let i=0,il=attributeArray.length;i<il;i++){const attribute=attributeArray[i];array.push(attribute.toJSON(data.data));}if(array.length>0){morphAttributes[key]=array;hasMorphAttributes=true;}}if(hasMorphAttributes){data.data.morphAttributes=morphAttributes;data.data.morphTargetsRelative=this.morphTargetsRelative;}const groups=this.groups;if(groups.length>0){data.data.groups=JSON.parse(JSON.stringify(groups));}const boundingSphere=this.boundingSphere;if(boundingSphere!==null){data.data.boundingSphere={center:boundingSphere.center.toArray(),radius:boundingSphere.radius};}return data;}clone(){return new this.constructor().copy(this);}copy(source){// reset
	this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;// used for storing cloned, shared data
	const data={};// name
	this.name=source.name;// index
	const index=source.index;if(index!==null){this.setIndex(index.clone(data));}// attributes
	const attributes=source.attributes;for(const name in attributes){const attribute=attributes[name];this.setAttribute(name,attribute.clone(data));}// morph attributes
	const morphAttributes=source.morphAttributes;for(const name in morphAttributes){const array=[];const morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes
	for(let i=0,l=morphAttribute.length;i<l;i++){array.push(morphAttribute[i].clone(data));}this.morphAttributes[name]=array;}this.morphTargetsRelative=source.morphTargetsRelative;// groups
	const groups=source.groups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i];this.addGroup(group.start,group.count,group.materialIndex);}// bounding box
	const boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
	const boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// draw range
	this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;// user data
	this.userData=source.userData;return this;}dispose(){this.dispatchEvent({type:'dispose'});}};const _inverseMatrix$3=/*@__PURE__*/new Matrix4$1();const _ray$3=/*@__PURE__*/new Ray();const _sphere$6=/*@__PURE__*/new Sphere$1();const _sphereHitAt=/*@__PURE__*/new Vector3$1();const _vA$1=/*@__PURE__*/new Vector3$1();const _vB$1=/*@__PURE__*/new Vector3$1();const _vC$1=/*@__PURE__*/new Vector3$1();const _tempA=/*@__PURE__*/new Vector3$1();const _morphA=/*@__PURE__*/new Vector3$1();const _intersectionPoint=/*@__PURE__*/new Vector3$1();const _intersectionPointWorld=/*@__PURE__*/new Vector3$1();class Mesh extends Object3D$1{constructor(geometry=new BufferGeometry$1(),material=new MeshBasicMaterial()){super();this.isMesh=true;this.type='Mesh';this.geometry=geometry;this.material=material;this.updateMorphTargets();}copy(source,recursive){super.copy(source,recursive);if(source.morphTargetInfluences!==undefined){this.morphTargetInfluences=source.morphTargetInfluences.slice();}if(source.morphTargetDictionary!==undefined){this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary);}this.material=Array.isArray(source.material)?source.material.slice():source.material;this.geometry=source.geometry;return this;}updateMorphTargets(){const geometry=this.geometry;const morphAttributes=geometry.morphAttributes;const keys=Object.keys(morphAttributes);if(keys.length>0){const morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(let m=0,ml=morphAttribute.length;m<ml;m++){const name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}getVertexPosition(index,target){const geometry=this.geometry;const position=geometry.attributes.position;const morphPosition=geometry.morphAttributes.position;const morphTargetsRelative=geometry.morphTargetsRelative;target.fromBufferAttribute(position,index);const morphInfluences=this.morphTargetInfluences;if(morphPosition&&morphInfluences){_morphA.set(0,0,0);for(let i=0,il=morphPosition.length;i<il;i++){const influence=morphInfluences[i];const morphAttribute=morphPosition[i];if(influence===0)continue;_tempA.fromBufferAttribute(morphAttribute,index);if(morphTargetsRelative){_morphA.addScaledVector(_tempA,influence);}else {_morphA.addScaledVector(_tempA.sub(target),influence);}}target.add(_morphA);}return target;}raycast(raycaster,intersects){const geometry=this.geometry;const material=this.material;const matrixWorld=this.matrixWorld;if(material===undefined)return;// test with bounding sphere in world space
	if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$6.copy(geometry.boundingSphere);_sphere$6.applyMatrix4(matrixWorld);// check distance from ray origin to bounding sphere
	_ray$3.copy(raycaster.ray).recast(raycaster.near);if(_sphere$6.containsPoint(_ray$3.origin)===false){if(_ray$3.intersectSphere(_sphere$6,_sphereHitAt)===null)return;if(_ray$3.origin.distanceToSquared(_sphereHitAt)>(raycaster.far-raycaster.near)**2)return;}// convert ray to local space of mesh
	_inverseMatrix$3.copy(matrixWorld).invert();_ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);// test with bounding box in local space
	if(geometry.boundingBox!==null){if(_ray$3.intersectsBox(geometry.boundingBox)===false)return;}// test for intersections with geometry
	this._computeIntersections(raycaster,intersects,_ray$3);}_computeIntersections(raycaster,intersects,rayLocalSpace){let intersection;const geometry=this.geometry;const material=this.material;const index=geometry.index;const position=geometry.attributes.position;const uv=geometry.attributes.uv;const uv1=geometry.attributes.uv1;const normal=geometry.attributes.normal;const groups=geometry.groups;const drawRange=geometry.drawRange;if(index!==null){// indexed buffer geometry
	if(Array.isArray(material)){for(let i=0,il=groups.length;i<il;i++){const group=groups[i];const groupMaterial=material[group.materialIndex];const start=Math.max(group.start,drawRange.start);const end=Math.min(index.count,Math.min(group.start+group.count,drawRange.start+drawRange.count));for(let j=start,jl=end;j<jl;j+=3){const a=index.getX(j);const b=index.getX(j+1);const c=index.getX(j+2);intersection=checkGeometryIntersection(this,groupMaterial,raycaster,rayLocalSpace,uv,uv1,normal,a,b,c);if(intersection){intersection.faceIndex=Math.floor(j/3);// triangle number in indexed buffer semantics
	intersection.face.materialIndex=group.materialIndex;intersects.push(intersection);}}}}else {const start=Math.max(0,drawRange.start);const end=Math.min(index.count,drawRange.start+drawRange.count);for(let i=start,il=end;i<il;i+=3){const a=index.getX(i);const b=index.getX(i+1);const c=index.getX(i+2);intersection=checkGeometryIntersection(this,material,raycaster,rayLocalSpace,uv,uv1,normal,a,b,c);if(intersection){intersection.faceIndex=Math.floor(i/3);// triangle number in indexed buffer semantics
	intersects.push(intersection);}}}}else if(position!==undefined){// non-indexed buffer geometry
	if(Array.isArray(material)){for(let i=0,il=groups.length;i<il;i++){const group=groups[i];const groupMaterial=material[group.materialIndex];const start=Math.max(group.start,drawRange.start);const end=Math.min(position.count,Math.min(group.start+group.count,drawRange.start+drawRange.count));for(let j=start,jl=end;j<jl;j+=3){const a=j;const b=j+1;const c=j+2;intersection=checkGeometryIntersection(this,groupMaterial,raycaster,rayLocalSpace,uv,uv1,normal,a,b,c);if(intersection){intersection.faceIndex=Math.floor(j/3);// triangle number in non-indexed buffer semantics
	intersection.face.materialIndex=group.materialIndex;intersects.push(intersection);}}}}else {const start=Math.max(0,drawRange.start);const end=Math.min(position.count,drawRange.start+drawRange.count);for(let i=start,il=end;i<il;i+=3){const a=i;const b=i+1;const c=i+2;intersection=checkGeometryIntersection(this,material,raycaster,rayLocalSpace,uv,uv1,normal,a,b,c);if(intersection){intersection.faceIndex=Math.floor(i/3);// triangle number in non-indexed buffer semantics
	intersects.push(intersection);}}}}}}function checkIntersection$1(object,material,raycaster,ray,pA,pB,pC,point){let intersect;if(material.side===BackSide){intersect=ray.intersectTriangle(pC,pB,pA,true,point);}else {intersect=ray.intersectTriangle(pA,pB,pC,material.side===FrontSide,point);}if(intersect===null)return null;_intersectionPointWorld.copy(point);_intersectionPointWorld.applyMatrix4(object.matrixWorld);const distance=raycaster.ray.origin.distanceTo(_intersectionPointWorld);if(distance<raycaster.near||distance>raycaster.far)return null;return {distance:distance,point:_intersectionPointWorld.clone(),object:object};}function checkGeometryIntersection(object,material,raycaster,ray,uv,uv1,normal,a,b,c){object.getVertexPosition(a,_vA$1);object.getVertexPosition(b,_vB$1);object.getVertexPosition(c,_vC$1);const intersection=checkIntersection$1(object,material,raycaster,ray,_vA$1,_vB$1,_vC$1,_intersectionPoint);if(intersection){const barycoord=new Vector3$1();Triangle.getBarycoord(_intersectionPoint,_vA$1,_vB$1,_vC$1,barycoord);if(uv){intersection.uv=Triangle.getInterpolatedAttribute(uv,a,b,c,barycoord,new Vector2$1());}if(uv1){intersection.uv1=Triangle.getInterpolatedAttribute(uv1,a,b,c,barycoord,new Vector2$1());}if(normal){intersection.normal=Triangle.getInterpolatedAttribute(normal,a,b,c,barycoord,new Vector3$1());if(intersection.normal.dot(ray.direction)>0){intersection.normal.multiplyScalar(-1);}}const face={a:a,b:b,c:c,normal:new Vector3$1(),materialIndex:0};Triangle.getNormal(_vA$1,_vB$1,_vC$1,face.normal);intersection.face=face;intersection.barycoord=barycoord;}return intersection;}let BoxGeometry$1 = class BoxGeometry extends BufferGeometry$1{constructor(width=1,height=1,depth=1,widthSegments=1,heightSegments=1,depthSegments=1){super();this.type='BoxGeometry';this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};const scope=this;// segments
	widthSegments=Math.floor(widthSegments);heightSegments=Math.floor(heightSegments);depthSegments=Math.floor(depthSegments);// buffers
	const indices=[];const vertices=[];const normals=[];const uvs=[];// helper variables
	let numberOfVertices=0;let groupStart=0;// build each side of the box geometry
	buildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px
	buildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx
	buildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py
	buildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny
	buildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz
	buildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz
	// build geometry
	this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute$1(vertices,3));this.setAttribute('normal',new Float32BufferAttribute$1(normals,3));this.setAttribute('uv',new Float32BufferAttribute$1(uvs,2));function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){const segmentWidth=width/gridX;const segmentHeight=height/gridY;const widthHalf=width/2;const heightHalf=height/2;const depthHalf=depth/2;const gridX1=gridX+1;const gridY1=gridY+1;let vertexCounter=0;let groupCount=0;const vector=new Vector3$1();// generate vertices, normals and uvs
	for(let iy=0;iy<gridY1;iy++){const y=iy*segmentHeight-heightHalf;for(let ix=0;ix<gridX1;ix++){const x=ix*segmentWidth-widthHalf;// set values to correct vector component
	vector[u]=x*udir;vector[v]=y*vdir;vector[w]=depthHalf;// now apply vector to vertex buffer
	vertices.push(vector.x,vector.y,vector.z);// set values to correct vector component
	vector[u]=0;vector[v]=0;vector[w]=depth>0?1:-1;// now apply vector to normal buffer
	normals.push(vector.x,vector.y,vector.z);// uvs
	uvs.push(ix/gridX);uvs.push(1-iy/gridY);// counters
	vertexCounter+=1;}}// indices
	// 1. you need three indices to draw a single face
	// 2. a single segment consists of two faces
	// 3. so we need to generate six (2*3) indices per segment
	for(let iy=0;iy<gridY;iy++){for(let ix=0;ix<gridX;ix++){const a=numberOfVertices+ix+gridX1*iy;const b=numberOfVertices+ix+gridX1*(iy+1);const c=numberOfVertices+(ix+1)+gridX1*(iy+1);const d=numberOfVertices+(ix+1)+gridX1*iy;// faces
	indices.push(a,b,d);indices.push(b,c,d);// increase counter
	groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
	scope.addGroup(groupStart,groupCount,materialIndex);// calculate new start value for groups
	groupStart+=groupCount;// update total number of vertices
	numberOfVertices+=vertexCounter;}}copy(source){super.copy(source);this.parameters=Object.assign({},source.parameters);return this;}static fromJSON(data){return new BoxGeometry(data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments);}};/**
	 * Uniform Utilities
	 */function cloneUniforms(src){const dst={};for(const u in src){dst[u]={};for(const p in src[u]){const property=src[u][p];if(property&&(property.isColor||property.isMatrix3||property.isMatrix4||property.isVector2||property.isVector3||property.isVector4||property.isTexture||property.isQuaternion)){if(property.isRenderTargetTexture){console.warn('UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().');dst[u][p]=null;}else {dst[u][p]=property.clone();}}else if(Array.isArray(property)){dst[u][p]=property.slice();}else {dst[u][p]=property;}}}return dst;}function mergeUniforms(uniforms){const merged={};for(let u=0;u<uniforms.length;u++){const tmp=cloneUniforms(uniforms[u]);for(const p in tmp){merged[p]=tmp[p];}}return merged;}function cloneUniformsGroups(src){const dst=[];for(let u=0;u<src.length;u++){dst.push(src[u].clone());}return dst;}function getUnlitUniformColorSpace(renderer){const currentRenderTarget=renderer.getRenderTarget();if(currentRenderTarget===null){// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
	return renderer.outputColorSpace;}// https://github.com/mrdoob/three.js/issues/27868
	if(currentRenderTarget.isXRRenderTarget===true){return currentRenderTarget.texture.colorSpace;}return ColorManagement.workingColorSpace;}// Legacy
	const UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};var default_vertex="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";var default_fragment="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";class ShaderMaterial extends Material{constructor(parameters){super();this.isShaderMaterial=true;this.type='ShaderMaterial';this.defines={};this.uniforms={};this.uniformsGroups=[];this.vertexShader=default_vertex;this.fragmentShader=default_fragment;this.linewidth=1;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;// set to use scene fog
	this.lights=false;// set to use scene lights
	this.clipping=false;// set to use user-defined clipping planes
	this.forceSinglePass=true;this.extensions={clipCullDistance:false,// set to use vertex shader clipping
	multiDraw:false// set to use vertex shader multi_draw / enable gl_DrawID
	};// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues={'color':[1,1,1],'uv':[0,0],'uv1':[0,0]};this.index0AttributeName=undefined;this.uniformsNeedUpdate=false;this.glslVersion=null;if(parameters!==undefined){this.setValues(parameters);}}copy(source){super.copy(source);this.fragmentShader=source.fragmentShader;this.vertexShader=source.vertexShader;this.uniforms=cloneUniforms(source.uniforms);this.uniformsGroups=cloneUniformsGroups(source.uniformsGroups);this.defines=Object.assign({},source.defines);this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.fog=source.fog;this.lights=source.lights;this.clipping=source.clipping;this.extensions=Object.assign({},source.extensions);this.glslVersion=source.glslVersion;return this;}toJSON(meta){const data=super.toJSON(meta);data.glslVersion=this.glslVersion;data.uniforms={};for(const name in this.uniforms){const uniform=this.uniforms[name];const value=uniform.value;if(value&&value.isTexture){data.uniforms[name]={type:'t',value:value.toJSON(meta).uuid};}else if(value&&value.isColor){data.uniforms[name]={type:'c',value:value.getHex()};}else if(value&&value.isVector2){data.uniforms[name]={type:'v2',value:value.toArray()};}else if(value&&value.isVector3){data.uniforms[name]={type:'v3',value:value.toArray()};}else if(value&&value.isVector4){data.uniforms[name]={type:'v4',value:value.toArray()};}else if(value&&value.isMatrix3){data.uniforms[name]={type:'m3',value:value.toArray()};}else if(value&&value.isMatrix4){data.uniforms[name]={type:'m4',value:value.toArray()};}else {data.uniforms[name]={value:value};// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
	}}if(Object.keys(this.defines).length>0)data.defines=this.defines;data.vertexShader=this.vertexShader;data.fragmentShader=this.fragmentShader;data.lights=this.lights;data.clipping=this.clipping;const extensions={};for(const key in this.extensions){if(this.extensions[key]===true)extensions[key]=true;}if(Object.keys(extensions).length>0)data.extensions=extensions;return data;}}class Camera extends Object3D$1{constructor(){super();this.isCamera=true;this.type='Camera';this.matrixWorldInverse=new Matrix4$1();this.projectionMatrix=new Matrix4$1();this.projectionMatrixInverse=new Matrix4$1();this.coordinateSystem=WebGLCoordinateSystem$1;}copy(source,recursive){super.copy(source,recursive);this.matrixWorldInverse.copy(source.matrixWorldInverse);this.projectionMatrix.copy(source.projectionMatrix);this.projectionMatrixInverse.copy(source.projectionMatrixInverse);this.coordinateSystem=source.coordinateSystem;return this;}getWorldDirection(target){return super.getWorldDirection(target).negate();}updateMatrixWorld(force){super.updateMatrixWorld(force);this.matrixWorldInverse.copy(this.matrixWorld).invert();}updateWorldMatrix(updateParents,updateChildren){super.updateWorldMatrix(updateParents,updateChildren);this.matrixWorldInverse.copy(this.matrixWorld).invert();}clone(){return new this.constructor().copy(this);}}const _v3$1=/*@__PURE__*/new Vector3$1();const _minTarget=/*@__PURE__*/new Vector2$1();const _maxTarget=/*@__PURE__*/new Vector2$1();class PerspectiveCamera extends Camera{constructor(fov=50,aspect=1,near=0.1,far=2000){super();this.isPerspectiveCamera=true;this.type='PerspectiveCamera';this.fov=fov;this.zoom=1;this.near=near;this.far=far;this.focus=10;this.aspect=aspect;this.view=null;this.filmGauge=35;// width of the film (default in millimeters)
	this.filmOffset=0;// horizontal film offset (same unit as gauge)
	this.updateProjectionMatrix();}copy(source,recursive){super.copy(source,recursive);this.fov=source.fov;this.zoom=source.zoom;this.near=source.near;this.far=source.far;this.focus=source.focus;this.aspect=source.aspect;this.view=source.view===null?null:Object.assign({},source.view);this.filmGauge=source.filmGauge;this.filmOffset=source.filmOffset;return this;}/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */setFocalLength(focalLength){/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */const vExtentSlope=0.5*this.getFilmHeight()/focalLength;this.fov=RAD2DEG*2*Math.atan(vExtentSlope);this.updateProjectionMatrix();}/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */getFocalLength(){const vExtentSlope=Math.tan(DEG2RAD*0.5*this.fov);return 0.5*this.getFilmHeight()/vExtentSlope;}getEffectiveFOV(){return RAD2DEG*2*Math.atan(Math.tan(DEG2RAD*0.5*this.fov)/this.zoom);}getFilmWidth(){// film not completely covered in portrait format (aspect < 1)
	return this.filmGauge*Math.min(this.aspect,1);}getFilmHeight(){// film not completely covered in landscape format (aspect > 1)
	return this.filmGauge/Math.max(this.aspect,1);}/**
		 * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
		 * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
		 */getViewBounds(distance,minTarget,maxTarget){_v3$1.set(-1,-1,0.5).applyMatrix4(this.projectionMatrixInverse);minTarget.set(_v3$1.x,_v3$1.y).multiplyScalar(-distance/_v3$1.z);_v3$1.set(1,1,0.5).applyMatrix4(this.projectionMatrixInverse);maxTarget.set(_v3$1.x,_v3$1.y).multiplyScalar(-distance/_v3$1.z);}/**
		 * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
		 * Copies the result into the target Vector2, where x is width and y is height.
		 */getViewSize(distance,target){this.getViewBounds(distance,_minTarget,_maxTarget);return target.subVectors(_maxTarget,_minTarget);}/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   const w = 1920;
		 *   const h = 1080;
		 *   const fullWidth = w * 3;
		 *   const fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */setViewOffset(fullWidth,fullHeight,x,y,width,height){this.aspect=fullWidth/fullHeight;if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();}clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();}updateProjectionMatrix(){const near=this.near;let top=near*Math.tan(DEG2RAD*0.5*this.fov)/this.zoom;let height=2*top;let width=this.aspect*height;let left=-0.5*width;const view=this.view;if(this.view!==null&&this.view.enabled){const fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth;top-=view.offsetY*height/fullHeight;width*=view.width/fullWidth;height*=view.height/fullHeight;}const skew=this.filmOffset;if(skew!==0)left+=near*skew/this.getFilmWidth();this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far,this.coordinateSystem);this.projectionMatrixInverse.copy(this.projectionMatrix).invert();}toJSON(meta){const data=super.toJSON(meta);data.object.fov=this.fov;data.object.zoom=this.zoom;data.object.near=this.near;data.object.far=this.far;data.object.focus=this.focus;data.object.aspect=this.aspect;if(this.view!==null)data.object.view=Object.assign({},this.view);data.object.filmGauge=this.filmGauge;data.object.filmOffset=this.filmOffset;return data;}}const fov=-90;// negative fov is not an error
	const aspect=1;class CubeCamera extends Object3D$1{constructor(near,far,renderTarget){super();this.type='CubeCamera';this.renderTarget=renderTarget;this.coordinateSystem=null;this.activeMipmapLevel=0;const cameraPX=new PerspectiveCamera(fov,aspect,near,far);cameraPX.layers=this.layers;this.add(cameraPX);const cameraNX=new PerspectiveCamera(fov,aspect,near,far);cameraNX.layers=this.layers;this.add(cameraNX);const cameraPY=new PerspectiveCamera(fov,aspect,near,far);cameraPY.layers=this.layers;this.add(cameraPY);const cameraNY=new PerspectiveCamera(fov,aspect,near,far);cameraNY.layers=this.layers;this.add(cameraNY);const cameraPZ=new PerspectiveCamera(fov,aspect,near,far);cameraPZ.layers=this.layers;this.add(cameraPZ);const cameraNZ=new PerspectiveCamera(fov,aspect,near,far);cameraNZ.layers=this.layers;this.add(cameraNZ);}updateCoordinateSystem(){const coordinateSystem=this.coordinateSystem;const cameras=this.children.concat();const[cameraPX,cameraNX,cameraPY,cameraNY,cameraPZ,cameraNZ]=cameras;for(const camera of cameras)this.remove(camera);if(coordinateSystem===WebGLCoordinateSystem$1){cameraPX.up.set(0,1,0);cameraPX.lookAt(1,0,0);cameraNX.up.set(0,1,0);cameraNX.lookAt(-1,0,0);cameraPY.up.set(0,0,-1);cameraPY.lookAt(0,1,0);cameraNY.up.set(0,0,1);cameraNY.lookAt(0,-1,0);cameraPZ.up.set(0,1,0);cameraPZ.lookAt(0,0,1);cameraNZ.up.set(0,1,0);cameraNZ.lookAt(0,0,-1);}else if(coordinateSystem===WebGPUCoordinateSystem$1){cameraPX.up.set(0,-1,0);cameraPX.lookAt(-1,0,0);cameraNX.up.set(0,-1,0);cameraNX.lookAt(1,0,0);cameraPY.up.set(0,0,1);cameraPY.lookAt(0,1,0);cameraNY.up.set(0,0,-1);cameraNY.lookAt(0,-1,0);cameraPZ.up.set(0,-1,0);cameraPZ.lookAt(0,0,1);cameraNZ.up.set(0,-1,0);cameraNZ.lookAt(0,0,-1);}else {throw new Error('THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: '+coordinateSystem);}for(const camera of cameras){this.add(camera);camera.updateMatrixWorld();}}update(renderer,scene){if(this.parent===null)this.updateMatrixWorld();const{renderTarget,activeMipmapLevel}=this;if(this.coordinateSystem!==renderer.coordinateSystem){this.coordinateSystem=renderer.coordinateSystem;this.updateCoordinateSystem();}const[cameraPX,cameraNX,cameraPY,cameraNY,cameraPZ,cameraNZ]=this.children;const currentRenderTarget=renderer.getRenderTarget();const currentActiveCubeFace=renderer.getActiveCubeFace();const currentActiveMipmapLevel=renderer.getActiveMipmapLevel();const currentXrEnabled=renderer.xr.enabled;renderer.xr.enabled=false;const generateMipmaps=renderTarget.texture.generateMipmaps;renderTarget.texture.generateMipmaps=false;renderer.setRenderTarget(renderTarget,0,activeMipmapLevel);renderer.render(scene,cameraPX);renderer.setRenderTarget(renderTarget,1,activeMipmapLevel);renderer.render(scene,cameraNX);renderer.setRenderTarget(renderTarget,2,activeMipmapLevel);renderer.render(scene,cameraPY);renderer.setRenderTarget(renderTarget,3,activeMipmapLevel);renderer.render(scene,cameraNY);renderer.setRenderTarget(renderTarget,4,activeMipmapLevel);renderer.render(scene,cameraPZ);// mipmaps are generated during the last call of render()
	// at this point, all sides of the cube render target are defined
	renderTarget.texture.generateMipmaps=generateMipmaps;renderer.setRenderTarget(renderTarget,5,activeMipmapLevel);renderer.render(scene,cameraNZ);renderer.setRenderTarget(currentRenderTarget,currentActiveCubeFace,currentActiveMipmapLevel);renderer.xr.enabled=currentXrEnabled;renderTarget.texture.needsPMREMUpdate=true;}}class CubeTexture extends Texture{constructor(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,colorSpace){images=images!==undefined?images:[];mapping=mapping!==undefined?mapping:CubeReflectionMapping;super(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,colorSpace);this.isCubeTexture=true;this.flipY=false;}get images(){return this.image;}set images(value){this.image=value;}}class WebGLCubeRenderTarget extends WebGLRenderTarget{constructor(size=1,options={}){super(size,size,options);this.isWebGLCubeRenderTarget=true;const image={width:size,height:size,depth:1};const images=[image,image,image,image,image,image];this.texture=new CubeTexture(images,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.colorSpace);// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
	// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
	// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
	// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
	// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
	// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
	this.texture.isRenderTargetTexture=true;this.texture.generateMipmaps=options.generateMipmaps!==undefined?options.generateMipmaps:false;this.texture.minFilter=options.minFilter!==undefined?options.minFilter:LinearFilter;}fromEquirectangularTexture(renderer,texture){this.texture.type=texture.type;this.texture.colorSpace=texture.colorSpace;this.texture.generateMipmaps=texture.generateMipmaps;this.texture.minFilter=texture.minFilter;this.texture.magFilter=texture.magFilter;const shader={uniforms:{tEquirect:{value:null}},vertexShader:/* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:/* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`};const geometry=new BoxGeometry$1(5,5,5);const material=new ShaderMaterial({name:'CubemapFromEquirect',uniforms:cloneUniforms(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader,side:BackSide,blending:NoBlending});material.uniforms.tEquirect.value=texture;const mesh=new Mesh(geometry,material);const currentMinFilter=texture.minFilter;// Avoid blurred poles
	if(texture.minFilter===LinearMipmapLinearFilter)texture.minFilter=LinearFilter;const camera=new CubeCamera(1,10,this);camera.update(renderer,mesh);texture.minFilter=currentMinFilter;mesh.geometry.dispose();mesh.material.dispose();return this;}clear(renderer,color,depth,stencil){const currentRenderTarget=renderer.getRenderTarget();for(let i=0;i<6;i++){renderer.setRenderTarget(this,i);renderer.clear(color,depth,stencil);}renderer.setRenderTarget(currentRenderTarget);}}class Scene extends Object3D$1{constructor(){super();this.isScene=true;this.type='Scene';this.background=null;this.environment=null;this.fog=null;this.backgroundBlurriness=0;this.backgroundIntensity=1;this.backgroundRotation=new Euler$1();this.environmentIntensity=1;this.environmentRotation=new Euler$1();this.overrideMaterial=null;if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:this}));}}copy(source,recursive){super.copy(source,recursive);if(source.background!==null)this.background=source.background.clone();if(source.environment!==null)this.environment=source.environment.clone();if(source.fog!==null)this.fog=source.fog.clone();this.backgroundBlurriness=source.backgroundBlurriness;this.backgroundIntensity=source.backgroundIntensity;this.backgroundRotation.copy(source.backgroundRotation);this.environmentIntensity=source.environmentIntensity;this.environmentRotation.copy(source.environmentRotation);if(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();this.matrixAutoUpdate=source.matrixAutoUpdate;return this;}toJSON(meta){const data=super.toJSON(meta);if(this.fog!==null)data.object.fog=this.fog.toJSON();if(this.backgroundBlurriness>0)data.object.backgroundBlurriness=this.backgroundBlurriness;if(this.backgroundIntensity!==1)data.object.backgroundIntensity=this.backgroundIntensity;data.object.backgroundRotation=this.backgroundRotation.toArray();if(this.environmentIntensity!==1)data.object.environmentIntensity=this.environmentIntensity;data.object.environmentRotation=this.environmentRotation.toArray();return data;}}const _vector1=/*@__PURE__*/new Vector3$1();const _vector2$2=/*@__PURE__*/new Vector3$1();const _normalMatrix=/*@__PURE__*/new Matrix3$1();class Plane{constructor(normal=new Vector3$1(1,0,0),constant=0){this.isPlane=true;// normal is assumed to be normalized
	this.normal=normal;this.constant=constant;}set(normal,constant){this.normal.copy(normal);this.constant=constant;return this;}setComponents(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this;}setFromNormalAndCoplanarPoint(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);return this;}setFromCoplanarPoints(a,b,c){const normal=_vector1.subVectors(c,b).cross(_vector2$2.subVectors(a,b)).normalize();// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	this.setFromNormalAndCoplanarPoint(normal,a);return this;}copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this;}normalize(){// Note: will lead to a divide by zero if the plane is invalid.
	const inverseNormalLength=1.0/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this;}negate(){this.constant*=-1;this.normal.negate();return this;}distanceToPoint(point){return this.normal.dot(point)+this.constant;}distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius;}projectPoint(point,target){return target.copy(point).addScaledVector(this.normal,-this.distanceToPoint(point));}intersectLine(line,target){const direction=line.delta(_vector1);const denominator=this.normal.dot(direction);if(denominator===0){// line is coplanar, return origin
	if(this.distanceToPoint(line.start)===0){return target.copy(line.start);}// Unsure if this is the correct method to handle this case.
	return null;}const t=-(line.start.dot(this.normal)+this.constant)/denominator;if(t<0||t>1){return null;}return target.copy(line.start).addScaledVector(direction,t);}intersectsLine(line){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	const startSign=this.distanceToPoint(line.start);const endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0;}intersectsBox(box){return box.intersectsPlane(this);}intersectsSphere(sphere){return sphere.intersectsPlane(this);}coplanarPoint(target){return target.copy(this.normal).multiplyScalar(-this.constant);}applyMatrix4(matrix,optionalNormalMatrix){const normalMatrix=optionalNormalMatrix||_normalMatrix.getNormalMatrix(matrix);const referencePoint=this.coplanarPoint(_vector1).applyMatrix4(matrix);const normal=this.normal.applyMatrix3(normalMatrix).normalize();this.constant=-referencePoint.dot(normal);return this;}translate(offset){this.constant-=offset.dot(this.normal);return this;}equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant;}clone(){return new this.constructor().copy(this);}}const _sphere$3=/*@__PURE__*/new Sphere$1();const _vector$6=/*@__PURE__*/new Vector3$1();class Frustum{constructor(p0=new Plane(),p1=new Plane(),p2=new Plane(),p3=new Plane(),p4=new Plane(),p5=new Plane()){this.planes=[p0,p1,p2,p3,p4,p5];}set(p0,p1,p2,p3,p4,p5){const planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this;}copy(frustum){const planes=this.planes;for(let i=0;i<6;i++){planes[i].copy(frustum.planes[i]);}return this;}setFromProjectionMatrix(m,coordinateSystem=WebGLCoordinateSystem$1){const planes=this.planes;const me=m.elements;const me0=me[0],me1=me[1],me2=me[2],me3=me[3];const me4=me[4],me5=me[5],me6=me[6],me7=me[7];const me8=me[8],me9=me[9],me10=me[10],me11=me[11];const me12=me[12],me13=me[13],me14=me[14],me15=me[15];planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();if(coordinateSystem===WebGLCoordinateSystem$1){planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();}else if(coordinateSystem===WebGPUCoordinateSystem$1){planes[5].setComponents(me2,me6,me10,me14).normalize();}else {throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: '+coordinateSystem);}return this;}intersectsObject(object){if(object.boundingSphere!==undefined){if(object.boundingSphere===null)object.computeBoundingSphere();_sphere$3.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);}else {const geometry=object.geometry;if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$3.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);}return this.intersectsSphere(_sphere$3);}intersectsSprite(sprite){_sphere$3.center.set(0,0,0);_sphere$3.radius=0.7071067811865476;_sphere$3.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(_sphere$3);}intersectsSphere(sphere){const planes=this.planes;const center=sphere.center;const negRadius=-sphere.radius;for(let i=0;i<6;i++){const distance=planes[i].distanceToPoint(center);if(distance<negRadius){return false;}}return true;}intersectsBox(box){const planes=this.planes;for(let i=0;i<6;i++){const plane=planes[i];// corner at max distance
	_vector$6.x=plane.normal.x>0?box.max.x:box.min.x;_vector$6.y=plane.normal.y>0?box.max.y:box.min.y;_vector$6.z=plane.normal.z>0?box.max.z:box.min.z;if(plane.distanceToPoint(_vector$6)<0){return false;}}return true;}containsPoint(point){const planes=this.planes;for(let i=0;i<6;i++){if(planes[i].distanceToPoint(point)<0){return false;}}return true;}clone(){return new this.constructor().copy(this);}}class Group extends Object3D$1{constructor(){super();this.isGroup=true;this.type='Group';}}class DepthTexture extends Texture{constructor(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format=DepthFormat){if(format!==DepthFormat&&format!==DepthStencilFormat){throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');}if(type===undefined&&format===DepthFormat)type=UnsignedIntType;if(type===undefined&&format===DepthStencilFormat)type=UnsignedInt248Type;super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.isDepthTexture=true;this.image={width:width,height:height};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.flipY=false;this.generateMipmaps=false;this.compareFunction=null;}copy(source){super.copy(source);this.compareFunction=source.compareFunction;return this;}toJSON(meta){const data=super.toJSON(meta);if(this.compareFunction!==null)data.compareFunction=this.compareFunction;return data;}}class PlaneGeometry extends BufferGeometry$1{constructor(width=1,height=1,widthSegments=1,heightSegments=1){super();this.type='PlaneGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};const width_half=width/2;const height_half=height/2;const gridX=Math.floor(widthSegments);const gridY=Math.floor(heightSegments);const gridX1=gridX+1;const gridY1=gridY+1;const segment_width=width/gridX;const segment_height=height/gridY;//
	const indices=[];const vertices=[];const normals=[];const uvs=[];for(let iy=0;iy<gridY1;iy++){const y=iy*segment_height-height_half;for(let ix=0;ix<gridX1;ix++){const x=ix*segment_width-width_half;vertices.push(x,-y,0);normals.push(0,0,1);uvs.push(ix/gridX);uvs.push(1-iy/gridY);}}for(let iy=0;iy<gridY;iy++){for(let ix=0;ix<gridX;ix++){const a=ix+gridX1*iy;const b=ix+gridX1*(iy+1);const c=ix+1+gridX1*(iy+1);const d=ix+1+gridX1*iy;indices.push(a,b,d);indices.push(b,c,d);}}this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute$1(vertices,3));this.setAttribute('normal',new Float32BufferAttribute$1(normals,3));this.setAttribute('uv',new Float32BufferAttribute$1(uvs,2));}copy(source){super.copy(source);this.parameters=Object.assign({},source.parameters);return this;}static fromJSON(data){return new PlaneGeometry(data.width,data.height,data.widthSegments,data.heightSegments);}}class MeshPhongMaterial extends Material{constructor(parameters){super();this.isMeshPhongMaterial=true;this.type='MeshPhongMaterial';this.color=new Color(0xffffff);// diffuse
	this.specular=new Color(0x111111);this.shininess=30;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2$1(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.envMapRotation=new Euler$1();this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.flatShading=false;this.fog=true;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.specular.copy(source.specular);this.shininess=source.shininess;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapRotation.copy(source.envMapRotation);this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;this.fog=source.fog;return this;}}class MeshLambertMaterial extends Material{constructor(parameters){super();this.isMeshLambertMaterial=true;this.type='MeshLambertMaterial';this.color=new Color(0xffffff);// diffuse
	this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2$1(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.envMapRotation=new Euler$1();this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.flatShading=false;this.fog=true;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapRotation.copy(source.envMapRotation);this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;this.fog=source.fog;return this;}}class MeshDepthMaterial extends Material{constructor(parameters){super();this.isMeshDepthMaterial=true;this.type='MeshDepthMaterial';this.depthPacking=BasicDepthPacking;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.setValues(parameters);}copy(source){super.copy(source);this.depthPacking=source.depthPacking;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;return this;}}class MeshDistanceMaterial extends Material{constructor(parameters){super();this.isMeshDistanceMaterial=true;this.type='MeshDistanceMaterial';this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.setValues(parameters);}copy(source){super.copy(source);this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;return this;}}class Light extends Object3D$1{constructor(color,intensity=1){super();this.isLight=true;this.type='Light';this.color=new Color(color);this.intensity=intensity;}dispose(){// Empty here in base class; some subclasses override.
	}copy(source,recursive){super.copy(source,recursive);this.color.copy(source.color);this.intensity=source.intensity;return this;}toJSON(meta){const data=super.toJSON(meta);data.object.color=this.color.getHex();data.object.intensity=this.intensity;if(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();if(this.distance!==undefined)data.object.distance=this.distance;if(this.angle!==undefined)data.object.angle=this.angle;if(this.decay!==undefined)data.object.decay=this.decay;if(this.penumbra!==undefined)data.object.penumbra=this.penumbra;if(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();if(this.target!==undefined)data.object.target=this.target.uuid;return data;}}const _projScreenMatrix$1=/*@__PURE__*/new Matrix4$1();const _lightPositionWorld$1=/*@__PURE__*/new Vector3$1();const _lookTarget$1=/*@__PURE__*/new Vector3$1();class LightShadow{constructor(camera){this.camera=camera;this.intensity=1;this.bias=0;this.normalBias=0;this.radius=1;this.blurSamples=8;this.mapSize=new Vector2$1(512,512);this.map=null;this.mapPass=null;this.matrix=new Matrix4$1();this.autoUpdate=true;this.needsUpdate=false;this._frustum=new Frustum();this._frameExtents=new Vector2$1(1,1);this._viewportCount=1;this._viewports=[new Vector4(0,0,1,1)];}getViewportCount(){return this._viewportCount;}getFrustum(){return this._frustum;}updateMatrices(light){const shadowCamera=this.camera;const shadowMatrix=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);shadowCamera.position.copy(_lightPositionWorld$1);_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);shadowCamera.lookAt(_lookTarget$1);shadowCamera.updateMatrixWorld();_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);shadowMatrix.set(0.5,0.0,0.0,0.5,0.0,0.5,0.0,0.5,0.0,0.0,0.5,0.5,0.0,0.0,0.0,1.0);shadowMatrix.multiply(_projScreenMatrix$1);}getViewport(viewportIndex){return this._viewports[viewportIndex];}getFrameExtents(){return this._frameExtents;}dispose(){if(this.map){this.map.dispose();}if(this.mapPass){this.mapPass.dispose();}}copy(source){this.camera=source.camera.clone();this.intensity=source.intensity;this.bias=source.bias;this.radius=source.radius;this.mapSize.copy(source.mapSize);return this;}clone(){return new this.constructor().copy(this);}toJSON(){const object={};if(this.intensity!==1)object.intensity=this.intensity;if(this.bias!==0)object.bias=this.bias;if(this.normalBias!==0)object.normalBias=this.normalBias;if(this.radius!==1)object.radius=this.radius;if(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();object.camera=this.camera.toJSON(false).object;delete object.camera.matrix;return object;}}class OrthographicCamera extends Camera{constructor(left=-1,right=1,top=1,bottom=-1,near=0.1,far=2000){super();this.isOrthographicCamera=true;this.type='OrthographicCamera';this.zoom=1;this.view=null;this.left=left;this.right=right;this.top=top;this.bottom=bottom;this.near=near;this.far=far;this.updateProjectionMatrix();}copy(source,recursive){super.copy(source,recursive);this.left=source.left;this.right=source.right;this.top=source.top;this.bottom=source.bottom;this.near=source.near;this.far=source.far;this.zoom=source.zoom;this.view=source.view===null?null:Object.assign({},source.view);return this;}setViewOffset(fullWidth,fullHeight,x,y,width,height){if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();}clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();}updateProjectionMatrix(){const dx=(this.right-this.left)/(2*this.zoom);const dy=(this.top-this.bottom)/(2*this.zoom);const cx=(this.right+this.left)/2;const cy=(this.top+this.bottom)/2;let left=cx-dx;let right=cx+dx;let top=cy+dy;let bottom=cy-dy;if(this.view!==null&&this.view.enabled){const scaleW=(this.right-this.left)/this.view.fullWidth/this.zoom;const scaleH=(this.top-this.bottom)/this.view.fullHeight/this.zoom;left+=scaleW*this.view.offsetX;right=left+scaleW*this.view.width;top-=scaleH*this.view.offsetY;bottom=top-scaleH*this.view.height;}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far,this.coordinateSystem);this.projectionMatrixInverse.copy(this.projectionMatrix).invert();}toJSON(meta){const data=super.toJSON(meta);data.object.zoom=this.zoom;data.object.left=this.left;data.object.right=this.right;data.object.top=this.top;data.object.bottom=this.bottom;data.object.near=this.near;data.object.far=this.far;if(this.view!==null)data.object.view=Object.assign({},this.view);return data;}}class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera(-5,5,5,-5,0.5,500));this.isDirectionalLightShadow=true;}}class DirectionalLight extends Light{constructor(color,intensity){super(color,intensity);this.isDirectionalLight=true;this.type='DirectionalLight';this.position.copy(Object3D$1.DEFAULT_UP);this.updateMatrix();this.target=new Object3D$1();this.shadow=new DirectionalLightShadow();}dispose(){this.shadow.dispose();}copy(source){super.copy(source);this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}}class AmbientLight extends Light{constructor(color,intensity){super(color,intensity);this.isAmbientLight=true;this.type='AmbientLight';}}class ArrayCamera extends PerspectiveCamera{constructor(array=[]){super();this.isArrayCamera=true;this.cameras=array;}}/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * phi (the polar angle) is measured from the positive y-axis. The positive y-axis is up.
	 * theta (the azimuthal angle) is measured from the positive z-axis.
	 */class Spherical{constructor(radius=1,phi=0,theta=0){this.radius=radius;this.phi=phi;// polar angle
	this.theta=theta;// azimuthal angle
	return this;}set(radius,phi,theta){this.radius=radius;this.phi=phi;this.theta=theta;return this;}copy(other){this.radius=other.radius;this.phi=other.phi;this.theta=other.theta;return this;}// restrict phi to be between EPS and PI-EPS
	makeSafe(){const EPS=0.000001;this.phi=clamp$1(this.phi,EPS,Math.PI-EPS);return this;}setFromVector3(v){return this.setFromCartesianCoords(v.x,v.y,v.z);}setFromCartesianCoords(x,y,z){this.radius=Math.sqrt(x*x+y*y+z*z);if(this.radius===0){this.theta=0;this.phi=0;}else {this.theta=Math.atan2(x,z);this.phi=Math.acos(clamp$1(y/this.radius,-1,1));}return this;}clone(){return new this.constructor().copy(this);}}class Controls extends EventDispatcher$1{constructor(object,domElement=null){super();this.object=object;this.domElement=domElement;this.enabled=true;this.state=-1;this.keys={};this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null};this.touches={ONE:null,TWO:null};}connect(){}disconnect(){}dispose(){}update(/* delta */){}}/**
	 * Given the width, height, format, and type of a texture. Determines how many
	 * bytes must be used to represent the texture.
	 */function getByteLength(width,height,format,type){const typeByteLength=getTextureTypeByteLength(type);switch(format){// https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
	case AlphaFormat:return width*height;case LuminanceFormat:return width*height;case LuminanceAlphaFormat:return width*height*2;case RedFormat:return width*height/typeByteLength.components*typeByteLength.byteLength;case RedIntegerFormat:return width*height/typeByteLength.components*typeByteLength.byteLength;case RGFormat:return width*height*2/typeByteLength.components*typeByteLength.byteLength;case RGIntegerFormat:return width*height*2/typeByteLength.components*typeByteLength.byteLength;case RGBFormat:return width*height*3/typeByteLength.components*typeByteLength.byteLength;case RGBAFormat:return width*height*4/typeByteLength.components*typeByteLength.byteLength;case RGBAIntegerFormat:return width*height*4/typeByteLength.components*typeByteLength.byteLength;// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
	case RGB_S3TC_DXT1_Format:case RGBA_S3TC_DXT1_Format:return Math.floor((width+3)/4)*Math.floor((height+3)/4)*8;case RGBA_S3TC_DXT3_Format:case RGBA_S3TC_DXT5_Format:return Math.floor((width+3)/4)*Math.floor((height+3)/4)*16;// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
	case RGB_PVRTC_2BPPV1_Format:case RGBA_PVRTC_2BPPV1_Format:return Math.max(width,16)*Math.max(height,8)/4;case RGB_PVRTC_4BPPV1_Format:case RGBA_PVRTC_4BPPV1_Format:return Math.max(width,8)*Math.max(height,8)/2;// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
	case RGB_ETC1_Format:case RGB_ETC2_Format:return Math.floor((width+3)/4)*Math.floor((height+3)/4)*8;case RGBA_ETC2_EAC_Format:return Math.floor((width+3)/4)*Math.floor((height+3)/4)*16;// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
	case RGBA_ASTC_4x4_Format:return Math.floor((width+3)/4)*Math.floor((height+3)/4)*16;case RGBA_ASTC_5x4_Format:return Math.floor((width+4)/5)*Math.floor((height+3)/4)*16;case RGBA_ASTC_5x5_Format:return Math.floor((width+4)/5)*Math.floor((height+4)/5)*16;case RGBA_ASTC_6x5_Format:return Math.floor((width+5)/6)*Math.floor((height+4)/5)*16;case RGBA_ASTC_6x6_Format:return Math.floor((width+5)/6)*Math.floor((height+5)/6)*16;case RGBA_ASTC_8x5_Format:return Math.floor((width+7)/8)*Math.floor((height+4)/5)*16;case RGBA_ASTC_8x6_Format:return Math.floor((width+7)/8)*Math.floor((height+5)/6)*16;case RGBA_ASTC_8x8_Format:return Math.floor((width+7)/8)*Math.floor((height+7)/8)*16;case RGBA_ASTC_10x5_Format:return Math.floor((width+9)/10)*Math.floor((height+4)/5)*16;case RGBA_ASTC_10x6_Format:return Math.floor((width+9)/10)*Math.floor((height+5)/6)*16;case RGBA_ASTC_10x8_Format:return Math.floor((width+9)/10)*Math.floor((height+7)/8)*16;case RGBA_ASTC_10x10_Format:return Math.floor((width+9)/10)*Math.floor((height+9)/10)*16;case RGBA_ASTC_12x10_Format:return Math.floor((width+11)/12)*Math.floor((height+9)/10)*16;case RGBA_ASTC_12x12_Format:return Math.floor((width+11)/12)*Math.floor((height+11)/12)*16;// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
	case RGBA_BPTC_Format:case RGB_BPTC_SIGNED_Format:case RGB_BPTC_UNSIGNED_Format:return Math.ceil(width/4)*Math.ceil(height/4)*16;// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
	case RED_RGTC1_Format:case SIGNED_RED_RGTC1_Format:return Math.ceil(width/4)*Math.ceil(height/4)*8;case RED_GREEN_RGTC2_Format:case SIGNED_RED_GREEN_RGTC2_Format:return Math.ceil(width/4)*Math.ceil(height/4)*16;}throw new Error(`Unable to determine texture byte length for ${format} format.`);}function getTextureTypeByteLength(type){switch(type){case UnsignedByteType:case ByteType:return {byteLength:1,components:1};case UnsignedShortType:case ShortType:case HalfFloatType:return {byteLength:2,components:1};case UnsignedShort4444Type:case UnsignedShort5551Type:return {byteLength:2,components:4};case UnsignedIntType:case IntType:case FloatType$1:return {byteLength:4,components:1};case UnsignedInt5999Type:return {byteLength:4,components:3};}throw new Error(`Unknown texture type ${type}.`);}if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register',{detail:{revision:REVISION}}));}if(typeof window!=='undefined'){if(window.__THREE__){console.warn('WARNING: Multiple instances of Three.js being imported.');}else {window.__THREE__=REVISION;}}

	function WebGLAnimation(){let context=null;let isAnimating=false;let animationLoop=null;let requestId=null;function onAnimationFrame(time,frame){animationLoop(time,frame);requestId=context.requestAnimationFrame(onAnimationFrame);}return {start:function(){if(isAnimating===true)return;if(animationLoop===null)return;requestId=context.requestAnimationFrame(onAnimationFrame);isAnimating=true;},stop:function(){context.cancelAnimationFrame(requestId);isAnimating=false;},setAnimationLoop:function(callback){animationLoop=callback;},setContext:function(value){context=value;}};}function WebGLAttributes(gl){const buffers=new WeakMap();function createBuffer(attribute,bufferType){const array=attribute.array;const usage=attribute.usage;const size=array.byteLength;const buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer);gl.bufferData(bufferType,array,usage);attribute.onUploadCallback();let type;if(array instanceof Float32Array){type=gl.FLOAT;}else if(array instanceof Uint16Array){if(attribute.isFloat16BufferAttribute){type=gl.HALF_FLOAT;}else {type=gl.UNSIGNED_SHORT;}}else if(array instanceof Int16Array){type=gl.SHORT;}else if(array instanceof Uint32Array){type=gl.UNSIGNED_INT;}else if(array instanceof Int32Array){type=gl.INT;}else if(array instanceof Int8Array){type=gl.BYTE;}else if(array instanceof Uint8Array){type=gl.UNSIGNED_BYTE;}else if(array instanceof Uint8ClampedArray){type=gl.UNSIGNED_BYTE;}else {throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: '+array);}return {buffer:buffer,type:type,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version,size:size};}function updateBuffer(buffer,attribute,bufferType){const array=attribute.array;const updateRanges=attribute.updateRanges;gl.bindBuffer(bufferType,buffer);if(updateRanges.length===0){// Not using update ranges
	gl.bufferSubData(bufferType,0,array);}else {// Before applying update ranges, we merge any adjacent / overlapping
	// ranges to reduce load on `gl.bufferSubData`. Empirically, this has led
	// to performance improvements for applications which make heavy use of
	// update ranges. Likely due to GPU command overhead.
	//
	// Note that to reduce garbage collection between frames, we merge the
	// update ranges in-place. This is safe because this method will clear the
	// update ranges once updated.
	updateRanges.sort((a,b)=>a.start-b.start);// To merge the update ranges in-place, we work from left to right in the
	// existing updateRanges array, merging ranges. This may result in a final
	// array which is smaller than the original. This index tracks the last
	// index representing a merged range, any data after this index can be
	// trimmed once the merge algorithm is completed.
	let mergeIndex=0;for(let i=1;i<updateRanges.length;i++){const previousRange=updateRanges[mergeIndex];const range=updateRanges[i];// We add one here to merge adjacent ranges. This is safe because ranges
	// operate over positive integers.
	if(range.start<=previousRange.start+previousRange.count+1){previousRange.count=Math.max(previousRange.count,range.start+range.count-previousRange.start);}else {++mergeIndex;updateRanges[mergeIndex]=range;}}// Trim the array to only contain the merged ranges.
	updateRanges.length=mergeIndex+1;for(let i=0,l=updateRanges.length;i<l;i++){const range=updateRanges[i];gl.bufferSubData(bufferType,range.start*array.BYTES_PER_ELEMENT,array,range.start,range.count);}attribute.clearUpdateRanges();}attribute.onUploadCallback();}//
	function get(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;return buffers.get(attribute);}function remove(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;const data=buffers.get(attribute);if(data){gl.deleteBuffer(data.buffer);buffers.delete(attribute);}}function update(attribute,bufferType){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;if(attribute.isGLBufferAttribute){const cached=buffers.get(attribute);if(!cached||cached.version<attribute.version){buffers.set(attribute,{buffer:attribute.buffer,type:attribute.type,bytesPerElement:attribute.elementSize,version:attribute.version});}return;}const data=buffers.get(attribute);if(data===undefined){buffers.set(attribute,createBuffer(attribute,bufferType));}else if(data.version<attribute.version){if(data.size!==attribute.array.byteLength){throw new Error('THREE.WebGLAttributes: The size of the buffer attribute\'s array buffer does not match the original size. Resizing buffer attributes is not supported.');}updateBuffer(data.buffer,attribute,bufferType);data.version=attribute.version;}}return {get:get,remove:remove,update:update};}var alphahash_fragment="#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";var alphahash_pars_fragment="#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif";var alphamap_fragment="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";var alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var alphatest_fragment="#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif";var alphatest_pars_fragment="#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";var aomap_fragment="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";var aomap_pars_fragment="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";var batching_pars_vertex="#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif";var batching_vertex="#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";var begin_vertex="vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif";var beginnormal_vertex="vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";var bsdfs="float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated";var iridescence_fragment="#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";var bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";var clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif";var clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";var clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";var clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";var color_fragment="#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";var color_pars_fragment="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";var color_pars_vertex="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif";var color_vertex="#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif";var common="#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";var cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";var defaultnormal_vertex="vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";var displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";var displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";var emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";var emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";var colorspace_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );";var colorspace_pars_fragment="vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";var envmap_fragment="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";var envmap_common_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";var envmap_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";var envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";var envmap_vertex="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";var fog_vertex="#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";var fog_pars_vertex="#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";var fog_fragment="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";var fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";var gradientmap_pars_fragment="#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";var lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";var lights_lambert_fragment="LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";var lights_lambert_pars_fragment="varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";var lights_pars_begin="uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";var envmap_physical_pars_fragment="#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif";var lights_toon_fragment="ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";var lights_toon_pars_fragment="varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";var lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";var lights_phong_pars_fragment="varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";var lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";var lights_physical_pars_fragment="struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";var lights_fragment_begin="\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";var lights_fragment_maps="#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";var lights_fragment_end="#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";var logdepthbuf_fragment="#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";var logdepthbuf_pars_fragment="#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";var logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";var logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";var map_fragment="#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";var map_pars_fragment="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";var map_particle_fragment="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";var map_particle_pars_fragment="#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";var metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";var morphinstance_vertex="#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif";var morphcolor_vertex="#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";var morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";var morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif";var morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";var normal_fragment_begin="float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;";var normal_fragment_maps="#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";var normal_pars_fragment="#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";var normal_pars_vertex="#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";var normal_vertex="#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";var normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif";var clearcoat_normal_fragment_begin="#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif";var clearcoat_normal_fragment_maps="#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";var clearcoat_pars_fragment="#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif";var iridescence_pars_fragment="#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";var opaque_fragment="#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";var packing="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}";var premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";var project_vertex="vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";var dithering_fragment="#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";var dithering_pars_fragment="#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";var roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";var roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";var shadowmap_pars_fragment="#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif";var shadowmap_pars_vertex="#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";var shadowmap_vertex="#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";var shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";var skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";var skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif";var skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";var skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";var specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";var specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";var tonemapping_fragment="#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";var tonemapping_pars_fragment="#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";var transmission_fragment="#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";var transmission_pars_fragment="#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif";var uv_pars_fragment="#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";var uv_pars_vertex="#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";var uv_vertex="#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";var worldpos_vertex="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";const vertex$h="varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";const fragment$h="uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";const vertex$g="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";const fragment$g="#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";const vertex$f="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";const fragment$f="uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";const vertex$e="#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";const fragment$e="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}";const vertex$d="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";const fragment$d="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";const vertex$c="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";const fragment$c="uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";const vertex$b="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";const fragment$b="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";const vertex$a="#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";const fragment$a="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const vertex$9="#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";const fragment$9="#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const vertex$8="#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";const fragment$8="#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const vertex$7="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";const fragment$7="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";const vertex$6="#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";const fragment$6="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const vertex$5="#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";const fragment$5="#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const vertex$4="#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";const fragment$4="#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const vertex$3="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";const fragment$3="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";const vertex$2="#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";const fragment$2="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";const vertex$1="uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";const fragment$1="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";const ShaderChunk={alphahash_fragment:alphahash_fragment,alphahash_pars_fragment:alphahash_pars_fragment,alphamap_fragment:alphamap_fragment,alphamap_pars_fragment:alphamap_pars_fragment,alphatest_fragment:alphatest_fragment,alphatest_pars_fragment:alphatest_pars_fragment,aomap_fragment:aomap_fragment,aomap_pars_fragment:aomap_pars_fragment,batching_pars_vertex:batching_pars_vertex,batching_vertex:batching_vertex,begin_vertex:begin_vertex,beginnormal_vertex:beginnormal_vertex,bsdfs:bsdfs,iridescence_fragment:iridescence_fragment,bumpmap_pars_fragment:bumpmap_pars_fragment,clipping_planes_fragment:clipping_planes_fragment,clipping_planes_pars_fragment:clipping_planes_pars_fragment,clipping_planes_pars_vertex:clipping_planes_pars_vertex,clipping_planes_vertex:clipping_planes_vertex,color_fragment:color_fragment,color_pars_fragment:color_pars_fragment,color_pars_vertex:color_pars_vertex,color_vertex:color_vertex,common:common,cube_uv_reflection_fragment:cube_uv_reflection_fragment,defaultnormal_vertex:defaultnormal_vertex,displacementmap_pars_vertex:displacementmap_pars_vertex,displacementmap_vertex:displacementmap_vertex,emissivemap_fragment:emissivemap_fragment,emissivemap_pars_fragment:emissivemap_pars_fragment,colorspace_fragment:colorspace_fragment,colorspace_pars_fragment:colorspace_pars_fragment,envmap_fragment:envmap_fragment,envmap_common_pars_fragment:envmap_common_pars_fragment,envmap_pars_fragment:envmap_pars_fragment,envmap_pars_vertex:envmap_pars_vertex,envmap_physical_pars_fragment:envmap_physical_pars_fragment,envmap_vertex:envmap_vertex,fog_vertex:fog_vertex,fog_pars_vertex:fog_pars_vertex,fog_fragment:fog_fragment,fog_pars_fragment:fog_pars_fragment,gradientmap_pars_fragment:gradientmap_pars_fragment,lightmap_pars_fragment:lightmap_pars_fragment,lights_lambert_fragment:lights_lambert_fragment,lights_lambert_pars_fragment:lights_lambert_pars_fragment,lights_pars_begin:lights_pars_begin,lights_toon_fragment:lights_toon_fragment,lights_toon_pars_fragment:lights_toon_pars_fragment,lights_phong_fragment:lights_phong_fragment,lights_phong_pars_fragment:lights_phong_pars_fragment,lights_physical_fragment:lights_physical_fragment,lights_physical_pars_fragment:lights_physical_pars_fragment,lights_fragment_begin:lights_fragment_begin,lights_fragment_maps:lights_fragment_maps,lights_fragment_end:lights_fragment_end,logdepthbuf_fragment:logdepthbuf_fragment,logdepthbuf_pars_fragment:logdepthbuf_pars_fragment,logdepthbuf_pars_vertex:logdepthbuf_pars_vertex,logdepthbuf_vertex:logdepthbuf_vertex,map_fragment:map_fragment,map_pars_fragment:map_pars_fragment,map_particle_fragment:map_particle_fragment,map_particle_pars_fragment:map_particle_pars_fragment,metalnessmap_fragment:metalnessmap_fragment,metalnessmap_pars_fragment:metalnessmap_pars_fragment,morphinstance_vertex:morphinstance_vertex,morphcolor_vertex:morphcolor_vertex,morphnormal_vertex:morphnormal_vertex,morphtarget_pars_vertex:morphtarget_pars_vertex,morphtarget_vertex:morphtarget_vertex,normal_fragment_begin:normal_fragment_begin,normal_fragment_maps:normal_fragment_maps,normal_pars_fragment:normal_pars_fragment,normal_pars_vertex:normal_pars_vertex,normal_vertex:normal_vertex,normalmap_pars_fragment:normalmap_pars_fragment,clearcoat_normal_fragment_begin:clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps:clearcoat_normal_fragment_maps,clearcoat_pars_fragment:clearcoat_pars_fragment,iridescence_pars_fragment:iridescence_pars_fragment,opaque_fragment:opaque_fragment,packing:packing,premultiplied_alpha_fragment:premultiplied_alpha_fragment,project_vertex:project_vertex,dithering_fragment:dithering_fragment,dithering_pars_fragment:dithering_pars_fragment,roughnessmap_fragment:roughnessmap_fragment,roughnessmap_pars_fragment:roughnessmap_pars_fragment,shadowmap_pars_fragment:shadowmap_pars_fragment,shadowmap_pars_vertex:shadowmap_pars_vertex,shadowmap_vertex:shadowmap_vertex,shadowmask_pars_fragment:shadowmask_pars_fragment,skinbase_vertex:skinbase_vertex,skinning_pars_vertex:skinning_pars_vertex,skinning_vertex:skinning_vertex,skinnormal_vertex:skinnormal_vertex,specularmap_fragment:specularmap_fragment,specularmap_pars_fragment:specularmap_pars_fragment,tonemapping_fragment:tonemapping_fragment,tonemapping_pars_fragment:tonemapping_pars_fragment,transmission_fragment:transmission_fragment,transmission_pars_fragment:transmission_pars_fragment,uv_pars_fragment:uv_pars_fragment,uv_pars_vertex:uv_pars_vertex,uv_vertex:uv_vertex,worldpos_vertex:worldpos_vertex,background_vert:vertex$h,background_frag:fragment$h,backgroundCube_vert:vertex$g,backgroundCube_frag:fragment$g,cube_vert:vertex$f,cube_frag:fragment$f,depth_vert:vertex$e,depth_frag:fragment$e,distanceRGBA_vert:vertex$d,distanceRGBA_frag:fragment$d,equirect_vert:vertex$c,equirect_frag:fragment$c,linedashed_vert:vertex$b,linedashed_frag:fragment$b,meshbasic_vert:vertex$a,meshbasic_frag:fragment$a,meshlambert_vert:vertex$9,meshlambert_frag:fragment$9,meshmatcap_vert:vertex$8,meshmatcap_frag:fragment$8,meshnormal_vert:vertex$7,meshnormal_frag:fragment$7,meshphong_vert:vertex$6,meshphong_frag:fragment$6,meshphysical_vert:vertex$5,meshphysical_frag:fragment$5,meshtoon_vert:vertex$4,meshtoon_frag:fragment$4,points_vert:vertex$3,points_frag:fragment$3,shadow_vert:vertex$2,shadow_frag:fragment$2,sprite_vert:vertex$1,sprite_frag:fragment$1};/**
	 * Uniforms library for shared webgl shaders
	 */const UniformsLib={common:{diffuse:{value:/*@__PURE__*/new Color(0xffffff)},opacity:{value:1.0},map:{value:null},mapTransform:{value:/*@__PURE__*/new Matrix3$1()},alphaMap:{value:null},alphaMapTransform:{value:/*@__PURE__*/new Matrix3$1()},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:/*@__PURE__*/new Matrix3$1()}},envmap:{envMap:{value:null},envMapRotation:{value:/*@__PURE__*/new Matrix3$1()},flipEnvMap:{value:-1},reflectivity:{value:1.0},// basic, lambert, phong
	ior:{value:1.5},// physical
	refractionRatio:{value:0.98}// basic, lambert, phong
	},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:/*@__PURE__*/new Matrix3$1()}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:/*@__PURE__*/new Matrix3$1()}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:/*@__PURE__*/new Matrix3$1()},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:/*@__PURE__*/new Matrix3$1()},normalScale:{value:/*@__PURE__*/new Vector2$1(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:/*@__PURE__*/new Matrix3$1()},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:/*@__PURE__*/new Matrix3$1()}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:/*@__PURE__*/new Matrix3$1()}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:/*@__PURE__*/new Matrix3$1()}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:/*@__PURE__*/new Color(0xffffff)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
	rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:/*@__PURE__*/new Color(0xffffff)},opacity:{value:1.0},size:{value:1.0},scale:{value:1.0},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:/*@__PURE__*/new Matrix3$1()},alphaTest:{value:0},uvTransform:{value:/*@__PURE__*/new Matrix3$1()}},sprite:{diffuse:{value:/*@__PURE__*/new Color(0xffffff)},opacity:{value:1.0},center:{value:/*@__PURE__*/new Vector2$1(0.5,0.5)},rotation:{value:0.0},map:{value:null},mapTransform:{value:/*@__PURE__*/new Matrix3$1()},alphaMap:{value:null},alphaMapTransform:{value:/*@__PURE__*/new Matrix3$1()},alphaTest:{value:0}}};const ShaderLib={basic:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:/*@__PURE__*/new Color(0x000000)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:/*@__PURE__*/new Color(0x000000)},specular:{value:/*@__PURE__*/new Color(0x111111)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:/*@__PURE__*/new Color(0x000000)},roughness:{value:1.0},metalness:{value:0.0},envMapIntensity:{value:1}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:/*@__PURE__*/new Color(0x000000)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.meshnormal_vert,fragmentShader:ShaderChunk.meshnormal_frag},sprite:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:/*@__PURE__*/new Matrix3$1()},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:/*@__PURE__*/new Matrix3$1()}},vertexShader:ShaderChunk.backgroundCube_vert,fragmentShader:ShaderChunk.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1.0}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:/*@__PURE__*/new Vector3$1()},nearDistance:{value:1},farDistance:{value:1000}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:/*@__PURE__*/new Color(0x00000)},opacity:{value:1.0}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:/*@__PURE__*/mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:/*@__PURE__*/new Matrix3$1()},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:/*@__PURE__*/new Matrix3$1()},clearcoatNormalScale:{value:/*@__PURE__*/new Vector2$1(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:/*@__PURE__*/new Matrix3$1()},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:/*@__PURE__*/new Matrix3$1()},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:/*@__PURE__*/new Matrix3$1()},sheen:{value:0},sheenColor:{value:/*@__PURE__*/new Color(0x000000)},sheenColorMap:{value:null},sheenColorMapTransform:{value:/*@__PURE__*/new Matrix3$1()},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:/*@__PURE__*/new Matrix3$1()},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:/*@__PURE__*/new Matrix3$1()},transmissionSamplerSize:{value:/*@__PURE__*/new Vector2$1()},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:/*@__PURE__*/new Matrix3$1()},attenuationDistance:{value:0},attenuationColor:{value:/*@__PURE__*/new Color(0x000000)},specularColor:{value:/*@__PURE__*/new Color(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:/*@__PURE__*/new Matrix3$1()},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:/*@__PURE__*/new Matrix3$1()},anisotropyVector:{value:/*@__PURE__*/new Vector2$1()},anisotropyMap:{value:null},anisotropyMapTransform:{value:/*@__PURE__*/new Matrix3$1()}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};const _rgb={r:0,b:0,g:0};const _e1$1=/*@__PURE__*/new Euler$1();const _m1$1$1=/*@__PURE__*/new Matrix4$1();function WebGLBackground(renderer,cubemaps,cubeuvmaps,state,objects,alpha,premultipliedAlpha){const clearColor=new Color(0x000000);let clearAlpha=alpha===true?0:1;let planeMesh;let boxMesh;let currentBackground=null;let currentBackgroundVersion=0;let currentTonemapping=null;function getBackground(scene){let background=scene.isScene===true?scene.background:null;if(background&&background.isTexture){const usePMREM=scene.backgroundBlurriness>0;// use PMREM if the user wants to blur the background
	background=(usePMREM?cubeuvmaps:cubemaps).get(background);}return background;}function render(scene){let forceClear=false;const background=getBackground(scene);if(background===null){setClear(clearColor,clearAlpha);}else if(background&&background.isColor){setClear(background,1);forceClear=true;}const environmentBlendMode=renderer.xr.getEnvironmentBlendMode();if(environmentBlendMode==='additive'){state.buffers.color.setClear(0,0,0,1,premultipliedAlpha);}else if(environmentBlendMode==='alpha-blend'){state.buffers.color.setClear(0,0,0,0,premultipliedAlpha);}if(renderer.autoClear||forceClear){// buffers might not be writable which is required to ensure a correct clear
	state.buffers.depth.setTest(true);state.buffers.depth.setMask(true);state.buffers.color.setMask(true);renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil);}}function addToRenderList(renderList,scene){const background=getBackground(scene);if(background&&(background.isCubeTexture||background.mapping===CubeUVReflectionMapping)){if(boxMesh===undefined){boxMesh=new Mesh(new BoxGeometry$1(1,1,1),new ShaderMaterial({name:'BackgroundCubeMaterial',uniforms:cloneUniforms(ShaderLib.backgroundCube.uniforms),vertexShader:ShaderLib.backgroundCube.vertexShader,fragmentShader:ShaderLib.backgroundCube.fragmentShader,side:BackSide,depthTest:false,depthWrite:false,fog:false}));boxMesh.geometry.deleteAttribute('normal');boxMesh.geometry.deleteAttribute('uv');boxMesh.onBeforeRender=function(renderer,scene,camera){this.matrixWorld.copyPosition(camera.matrixWorld);};// add "envMap" material property so the renderer can evaluate it like for built-in materials
	Object.defineProperty(boxMesh.material,'envMap',{get:function(){return this.uniforms.envMap.value;}});objects.update(boxMesh);}_e1$1.copy(scene.backgroundRotation);// accommodate left-handed frame
	_e1$1.x*=-1;_e1$1.y*=-1;_e1$1.z*=-1;if(background.isCubeTexture&&background.isRenderTargetTexture===false){// environment maps which are not cube render targets or PMREMs follow a different convention
	_e1$1.y*=-1;_e1$1.z*=-1;}boxMesh.material.uniforms.envMap.value=background;boxMesh.material.uniforms.flipEnvMap.value=background.isCubeTexture&&background.isRenderTargetTexture===false?-1:1;boxMesh.material.uniforms.backgroundBlurriness.value=scene.backgroundBlurriness;boxMesh.material.uniforms.backgroundIntensity.value=scene.backgroundIntensity;boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1$1.makeRotationFromEuler(_e1$1));boxMesh.material.toneMapped=ColorManagement.getTransfer(background.colorSpace)!==SRGBTransfer;if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping){boxMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=background.version;currentTonemapping=renderer.toneMapping;}boxMesh.layers.enableAll();// push to the pre-sorted opaque render list
	renderList.unshift(boxMesh,boxMesh.geometry,boxMesh.material,0,0,null);}else if(background&&background.isTexture){if(planeMesh===undefined){planeMesh=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:'BackgroundMaterial',uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:false,depthWrite:false,fog:false}));planeMesh.geometry.deleteAttribute('normal');// add "map" material property so the renderer can evaluate it like for built-in materials
	Object.defineProperty(planeMesh.material,'map',{get:function(){return this.uniforms.t2D.value;}});objects.update(planeMesh);}planeMesh.material.uniforms.t2D.value=background;planeMesh.material.uniforms.backgroundIntensity.value=scene.backgroundIntensity;planeMesh.material.toneMapped=ColorManagement.getTransfer(background.colorSpace)!==SRGBTransfer;if(background.matrixAutoUpdate===true){background.updateMatrix();}planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping){planeMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=background.version;currentTonemapping=renderer.toneMapping;}planeMesh.layers.enableAll();// push to the pre-sorted opaque render list
	renderList.unshift(planeMesh,planeMesh.geometry,planeMesh.material,0,0,null);}}function setClear(color,alpha){color.getRGB(_rgb,getUnlitUniformColorSpace(renderer));state.buffers.color.setClear(_rgb.r,_rgb.g,_rgb.b,alpha,premultipliedAlpha);}function dispose(){if(boxMesh!==undefined){boxMesh.geometry.dispose();boxMesh.material.dispose();}if(planeMesh!==undefined){planeMesh.geometry.dispose();planeMesh.material.dispose();}}return {getClearColor:function(){return clearColor;},setClearColor:function(color,alpha=1){clearColor.set(color);clearAlpha=alpha;setClear(clearColor,clearAlpha);},getClearAlpha:function(){return clearAlpha;},setClearAlpha:function(alpha){clearAlpha=alpha;setClear(clearColor,clearAlpha);},render:render,addToRenderList:addToRenderList,dispose:dispose};}function WebGLBindingStates(gl,attributes){const maxVertexAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);const bindingStates={};const defaultState=createBindingState(null);let currentState=defaultState;let forceUpdate=false;function setup(object,material,program,geometry,index){let updateBuffers=false;const state=getBindingState(geometry,program,material);if(currentState!==state){currentState=state;bindVertexArrayObject(currentState.object);}updateBuffers=needsUpdate(object,geometry,program,index);if(updateBuffers)saveCache(object,geometry,program,index);if(index!==null){attributes.update(index,gl.ELEMENT_ARRAY_BUFFER);}if(updateBuffers||forceUpdate){forceUpdate=false;setupVertexAttributes(object,material,program,geometry);if(index!==null){gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,attributes.get(index).buffer);}}}function createVertexArrayObject(){return gl.createVertexArray();}function bindVertexArrayObject(vao){return gl.bindVertexArray(vao);}function deleteVertexArrayObject(vao){return gl.deleteVertexArray(vao);}function getBindingState(geometry,program,material){const wireframe=material.wireframe===true;let programMap=bindingStates[geometry.id];if(programMap===undefined){programMap={};bindingStates[geometry.id]=programMap;}let stateMap=programMap[program.id];if(stateMap===undefined){stateMap={};programMap[program.id]=stateMap;}let state=stateMap[wireframe];if(state===undefined){state=createBindingState(createVertexArrayObject());stateMap[wireframe]=state;}return state;}function createBindingState(vao){const newAttributes=[];const enabledAttributes=[];const attributeDivisors=[];for(let i=0;i<maxVertexAttributes;i++){newAttributes[i]=0;enabledAttributes[i]=0;attributeDivisors[i]=0;}return {// for backward compatibility on non-VAO support browser
	geometry:null,program:null,wireframe:false,newAttributes:newAttributes,enabledAttributes:enabledAttributes,attributeDivisors:attributeDivisors,object:vao,attributes:{},index:null};}function needsUpdate(object,geometry,program,index){const cachedAttributes=currentState.attributes;const geometryAttributes=geometry.attributes;let attributesNum=0;const programAttributes=program.getAttributes();for(const name in programAttributes){const programAttribute=programAttributes[name];if(programAttribute.location>=0){const cachedAttribute=cachedAttributes[name];let geometryAttribute=geometryAttributes[name];if(geometryAttribute===undefined){if(name==='instanceMatrix'&&object.instanceMatrix)geometryAttribute=object.instanceMatrix;if(name==='instanceColor'&&object.instanceColor)geometryAttribute=object.instanceColor;}if(cachedAttribute===undefined)return true;if(cachedAttribute.attribute!==geometryAttribute)return true;if(geometryAttribute&&cachedAttribute.data!==geometryAttribute.data)return true;attributesNum++;}}if(currentState.attributesNum!==attributesNum)return true;if(currentState.index!==index)return true;return false;}function saveCache(object,geometry,program,index){const cache={};const attributes=geometry.attributes;let attributesNum=0;const programAttributes=program.getAttributes();for(const name in programAttributes){const programAttribute=programAttributes[name];if(programAttribute.location>=0){let attribute=attributes[name];if(attribute===undefined){if(name==='instanceMatrix'&&object.instanceMatrix)attribute=object.instanceMatrix;if(name==='instanceColor'&&object.instanceColor)attribute=object.instanceColor;}const data={};data.attribute=attribute;if(attribute&&attribute.data){data.data=attribute.data;}cache[name]=data;attributesNum++;}}currentState.attributes=cache;currentState.attributesNum=attributesNum;currentState.index=index;}function initAttributes(){const newAttributes=currentState.newAttributes;for(let i=0,il=newAttributes.length;i<il;i++){newAttributes[i]=0;}}function enableAttribute(attribute){enableAttributeAndDivisor(attribute,0);}function enableAttributeAndDivisor(attribute,meshPerAttribute){const newAttributes=currentState.newAttributes;const enabledAttributes=currentState.enabledAttributes;const attributeDivisors=currentState.attributeDivisors;newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==meshPerAttribute){gl.vertexAttribDivisor(attribute,meshPerAttribute);attributeDivisors[attribute]=meshPerAttribute;}}function disableUnusedAttributes(){const newAttributes=currentState.newAttributes;const enabledAttributes=currentState.enabledAttributes;for(let i=0,il=enabledAttributes.length;i<il;i++){if(enabledAttributes[i]!==newAttributes[i]){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}}function vertexAttribPointer(index,size,type,normalized,stride,offset,integer){if(integer===true){gl.vertexAttribIPointer(index,size,type,stride,offset);}else {gl.vertexAttribPointer(index,size,type,normalized,stride,offset);}}function setupVertexAttributes(object,material,program,geometry){initAttributes();const geometryAttributes=geometry.attributes;const programAttributes=program.getAttributes();const materialDefaultAttributeValues=material.defaultAttributeValues;for(const name in programAttributes){const programAttribute=programAttributes[name];if(programAttribute.location>=0){let geometryAttribute=geometryAttributes[name];if(geometryAttribute===undefined){if(name==='instanceMatrix'&&object.instanceMatrix)geometryAttribute=object.instanceMatrix;if(name==='instanceColor'&&object.instanceColor)geometryAttribute=object.instanceColor;}if(geometryAttribute!==undefined){const normalized=geometryAttribute.normalized;const size=geometryAttribute.itemSize;const attribute=attributes.get(geometryAttribute);// TODO Attribute may not be available on context restore
	if(attribute===undefined)continue;const buffer=attribute.buffer;const type=attribute.type;const bytesPerElement=attribute.bytesPerElement;// check for integer attributes
	const integer=type===gl.INT||type===gl.UNSIGNED_INT||geometryAttribute.gpuType===IntType;if(geometryAttribute.isInterleavedBufferAttribute){const data=geometryAttribute.data;const stride=data.stride;const offset=geometryAttribute.offset;if(data.isInstancedInterleavedBuffer){for(let i=0;i<programAttribute.locationSize;i++){enableAttributeAndDivisor(programAttribute.location+i,data.meshPerAttribute);}if(object.isInstancedMesh!==true&&geometry._maxInstanceCount===undefined){geometry._maxInstanceCount=data.meshPerAttribute*data.count;}}else {for(let i=0;i<programAttribute.locationSize;i++){enableAttribute(programAttribute.location+i);}}gl.bindBuffer(gl.ARRAY_BUFFER,buffer);for(let i=0;i<programAttribute.locationSize;i++){vertexAttribPointer(programAttribute.location+i,size/programAttribute.locationSize,type,normalized,stride*bytesPerElement,(offset+size/programAttribute.locationSize*i)*bytesPerElement,integer);}}else {if(geometryAttribute.isInstancedBufferAttribute){for(let i=0;i<programAttribute.locationSize;i++){enableAttributeAndDivisor(programAttribute.location+i,geometryAttribute.meshPerAttribute);}if(object.isInstancedMesh!==true&&geometry._maxInstanceCount===undefined){geometry._maxInstanceCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;}}else {for(let i=0;i<programAttribute.locationSize;i++){enableAttribute(programAttribute.location+i);}}gl.bindBuffer(gl.ARRAY_BUFFER,buffer);for(let i=0;i<programAttribute.locationSize;i++){vertexAttribPointer(programAttribute.location+i,size/programAttribute.locationSize,type,normalized,size*bytesPerElement,size/programAttribute.locationSize*i*bytesPerElement,integer);}}}else if(materialDefaultAttributeValues!==undefined){const value=materialDefaultAttributeValues[name];if(value!==undefined){switch(value.length){case 2:gl.vertexAttrib2fv(programAttribute.location,value);break;case 3:gl.vertexAttrib3fv(programAttribute.location,value);break;case 4:gl.vertexAttrib4fv(programAttribute.location,value);break;default:gl.vertexAttrib1fv(programAttribute.location,value);}}}}}disableUnusedAttributes();}function dispose(){reset();for(const geometryId in bindingStates){const programMap=bindingStates[geometryId];for(const programId in programMap){const stateMap=programMap[programId];for(const wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[programId];}delete bindingStates[geometryId];}}function releaseStatesOfGeometry(geometry){if(bindingStates[geometry.id]===undefined)return;const programMap=bindingStates[geometry.id];for(const programId in programMap){const stateMap=programMap[programId];for(const wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[programId];}delete bindingStates[geometry.id];}function releaseStatesOfProgram(program){for(const geometryId in bindingStates){const programMap=bindingStates[geometryId];if(programMap[program.id]===undefined)continue;const stateMap=programMap[program.id];for(const wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[program.id];}}function reset(){resetDefaultState();forceUpdate=true;if(currentState===defaultState)return;currentState=defaultState;bindVertexArrayObject(currentState.object);}// for backward-compatibility
	function resetDefaultState(){defaultState.geometry=null;defaultState.program=null;defaultState.wireframe=false;}return {setup:setup,reset:reset,resetDefaultState:resetDefaultState,dispose:dispose,releaseStatesOfGeometry:releaseStatesOfGeometry,releaseStatesOfProgram:releaseStatesOfProgram,initAttributes:initAttributes,enableAttribute:enableAttribute,disableUnusedAttributes:disableUnusedAttributes};}function WebGLBufferRenderer(gl,extensions,info){let mode;function setMode(value){mode=value;}function render(start,count){gl.drawArrays(mode,start,count);info.update(count,mode,1);}function renderInstances(start,count,primcount){if(primcount===0)return;gl.drawArraysInstanced(mode,start,count,primcount);info.update(count,mode,primcount);}function renderMultiDraw(starts,counts,drawCount){if(drawCount===0)return;const extension=extensions.get('WEBGL_multi_draw');extension.multiDrawArraysWEBGL(mode,starts,0,counts,0,drawCount);let elementCount=0;for(let i=0;i<drawCount;i++){elementCount+=counts[i];}info.update(elementCount,mode,1);}function renderMultiDrawInstances(starts,counts,drawCount,primcount){if(drawCount===0)return;const extension=extensions.get('WEBGL_multi_draw');if(extension===null){for(let i=0;i<starts.length;i++){renderInstances(starts[i],counts[i],primcount[i]);}}else {extension.multiDrawArraysInstancedWEBGL(mode,starts,0,counts,0,primcount,0,drawCount);let elementCount=0;for(let i=0;i<drawCount;i++){elementCount+=counts[i]*primcount[i];}info.update(elementCount,mode,1);}}//
	this.setMode=setMode;this.render=render;this.renderInstances=renderInstances;this.renderMultiDraw=renderMultiDraw;this.renderMultiDrawInstances=renderMultiDrawInstances;}function WebGLCapabilities(gl,extensions,parameters,utils){let maxAnisotropy;function getMaxAnisotropy(){if(maxAnisotropy!==undefined)return maxAnisotropy;if(extensions.has('EXT_texture_filter_anisotropic')===true){const extension=extensions.get('EXT_texture_filter_anisotropic');maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);}else {maxAnisotropy=0;}return maxAnisotropy;}function textureFormatReadable(textureFormat){if(textureFormat!==RGBAFormat&&utils.convert(textureFormat)!==gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)){return false;}return true;}function textureTypeReadable(textureType){const halfFloatSupportedByExt=textureType===HalfFloatType&&(extensions.has('EXT_color_buffer_half_float')||extensions.has('EXT_color_buffer_float'));if(textureType!==UnsignedByteType&&utils.convert(textureType)!==gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE)&&// Edge and Chrome Mac < 52 (#9513)
	textureType!==FloatType$1&&!halfFloatSupportedByExt){return false;}return true;}function getMaxPrecision(precision){if(precision==='highp'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.HIGH_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision>0){return 'highp';}precision='mediump';}if(precision==='mediump'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.MEDIUM_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT).precision>0){return 'mediump';}}return 'lowp';}let precision=parameters.precision!==undefined?parameters.precision:'highp';const maxPrecision=getMaxPrecision(precision);if(maxPrecision!==precision){console.warn('THREE.WebGLRenderer:',precision,'not supported, using',maxPrecision,'instead.');precision=maxPrecision;}const logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true;const reverseDepthBuffer=parameters.reverseDepthBuffer===true&&extensions.has('EXT_clip_control');const maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);const maxVertexTextures=gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);const maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE);const maxCubemapSize=gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);const maxAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);const maxVertexUniforms=gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);const maxVaryings=gl.getParameter(gl.MAX_VARYING_VECTORS);const maxFragmentUniforms=gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);const vertexTextures=maxVertexTextures>0;const maxSamples=gl.getParameter(gl.MAX_SAMPLES);return {isWebGL2:true,// keeping this for backwards compatibility
	getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,textureFormatReadable:textureFormatReadable,textureTypeReadable:textureTypeReadable,precision:precision,logarithmicDepthBuffer:logarithmicDepthBuffer,reverseDepthBuffer:reverseDepthBuffer,maxTextures:maxTextures,maxVertexTextures:maxVertexTextures,maxTextureSize:maxTextureSize,maxCubemapSize:maxCubemapSize,maxAttributes:maxAttributes,maxVertexUniforms:maxVertexUniforms,maxVaryings:maxVaryings,maxFragmentUniforms:maxFragmentUniforms,vertexTextures:vertexTextures,maxSamples:maxSamples};}function WebGLClipping(properties){const scope=this;let globalState=null,numGlobalPlanes=0,localClippingEnabled=false,renderingShadows=false;const plane=new Plane(),viewNormalMatrix=new Matrix3$1(),uniform={value:null,needsUpdate:false};this.uniform=uniform;this.numPlanes=0;this.numIntersection=0;this.init=function(planes,enableLocalClipping){const enabled=planes.length!==0||enableLocalClipping||// enable state of previous frame - the clipping code has to
	// run another frame in order to reset the state:
	numGlobalPlanes!==0||localClippingEnabled;localClippingEnabled=enableLocalClipping;numGlobalPlanes=planes.length;return enabled;};this.beginShadows=function(){renderingShadows=true;projectPlanes(null);};this.endShadows=function(){renderingShadows=false;};this.setGlobalState=function(planes,camera){globalState=projectPlanes(planes,camera,0);};this.setState=function(material,camera,useCache){const planes=material.clippingPlanes,clipIntersection=material.clipIntersection,clipShadows=material.clipShadows;const materialProperties=properties.get(material);if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows){// there's no local clipping
	if(renderingShadows){// there's no global clipping
	projectPlanes(null);}else {resetGlobalState();}}else {const nGlobal=renderingShadows?0:numGlobalPlanes,lGlobal=nGlobal*4;let dstArray=materialProperties.clippingState||null;uniform.value=dstArray;// ensure unique state
	dstArray=projectPlanes(planes,camera,lGlobal,useCache);for(let i=0;i!==lGlobal;++i){dstArray[i]=globalState[i];}materialProperties.clippingState=dstArray;this.numIntersection=clipIntersection?this.numPlanes:0;this.numPlanes+=nGlobal;}};function resetGlobalState(){if(uniform.value!==globalState){uniform.value=globalState;uniform.needsUpdate=numGlobalPlanes>0;}scope.numPlanes=numGlobalPlanes;scope.numIntersection=0;}function projectPlanes(planes,camera,dstOffset,skipTransform){const nPlanes=planes!==null?planes.length:0;let dstArray=null;if(nPlanes!==0){dstArray=uniform.value;if(skipTransform!==true||dstArray===null){const flatSize=dstOffset+nPlanes*4,viewMatrix=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(viewMatrix);if(dstArray===null||dstArray.length<flatSize){dstArray=new Float32Array(flatSize);}for(let i=0,i4=dstOffset;i!==nPlanes;++i,i4+=4){plane.copy(planes[i]).applyMatrix4(viewMatrix,viewNormalMatrix);plane.normal.toArray(dstArray,i4);dstArray[i4+3]=plane.constant;}}uniform.value=dstArray;uniform.needsUpdate=true;}scope.numPlanes=nPlanes;scope.numIntersection=0;return dstArray;}}function WebGLCubeMaps(renderer){let cubemaps=new WeakMap();function mapTextureMapping(texture,mapping){if(mapping===EquirectangularReflectionMapping){texture.mapping=CubeReflectionMapping;}else if(mapping===EquirectangularRefractionMapping){texture.mapping=CubeRefractionMapping;}return texture;}function get(texture){if(texture&&texture.isTexture){const mapping=texture.mapping;if(mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping){if(cubemaps.has(texture)){const cubemap=cubemaps.get(texture).texture;return mapTextureMapping(cubemap,texture.mapping);}else {const image=texture.image;if(image&&image.height>0){const renderTarget=new WebGLCubeRenderTarget(image.height);renderTarget.fromEquirectangularTexture(renderer,texture);cubemaps.set(texture,renderTarget);texture.addEventListener('dispose',onTextureDispose);return mapTextureMapping(renderTarget.texture,texture.mapping);}else {// image not yet ready. try the conversion next frame
	return null;}}}}return texture;}function onTextureDispose(event){const texture=event.target;texture.removeEventListener('dispose',onTextureDispose);const cubemap=cubemaps.get(texture);if(cubemap!==undefined){cubemaps.delete(texture);cubemap.dispose();}}function dispose(){cubemaps=new WeakMap();}return {get:get,dispose:dispose};}const LOD_MIN=4;// The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.
	const EXTRA_LOD_SIGMA=[0.125,0.215,0.35,0.446,0.526,0.582];// The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.
	const MAX_SAMPLES=20;const _flatCamera=/*@__PURE__*/new OrthographicCamera();const _clearColor=/*@__PURE__*/new Color();let _oldTarget=null;let _oldActiveCubeFace=0;let _oldActiveMipmapLevel=0;let _oldXrEnabled=false;// Golden Ratio
	const PHI=(1+Math.sqrt(5))/2;const INV_PHI=1/PHI;// Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.
	const _axisDirections=[/*@__PURE__*/new Vector3$1(-PHI,INV_PHI,0),/*@__PURE__*/new Vector3$1(PHI,INV_PHI,0),/*@__PURE__*/new Vector3$1(-INV_PHI,0,PHI),/*@__PURE__*/new Vector3$1(INV_PHI,0,PHI),/*@__PURE__*/new Vector3$1(0,PHI,-INV_PHI),/*@__PURE__*/new Vector3$1(0,PHI,INV_PHI),/*@__PURE__*/new Vector3$1(-1,1,-1),/*@__PURE__*/new Vector3$1(1,1,-1),/*@__PURE__*/new Vector3$1(-1,1,1),/*@__PURE__*/new Vector3$1(1,1,1)];/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * Paper: Fast, Accurate Image-Based Lighting
	 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
	*/class PMREMGenerator{constructor(renderer){this._renderer=renderer;this._pingPongRenderTarget=null;this._lodMax=0;this._cubeSize=0;this._lodPlanes=[];this._sizeLods=[];this._sigmas=[];this._blurMaterial=null;this._cubemapMaterial=null;this._equirectMaterial=null;this._compileMaterial(this._blurMaterial);}/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */fromScene(scene,sigma=0,near=0.1,far=100){_oldTarget=this._renderer.getRenderTarget();_oldActiveCubeFace=this._renderer.getActiveCubeFace();_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel();_oldXrEnabled=this._renderer.xr.enabled;this._renderer.xr.enabled=false;this._setSize(256);const cubeUVRenderTarget=this._allocateTargets();cubeUVRenderTarget.depthBuffer=true;this._sceneToCubeUV(scene,near,far,cubeUVRenderTarget);if(sigma>0){this._blur(cubeUVRenderTarget,0,0,sigma);}this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;}/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * or HDR. The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 * The smallest supported equirectangular image size is 64 x 32.
		 */fromEquirectangular(equirectangular,renderTarget=null){return this._fromTexture(equirectangular,renderTarget);}/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * or HDR. The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 * The smallest supported cube size is 16 x 16.
		 */fromCubemap(cubemap,renderTarget=null){return this._fromTexture(cubemap,renderTarget);}/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */compileCubemapShader(){if(this._cubemapMaterial===null){this._cubemapMaterial=_getCubemapMaterial();this._compileMaterial(this._cubemapMaterial);}}/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */compileEquirectangularShader(){if(this._equirectMaterial===null){this._equirectMaterial=_getEquirectMaterial();this._compileMaterial(this._equirectMaterial);}}/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */dispose(){this._dispose();if(this._cubemapMaterial!==null)this._cubemapMaterial.dispose();if(this._equirectMaterial!==null)this._equirectMaterial.dispose();}// private interface
	_setSize(cubeSize){this._lodMax=Math.floor(Math.log2(cubeSize));this._cubeSize=Math.pow(2,this._lodMax);}_dispose(){if(this._blurMaterial!==null)this._blurMaterial.dispose();if(this._pingPongRenderTarget!==null)this._pingPongRenderTarget.dispose();for(let i=0;i<this._lodPlanes.length;i++){this._lodPlanes[i].dispose();}}_cleanup(outputTarget){this._renderer.setRenderTarget(_oldTarget,_oldActiveCubeFace,_oldActiveMipmapLevel);this._renderer.xr.enabled=_oldXrEnabled;outputTarget.scissorTest=false;_setViewport(outputTarget,0,0,outputTarget.width,outputTarget.height);}_fromTexture(texture,renderTarget){if(texture.mapping===CubeReflectionMapping||texture.mapping===CubeRefractionMapping){this._setSize(texture.image.length===0?16:texture.image[0].width||texture.image[0].image.width);}else {// Equirectangular
	this._setSize(texture.image.width/4);}_oldTarget=this._renderer.getRenderTarget();_oldActiveCubeFace=this._renderer.getActiveCubeFace();_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel();_oldXrEnabled=this._renderer.xr.enabled;this._renderer.xr.enabled=false;const cubeUVRenderTarget=renderTarget||this._allocateTargets();this._textureToCubeUV(texture,cubeUVRenderTarget);this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;}_allocateTargets(){const width=3*Math.max(this._cubeSize,16*7);const height=4*this._cubeSize;const params={magFilter:LinearFilter,minFilter:LinearFilter,generateMipmaps:false,type:HalfFloatType,format:RGBAFormat,colorSpace:LinearSRGBColorSpace,depthBuffer:false};const cubeUVRenderTarget=_createRenderTarget(width,height,params);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==width||this._pingPongRenderTarget.height!==height){if(this._pingPongRenderTarget!==null){this._dispose();}this._pingPongRenderTarget=_createRenderTarget(width,height,params);const{_lodMax}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=_createPlanes(_lodMax));this._blurMaterial=_getBlurShader(_lodMax,width,height);}return cubeUVRenderTarget;}_compileMaterial(material){const tmpMesh=new Mesh(this._lodPlanes[0],material);this._renderer.compile(tmpMesh,_flatCamera);}_sceneToCubeUV(scene,near,far,cubeUVRenderTarget){const fov=90;const aspect=1;const cubeCamera=new PerspectiveCamera(fov,aspect,near,far);const upSign=[1,-1,1,1,1,1];const forwardSign=[1,1,1,-1,-1,-1];const renderer=this._renderer;const originalAutoClear=renderer.autoClear;const toneMapping=renderer.toneMapping;renderer.getClearColor(_clearColor);renderer.toneMapping=NoToneMapping;renderer.autoClear=false;const backgroundMaterial=new MeshBasicMaterial({name:'PMREM.Background',side:BackSide,depthWrite:false,depthTest:false});const backgroundBox=new Mesh(new BoxGeometry$1(),backgroundMaterial);let useSolidColor=false;const background=scene.background;if(background){if(background.isColor){backgroundMaterial.color.copy(background);scene.background=null;useSolidColor=true;}}else {backgroundMaterial.color.copy(_clearColor);useSolidColor=true;}for(let i=0;i<6;i++){const col=i%3;if(col===0){cubeCamera.up.set(0,upSign[i],0);cubeCamera.lookAt(forwardSign[i],0,0);}else if(col===1){cubeCamera.up.set(0,0,upSign[i]);cubeCamera.lookAt(0,forwardSign[i],0);}else {cubeCamera.up.set(0,upSign[i],0);cubeCamera.lookAt(0,0,forwardSign[i]);}const size=this._cubeSize;_setViewport(cubeUVRenderTarget,col*size,i>2?size:0,size,size);renderer.setRenderTarget(cubeUVRenderTarget);if(useSolidColor){renderer.render(backgroundBox,cubeCamera);}renderer.render(scene,cubeCamera);}backgroundBox.geometry.dispose();backgroundBox.material.dispose();renderer.toneMapping=toneMapping;renderer.autoClear=originalAutoClear;scene.background=background;}_textureToCubeUV(texture,cubeUVRenderTarget){const renderer=this._renderer;const isCubeTexture=texture.mapping===CubeReflectionMapping||texture.mapping===CubeRefractionMapping;if(isCubeTexture){if(this._cubemapMaterial===null){this._cubemapMaterial=_getCubemapMaterial();}this._cubemapMaterial.uniforms.flipEnvMap.value=texture.isRenderTargetTexture===false?-1:1;}else {if(this._equirectMaterial===null){this._equirectMaterial=_getEquirectMaterial();}}const material=isCubeTexture?this._cubemapMaterial:this._equirectMaterial;const mesh=new Mesh(this._lodPlanes[0],material);const uniforms=material.uniforms;uniforms['envMap'].value=texture;const size=this._cubeSize;_setViewport(cubeUVRenderTarget,0,0,3*size,2*size);renderer.setRenderTarget(cubeUVRenderTarget);renderer.render(mesh,_flatCamera);}_applyPMREM(cubeUVRenderTarget){const renderer=this._renderer;const autoClear=renderer.autoClear;renderer.autoClear=false;const n=this._lodPlanes.length;for(let i=1;i<n;i++){const sigma=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]);const poleAxis=_axisDirections[(n-i-1)%_axisDirections.length];this._blur(cubeUVRenderTarget,i-1,i,sigma,poleAxis);}renderer.autoClear=autoClear;}/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */_blur(cubeUVRenderTarget,lodIn,lodOut,sigma,poleAxis){const pingPongRenderTarget=this._pingPongRenderTarget;this._halfBlur(cubeUVRenderTarget,pingPongRenderTarget,lodIn,lodOut,sigma,'latitudinal',poleAxis);this._halfBlur(pingPongRenderTarget,cubeUVRenderTarget,lodOut,lodOut,sigma,'longitudinal',poleAxis);}_halfBlur(targetIn,targetOut,lodIn,lodOut,sigmaRadians,direction,poleAxis){const renderer=this._renderer;const blurMaterial=this._blurMaterial;if(direction!=='latitudinal'&&direction!=='longitudinal'){console.error('blur direction must be either latitudinal or longitudinal!');}// Number of standard deviations at which to cut off the discrete approximation.
	const STANDARD_DEVIATIONS=3;const blurMesh=new Mesh(this._lodPlanes[lodOut],blurMaterial);const blurUniforms=blurMaterial.uniforms;const pixels=this._sizeLods[lodIn]-1;const radiansPerPixel=isFinite(sigmaRadians)?Math.PI/(2*pixels):2*Math.PI/(2*MAX_SAMPLES-1);const sigmaPixels=sigmaRadians/radiansPerPixel;const samples=isFinite(sigmaRadians)?1+Math.floor(STANDARD_DEVIATIONS*sigmaPixels):MAX_SAMPLES;if(samples>MAX_SAMPLES){console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);}const weights=[];let sum=0;for(let i=0;i<MAX_SAMPLES;++i){const x=i/sigmaPixels;const weight=Math.exp(-x*x/2);weights.push(weight);if(i===0){sum+=weight;}else if(i<samples){sum+=2*weight;}}for(let i=0;i<weights.length;i++){weights[i]=weights[i]/sum;}blurUniforms['envMap'].value=targetIn.texture;blurUniforms['samples'].value=samples;blurUniforms['weights'].value=weights;blurUniforms['latitudinal'].value=direction==='latitudinal';if(poleAxis){blurUniforms['poleAxis'].value=poleAxis;}const{_lodMax}=this;blurUniforms['dTheta'].value=radiansPerPixel;blurUniforms['mipInt'].value=_lodMax-lodIn;const outputSize=this._sizeLods[lodOut];const x=3*outputSize*(lodOut>_lodMax-LOD_MIN?lodOut-_lodMax+LOD_MIN:0);const y=4*(this._cubeSize-outputSize);_setViewport(targetOut,x,y,3*outputSize,2*outputSize);renderer.setRenderTarget(targetOut);renderer.render(blurMesh,_flatCamera);}}function _createPlanes(lodMax){const lodPlanes=[];const sizeLods=[];const sigmas=[];let lod=lodMax;const totalLods=lodMax-LOD_MIN+1+EXTRA_LOD_SIGMA.length;for(let i=0;i<totalLods;i++){const sizeLod=Math.pow(2,lod);sizeLods.push(sizeLod);let sigma=1.0/sizeLod;if(i>lodMax-LOD_MIN){sigma=EXTRA_LOD_SIGMA[i-lodMax+LOD_MIN-1];}else if(i===0){sigma=0;}sigmas.push(sigma);const texelSize=1.0/(sizeLod-2);const min=-texelSize;const max=1+texelSize;const uv1=[min,min,max,min,max,max,min,min,max,max,min,max];const cubeFaces=6;const vertices=6;const positionSize=3;const uvSize=2;const faceIndexSize=1;const position=new Float32Array(positionSize*vertices*cubeFaces);const uv=new Float32Array(uvSize*vertices*cubeFaces);const faceIndex=new Float32Array(faceIndexSize*vertices*cubeFaces);for(let face=0;face<cubeFaces;face++){const x=face%3*2/3-1;const y=face>2?0:-1;const coordinates=[x,y,0,x+2/3,y,0,x+2/3,y+1,0,x,y,0,x+2/3,y+1,0,x,y+1,0];position.set(coordinates,positionSize*vertices*face);uv.set(uv1,uvSize*vertices*face);const fill=[face,face,face,face,face,face];faceIndex.set(fill,faceIndexSize*vertices*face);}const planes=new BufferGeometry$1();planes.setAttribute('position',new BufferAttribute$1(position,positionSize));planes.setAttribute('uv',new BufferAttribute$1(uv,uvSize));planes.setAttribute('faceIndex',new BufferAttribute$1(faceIndex,faceIndexSize));lodPlanes.push(planes);if(lod>LOD_MIN){lod--;}}return {lodPlanes,sizeLods,sigmas};}function _createRenderTarget(width,height,params){const cubeUVRenderTarget=new WebGLRenderTarget(width,height,params);cubeUVRenderTarget.texture.mapping=CubeUVReflectionMapping;cubeUVRenderTarget.texture.name='PMREM.cubeUv';cubeUVRenderTarget.scissorTest=true;return cubeUVRenderTarget;}function _setViewport(target,x,y,width,height){target.viewport.set(x,y,width,height);target.scissor.set(x,y,width,height);}function _getBlurShader(lodMax,width,height){const weights=new Float32Array(MAX_SAMPLES);const poleAxis=new Vector3$1(0,1,0);const shaderMaterial=new ShaderMaterial({name:'SphericalGaussianBlur',defines:{'n':MAX_SAMPLES,'CUBEUV_TEXEL_WIDTH':1.0/width,'CUBEUV_TEXEL_HEIGHT':1.0/height,'CUBEUV_MAX_MIP':`${lodMax}.0`},uniforms:{'envMap':{value:null},'samples':{value:1},'weights':{value:weights},'latitudinal':{value:false},'dTheta':{value:0},'mipInt':{value:0},'poleAxis':{value:poleAxis}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:NoBlending,depthTest:false,depthWrite:false});return shaderMaterial;}function _getEquirectMaterial(){return new ShaderMaterial({name:'EquirectangularToCubeUV',uniforms:{'envMap':{value:null}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:NoBlending,depthTest:false,depthWrite:false});}function _getCubemapMaterial(){return new ShaderMaterial({name:'CubemapToCubeUV',uniforms:{'envMap':{value:null},'flipEnvMap':{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:NoBlending,depthTest:false,depthWrite:false});}function _getCommonVertexShader(){return/* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;}function WebGLCubeUVMaps(renderer){let cubeUVmaps=new WeakMap();let pmremGenerator=null;function get(texture){if(texture&&texture.isTexture){const mapping=texture.mapping;const isEquirectMap=mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping;const isCubeMap=mapping===CubeReflectionMapping||mapping===CubeRefractionMapping;// equirect/cube map to cubeUV conversion
	if(isEquirectMap||isCubeMap){let renderTarget=cubeUVmaps.get(texture);const currentPMREMVersion=renderTarget!==undefined?renderTarget.texture.pmremVersion:0;if(texture.isRenderTargetTexture&&texture.pmremVersion!==currentPMREMVersion){if(pmremGenerator===null)pmremGenerator=new PMREMGenerator(renderer);renderTarget=isEquirectMap?pmremGenerator.fromEquirectangular(texture,renderTarget):pmremGenerator.fromCubemap(texture,renderTarget);renderTarget.texture.pmremVersion=texture.pmremVersion;cubeUVmaps.set(texture,renderTarget);return renderTarget.texture;}else {if(renderTarget!==undefined){return renderTarget.texture;}else {const image=texture.image;if(isEquirectMap&&image&&image.height>0||isCubeMap&&image&&isCubeTextureComplete(image)){if(pmremGenerator===null)pmremGenerator=new PMREMGenerator(renderer);renderTarget=isEquirectMap?pmremGenerator.fromEquirectangular(texture):pmremGenerator.fromCubemap(texture);renderTarget.texture.pmremVersion=texture.pmremVersion;cubeUVmaps.set(texture,renderTarget);texture.addEventListener('dispose',onTextureDispose);return renderTarget.texture;}else {// image not yet ready. try the conversion next frame
	return null;}}}}}return texture;}function isCubeTextureComplete(image){let count=0;const length=6;for(let i=0;i<length;i++){if(image[i]!==undefined)count++;}return count===length;}function onTextureDispose(event){const texture=event.target;texture.removeEventListener('dispose',onTextureDispose);const cubemapUV=cubeUVmaps.get(texture);if(cubemapUV!==undefined){cubeUVmaps.delete(texture);cubemapUV.dispose();}}function dispose(){cubeUVmaps=new WeakMap();if(pmremGenerator!==null){pmremGenerator.dispose();pmremGenerator=null;}}return {get:get,dispose:dispose};}function WebGLExtensions(gl){const extensions={};function getExtension(name){if(extensions[name]!==undefined){return extensions[name];}let extension;switch(name){case'WEBGL_depth_texture':extension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');break;case'EXT_texture_filter_anisotropic':extension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');break;case'WEBGL_compressed_texture_s3tc':extension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');break;case'WEBGL_compressed_texture_pvrtc':extension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');break;default:extension=gl.getExtension(name);}extensions[name]=extension;return extension;}return {has:function(name){return getExtension(name)!==null;},init:function(){getExtension('EXT_color_buffer_float');getExtension('WEBGL_clip_cull_distance');getExtension('OES_texture_float_linear');getExtension('EXT_color_buffer_half_float');getExtension('WEBGL_multisampled_render_to_texture');getExtension('WEBGL_render_shared_exponent');},get:function(name){const extension=getExtension(name);if(extension===null){warnOnce('THREE.WebGLRenderer: '+name+' extension not supported.');}return extension;}};}function WebGLGeometries(gl,attributes,info,bindingStates){const geometries={};const wireframeAttributes=new WeakMap();function onGeometryDispose(event){const geometry=event.target;if(geometry.index!==null){attributes.remove(geometry.index);}for(const name in geometry.attributes){attributes.remove(geometry.attributes[name]);}geometry.removeEventListener('dispose',onGeometryDispose);delete geometries[geometry.id];const attribute=wireframeAttributes.get(geometry);if(attribute){attributes.remove(attribute);wireframeAttributes.delete(geometry);}bindingStates.releaseStatesOfGeometry(geometry);if(geometry.isInstancedBufferGeometry===true){delete geometry._maxInstanceCount;}//
	info.memory.geometries--;}function get(object,geometry){if(geometries[geometry.id]===true)return geometry;geometry.addEventListener('dispose',onGeometryDispose);geometries[geometry.id]=true;info.memory.geometries++;return geometry;}function update(geometry){const geometryAttributes=geometry.attributes;// Updating index buffer in VAO now. See WebGLBindingStates.
	for(const name in geometryAttributes){attributes.update(geometryAttributes[name],gl.ARRAY_BUFFER);}}function updateWireframeAttribute(geometry){const indices=[];const geometryIndex=geometry.index;const geometryPosition=geometry.attributes.position;let version=0;if(geometryIndex!==null){const array=geometryIndex.array;version=geometryIndex.version;for(let i=0,l=array.length;i<l;i+=3){const a=array[i+0];const b=array[i+1];const c=array[i+2];indices.push(a,b,b,c,c,a);}}else if(geometryPosition!==undefined){const array=geometryPosition.array;version=geometryPosition.version;for(let i=0,l=array.length/3-1;i<l;i+=3){const a=i+0;const b=i+1;const c=i+2;indices.push(a,b,b,c,c,a);}}else {return;}const attribute=new(arrayNeedsUint32$1(indices)?Uint32BufferAttribute$1:Uint16BufferAttribute$1)(indices,1);attribute.version=version;// Updating index buffer in VAO now. See WebGLBindingStates
	//
	const previousAttribute=wireframeAttributes.get(geometry);if(previousAttribute)attributes.remove(previousAttribute);//
	wireframeAttributes.set(geometry,attribute);}function getWireframeAttribute(geometry){const currentAttribute=wireframeAttributes.get(geometry);if(currentAttribute){const geometryIndex=geometry.index;if(geometryIndex!==null){// if the attribute is obsolete, create a new one
	if(currentAttribute.version<geometryIndex.version){updateWireframeAttribute(geometry);}}}else {updateWireframeAttribute(geometry);}return wireframeAttributes.get(geometry);}return {get:get,update:update,getWireframeAttribute:getWireframeAttribute};}function WebGLIndexedBufferRenderer(gl,extensions,info){let mode;function setMode(value){mode=value;}let type,bytesPerElement;function setIndex(value){type=value.type;bytesPerElement=value.bytesPerElement;}function render(start,count){gl.drawElements(mode,count,type,start*bytesPerElement);info.update(count,mode,1);}function renderInstances(start,count,primcount){if(primcount===0)return;gl.drawElementsInstanced(mode,count,type,start*bytesPerElement,primcount);info.update(count,mode,primcount);}function renderMultiDraw(starts,counts,drawCount){if(drawCount===0)return;const extension=extensions.get('WEBGL_multi_draw');extension.multiDrawElementsWEBGL(mode,counts,0,type,starts,0,drawCount);let elementCount=0;for(let i=0;i<drawCount;i++){elementCount+=counts[i];}info.update(elementCount,mode,1);}function renderMultiDrawInstances(starts,counts,drawCount,primcount){if(drawCount===0)return;const extension=extensions.get('WEBGL_multi_draw');if(extension===null){for(let i=0;i<starts.length;i++){renderInstances(starts[i]/bytesPerElement,counts[i],primcount[i]);}}else {extension.multiDrawElementsInstancedWEBGL(mode,counts,0,type,starts,0,primcount,0,drawCount);let elementCount=0;for(let i=0;i<drawCount;i++){elementCount+=counts[i]*primcount[i];}info.update(elementCount,mode,1);}}//
	this.setMode=setMode;this.setIndex=setIndex;this.render=render;this.renderInstances=renderInstances;this.renderMultiDraw=renderMultiDraw;this.renderMultiDrawInstances=renderMultiDrawInstances;}function WebGLInfo(gl){const memory={geometries:0,textures:0};const render={frame:0,calls:0,triangles:0,points:0,lines:0};function update(count,mode,instanceCount){render.calls++;switch(mode){case gl.TRIANGLES:render.triangles+=instanceCount*(count/3);break;case gl.LINES:render.lines+=instanceCount*(count/2);break;case gl.LINE_STRIP:render.lines+=instanceCount*(count-1);break;case gl.LINE_LOOP:render.lines+=instanceCount*count;break;case gl.POINTS:render.points+=instanceCount*count;break;default:console.error('THREE.WebGLInfo: Unknown draw mode:',mode);break;}}function reset(){render.calls=0;render.triangles=0;render.points=0;render.lines=0;}return {memory:memory,render:render,programs:null,autoReset:true,reset:reset,update:update};}function WebGLMorphtargets(gl,capabilities,textures){const morphTextures=new WeakMap();const morph=new Vector4();function update(object,geometry,program){const objectInfluences=object.morphTargetInfluences;// the following encodes morph targets into an array of data textures. Each layer represents a single morph target.
	const morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color;const morphTargetsCount=morphAttribute!==undefined?morphAttribute.length:0;let entry=morphTextures.get(geometry);if(entry===undefined||entry.count!==morphTargetsCount){if(entry!==undefined)entry.texture.dispose();const hasMorphPosition=geometry.morphAttributes.position!==undefined;const hasMorphNormals=geometry.morphAttributes.normal!==undefined;const hasMorphColors=geometry.morphAttributes.color!==undefined;const morphTargets=geometry.morphAttributes.position||[];const morphNormals=geometry.morphAttributes.normal||[];const morphColors=geometry.morphAttributes.color||[];let vertexDataCount=0;if(hasMorphPosition===true)vertexDataCount=1;if(hasMorphNormals===true)vertexDataCount=2;if(hasMorphColors===true)vertexDataCount=3;let width=geometry.attributes.position.count*vertexDataCount;let height=1;if(width>capabilities.maxTextureSize){height=Math.ceil(width/capabilities.maxTextureSize);width=capabilities.maxTextureSize;}const buffer=new Float32Array(width*height*4*morphTargetsCount);const texture=new DataArrayTexture(buffer,width,height,morphTargetsCount);texture.type=FloatType$1;texture.needsUpdate=true;// fill buffer
	const vertexDataStride=vertexDataCount*4;for(let i=0;i<morphTargetsCount;i++){const morphTarget=morphTargets[i];const morphNormal=morphNormals[i];const morphColor=morphColors[i];const offset=width*height*4*i;for(let j=0;j<morphTarget.count;j++){const stride=j*vertexDataStride;if(hasMorphPosition===true){morph.fromBufferAttribute(morphTarget,j);buffer[offset+stride+0]=morph.x;buffer[offset+stride+1]=morph.y;buffer[offset+stride+2]=morph.z;buffer[offset+stride+3]=0;}if(hasMorphNormals===true){morph.fromBufferAttribute(morphNormal,j);buffer[offset+stride+4]=morph.x;buffer[offset+stride+5]=morph.y;buffer[offset+stride+6]=morph.z;buffer[offset+stride+7]=0;}if(hasMorphColors===true){morph.fromBufferAttribute(morphColor,j);buffer[offset+stride+8]=morph.x;buffer[offset+stride+9]=morph.y;buffer[offset+stride+10]=morph.z;buffer[offset+stride+11]=morphColor.itemSize===4?morph.w:1;}}}entry={count:morphTargetsCount,texture:texture,size:new Vector2$1(width,height)};morphTextures.set(geometry,entry);function disposeTexture(){texture.dispose();morphTextures.delete(geometry);geometry.removeEventListener('dispose',disposeTexture);}geometry.addEventListener('dispose',disposeTexture);}//
	if(object.isInstancedMesh===true&&object.morphTexture!==null){program.getUniforms().setValue(gl,'morphTexture',object.morphTexture,textures);}else {let morphInfluencesSum=0;for(let i=0;i<objectInfluences.length;i++){morphInfluencesSum+=objectInfluences[i];}const morphBaseInfluence=geometry.morphTargetsRelative?1:1-morphInfluencesSum;program.getUniforms().setValue(gl,'morphTargetBaseInfluence',morphBaseInfluence);program.getUniforms().setValue(gl,'morphTargetInfluences',objectInfluences);}program.getUniforms().setValue(gl,'morphTargetsTexture',entry.texture,textures);program.getUniforms().setValue(gl,'morphTargetsTextureSize',entry.size);}return {update:update};}function WebGLObjects(gl,geometries,attributes,info){let updateMap=new WeakMap();function update(object){const frame=info.render.frame;const geometry=object.geometry;const buffergeometry=geometries.get(object,geometry);// Update once per frame
	if(updateMap.get(buffergeometry)!==frame){geometries.update(buffergeometry);updateMap.set(buffergeometry,frame);}if(object.isInstancedMesh){if(object.hasEventListener('dispose',onInstancedMeshDispose)===false){object.addEventListener('dispose',onInstancedMeshDispose);}if(updateMap.get(object)!==frame){attributes.update(object.instanceMatrix,gl.ARRAY_BUFFER);if(object.instanceColor!==null){attributes.update(object.instanceColor,gl.ARRAY_BUFFER);}updateMap.set(object,frame);}}if(object.isSkinnedMesh){const skeleton=object.skeleton;if(updateMap.get(skeleton)!==frame){skeleton.update();updateMap.set(skeleton,frame);}}return buffergeometry;}function dispose(){updateMap=new WeakMap();}function onInstancedMeshDispose(event){const instancedMesh=event.target;instancedMesh.removeEventListener('dispose',onInstancedMeshDispose);attributes.remove(instancedMesh.instanceMatrix);if(instancedMesh.instanceColor!==null)attributes.remove(instancedMesh.instanceColor);}return {update:update,dispose:dispose};}/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */const emptyTexture=/*@__PURE__*/new Texture();const emptyShadowTexture=/*@__PURE__*/new DepthTexture(1,1);const emptyArrayTexture=/*@__PURE__*/new DataArrayTexture();const empty3dTexture=/*@__PURE__*/new Data3DTexture();const emptyCubeTexture=/*@__PURE__*/new CubeTexture();// --- Utilities ---
	// Array Caches (provide typed arrays for temporary by size)
	const arrayCacheF32=[];const arrayCacheI32=[];// Float32Array caches used for uploading Matrix uniforms
	const mat4array=new Float32Array(16);const mat3array=new Float32Array(9);const mat2array=new Float32Array(4);// Flattening for arrays of vectors and matrices
	function flatten(array,nBlocks,blockSize){const firstElem=array[0];if(firstElem<=0||firstElem>0)return array;// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983
	const n=nBlocks*blockSize;let r=arrayCacheF32[n];if(r===undefined){r=new Float32Array(n);arrayCacheF32[n]=r;}if(nBlocks!==0){firstElem.toArray(r,0);for(let i=1,offset=0;i!==nBlocks;++i){offset+=blockSize;array[i].toArray(r,offset);}}return r;}function arraysEqual(a,b){if(a.length!==b.length)return false;for(let i=0,l=a.length;i<l;i++){if(a[i]!==b[i])return false;}return true;}function copyArray(a,b){for(let i=0,l=b.length;i<l;i++){a[i]=b[i];}}// Texture unit allocation
	function allocTexUnits(textures,n){let r=arrayCacheI32[n];if(r===undefined){r=new Int32Array(n);arrayCacheI32[n]=r;}for(let i=0;i!==n;++i){r[i]=textures.allocateTextureUnit();}return r;}// --- Setters ---
	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.
	// Single scalar
	function setValueV1f(gl,v){const cache=this.cache;if(cache[0]===v)return;gl.uniform1f(this.addr,v);cache[0]=v;}// Single float vector (from flat array or THREE.VectorN)
	function setValueV2f(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y){gl.uniform2f(this.addr,v.x,v.y);cache[0]=v.x;cache[1]=v.y;}}else {if(arraysEqual(cache,v))return;gl.uniform2fv(this.addr,v);copyArray(cache,v);}}function setValueV3f(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z){gl.uniform3f(this.addr,v.x,v.y,v.z);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;}}else if(v.r!==undefined){if(cache[0]!==v.r||cache[1]!==v.g||cache[2]!==v.b){gl.uniform3f(this.addr,v.r,v.g,v.b);cache[0]=v.r;cache[1]=v.g;cache[2]=v.b;}}else {if(arraysEqual(cache,v))return;gl.uniform3fv(this.addr,v);copyArray(cache,v);}}function setValueV4f(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w){gl.uniform4f(this.addr,v.x,v.y,v.z,v.w);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;cache[3]=v.w;}}else {if(arraysEqual(cache,v))return;gl.uniform4fv(this.addr,v);copyArray(cache,v);}}// Single matrix (from flat array or THREE.MatrixN)
	function setValueM2(gl,v){const cache=this.cache;const elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix2fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat2array.set(elements);gl.uniformMatrix2fv(this.addr,false,mat2array);copyArray(cache,elements);}}function setValueM3(gl,v){const cache=this.cache;const elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix3fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat3array.set(elements);gl.uniformMatrix3fv(this.addr,false,mat3array);copyArray(cache,elements);}}function setValueM4(gl,v){const cache=this.cache;const elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix4fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat4array.set(elements);gl.uniformMatrix4fv(this.addr,false,mat4array);copyArray(cache,elements);}}// Single integer / boolean
	function setValueV1i(gl,v){const cache=this.cache;if(cache[0]===v)return;gl.uniform1i(this.addr,v);cache[0]=v;}// Single integer / boolean vector (from flat array or THREE.VectorN)
	function setValueV2i(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y){gl.uniform2i(this.addr,v.x,v.y);cache[0]=v.x;cache[1]=v.y;}}else {if(arraysEqual(cache,v))return;gl.uniform2iv(this.addr,v);copyArray(cache,v);}}function setValueV3i(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z){gl.uniform3i(this.addr,v.x,v.y,v.z);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;}}else {if(arraysEqual(cache,v))return;gl.uniform3iv(this.addr,v);copyArray(cache,v);}}function setValueV4i(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w){gl.uniform4i(this.addr,v.x,v.y,v.z,v.w);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;cache[3]=v.w;}}else {if(arraysEqual(cache,v))return;gl.uniform4iv(this.addr,v);copyArray(cache,v);}}// Single unsigned integer
	function setValueV1ui(gl,v){const cache=this.cache;if(cache[0]===v)return;gl.uniform1ui(this.addr,v);cache[0]=v;}// Single unsigned integer vector (from flat array or THREE.VectorN)
	function setValueV2ui(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y){gl.uniform2ui(this.addr,v.x,v.y);cache[0]=v.x;cache[1]=v.y;}}else {if(arraysEqual(cache,v))return;gl.uniform2uiv(this.addr,v);copyArray(cache,v);}}function setValueV3ui(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z){gl.uniform3ui(this.addr,v.x,v.y,v.z);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;}}else {if(arraysEqual(cache,v))return;gl.uniform3uiv(this.addr,v);copyArray(cache,v);}}function setValueV4ui(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w){gl.uniform4ui(this.addr,v.x,v.y,v.z,v.w);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;cache[3]=v.w;}}else {if(arraysEqual(cache,v))return;gl.uniform4uiv(this.addr,v);copyArray(cache,v);}}// Single texture (2D / Cube)
	function setValueT1(gl,v,textures){const cache=this.cache;const unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}let emptyTexture2D;if(this.type===gl.SAMPLER_2D_SHADOW){emptyShadowTexture.compareFunction=LessEqualCompare;// #28670
	emptyTexture2D=emptyShadowTexture;}else {emptyTexture2D=emptyTexture;}textures.setTexture2D(v||emptyTexture2D,unit);}function setValueT3D1(gl,v,textures){const cache=this.cache;const unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture3D(v||empty3dTexture,unit);}function setValueT6(gl,v,textures){const cache=this.cache;const unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTextureCube(v||emptyCubeTexture,unit);}function setValueT2DArray1(gl,v,textures){const cache=this.cache;const unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture2DArray(v||emptyArrayTexture,unit);}// Helper to pick the right setter for the singular case
	function getSingularSetter(type){switch(type){case 0x1406:return setValueV1f;// FLOAT
	case 0x8b50:return setValueV2f;// _VEC2
	case 0x8b51:return setValueV3f;// _VEC3
	case 0x8b52:return setValueV4f;// _VEC4
	case 0x8b5a:return setValueM2;// _MAT2
	case 0x8b5b:return setValueM3;// _MAT3
	case 0x8b5c:return setValueM4;// _MAT4
	case 0x1404:case 0x8b56:return setValueV1i;// INT, BOOL
	case 0x8b53:case 0x8b57:return setValueV2i;// _VEC2
	case 0x8b54:case 0x8b58:return setValueV3i;// _VEC3
	case 0x8b55:case 0x8b59:return setValueV4i;// _VEC4
	case 0x1405:return setValueV1ui;// UINT
	case 0x8dc6:return setValueV2ui;// _VEC2
	case 0x8dc7:return setValueV3ui;// _VEC3
	case 0x8dc8:return setValueV4ui;// _VEC4
	case 0x8b5e:// SAMPLER_2D
	case 0x8d66:// SAMPLER_EXTERNAL_OES
	case 0x8dca:// INT_SAMPLER_2D
	case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
	case 0x8b62:// SAMPLER_2D_SHADOW
	return setValueT1;case 0x8b5f:// SAMPLER_3D
	case 0x8dcb:// INT_SAMPLER_3D
	case 0x8dd3:// UNSIGNED_INT_SAMPLER_3D
	return setValueT3D1;case 0x8b60:// SAMPLER_CUBE
	case 0x8dcc:// INT_SAMPLER_CUBE
	case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
	case 0x8dc5:// SAMPLER_CUBE_SHADOW
	return setValueT6;case 0x8dc1:// SAMPLER_2D_ARRAY
	case 0x8dcf:// INT_SAMPLER_2D_ARRAY
	case 0x8dd7:// UNSIGNED_INT_SAMPLER_2D_ARRAY
	case 0x8dc4:// SAMPLER_2D_ARRAY_SHADOW
	return setValueT2DArray1;}}// Array of scalars
	function setValueV1fArray(gl,v){gl.uniform1fv(this.addr,v);}// Array of vectors (from flat array or array of THREE.VectorN)
	function setValueV2fArray(gl,v){const data=flatten(v,this.size,2);gl.uniform2fv(this.addr,data);}function setValueV3fArray(gl,v){const data=flatten(v,this.size,3);gl.uniform3fv(this.addr,data);}function setValueV4fArray(gl,v){const data=flatten(v,this.size,4);gl.uniform4fv(this.addr,data);}// Array of matrices (from flat array or array of THREE.MatrixN)
	function setValueM2Array(gl,v){const data=flatten(v,this.size,4);gl.uniformMatrix2fv(this.addr,false,data);}function setValueM3Array(gl,v){const data=flatten(v,this.size,9);gl.uniformMatrix3fv(this.addr,false,data);}function setValueM4Array(gl,v){const data=flatten(v,this.size,16);gl.uniformMatrix4fv(this.addr,false,data);}// Array of integer / boolean
	function setValueV1iArray(gl,v){gl.uniform1iv(this.addr,v);}// Array of integer / boolean vectors (from flat array)
	function setValueV2iArray(gl,v){gl.uniform2iv(this.addr,v);}function setValueV3iArray(gl,v){gl.uniform3iv(this.addr,v);}function setValueV4iArray(gl,v){gl.uniform4iv(this.addr,v);}// Array of unsigned integer
	function setValueV1uiArray(gl,v){gl.uniform1uiv(this.addr,v);}// Array of unsigned integer vectors (from flat array)
	function setValueV2uiArray(gl,v){gl.uniform2uiv(this.addr,v);}function setValueV3uiArray(gl,v){gl.uniform3uiv(this.addr,v);}function setValueV4uiArray(gl,v){gl.uniform4uiv(this.addr,v);}// Array of textures (2D / 3D / Cube / 2DArray)
	function setValueT1Array(gl,v,textures){const cache=this.cache;const n=v.length;const units=allocTexUnits(textures,n);if(!arraysEqual(cache,units)){gl.uniform1iv(this.addr,units);copyArray(cache,units);}for(let i=0;i!==n;++i){textures.setTexture2D(v[i]||emptyTexture,units[i]);}}function setValueT3DArray(gl,v,textures){const cache=this.cache;const n=v.length;const units=allocTexUnits(textures,n);if(!arraysEqual(cache,units)){gl.uniform1iv(this.addr,units);copyArray(cache,units);}for(let i=0;i!==n;++i){textures.setTexture3D(v[i]||empty3dTexture,units[i]);}}function setValueT6Array(gl,v,textures){const cache=this.cache;const n=v.length;const units=allocTexUnits(textures,n);if(!arraysEqual(cache,units)){gl.uniform1iv(this.addr,units);copyArray(cache,units);}for(let i=0;i!==n;++i){textures.setTextureCube(v[i]||emptyCubeTexture,units[i]);}}function setValueT2DArrayArray(gl,v,textures){const cache=this.cache;const n=v.length;const units=allocTexUnits(textures,n);if(!arraysEqual(cache,units)){gl.uniform1iv(this.addr,units);copyArray(cache,units);}for(let i=0;i!==n;++i){textures.setTexture2DArray(v[i]||emptyArrayTexture,units[i]);}}// Helper to pick the right setter for a pure (bottom-level) array
	function getPureArraySetter(type){switch(type){case 0x1406:return setValueV1fArray;// FLOAT
	case 0x8b50:return setValueV2fArray;// _VEC2
	case 0x8b51:return setValueV3fArray;// _VEC3
	case 0x8b52:return setValueV4fArray;// _VEC4
	case 0x8b5a:return setValueM2Array;// _MAT2
	case 0x8b5b:return setValueM3Array;// _MAT3
	case 0x8b5c:return setValueM4Array;// _MAT4
	case 0x1404:case 0x8b56:return setValueV1iArray;// INT, BOOL
	case 0x8b53:case 0x8b57:return setValueV2iArray;// _VEC2
	case 0x8b54:case 0x8b58:return setValueV3iArray;// _VEC3
	case 0x8b55:case 0x8b59:return setValueV4iArray;// _VEC4
	case 0x1405:return setValueV1uiArray;// UINT
	case 0x8dc6:return setValueV2uiArray;// _VEC2
	case 0x8dc7:return setValueV3uiArray;// _VEC3
	case 0x8dc8:return setValueV4uiArray;// _VEC4
	case 0x8b5e:// SAMPLER_2D
	case 0x8d66:// SAMPLER_EXTERNAL_OES
	case 0x8dca:// INT_SAMPLER_2D
	case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
	case 0x8b62:// SAMPLER_2D_SHADOW
	return setValueT1Array;case 0x8b5f:// SAMPLER_3D
	case 0x8dcb:// INT_SAMPLER_3D
	case 0x8dd3:// UNSIGNED_INT_SAMPLER_3D
	return setValueT3DArray;case 0x8b60:// SAMPLER_CUBE
	case 0x8dcc:// INT_SAMPLER_CUBE
	case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
	case 0x8dc5:// SAMPLER_CUBE_SHADOW
	return setValueT6Array;case 0x8dc1:// SAMPLER_2D_ARRAY
	case 0x8dcf:// INT_SAMPLER_2D_ARRAY
	case 0x8dd7:// UNSIGNED_INT_SAMPLER_2D_ARRAY
	case 0x8dc4:// SAMPLER_2D_ARRAY_SHADOW
	return setValueT2DArrayArray;}}// --- Uniform Classes ---
	class SingleUniform{constructor(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=[];this.type=activeInfo.type;this.setValue=getSingularSetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
	}}class PureArrayUniform{constructor(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=[];this.type=activeInfo.type;this.size=activeInfo.size;this.setValue=getPureArraySetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
	}}class StructuredUniform{constructor(id){this.id=id;this.seq=[];this.map={};}setValue(gl,value,textures){const seq=this.seq;for(let i=0,n=seq.length;i!==n;++i){const u=seq[i];u.setValue(gl,value[u.id],textures);}}}// --- Top-level ---
	// Parser - builds up the property tree from the path strings
	const RePathPart=/(\w+)(\])?(\[|\.)?/g;// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.
	function addUniform(container,uniformObject){container.seq.push(uniformObject);container.map[uniformObject.id]=uniformObject;}function parseUniform(activeInfo,addr,container){const path=activeInfo.name,pathLength=path.length;// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex=0;while(true){const match=RePathPart.exec(path),matchEnd=RePathPart.lastIndex;let id=match[1];const idIsIndex=match[2]===']',subscript=match[3];if(idIsIndex)id=id|0;// convert to integer
	if(subscript===undefined||subscript==='['&&matchEnd+2===pathLength){// bare name or "pure" bottom-level array "[0]" suffix
	addUniform(container,subscript===undefined?new SingleUniform(id,activeInfo,addr):new PureArrayUniform(id,activeInfo,addr));break;}else {// step into inner node / create it in case it doesn't exist
	const map=container.map;let next=map[id];if(next===undefined){next=new StructuredUniform(id);addUniform(container,next);}container=next;}}}// Root Container
	class WebGLUniforms{constructor(gl,program){this.seq=[];this.map={};const n=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const info=gl.getActiveUniform(program,i),addr=gl.getUniformLocation(program,info.name);parseUniform(info,addr,this);}}setValue(gl,name,value,textures){const u=this.map[name];if(u!==undefined)u.setValue(gl,value,textures);}setOptional(gl,object,name){const v=object[name];if(v!==undefined)this.setValue(gl,name,v);}static upload(gl,seq,values,textures){for(let i=0,n=seq.length;i!==n;++i){const u=seq[i],v=values[u.id];if(v.needsUpdate!==false){// note: always updating when .needsUpdate is undefined
	u.setValue(gl,v.value,textures);}}}static seqWithValue(seq,values){const r=[];for(let i=0,n=seq.length;i!==n;++i){const u=seq[i];if(u.id in values)r.push(u);}return r;}}function WebGLShader(gl,type,string){const shader=gl.createShader(type);gl.shaderSource(shader,string);gl.compileShader(shader);return shader;}// From https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/
	const COMPLETION_STATUS_KHR=0x91B1;let programIdCount=0;function handleSource(string,errorLine){const lines=string.split('\n');const lines2=[];const from=Math.max(errorLine-6,0);const to=Math.min(errorLine+6,lines.length);for(let i=from;i<to;i++){const line=i+1;lines2.push(`${line===errorLine?'>':' '} ${line}: ${lines[i]}`);}return lines2.join('\n');}const _m0=/*@__PURE__*/new Matrix3$1();function getEncodingComponents(colorSpace){ColorManagement._getMatrix(_m0,ColorManagement.workingColorSpace,colorSpace);const encodingMatrix=`mat3( ${_m0.elements.map(v=>v.toFixed(4))} )`;switch(ColorManagement.getTransfer(colorSpace)){case LinearTransfer:return [encodingMatrix,'LinearTransferOETF'];case SRGBTransfer:return [encodingMatrix,'sRGBTransferOETF'];default:console.warn('THREE.WebGLProgram: Unsupported color space: ',colorSpace);return [encodingMatrix,'LinearTransferOETF'];}}function getShaderErrors(gl,shader,type){const status=gl.getShaderParameter(shader,gl.COMPILE_STATUS);const errors=gl.getShaderInfoLog(shader).trim();if(status&&errors==='')return '';const errorMatches=/ERROR: 0:(\d+)/.exec(errors);if(errorMatches){// --enable-privileged-webgl-extension
	// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
	const errorLine=parseInt(errorMatches[1]);return type.toUpperCase()+'\n\n'+errors+'\n\n'+handleSource(gl.getShaderSource(shader),errorLine);}else {return errors;}}function getTexelEncodingFunction(functionName,colorSpace){const components=getEncodingComponents(colorSpace);return [`vec4 ${functionName}( vec4 value ) {`,`	return ${components[1]}( vec4( value.rgb * ${components[0]}, value.a ) );`,'}'].join('\n');}function getToneMappingFunction(functionName,toneMapping){let toneMappingName;switch(toneMapping){case LinearToneMapping:toneMappingName='Linear';break;case ReinhardToneMapping:toneMappingName='Reinhard';break;case CineonToneMapping:toneMappingName='Cineon';break;case ACESFilmicToneMapping:toneMappingName='ACESFilmic';break;case AgXToneMapping:toneMappingName='AgX';break;case NeutralToneMapping:toneMappingName='Neutral';break;case CustomToneMapping:toneMappingName='Custom';break;default:console.warn('THREE.WebGLProgram: Unsupported toneMapping:',toneMapping);toneMappingName='Linear';}return 'vec3 '+functionName+'( vec3 color ) { return '+toneMappingName+'ToneMapping( color ); }';}const _v0$1=/*@__PURE__*/new Vector3$1();function getLuminanceFunction(){ColorManagement.getLuminanceCoefficients(_v0$1);const r=_v0$1.x.toFixed(4);const g=_v0$1.y.toFixed(4);const b=_v0$1.z.toFixed(4);return ['float luminance( const in vec3 rgb ) {',`	const vec3 weights = vec3( ${r}, ${g}, ${b} );`,'	return dot( weights, rgb );','}'].join('\n');}function generateVertexExtensions(parameters){const chunks=[parameters.extensionClipCullDistance?'#extension GL_ANGLE_clip_cull_distance : require':'',parameters.extensionMultiDraw?'#extension GL_ANGLE_multi_draw : require':''];return chunks.filter(filterEmptyLine).join('\n');}function generateDefines(defines){const chunks=[];for(const name in defines){const value=defines[name];if(value===false)continue;chunks.push('#define '+name+' '+value);}return chunks.join('\n');}function fetchAttributeLocations(gl,program){const attributes={};const n=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);for(let i=0;i<n;i++){const info=gl.getActiveAttrib(program,i);const name=info.name;let locationSize=1;if(info.type===gl.FLOAT_MAT2)locationSize=2;if(info.type===gl.FLOAT_MAT3)locationSize=3;if(info.type===gl.FLOAT_MAT4)locationSize=4;// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
	attributes[name]={type:info.type,location:gl.getAttribLocation(program,name),locationSize:locationSize};}return attributes;}function filterEmptyLine(string){return string!=='';}function replaceLightNums(string,parameters){const numSpotLightCoords=parameters.numSpotLightShadows+parameters.numSpotLightMaps-parameters.numSpotLightShadowsWithMaps;return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,parameters.numPointLightShadows);}function replaceClippingPlaneNums(string,parameters){return string.replace(/NUM_CLIPPING_PLANES/g,parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,parameters.numClippingPlanes-parameters.numClipIntersection);}// Resolve Includes
	const includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(string){return string.replace(includePattern,includeReplacer);}const shaderChunkMap=new Map();function includeReplacer(match,include){let string=ShaderChunk[include];if(string===undefined){const newInclude=shaderChunkMap.get(include);if(newInclude!==undefined){string=ShaderChunk[newInclude];console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',include,newInclude);}else {throw new Error('Can not resolve #include <'+include+'>');}}return resolveIncludes(string);}// Unroll Loops
	const unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(string){return string.replace(unrollLoopPattern,loopReplacer);}function loopReplacer(match,start,end,snippet){let string='';for(let i=parseInt(start);i<parseInt(end);i++){string+=snippet.replace(/\[\s*i\s*\]/g,'[ '+i+' ]').replace(/UNROLLED_LOOP_INDEX/g,i);}return string;}//
	function generatePrecision(parameters){let precisionstring=`precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;if(parameters.precision==='highp'){precisionstring+='\n#define HIGH_PRECISION';}else if(parameters.precision==='mediump'){precisionstring+='\n#define MEDIUM_PRECISION';}else if(parameters.precision==='lowp'){precisionstring+='\n#define LOW_PRECISION';}return precisionstring;}function generateShadowMapTypeDefine(parameters){let shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';if(parameters.shadowMapType===PCFShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF';}else if(parameters.shadowMapType===PCFSoftShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';}else if(parameters.shadowMapType===VSMShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_VSM';}return shadowMapTypeDefine;}function generateEnvMapTypeDefine(parameters){let envMapTypeDefine='ENVMAP_TYPE_CUBE';if(parameters.envMap){switch(parameters.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE';break;case CubeUVReflectionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE_UV';break;}}return envMapTypeDefine;}function generateEnvMapModeDefine(parameters){let envMapModeDefine='ENVMAP_MODE_REFLECTION';if(parameters.envMap){switch(parameters.envMapMode){case CubeRefractionMapping:envMapModeDefine='ENVMAP_MODE_REFRACTION';break;}}return envMapModeDefine;}function generateEnvMapBlendingDefine(parameters){let envMapBlendingDefine='ENVMAP_BLENDING_NONE';if(parameters.envMap){switch(parameters.combine){case MultiplyOperation:envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';break;case MixOperation:envMapBlendingDefine='ENVMAP_BLENDING_MIX';break;case AddOperation:envMapBlendingDefine='ENVMAP_BLENDING_ADD';break;}}return envMapBlendingDefine;}function generateCubeUVSize(parameters){const imageHeight=parameters.envMapCubeUVHeight;if(imageHeight===null)return null;const maxMip=Math.log2(imageHeight)-2;const texelHeight=1.0/imageHeight;const texelWidth=1.0/(3*Math.max(Math.pow(2,maxMip),7*16));return {texelWidth,texelHeight,maxMip};}function WebGLProgram(renderer,cacheKey,parameters,bindingStates){// TODO Send this event to Three.js DevTools
	// console.log( 'WebGLProgram', cacheKey );
	const gl=renderer.getContext();const defines=parameters.defines;let vertexShader=parameters.vertexShader;let fragmentShader=parameters.fragmentShader;const shadowMapTypeDefine=generateShadowMapTypeDefine(parameters);const envMapTypeDefine=generateEnvMapTypeDefine(parameters);const envMapModeDefine=generateEnvMapModeDefine(parameters);const envMapBlendingDefine=generateEnvMapBlendingDefine(parameters);const envMapCubeUVSize=generateCubeUVSize(parameters);const customVertexExtensions=generateVertexExtensions(parameters);const customDefines=generateDefines(defines);const program=gl.createProgram();let prefixVertex,prefixFragment;let versionString=parameters.glslVersion?'#version '+parameters.glslVersion+'\n':'';if(parameters.isRawShaderMaterial){prefixVertex=['#define SHADER_TYPE '+parameters.shaderType,'#define SHADER_NAME '+parameters.shaderName,customDefines].filter(filterEmptyLine).join('\n');if(prefixVertex.length>0){prefixVertex+='\n';}prefixFragment=['#define SHADER_TYPE '+parameters.shaderType,'#define SHADER_NAME '+parameters.shaderName,customDefines].filter(filterEmptyLine).join('\n');if(prefixFragment.length>0){prefixFragment+='\n';}}else {prefixVertex=[generatePrecision(parameters),'#define SHADER_TYPE '+parameters.shaderType,'#define SHADER_NAME '+parameters.shaderName,customDefines,parameters.extensionClipCullDistance?'#define USE_CLIP_DISTANCE':'',parameters.batching?'#define USE_BATCHING':'',parameters.batchingColor?'#define USE_BATCHING_COLOR':'',parameters.instancing?'#define USE_INSTANCING':'',parameters.instancingColor?'#define USE_INSTANCING_COLOR':'',parameters.instancingMorph?'#define USE_INSTANCING_MORPH':'',parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMapObjectSpace?'#define USE_NORMALMAP_OBJECTSPACE':'',parameters.normalMapTangentSpace?'#define USE_NORMALMAP_TANGENTSPACE':'',parameters.displacementMap?'#define USE_DISPLACEMENTMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.anisotropy?'#define USE_ANISOTROPY':'',parameters.anisotropyMap?'#define USE_ANISOTROPYMAP':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.iridescenceMap?'#define USE_IRIDESCENCEMAP':'',parameters.iridescenceThicknessMap?'#define USE_IRIDESCENCE_THICKNESSMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.specularColorMap?'#define USE_SPECULAR_COLORMAP':'',parameters.specularIntensityMap?'#define USE_SPECULAR_INTENSITYMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.alphaHash?'#define USE_ALPHAHASH':'',parameters.transmission?'#define USE_TRANSMISSION':'',parameters.transmissionMap?'#define USE_TRANSMISSIONMAP':'',parameters.thicknessMap?'#define USE_THICKNESSMAP':'',parameters.sheenColorMap?'#define USE_SHEEN_COLORMAP':'',parameters.sheenRoughnessMap?'#define USE_SHEEN_ROUGHNESSMAP':'',//
	parameters.mapUv?'#define MAP_UV '+parameters.mapUv:'',parameters.alphaMapUv?'#define ALPHAMAP_UV '+parameters.alphaMapUv:'',parameters.lightMapUv?'#define LIGHTMAP_UV '+parameters.lightMapUv:'',parameters.aoMapUv?'#define AOMAP_UV '+parameters.aoMapUv:'',parameters.emissiveMapUv?'#define EMISSIVEMAP_UV '+parameters.emissiveMapUv:'',parameters.bumpMapUv?'#define BUMPMAP_UV '+parameters.bumpMapUv:'',parameters.normalMapUv?'#define NORMALMAP_UV '+parameters.normalMapUv:'',parameters.displacementMapUv?'#define DISPLACEMENTMAP_UV '+parameters.displacementMapUv:'',parameters.metalnessMapUv?'#define METALNESSMAP_UV '+parameters.metalnessMapUv:'',parameters.roughnessMapUv?'#define ROUGHNESSMAP_UV '+parameters.roughnessMapUv:'',parameters.anisotropyMapUv?'#define ANISOTROPYMAP_UV '+parameters.anisotropyMapUv:'',parameters.clearcoatMapUv?'#define CLEARCOATMAP_UV '+parameters.clearcoatMapUv:'',parameters.clearcoatNormalMapUv?'#define CLEARCOAT_NORMALMAP_UV '+parameters.clearcoatNormalMapUv:'',parameters.clearcoatRoughnessMapUv?'#define CLEARCOAT_ROUGHNESSMAP_UV '+parameters.clearcoatRoughnessMapUv:'',parameters.iridescenceMapUv?'#define IRIDESCENCEMAP_UV '+parameters.iridescenceMapUv:'',parameters.iridescenceThicknessMapUv?'#define IRIDESCENCE_THICKNESSMAP_UV '+parameters.iridescenceThicknessMapUv:'',parameters.sheenColorMapUv?'#define SHEEN_COLORMAP_UV '+parameters.sheenColorMapUv:'',parameters.sheenRoughnessMapUv?'#define SHEEN_ROUGHNESSMAP_UV '+parameters.sheenRoughnessMapUv:'',parameters.specularMapUv?'#define SPECULARMAP_UV '+parameters.specularMapUv:'',parameters.specularColorMapUv?'#define SPECULAR_COLORMAP_UV '+parameters.specularColorMapUv:'',parameters.specularIntensityMapUv?'#define SPECULAR_INTENSITYMAP_UV '+parameters.specularIntensityMapUv:'',parameters.transmissionMapUv?'#define TRANSMISSIONMAP_UV '+parameters.transmissionMapUv:'',parameters.thicknessMapUv?'#define THICKNESSMAP_UV '+parameters.thicknessMapUv:'',//
	parameters.vertexTangents&&parameters.flatShading===false?'#define USE_TANGENT':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.vertexAlphas?'#define USE_COLOR_ALPHA':'',parameters.vertexUv1s?'#define USE_UV1':'',parameters.vertexUv2s?'#define USE_UV2':'',parameters.vertexUv3s?'#define USE_UV3':'',parameters.pointsUvs?'#define USE_POINTS_UV':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.skinning?'#define USE_SKINNING':'',parameters.morphTargets?'#define USE_MORPHTARGETS':'',parameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',parameters.morphColors?'#define USE_MORPHCOLORS':'',parameters.morphTargetsCount>0?'#define MORPHTARGETS_TEXTURE_STRIDE '+parameters.morphTextureStride:'',parameters.morphTargetsCount>0?'#define MORPHTARGETS_COUNT '+parameters.morphTargetsCount:'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',parameters.numLightProbes>0?'#define USE_LIGHT_PROBES':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.reverseDepthBuffer?'#define USE_REVERSEDEPTHBUF':'','uniform mat4 modelMatrix;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform mat4 viewMatrix;','uniform mat3 normalMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;','#ifdef USE_INSTANCING','	attribute mat4 instanceMatrix;','#endif','#ifdef USE_INSTANCING_COLOR','	attribute vec3 instanceColor;','#endif','#ifdef USE_INSTANCING_MORPH','	uniform sampler2D morphTexture;','#endif','attribute vec3 position;','attribute vec3 normal;','attribute vec2 uv;','#ifdef USE_UV1','	attribute vec2 uv1;','#endif','#ifdef USE_UV2','	attribute vec2 uv2;','#endif','#ifdef USE_UV3','	attribute vec2 uv3;','#endif','#ifdef USE_TANGENT','	attribute vec4 tangent;','#endif','#if defined( USE_COLOR_ALPHA )','	attribute vec4 color;','#elif defined( USE_COLOR )','	attribute vec3 color;','#endif','#ifdef USE_SKINNING','	attribute vec4 skinIndex;','	attribute vec4 skinWeight;','#endif','\n'].filter(filterEmptyLine).join('\n');prefixFragment=[generatePrecision(parameters),'#define SHADER_TYPE '+parameters.shaderType,'#define SHADER_NAME '+parameters.shaderName,customDefines,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.alphaToCoverage?'#define ALPHA_TO_COVERAGE':'',parameters.map?'#define USE_MAP':'',parameters.matcap?'#define USE_MATCAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapTypeDefine:'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.envMap?'#define '+envMapBlendingDefine:'',envMapCubeUVSize?'#define CUBEUV_TEXEL_WIDTH '+envMapCubeUVSize.texelWidth:'',envMapCubeUVSize?'#define CUBEUV_TEXEL_HEIGHT '+envMapCubeUVSize.texelHeight:'',envMapCubeUVSize?'#define CUBEUV_MAX_MIP '+envMapCubeUVSize.maxMip+'.0':'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMapObjectSpace?'#define USE_NORMALMAP_OBJECTSPACE':'',parameters.normalMapTangentSpace?'#define USE_NORMALMAP_TANGENTSPACE':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.anisotropy?'#define USE_ANISOTROPY':'',parameters.anisotropyMap?'#define USE_ANISOTROPYMAP':'',parameters.clearcoat?'#define USE_CLEARCOAT':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.dispersion?'#define USE_DISPERSION':'',parameters.iridescence?'#define USE_IRIDESCENCE':'',parameters.iridescenceMap?'#define USE_IRIDESCENCEMAP':'',parameters.iridescenceThicknessMap?'#define USE_IRIDESCENCE_THICKNESSMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.specularColorMap?'#define USE_SPECULAR_COLORMAP':'',parameters.specularIntensityMap?'#define USE_SPECULAR_INTENSITYMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.alphaTest?'#define USE_ALPHATEST':'',parameters.alphaHash?'#define USE_ALPHAHASH':'',parameters.sheen?'#define USE_SHEEN':'',parameters.sheenColorMap?'#define USE_SHEEN_COLORMAP':'',parameters.sheenRoughnessMap?'#define USE_SHEEN_ROUGHNESSMAP':'',parameters.transmission?'#define USE_TRANSMISSION':'',parameters.transmissionMap?'#define USE_TRANSMISSIONMAP':'',parameters.thicknessMap?'#define USE_THICKNESSMAP':'',parameters.vertexTangents&&parameters.flatShading===false?'#define USE_TANGENT':'',parameters.vertexColors||parameters.instancingColor||parameters.batchingColor?'#define USE_COLOR':'',parameters.vertexAlphas?'#define USE_COLOR_ALPHA':'',parameters.vertexUv1s?'#define USE_UV1':'',parameters.vertexUv2s?'#define USE_UV2':'',parameters.vertexUv3s?'#define USE_UV3':'',parameters.pointsUvs?'#define USE_POINTS_UV':'',parameters.gradientMap?'#define USE_GRADIENTMAP':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.premultipliedAlpha?'#define PREMULTIPLIED_ALPHA':'',parameters.numLightProbes>0?'#define USE_LIGHT_PROBES':'',parameters.decodeVideoTexture?'#define DECODE_VIDEO_TEXTURE':'',parameters.decodeVideoTextureEmissive?'#define DECODE_VIDEO_TEXTURE_EMISSIVE':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.reverseDepthBuffer?'#define USE_REVERSEDEPTHBUF':'','uniform mat4 viewMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;',parameters.toneMapping!==NoToneMapping?'#define TONE_MAPPING':'',parameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below
	parameters.toneMapping!==NoToneMapping?getToneMappingFunction('toneMapping',parameters.toneMapping):'',parameters.dithering?'#define DITHERING':'',parameters.opaque?'#define OPAQUE':'',ShaderChunk['colorspace_pars_fragment'],// this code is required here because it is used by the various encoding/decoding function defined below
	getTexelEncodingFunction('linearToOutputTexel',parameters.outputColorSpace),getLuminanceFunction(),parameters.useDepthPacking?'#define DEPTH_PACKING '+parameters.depthPacking:'','\n'].filter(filterEmptyLine).join('\n');}vertexShader=resolveIncludes(vertexShader);vertexShader=replaceLightNums(vertexShader,parameters);vertexShader=replaceClippingPlaneNums(vertexShader,parameters);fragmentShader=resolveIncludes(fragmentShader);fragmentShader=replaceLightNums(fragmentShader,parameters);fragmentShader=replaceClippingPlaneNums(fragmentShader,parameters);vertexShader=unrollLoops(vertexShader);fragmentShader=unrollLoops(fragmentShader);if(parameters.isRawShaderMaterial!==true){// GLSL 3.0 conversion for built-in materials and ShaderMaterial
	versionString='#version 300 es\n';prefixVertex=[customVertexExtensions,'#define attribute in','#define varying out','#define texture2D texture'].join('\n')+'\n'+prefixVertex;prefixFragment=['#define varying in',parameters.glslVersion===GLSL3?'':'layout(location = 0) out highp vec4 pc_fragColor;',parameters.glslVersion===GLSL3?'':'#define gl_FragColor pc_fragColor','#define gl_FragDepthEXT gl_FragDepth','#define texture2D texture','#define textureCube texture','#define texture2DProj textureProj','#define texture2DLodEXT textureLod','#define texture2DProjLodEXT textureProjLod','#define textureCubeLodEXT textureLod','#define texture2DGradEXT textureGrad','#define texture2DProjGradEXT textureProjGrad','#define textureCubeGradEXT textureGrad'].join('\n')+'\n'+prefixFragment;}const vertexGlsl=versionString+prefixVertex+vertexShader;const fragmentGlsl=versionString+prefixFragment+fragmentShader;// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );
	const glVertexShader=WebGLShader(gl,gl.VERTEX_SHADER,vertexGlsl);const glFragmentShader=WebGLShader(gl,gl.FRAGMENT_SHADER,fragmentGlsl);gl.attachShader(program,glVertexShader);gl.attachShader(program,glFragmentShader);// Force a particular attribute to index 0.
	if(parameters.index0AttributeName!==undefined){gl.bindAttribLocation(program,0,parameters.index0AttributeName);}else if(parameters.morphTargets===true){// programs with morphTargets displace position out of attribute 0
	gl.bindAttribLocation(program,0,'position');}gl.linkProgram(program);function onFirstUse(self){// check for link errors
	if(renderer.debug.checkShaderErrors){const programLog=gl.getProgramInfoLog(program).trim();const vertexLog=gl.getShaderInfoLog(glVertexShader).trim();const fragmentLog=gl.getShaderInfoLog(glFragmentShader).trim();let runnable=true;let haveDiagnostics=true;if(gl.getProgramParameter(program,gl.LINK_STATUS)===false){runnable=false;if(typeof renderer.debug.onShaderError==='function'){renderer.debug.onShaderError(gl,program,glVertexShader,glFragmentShader);}else {// default error reporting
	const vertexErrors=getShaderErrors(gl,glVertexShader,'vertex');const fragmentErrors=getShaderErrors(gl,glFragmentShader,'fragment');console.error('THREE.WebGLProgram: Shader Error '+gl.getError()+' - '+'VALIDATE_STATUS '+gl.getProgramParameter(program,gl.VALIDATE_STATUS)+'\n\n'+'Material Name: '+self.name+'\n'+'Material Type: '+self.type+'\n\n'+'Program Info Log: '+programLog+'\n'+vertexErrors+'\n'+fragmentErrors);}}else if(programLog!==''){console.warn('THREE.WebGLProgram: Program Info Log:',programLog);}else if(vertexLog===''||fragmentLog===''){haveDiagnostics=false;}if(haveDiagnostics){self.diagnostics={runnable:runnable,programLog:programLog,vertexShader:{log:vertexLog,prefix:prefixVertex},fragmentShader:{log:fragmentLog,prefix:prefixFragment}};}}// Clean up
	// Crashes in iOS9 and iOS10. #18402
	// gl.detachShader( program, glVertexShader );
	// gl.detachShader( program, glFragmentShader );
	gl.deleteShader(glVertexShader);gl.deleteShader(glFragmentShader);cachedUniforms=new WebGLUniforms(gl,program);cachedAttributes=fetchAttributeLocations(gl,program);}// set up caching for uniform locations
	let cachedUniforms;this.getUniforms=function(){if(cachedUniforms===undefined){// Populates cachedUniforms and cachedAttributes
	onFirstUse(this);}return cachedUniforms;};// set up caching for attribute locations
	let cachedAttributes;this.getAttributes=function(){if(cachedAttributes===undefined){// Populates cachedAttributes and cachedUniforms
	onFirstUse(this);}return cachedAttributes;};// indicate when the program is ready to be used. if the KHR_parallel_shader_compile extension isn't supported,
	// flag the program as ready immediately. It may cause a stall when it's first used.
	let programReady=parameters.rendererExtensionParallelShaderCompile===false;this.isReady=function(){if(programReady===false){programReady=gl.getProgramParameter(program,COMPLETION_STATUS_KHR);}return programReady;};// free resource
	this.destroy=function(){bindingStates.releaseStatesOfProgram(this);gl.deleteProgram(program);this.program=undefined;};//
	this.type=parameters.shaderType;this.name=parameters.shaderName;this.id=programIdCount++;this.cacheKey=cacheKey;this.usedTimes=1;this.program=program;this.vertexShader=glVertexShader;this.fragmentShader=glFragmentShader;return this;}let _id$1=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map();this.materialCache=new Map();}update(material){const vertexShader=material.vertexShader;const fragmentShader=material.fragmentShader;const vertexShaderStage=this._getShaderStage(vertexShader);const fragmentShaderStage=this._getShaderStage(fragmentShader);const materialShaders=this._getShaderCacheForMaterial(material);if(materialShaders.has(vertexShaderStage)===false){materialShaders.add(vertexShaderStage);vertexShaderStage.usedTimes++;}if(materialShaders.has(fragmentShaderStage)===false){materialShaders.add(fragmentShaderStage);fragmentShaderStage.usedTimes++;}return this;}remove(material){const materialShaders=this.materialCache.get(material);for(const shaderStage of materialShaders){shaderStage.usedTimes--;if(shaderStage.usedTimes===0)this.shaderCache.delete(shaderStage.code);}this.materialCache.delete(material);return this;}getVertexShaderID(material){return this._getShaderStage(material.vertexShader).id;}getFragmentShaderID(material){return this._getShaderStage(material.fragmentShader).id;}dispose(){this.shaderCache.clear();this.materialCache.clear();}_getShaderCacheForMaterial(material){const cache=this.materialCache;let set=cache.get(material);if(set===undefined){set=new Set();cache.set(material,set);}return set;}_getShaderStage(code){const cache=this.shaderCache;let stage=cache.get(code);if(stage===undefined){stage=new WebGLShaderStage(code);cache.set(code,stage);}return stage;}}class WebGLShaderStage{constructor(code){this.id=_id$1++;this.code=code;this.usedTimes=0;}}function WebGLPrograms(renderer,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping){const _programLayers=new Layers$1();const _customShaders=new WebGLShaderCache();const _activeChannels=new Set();const programs=[];const logarithmicDepthBuffer=capabilities.logarithmicDepthBuffer;const SUPPORTS_VERTEX_TEXTURES=capabilities.vertexTextures;let precision=capabilities.precision;const shaderIDs={MeshDepthMaterial:'depth',MeshDistanceMaterial:'distanceRGBA',MeshNormalMaterial:'normal',MeshBasicMaterial:'basic',MeshLambertMaterial:'lambert',MeshPhongMaterial:'phong',MeshToonMaterial:'toon',MeshStandardMaterial:'physical',MeshPhysicalMaterial:'physical',MeshMatcapMaterial:'matcap',LineBasicMaterial:'basic',LineDashedMaterial:'dashed',PointsMaterial:'points',ShadowMaterial:'shadow',SpriteMaterial:'sprite'};function getChannel(value){_activeChannels.add(value);if(value===0)return 'uv';return `uv${value}`;}function getParameters(material,lights,shadows,scene,object){const fog=scene.fog;const geometry=object.geometry;const environment=material.isMeshStandardMaterial?scene.environment:null;const envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment);const envMapCubeUVHeight=!!envMap&&envMap.mapping===CubeUVReflectionMapping?envMap.image.height:null;const shaderID=shaderIDs[material.type];// heuristics to create shader parameters according to lights in the scene
	// (not to blow over maxLights budget)
	if(material.precision!==null){precision=capabilities.getMaxPrecision(material.precision);if(precision!==material.precision){console.warn('THREE.WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');}}//
	const morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color;const morphTargetsCount=morphAttribute!==undefined?morphAttribute.length:0;let morphTextureStride=0;if(geometry.morphAttributes.position!==undefined)morphTextureStride=1;if(geometry.morphAttributes.normal!==undefined)morphTextureStride=2;if(geometry.morphAttributes.color!==undefined)morphTextureStride=3;//
	let vertexShader,fragmentShader;let customVertexShaderID,customFragmentShaderID;if(shaderID){const shader=ShaderLib[shaderID];vertexShader=shader.vertexShader;fragmentShader=shader.fragmentShader;}else {vertexShader=material.vertexShader;fragmentShader=material.fragmentShader;_customShaders.update(material);customVertexShaderID=_customShaders.getVertexShaderID(material);customFragmentShaderID=_customShaders.getFragmentShaderID(material);}const currentRenderTarget=renderer.getRenderTarget();const reverseDepthBuffer=renderer.state.buffers.depth.getReversed();const IS_INSTANCEDMESH=object.isInstancedMesh===true;const IS_BATCHEDMESH=object.isBatchedMesh===true;const HAS_MAP=!!material.map;const HAS_MATCAP=!!material.matcap;const HAS_ENVMAP=!!envMap;const HAS_AOMAP=!!material.aoMap;const HAS_LIGHTMAP=!!material.lightMap;const HAS_BUMPMAP=!!material.bumpMap;const HAS_NORMALMAP=!!material.normalMap;const HAS_DISPLACEMENTMAP=!!material.displacementMap;const HAS_EMISSIVEMAP=!!material.emissiveMap;const HAS_METALNESSMAP=!!material.metalnessMap;const HAS_ROUGHNESSMAP=!!material.roughnessMap;const HAS_ANISOTROPY=material.anisotropy>0;const HAS_CLEARCOAT=material.clearcoat>0;const HAS_DISPERSION=material.dispersion>0;const HAS_IRIDESCENCE=material.iridescence>0;const HAS_SHEEN=material.sheen>0;const HAS_TRANSMISSION=material.transmission>0;const HAS_ANISOTROPYMAP=HAS_ANISOTROPY&&!!material.anisotropyMap;const HAS_CLEARCOATMAP=HAS_CLEARCOAT&&!!material.clearcoatMap;const HAS_CLEARCOAT_NORMALMAP=HAS_CLEARCOAT&&!!material.clearcoatNormalMap;const HAS_CLEARCOAT_ROUGHNESSMAP=HAS_CLEARCOAT&&!!material.clearcoatRoughnessMap;const HAS_IRIDESCENCEMAP=HAS_IRIDESCENCE&&!!material.iridescenceMap;const HAS_IRIDESCENCE_THICKNESSMAP=HAS_IRIDESCENCE&&!!material.iridescenceThicknessMap;const HAS_SHEEN_COLORMAP=HAS_SHEEN&&!!material.sheenColorMap;const HAS_SHEEN_ROUGHNESSMAP=HAS_SHEEN&&!!material.sheenRoughnessMap;const HAS_SPECULARMAP=!!material.specularMap;const HAS_SPECULAR_COLORMAP=!!material.specularColorMap;const HAS_SPECULAR_INTENSITYMAP=!!material.specularIntensityMap;const HAS_TRANSMISSIONMAP=HAS_TRANSMISSION&&!!material.transmissionMap;const HAS_THICKNESSMAP=HAS_TRANSMISSION&&!!material.thicknessMap;const HAS_GRADIENTMAP=!!material.gradientMap;const HAS_ALPHAMAP=!!material.alphaMap;const HAS_ALPHATEST=material.alphaTest>0;const HAS_ALPHAHASH=!!material.alphaHash;const HAS_EXTENSIONS=!!material.extensions;let toneMapping=NoToneMapping;if(material.toneMapped){if(currentRenderTarget===null||currentRenderTarget.isXRRenderTarget===true){toneMapping=renderer.toneMapping;}}const parameters={shaderID:shaderID,shaderType:material.type,shaderName:material.name,vertexShader:vertexShader,fragmentShader:fragmentShader,defines:material.defines,customVertexShaderID:customVertexShaderID,customFragmentShaderID:customFragmentShaderID,isRawShaderMaterial:material.isRawShaderMaterial===true,glslVersion:material.glslVersion,precision:precision,batching:IS_BATCHEDMESH,batchingColor:IS_BATCHEDMESH&&object._colorsTexture!==null,instancing:IS_INSTANCEDMESH,instancingColor:IS_INSTANCEDMESH&&object.instanceColor!==null,instancingMorph:IS_INSTANCEDMESH&&object.morphTexture!==null,supportsVertexTextures:SUPPORTS_VERTEX_TEXTURES,outputColorSpace:currentRenderTarget===null?renderer.outputColorSpace:currentRenderTarget.isXRRenderTarget===true?currentRenderTarget.texture.colorSpace:LinearSRGBColorSpace,alphaToCoverage:!!material.alphaToCoverage,map:HAS_MAP,matcap:HAS_MATCAP,envMap:HAS_ENVMAP,envMapMode:HAS_ENVMAP&&envMap.mapping,envMapCubeUVHeight:envMapCubeUVHeight,aoMap:HAS_AOMAP,lightMap:HAS_LIGHTMAP,bumpMap:HAS_BUMPMAP,normalMap:HAS_NORMALMAP,displacementMap:SUPPORTS_VERTEX_TEXTURES&&HAS_DISPLACEMENTMAP,emissiveMap:HAS_EMISSIVEMAP,normalMapObjectSpace:HAS_NORMALMAP&&material.normalMapType===ObjectSpaceNormalMap,normalMapTangentSpace:HAS_NORMALMAP&&material.normalMapType===TangentSpaceNormalMap,metalnessMap:HAS_METALNESSMAP,roughnessMap:HAS_ROUGHNESSMAP,anisotropy:HAS_ANISOTROPY,anisotropyMap:HAS_ANISOTROPYMAP,clearcoat:HAS_CLEARCOAT,clearcoatMap:HAS_CLEARCOATMAP,clearcoatNormalMap:HAS_CLEARCOAT_NORMALMAP,clearcoatRoughnessMap:HAS_CLEARCOAT_ROUGHNESSMAP,dispersion:HAS_DISPERSION,iridescence:HAS_IRIDESCENCE,iridescenceMap:HAS_IRIDESCENCEMAP,iridescenceThicknessMap:HAS_IRIDESCENCE_THICKNESSMAP,sheen:HAS_SHEEN,sheenColorMap:HAS_SHEEN_COLORMAP,sheenRoughnessMap:HAS_SHEEN_ROUGHNESSMAP,specularMap:HAS_SPECULARMAP,specularColorMap:HAS_SPECULAR_COLORMAP,specularIntensityMap:HAS_SPECULAR_INTENSITYMAP,transmission:HAS_TRANSMISSION,transmissionMap:HAS_TRANSMISSIONMAP,thicknessMap:HAS_THICKNESSMAP,gradientMap:HAS_GRADIENTMAP,opaque:material.transparent===false&&material.blending===NormalBlending&&material.alphaToCoverage===false,alphaMap:HAS_ALPHAMAP,alphaTest:HAS_ALPHATEST,alphaHash:HAS_ALPHAHASH,combine:material.combine,//
	mapUv:HAS_MAP&&getChannel(material.map.channel),aoMapUv:HAS_AOMAP&&getChannel(material.aoMap.channel),lightMapUv:HAS_LIGHTMAP&&getChannel(material.lightMap.channel),bumpMapUv:HAS_BUMPMAP&&getChannel(material.bumpMap.channel),normalMapUv:HAS_NORMALMAP&&getChannel(material.normalMap.channel),displacementMapUv:HAS_DISPLACEMENTMAP&&getChannel(material.displacementMap.channel),emissiveMapUv:HAS_EMISSIVEMAP&&getChannel(material.emissiveMap.channel),metalnessMapUv:HAS_METALNESSMAP&&getChannel(material.metalnessMap.channel),roughnessMapUv:HAS_ROUGHNESSMAP&&getChannel(material.roughnessMap.channel),anisotropyMapUv:HAS_ANISOTROPYMAP&&getChannel(material.anisotropyMap.channel),clearcoatMapUv:HAS_CLEARCOATMAP&&getChannel(material.clearcoatMap.channel),clearcoatNormalMapUv:HAS_CLEARCOAT_NORMALMAP&&getChannel(material.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:HAS_CLEARCOAT_ROUGHNESSMAP&&getChannel(material.clearcoatRoughnessMap.channel),iridescenceMapUv:HAS_IRIDESCENCEMAP&&getChannel(material.iridescenceMap.channel),iridescenceThicknessMapUv:HAS_IRIDESCENCE_THICKNESSMAP&&getChannel(material.iridescenceThicknessMap.channel),sheenColorMapUv:HAS_SHEEN_COLORMAP&&getChannel(material.sheenColorMap.channel),sheenRoughnessMapUv:HAS_SHEEN_ROUGHNESSMAP&&getChannel(material.sheenRoughnessMap.channel),specularMapUv:HAS_SPECULARMAP&&getChannel(material.specularMap.channel),specularColorMapUv:HAS_SPECULAR_COLORMAP&&getChannel(material.specularColorMap.channel),specularIntensityMapUv:HAS_SPECULAR_INTENSITYMAP&&getChannel(material.specularIntensityMap.channel),transmissionMapUv:HAS_TRANSMISSIONMAP&&getChannel(material.transmissionMap.channel),thicknessMapUv:HAS_THICKNESSMAP&&getChannel(material.thicknessMap.channel),alphaMapUv:HAS_ALPHAMAP&&getChannel(material.alphaMap.channel),//
	vertexTangents:!!geometry.attributes.tangent&&(HAS_NORMALMAP||HAS_ANISOTROPY),vertexColors:material.vertexColors,vertexAlphas:material.vertexColors===true&&!!geometry.attributes.color&&geometry.attributes.color.itemSize===4,pointsUvs:object.isPoints===true&&!!geometry.attributes.uv&&(HAS_MAP||HAS_ALPHAMAP),fog:!!fog,useFog:material.fog===true,fogExp2:!!fog&&fog.isFogExp2,flatShading:material.flatShading===true,sizeAttenuation:material.sizeAttenuation===true,logarithmicDepthBuffer:logarithmicDepthBuffer,reverseDepthBuffer:reverseDepthBuffer,skinning:object.isSkinnedMesh===true,morphTargets:geometry.morphAttributes.position!==undefined,morphNormals:geometry.morphAttributes.normal!==undefined,morphColors:geometry.morphAttributes.color!==undefined,morphTargetsCount:morphTargetsCount,morphTextureStride:morphTextureStride,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numSpotLightMaps:lights.spotLightMap.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numDirLightShadows:lights.directionalShadowMap.length,numPointLightShadows:lights.pointShadowMap.length,numSpotLightShadows:lights.spotShadowMap.length,numSpotLightShadowsWithMaps:lights.numSpotLightShadowsWithMaps,numLightProbes:lights.numLightProbes,numClippingPlanes:clipping.numPlanes,numClipIntersection:clipping.numIntersection,dithering:material.dithering,shadowMapEnabled:renderer.shadowMap.enabled&&shadows.length>0,shadowMapType:renderer.shadowMap.type,toneMapping:toneMapping,decodeVideoTexture:HAS_MAP&&material.map.isVideoTexture===true&&ColorManagement.getTransfer(material.map.colorSpace)===SRGBTransfer,decodeVideoTextureEmissive:HAS_EMISSIVEMAP&&material.emissiveMap.isVideoTexture===true&&ColorManagement.getTransfer(material.emissiveMap.colorSpace)===SRGBTransfer,premultipliedAlpha:material.premultipliedAlpha,doubleSided:material.side===DoubleSide,flipSided:material.side===BackSide,useDepthPacking:material.depthPacking>=0,depthPacking:material.depthPacking||0,index0AttributeName:material.index0AttributeName,extensionClipCullDistance:HAS_EXTENSIONS&&material.extensions.clipCullDistance===true&&extensions.has('WEBGL_clip_cull_distance'),extensionMultiDraw:(HAS_EXTENSIONS&&material.extensions.multiDraw===true||IS_BATCHEDMESH)&&extensions.has('WEBGL_multi_draw'),rendererExtensionParallelShaderCompile:extensions.has('KHR_parallel_shader_compile'),customProgramCacheKey:material.customProgramCacheKey()};// the usage of getChannel() determines the active texture channels for this shader
	parameters.vertexUv1s=_activeChannels.has(1);parameters.vertexUv2s=_activeChannels.has(2);parameters.vertexUv3s=_activeChannels.has(3);_activeChannels.clear();return parameters;}function getProgramCacheKey(parameters){const array=[];if(parameters.shaderID){array.push(parameters.shaderID);}else {array.push(parameters.customVertexShaderID);array.push(parameters.customFragmentShaderID);}if(parameters.defines!==undefined){for(const name in parameters.defines){array.push(name);array.push(parameters.defines[name]);}}if(parameters.isRawShaderMaterial===false){getProgramCacheKeyParameters(array,parameters);getProgramCacheKeyBooleans(array,parameters);array.push(renderer.outputColorSpace);}array.push(parameters.customProgramCacheKey);return array.join();}function getProgramCacheKeyParameters(array,parameters){array.push(parameters.precision);array.push(parameters.outputColorSpace);array.push(parameters.envMapMode);array.push(parameters.envMapCubeUVHeight);array.push(parameters.mapUv);array.push(parameters.alphaMapUv);array.push(parameters.lightMapUv);array.push(parameters.aoMapUv);array.push(parameters.bumpMapUv);array.push(parameters.normalMapUv);array.push(parameters.displacementMapUv);array.push(parameters.emissiveMapUv);array.push(parameters.metalnessMapUv);array.push(parameters.roughnessMapUv);array.push(parameters.anisotropyMapUv);array.push(parameters.clearcoatMapUv);array.push(parameters.clearcoatNormalMapUv);array.push(parameters.clearcoatRoughnessMapUv);array.push(parameters.iridescenceMapUv);array.push(parameters.iridescenceThicknessMapUv);array.push(parameters.sheenColorMapUv);array.push(parameters.sheenRoughnessMapUv);array.push(parameters.specularMapUv);array.push(parameters.specularColorMapUv);array.push(parameters.specularIntensityMapUv);array.push(parameters.transmissionMapUv);array.push(parameters.thicknessMapUv);array.push(parameters.combine);array.push(parameters.fogExp2);array.push(parameters.sizeAttenuation);array.push(parameters.morphTargetsCount);array.push(parameters.morphAttributeCount);array.push(parameters.numDirLights);array.push(parameters.numPointLights);array.push(parameters.numSpotLights);array.push(parameters.numSpotLightMaps);array.push(parameters.numHemiLights);array.push(parameters.numRectAreaLights);array.push(parameters.numDirLightShadows);array.push(parameters.numPointLightShadows);array.push(parameters.numSpotLightShadows);array.push(parameters.numSpotLightShadowsWithMaps);array.push(parameters.numLightProbes);array.push(parameters.shadowMapType);array.push(parameters.toneMapping);array.push(parameters.numClippingPlanes);array.push(parameters.numClipIntersection);array.push(parameters.depthPacking);}function getProgramCacheKeyBooleans(array,parameters){_programLayers.disableAll();if(parameters.supportsVertexTextures)_programLayers.enable(0);if(parameters.instancing)_programLayers.enable(1);if(parameters.instancingColor)_programLayers.enable(2);if(parameters.instancingMorph)_programLayers.enable(3);if(parameters.matcap)_programLayers.enable(4);if(parameters.envMap)_programLayers.enable(5);if(parameters.normalMapObjectSpace)_programLayers.enable(6);if(parameters.normalMapTangentSpace)_programLayers.enable(7);if(parameters.clearcoat)_programLayers.enable(8);if(parameters.iridescence)_programLayers.enable(9);if(parameters.alphaTest)_programLayers.enable(10);if(parameters.vertexColors)_programLayers.enable(11);if(parameters.vertexAlphas)_programLayers.enable(12);if(parameters.vertexUv1s)_programLayers.enable(13);if(parameters.vertexUv2s)_programLayers.enable(14);if(parameters.vertexUv3s)_programLayers.enable(15);if(parameters.vertexTangents)_programLayers.enable(16);if(parameters.anisotropy)_programLayers.enable(17);if(parameters.alphaHash)_programLayers.enable(18);if(parameters.batching)_programLayers.enable(19);if(parameters.dispersion)_programLayers.enable(20);if(parameters.batchingColor)_programLayers.enable(21);array.push(_programLayers.mask);_programLayers.disableAll();if(parameters.fog)_programLayers.enable(0);if(parameters.useFog)_programLayers.enable(1);if(parameters.flatShading)_programLayers.enable(2);if(parameters.logarithmicDepthBuffer)_programLayers.enable(3);if(parameters.reverseDepthBuffer)_programLayers.enable(4);if(parameters.skinning)_programLayers.enable(5);if(parameters.morphTargets)_programLayers.enable(6);if(parameters.morphNormals)_programLayers.enable(7);if(parameters.morphColors)_programLayers.enable(8);if(parameters.premultipliedAlpha)_programLayers.enable(9);if(parameters.shadowMapEnabled)_programLayers.enable(10);if(parameters.doubleSided)_programLayers.enable(11);if(parameters.flipSided)_programLayers.enable(12);if(parameters.useDepthPacking)_programLayers.enable(13);if(parameters.dithering)_programLayers.enable(14);if(parameters.transmission)_programLayers.enable(15);if(parameters.sheen)_programLayers.enable(16);if(parameters.opaque)_programLayers.enable(17);if(parameters.pointsUvs)_programLayers.enable(18);if(parameters.decodeVideoTexture)_programLayers.enable(19);if(parameters.decodeVideoTextureEmissive)_programLayers.enable(20);if(parameters.alphaToCoverage)_programLayers.enable(21);array.push(_programLayers.mask);}function getUniforms(material){const shaderID=shaderIDs[material.type];let uniforms;if(shaderID){const shader=ShaderLib[shaderID];uniforms=UniformsUtils.clone(shader.uniforms);}else {uniforms=material.uniforms;}return uniforms;}function acquireProgram(parameters,cacheKey){let program;// Check if code has been already compiled
	for(let p=0,pl=programs.length;p<pl;p++){const preexistingProgram=programs[p];if(preexistingProgram.cacheKey===cacheKey){program=preexistingProgram;++program.usedTimes;break;}}if(program===undefined){program=new WebGLProgram(renderer,cacheKey,parameters,bindingStates);programs.push(program);}return program;}function releaseProgram(program){if(--program.usedTimes===0){// Remove from unordered set
	const i=programs.indexOf(program);programs[i]=programs[programs.length-1];programs.pop();// Free WebGL resources
	program.destroy();}}function releaseShaderCache(material){_customShaders.remove(material);}function dispose(){_customShaders.dispose();}return {getParameters:getParameters,getProgramCacheKey:getProgramCacheKey,getUniforms:getUniforms,acquireProgram:acquireProgram,releaseProgram:releaseProgram,releaseShaderCache:releaseShaderCache,// Exposed for resource monitoring & error feedback via renderer.info:
	programs:programs,dispose:dispose};}function WebGLProperties(){let properties=new WeakMap();function has(object){return properties.has(object);}function get(object){let map=properties.get(object);if(map===undefined){map={};properties.set(object,map);}return map;}function remove(object){properties.delete(object);}function update(object,key,value){properties.get(object)[key]=value;}function dispose(){properties=new WeakMap();}return {has:has,get:get,remove:remove,update:update,dispose:dispose};}function painterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.material.id!==b.material.id){return a.material.id-b.material.id;}else if(a.z!==b.z){return a.z-b.z;}else {return a.id-b.id;}}function reversePainterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.z!==b.z){return b.z-a.z;}else {return a.id-b.id;}}function WebGLRenderList(){const renderItems=[];let renderItemsIndex=0;const opaque=[];const transmissive=[];const transparent=[];function init(){renderItemsIndex=0;opaque.length=0;transmissive.length=0;transparent.length=0;}function getNextRenderItem(object,geometry,material,groupOrder,z,group){let renderItem=renderItems[renderItemsIndex];if(renderItem===undefined){renderItem={id:object.id,object:object,geometry:geometry,material:material,groupOrder:groupOrder,renderOrder:object.renderOrder,z:z,group:group};renderItems[renderItemsIndex]=renderItem;}else {renderItem.id=object.id;renderItem.object=object;renderItem.geometry=geometry;renderItem.material=material;renderItem.groupOrder=groupOrder;renderItem.renderOrder=object.renderOrder;renderItem.z=z;renderItem.group=group;}renderItemsIndex++;return renderItem;}function push(object,geometry,material,groupOrder,z,group){const renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);if(material.transmission>0.0){transmissive.push(renderItem);}else if(material.transparent===true){transparent.push(renderItem);}else {opaque.push(renderItem);}}function unshift(object,geometry,material,groupOrder,z,group){const renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);if(material.transmission>0.0){transmissive.unshift(renderItem);}else if(material.transparent===true){transparent.unshift(renderItem);}else {opaque.unshift(renderItem);}}function sort(customOpaqueSort,customTransparentSort){if(opaque.length>1)opaque.sort(customOpaqueSort||painterSortStable);if(transmissive.length>1)transmissive.sort(customTransparentSort||reversePainterSortStable);if(transparent.length>1)transparent.sort(customTransparentSort||reversePainterSortStable);}function finish(){// Clear references from inactive renderItems in the list
	for(let i=renderItemsIndex,il=renderItems.length;i<il;i++){const renderItem=renderItems[i];if(renderItem.id===null)break;renderItem.id=null;renderItem.object=null;renderItem.geometry=null;renderItem.material=null;renderItem.group=null;}}return {opaque:opaque,transmissive:transmissive,transparent:transparent,init:init,push:push,unshift:unshift,finish:finish,sort:sort};}function WebGLRenderLists(){let lists=new WeakMap();function get(scene,renderCallDepth){const listArray=lists.get(scene);let list;if(listArray===undefined){list=new WebGLRenderList();lists.set(scene,[list]);}else {if(renderCallDepth>=listArray.length){list=new WebGLRenderList();listArray.push(list);}else {list=listArray[renderCallDepth];}}return list;}function dispose(){lists=new WeakMap();}return {get:get,dispose:dispose};}function UniformsCache(){const lights={};return {get:function(light){if(lights[light.id]!==undefined){return lights[light.id];}let uniforms;switch(light.type){case'DirectionalLight':uniforms={direction:new Vector3$1(),color:new Color()};break;case'SpotLight':uniforms={position:new Vector3$1(),direction:new Vector3$1(),color:new Color(),distance:0,coneCos:0,penumbraCos:0,decay:0};break;case'PointLight':uniforms={position:new Vector3$1(),color:new Color(),distance:0,decay:0};break;case'HemisphereLight':uniforms={direction:new Vector3$1(),skyColor:new Color(),groundColor:new Color()};break;case'RectAreaLight':uniforms={color:new Color(),position:new Vector3$1(),halfWidth:new Vector3$1(),halfHeight:new Vector3$1()};break;}lights[light.id]=uniforms;return uniforms;}};}function ShadowUniformsCache(){const lights={};return {get:function(light){if(lights[light.id]!==undefined){return lights[light.id];}let uniforms;switch(light.type){case'DirectionalLight':uniforms={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2$1()};break;case'SpotLight':uniforms={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2$1()};break;case'PointLight':uniforms={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2$1(),shadowCameraNear:1,shadowCameraFar:1000};break;// TODO (abelnation): set RectAreaLight shadow uniforms
	}lights[light.id]=uniforms;return uniforms;}};}let nextVersion=0;function shadowCastingAndTexturingLightsFirst(lightA,lightB){return (lightB.castShadow?2:0)-(lightA.castShadow?2:0)+(lightB.map?1:0)-(lightA.map?1:0);}function WebGLLights(extensions){const cache=new UniformsCache();const shadowCache=ShadowUniformsCache();const state={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let i=0;i<9;i++)state.probe.push(new Vector3$1());const vector3=new Vector3$1();const matrix4=new Matrix4$1();const matrix42=new Matrix4$1();function setup(lights){let r=0,g=0,b=0;for(let i=0;i<9;i++)state.probe[i].set(0,0,0);let directionalLength=0;let pointLength=0;let spotLength=0;let rectAreaLength=0;let hemiLength=0;let numDirectionalShadows=0;let numPointShadows=0;let numSpotShadows=0;let numSpotMaps=0;let numSpotShadowsWithMaps=0;let numLightProbes=0;// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
	lights.sort(shadowCastingAndTexturingLightsFirst);for(let i=0,l=lights.length;i<l;i++){const light=lights[i];const color=light.color;const intensity=light.intensity;const distance=light.distance;const shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight){r+=color.r*intensity;g+=color.g*intensity;b+=color.b*intensity;}else if(light.isLightProbe){for(let j=0;j<9;j++){state.probe[j].addScaledVector(light.sh.coefficients[j],intensity);}numLightProbes++;}else if(light.isDirectionalLight){const uniforms=cache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity);if(light.castShadow){const shadow=light.shadow;const shadowUniforms=shadowCache.get(light);shadowUniforms.shadowIntensity=shadow.intensity;shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowNormalBias=shadow.normalBias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;state.directionalShadow[directionalLength]=shadowUniforms;state.directionalShadowMap[directionalLength]=shadowMap;state.directionalShadowMatrix[directionalLength]=light.shadow.matrix;numDirectionalShadows++;}state.directional[directionalLength]=uniforms;directionalLength++;}else if(light.isSpotLight){const uniforms=cache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.color.copy(color).multiplyScalar(intensity);uniforms.distance=distance;uniforms.coneCos=Math.cos(light.angle);uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));uniforms.decay=light.decay;state.spot[spotLength]=uniforms;const shadow=light.shadow;if(light.map){state.spotLightMap[numSpotMaps]=light.map;numSpotMaps++;// make sure the lightMatrix is up to date
	// TODO : do it if required only
	shadow.updateMatrices(light);if(light.castShadow)numSpotShadowsWithMaps++;}state.spotLightMatrix[spotLength]=shadow.matrix;if(light.castShadow){const shadowUniforms=shadowCache.get(light);shadowUniforms.shadowIntensity=shadow.intensity;shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowNormalBias=shadow.normalBias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;state.spotShadow[spotLength]=shadowUniforms;state.spotShadowMap[spotLength]=shadowMap;numSpotShadows++;}spotLength++;}else if(light.isRectAreaLight){const uniforms=cache.get(light);uniforms.color.copy(color).multiplyScalar(intensity);uniforms.halfWidth.set(light.width*0.5,0.0,0.0);uniforms.halfHeight.set(0.0,light.height*0.5,0.0);state.rectArea[rectAreaLength]=uniforms;rectAreaLength++;}else if(light.isPointLight){const uniforms=cache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.distance=light.distance;uniforms.decay=light.decay;if(light.castShadow){const shadow=light.shadow;const shadowUniforms=shadowCache.get(light);shadowUniforms.shadowIntensity=shadow.intensity;shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowNormalBias=shadow.normalBias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;shadowUniforms.shadowCameraNear=shadow.camera.near;shadowUniforms.shadowCameraFar=shadow.camera.far;state.pointShadow[pointLength]=shadowUniforms;state.pointShadowMap[pointLength]=shadowMap;state.pointShadowMatrix[pointLength]=light.shadow.matrix;numPointShadows++;}state.point[pointLength]=uniforms;pointLength++;}else if(light.isHemisphereLight){const uniforms=cache.get(light);uniforms.skyColor.copy(light.color).multiplyScalar(intensity);uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);state.hemi[hemiLength]=uniforms;hemiLength++;}}if(rectAreaLength>0){if(extensions.has('OES_texture_float_linear')===true){state.rectAreaLTC1=UniformsLib.LTC_FLOAT_1;state.rectAreaLTC2=UniformsLib.LTC_FLOAT_2;}else {state.rectAreaLTC1=UniformsLib.LTC_HALF_1;state.rectAreaLTC2=UniformsLib.LTC_HALF_2;}}state.ambient[0]=r;state.ambient[1]=g;state.ambient[2]=b;const hash=state.hash;if(hash.directionalLength!==directionalLength||hash.pointLength!==pointLength||hash.spotLength!==spotLength||hash.rectAreaLength!==rectAreaLength||hash.hemiLength!==hemiLength||hash.numDirectionalShadows!==numDirectionalShadows||hash.numPointShadows!==numPointShadows||hash.numSpotShadows!==numSpotShadows||hash.numSpotMaps!==numSpotMaps||hash.numLightProbes!==numLightProbes){state.directional.length=directionalLength;state.spot.length=spotLength;state.rectArea.length=rectAreaLength;state.point.length=pointLength;state.hemi.length=hemiLength;state.directionalShadow.length=numDirectionalShadows;state.directionalShadowMap.length=numDirectionalShadows;state.pointShadow.length=numPointShadows;state.pointShadowMap.length=numPointShadows;state.spotShadow.length=numSpotShadows;state.spotShadowMap.length=numSpotShadows;state.directionalShadowMatrix.length=numDirectionalShadows;state.pointShadowMatrix.length=numPointShadows;state.spotLightMatrix.length=numSpotShadows+numSpotMaps-numSpotShadowsWithMaps;state.spotLightMap.length=numSpotMaps;state.numSpotLightShadowsWithMaps=numSpotShadowsWithMaps;state.numLightProbes=numLightProbes;hash.directionalLength=directionalLength;hash.pointLength=pointLength;hash.spotLength=spotLength;hash.rectAreaLength=rectAreaLength;hash.hemiLength=hemiLength;hash.numDirectionalShadows=numDirectionalShadows;hash.numPointShadows=numPointShadows;hash.numSpotShadows=numSpotShadows;hash.numSpotMaps=numSpotMaps;hash.numLightProbes=numLightProbes;state.version=nextVersion++;}}function setupView(lights,camera){let directionalLength=0;let pointLength=0;let spotLength=0;let rectAreaLength=0;let hemiLength=0;const viewMatrix=camera.matrixWorldInverse;for(let i=0,l=lights.length;i<l;i++){const light=lights[i];if(light.isDirectionalLight){const uniforms=state.directional[directionalLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);directionalLength++;}else if(light.isSpotLight){const uniforms=state.spot[spotLength];uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);spotLength++;}else if(light.isRectAreaLight){const uniforms=state.rectArea[rectAreaLength];uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);// extract local rotation of light to derive width/height half vectors
	matrix42.identity();matrix4.copy(light.matrixWorld);matrix4.premultiply(viewMatrix);matrix42.extractRotation(matrix4);uniforms.halfWidth.set(light.width*0.5,0.0,0.0);uniforms.halfHeight.set(0.0,light.height*0.5,0.0);uniforms.halfWidth.applyMatrix4(matrix42);uniforms.halfHeight.applyMatrix4(matrix42);rectAreaLength++;}else if(light.isPointLight){const uniforms=state.point[pointLength];uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);pointLength++;}else if(light.isHemisphereLight){const uniforms=state.hemi[hemiLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld);uniforms.direction.transformDirection(viewMatrix);hemiLength++;}}}return {setup:setup,setupView:setupView,state:state};}function WebGLRenderState(extensions){const lights=new WebGLLights(extensions);const lightsArray=[];const shadowsArray=[];function init(camera){state.camera=camera;lightsArray.length=0;shadowsArray.length=0;}function pushLight(light){lightsArray.push(light);}function pushShadow(shadowLight){shadowsArray.push(shadowLight);}function setupLights(){lights.setup(lightsArray);}function setupLightsView(camera){lights.setupView(lightsArray,camera);}const state={lightsArray:lightsArray,shadowsArray:shadowsArray,camera:null,lights:lights,transmissionRenderTarget:{}};return {init:init,state:state,setupLights:setupLights,setupLightsView:setupLightsView,pushLight:pushLight,pushShadow:pushShadow};}function WebGLRenderStates(extensions){let renderStates=new WeakMap();function get(scene,renderCallDepth=0){const renderStateArray=renderStates.get(scene);let renderState;if(renderStateArray===undefined){renderState=new WebGLRenderState(extensions);renderStates.set(scene,[renderState]);}else {if(renderCallDepth>=renderStateArray.length){renderState=new WebGLRenderState(extensions);renderStateArray.push(renderState);}else {renderState=renderStateArray[renderCallDepth];}}return renderState;}function dispose(){renderStates=new WeakMap();}return {get:get,dispose:dispose};}const vertex="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";const fragment="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";function WebGLShadowMap(renderer,objects,capabilities){let _frustum=new Frustum();const _shadowMapSize=new Vector2$1(),_viewportSize=new Vector2$1(),_viewport=new Vector4(),_depthMaterial=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),_distanceMaterial=new MeshDistanceMaterial(),_materialCache={},_maxTextureSize=capabilities.maxTextureSize;const shadowSide={[FrontSide]:BackSide,[BackSide]:FrontSide,[DoubleSide]:DoubleSide};const shadowMaterialVertical=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2$1()},radius:{value:4.0}},vertexShader:vertex,fragmentShader:fragment});const shadowMaterialHorizontal=shadowMaterialVertical.clone();shadowMaterialHorizontal.defines.HORIZONTAL_PASS=1;const fullScreenTri=new BufferGeometry$1();fullScreenTri.setAttribute('position',new BufferAttribute$1(new Float32Array([-1,-1,0.5,3,-1,0.5,-1,3,0.5]),3));const fullScreenMesh=new Mesh(fullScreenTri,shadowMaterialVertical);const scope=this;this.enabled=false;this.autoUpdate=true;this.needsUpdate=false;this.type=PCFShadowMap;let _previousType=this.type;this.render=function(lights,scene,camera){if(scope.enabled===false)return;if(scope.autoUpdate===false&&scope.needsUpdate===false)return;if(lights.length===0)return;const currentRenderTarget=renderer.getRenderTarget();const activeCubeFace=renderer.getActiveCubeFace();const activeMipmapLevel=renderer.getActiveMipmapLevel();const _state=renderer.state;// Set GL state for depth map.
	_state.setBlending(NoBlending);_state.buffers.color.setClear(1,1,1,1);_state.buffers.depth.setTest(true);_state.setScissorTest(false);// check for shadow map type changes
	const toVSM=_previousType!==VSMShadowMap&&this.type===VSMShadowMap;const fromVSM=_previousType===VSMShadowMap&&this.type!==VSMShadowMap;// render depth map
	for(let i=0,il=lights.length;i<il;i++){const light=lights[i];const shadow=light.shadow;if(shadow===undefined){console.warn('THREE.WebGLShadowMap:',light,'has no shadow.');continue;}if(shadow.autoUpdate===false&&shadow.needsUpdate===false)continue;_shadowMapSize.copy(shadow.mapSize);const shadowFrameExtents=shadow.getFrameExtents();_shadowMapSize.multiply(shadowFrameExtents);_viewportSize.copy(shadow.mapSize);if(_shadowMapSize.x>_maxTextureSize||_shadowMapSize.y>_maxTextureSize){if(_shadowMapSize.x>_maxTextureSize){_viewportSize.x=Math.floor(_maxTextureSize/shadowFrameExtents.x);_shadowMapSize.x=_viewportSize.x*shadowFrameExtents.x;shadow.mapSize.x=_viewportSize.x;}if(_shadowMapSize.y>_maxTextureSize){_viewportSize.y=Math.floor(_maxTextureSize/shadowFrameExtents.y);_shadowMapSize.y=_viewportSize.y*shadowFrameExtents.y;shadow.mapSize.y=_viewportSize.y;}}if(shadow.map===null||toVSM===true||fromVSM===true){const pars=this.type!==VSMShadowMap?{minFilter:NearestFilter,magFilter:NearestFilter}:{};if(shadow.map!==null){shadow.map.dispose();}shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.map.texture.name=light.name+'.shadowMap';shadow.camera.updateProjectionMatrix();}renderer.setRenderTarget(shadow.map);renderer.clear();const viewportCount=shadow.getViewportCount();for(let vp=0;vp<viewportCount;vp++){const viewport=shadow.getViewport(vp);_viewport.set(_viewportSize.x*viewport.x,_viewportSize.y*viewport.y,_viewportSize.x*viewport.z,_viewportSize.y*viewport.w);_state.viewport(_viewport);shadow.updateMatrices(light,vp);_frustum=shadow.getFrustum();renderObject(scene,camera,shadow.camera,light,this.type);}// do blur pass for VSM
	if(shadow.isPointLightShadow!==true&&this.type===VSMShadowMap){VSMPass(shadow,camera);}shadow.needsUpdate=false;}_previousType=this.type;scope.needsUpdate=false;renderer.setRenderTarget(currentRenderTarget,activeCubeFace,activeMipmapLevel);};function VSMPass(shadow,camera){const geometry=objects.update(fullScreenMesh);if(shadowMaterialVertical.defines.VSM_SAMPLES!==shadow.blurSamples){shadowMaterialVertical.defines.VSM_SAMPLES=shadow.blurSamples;shadowMaterialHorizontal.defines.VSM_SAMPLES=shadow.blurSamples;shadowMaterialVertical.needsUpdate=true;shadowMaterialHorizontal.needsUpdate=true;}if(shadow.mapPass===null){shadow.mapPass=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y);}// vertical pass
	shadowMaterialVertical.uniforms.shadow_pass.value=shadow.map.texture;shadowMaterialVertical.uniforms.resolution.value=shadow.mapSize;shadowMaterialVertical.uniforms.radius.value=shadow.radius;renderer.setRenderTarget(shadow.mapPass);renderer.clear();renderer.renderBufferDirect(camera,null,geometry,shadowMaterialVertical,fullScreenMesh,null);// horizontal pass
	shadowMaterialHorizontal.uniforms.shadow_pass.value=shadow.mapPass.texture;shadowMaterialHorizontal.uniforms.resolution.value=shadow.mapSize;shadowMaterialHorizontal.uniforms.radius.value=shadow.radius;renderer.setRenderTarget(shadow.map);renderer.clear();renderer.renderBufferDirect(camera,null,geometry,shadowMaterialHorizontal,fullScreenMesh,null);}function getDepthMaterial(object,material,light,type){let result=null;const customMaterial=light.isPointLight===true?object.customDistanceMaterial:object.customDepthMaterial;if(customMaterial!==undefined){result=customMaterial;}else {result=light.isPointLight===true?_distanceMaterial:_depthMaterial;if(renderer.localClippingEnabled&&material.clipShadows===true&&Array.isArray(material.clippingPlanes)&&material.clippingPlanes.length!==0||material.displacementMap&&material.displacementScale!==0||material.alphaMap&&material.alphaTest>0||material.map&&material.alphaTest>0){// in this case we need a unique material instance reflecting the
	// appropriate state
	const keyA=result.uuid,keyB=material.uuid;let materialsForVariant=_materialCache[keyA];if(materialsForVariant===undefined){materialsForVariant={};_materialCache[keyA]=materialsForVariant;}let cachedMaterial=materialsForVariant[keyB];if(cachedMaterial===undefined){cachedMaterial=result.clone();materialsForVariant[keyB]=cachedMaterial;material.addEventListener('dispose',onMaterialDispose);}result=cachedMaterial;}}result.visible=material.visible;result.wireframe=material.wireframe;if(type===VSMShadowMap){result.side=material.shadowSide!==null?material.shadowSide:material.side;}else {result.side=material.shadowSide!==null?material.shadowSide:shadowSide[material.side];}result.alphaMap=material.alphaMap;result.alphaTest=material.alphaTest;result.map=material.map;result.clipShadows=material.clipShadows;result.clippingPlanes=material.clippingPlanes;result.clipIntersection=material.clipIntersection;result.displacementMap=material.displacementMap;result.displacementScale=material.displacementScale;result.displacementBias=material.displacementBias;result.wireframeLinewidth=material.wireframeLinewidth;result.linewidth=material.linewidth;if(light.isPointLight===true&&result.isMeshDistanceMaterial===true){const materialProperties=renderer.properties.get(result);materialProperties.light=light;}return result;}function renderObject(object,camera,shadowCamera,light,type){if(object.visible===false)return;const visible=object.layers.test(camera.layers);if(visible&&(object.isMesh||object.isLine||object.isPoints)){if((object.castShadow||object.receiveShadow&&type===VSMShadowMap)&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);const geometry=objects.update(object);const material=object.material;if(Array.isArray(material)){const groups=geometry.groups;for(let k=0,kl=groups.length;k<kl;k++){const group=groups[k];const groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){const depthMaterial=getDepthMaterial(object,groupMaterial,light,type);object.onBeforeShadow(renderer,object,camera,shadowCamera,geometry,depthMaterial,group);renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);object.onAfterShadow(renderer,object,camera,shadowCamera,geometry,depthMaterial,group);}}}else if(material.visible){const depthMaterial=getDepthMaterial(object,material,light,type);object.onBeforeShadow(renderer,object,camera,shadowCamera,geometry,depthMaterial,null);renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,null);object.onAfterShadow(renderer,object,camera,shadowCamera,geometry,depthMaterial,null);}}}const children=object.children;for(let i=0,l=children.length;i<l;i++){renderObject(children[i],camera,shadowCamera,light,type);}}function onMaterialDispose(event){const material=event.target;material.removeEventListener('dispose',onMaterialDispose);// make sure to remove the unique distance/depth materials used for shadow map rendering
	for(const id in _materialCache){const cache=_materialCache[id];const uuid=event.target.uuid;if(uuid in cache){const shadowMaterial=cache[uuid];shadowMaterial.dispose();delete cache[uuid];}}}}const reversedFuncs={[NeverDepth]:AlwaysDepth,[LessDepth]:GreaterDepth,[EqualDepth]:NotEqualDepth,[LessEqualDepth]:GreaterEqualDepth,[AlwaysDepth]:NeverDepth,[GreaterDepth]:LessDepth,[NotEqualDepth]:EqualDepth,[GreaterEqualDepth]:LessEqualDepth};function WebGLState(gl,extensions){function ColorBuffer(){let locked=false;const color=new Vector4();let currentColorMask=null;const currentColorClear=new Vector4(0,0,0,0);return {setMask:function(colorMask){if(currentColorMask!==colorMask&&!locked){gl.colorMask(colorMask,colorMask,colorMask,colorMask);currentColorMask=colorMask;}},setLocked:function(lock){locked=lock;},setClear:function(r,g,b,a,premultipliedAlpha){if(premultipliedAlpha===true){r*=a;g*=a;b*=a;}color.set(r,g,b,a);if(currentColorClear.equals(color)===false){gl.clearColor(r,g,b,a);currentColorClear.copy(color);}},reset:function(){locked=false;currentColorMask=null;currentColorClear.set(-1,0,0,0);// set to invalid state
	}};}function DepthBuffer(){let locked=false;let reversed=false;let currentDepthMask=null;let currentDepthFunc=null;let currentDepthClear=null;return {setReversed:function(value){if(reversed!==value){const ext=extensions.get('EXT_clip_control');if(reversed){ext.clipControlEXT(ext.LOWER_LEFT_EXT,ext.ZERO_TO_ONE_EXT);}else {ext.clipControlEXT(ext.LOWER_LEFT_EXT,ext.NEGATIVE_ONE_TO_ONE_EXT);}const oldDepth=currentDepthClear;currentDepthClear=null;this.setClear(oldDepth);}reversed=value;},getReversed:function(){return reversed;},setTest:function(depthTest){if(depthTest){enable(gl.DEPTH_TEST);}else {disable(gl.DEPTH_TEST);}},setMask:function(depthMask){if(currentDepthMask!==depthMask&&!locked){gl.depthMask(depthMask);currentDepthMask=depthMask;}},setFunc:function(depthFunc){if(reversed)depthFunc=reversedFuncs[depthFunc];if(currentDepthFunc!==depthFunc){switch(depthFunc){case NeverDepth:gl.depthFunc(gl.NEVER);break;case AlwaysDepth:gl.depthFunc(gl.ALWAYS);break;case LessDepth:gl.depthFunc(gl.LESS);break;case LessEqualDepth:gl.depthFunc(gl.LEQUAL);break;case EqualDepth:gl.depthFunc(gl.EQUAL);break;case GreaterEqualDepth:gl.depthFunc(gl.GEQUAL);break;case GreaterDepth:gl.depthFunc(gl.GREATER);break;case NotEqualDepth:gl.depthFunc(gl.NOTEQUAL);break;default:gl.depthFunc(gl.LEQUAL);}currentDepthFunc=depthFunc;}},setLocked:function(lock){locked=lock;},setClear:function(depth){if(currentDepthClear!==depth){if(reversed){depth=1-depth;}gl.clearDepth(depth);currentDepthClear=depth;}},reset:function(){locked=false;currentDepthMask=null;currentDepthFunc=null;currentDepthClear=null;reversed=false;}};}function StencilBuffer(){let locked=false;let currentStencilMask=null;let currentStencilFunc=null;let currentStencilRef=null;let currentStencilFuncMask=null;let currentStencilFail=null;let currentStencilZFail=null;let currentStencilZPass=null;let currentStencilClear=null;return {setTest:function(stencilTest){if(!locked){if(stencilTest){enable(gl.STENCIL_TEST);}else {disable(gl.STENCIL_TEST);}}},setMask:function(stencilMask){if(currentStencilMask!==stencilMask&&!locked){gl.stencilMask(stencilMask);currentStencilMask=stencilMask;}},setFunc:function(stencilFunc,stencilRef,stencilMask){if(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask){gl.stencilFunc(stencilFunc,stencilRef,stencilMask);currentStencilFunc=stencilFunc;currentStencilRef=stencilRef;currentStencilFuncMask=stencilMask;}},setOp:function(stencilFail,stencilZFail,stencilZPass){if(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||currentStencilZPass!==stencilZPass){gl.stencilOp(stencilFail,stencilZFail,stencilZPass);currentStencilFail=stencilFail;currentStencilZFail=stencilZFail;currentStencilZPass=stencilZPass;}},setLocked:function(lock){locked=lock;},setClear:function(stencil){if(currentStencilClear!==stencil){gl.clearStencil(stencil);currentStencilClear=stencil;}},reset:function(){locked=false;currentStencilMask=null;currentStencilFunc=null;currentStencilRef=null;currentStencilFuncMask=null;currentStencilFail=null;currentStencilZFail=null;currentStencilZPass=null;currentStencilClear=null;}};}//
	const colorBuffer=new ColorBuffer();const depthBuffer=new DepthBuffer();const stencilBuffer=new StencilBuffer();const uboBindings=new WeakMap();const uboProgramMap=new WeakMap();let enabledCapabilities={};let currentBoundFramebuffers={};let currentDrawbuffers=new WeakMap();let defaultDrawbuffers=[];let currentProgram=null;let currentBlendingEnabled=false;let currentBlending=null;let currentBlendEquation=null;let currentBlendSrc=null;let currentBlendDst=null;let currentBlendEquationAlpha=null;let currentBlendSrcAlpha=null;let currentBlendDstAlpha=null;let currentBlendColor=new Color(0,0,0);let currentBlendAlpha=0;let currentPremultipledAlpha=false;let currentFlipSided=null;let currentCullFace=null;let currentLineWidth=null;let currentPolygonOffsetFactor=null;let currentPolygonOffsetUnits=null;const maxTextures=gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let lineWidthAvailable=false;let version=0;const glVersion=gl.getParameter(gl.VERSION);if(glVersion.indexOf('WebGL')!==-1){version=parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);lineWidthAvailable=version>=1.0;}else if(glVersion.indexOf('OpenGL ES')!==-1){version=parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);lineWidthAvailable=version>=2.0;}let currentTextureSlot=null;let currentBoundTextures={};const scissorParam=gl.getParameter(gl.SCISSOR_BOX);const viewportParam=gl.getParameter(gl.VIEWPORT);const currentScissor=new Vector4().fromArray(scissorParam);const currentViewport=new Vector4().fromArray(viewportParam);function createTexture(type,target,count,dimensions){const data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.
	const texture=gl.createTexture();gl.bindTexture(type,texture);gl.texParameteri(type,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(type,gl.TEXTURE_MAG_FILTER,gl.NEAREST);for(let i=0;i<count;i++){if(type===gl.TEXTURE_3D||type===gl.TEXTURE_2D_ARRAY){gl.texImage3D(target,0,gl.RGBA,1,1,dimensions,0,gl.RGBA,gl.UNSIGNED_BYTE,data);}else {gl.texImage2D(target+i,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,data);}}return texture;}const emptyTextures={};emptyTextures[gl.TEXTURE_2D]=createTexture(gl.TEXTURE_2D,gl.TEXTURE_2D,1);emptyTextures[gl.TEXTURE_CUBE_MAP]=createTexture(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_CUBE_MAP_POSITIVE_X,6);emptyTextures[gl.TEXTURE_2D_ARRAY]=createTexture(gl.TEXTURE_2D_ARRAY,gl.TEXTURE_2D_ARRAY,1,1);emptyTextures[gl.TEXTURE_3D]=createTexture(gl.TEXTURE_3D,gl.TEXTURE_3D,1,1);// init
	colorBuffer.setClear(0,0,0,1);depthBuffer.setClear(1);stencilBuffer.setClear(0);enable(gl.DEPTH_TEST);depthBuffer.setFunc(LessEqualDepth);setFlipSided(false);setCullFace(CullFaceBack);enable(gl.CULL_FACE);setBlending(NoBlending);//
	function enable(id){if(enabledCapabilities[id]!==true){gl.enable(id);enabledCapabilities[id]=true;}}function disable(id){if(enabledCapabilities[id]!==false){gl.disable(id);enabledCapabilities[id]=false;}}function bindFramebuffer(target,framebuffer){if(currentBoundFramebuffers[target]!==framebuffer){gl.bindFramebuffer(target,framebuffer);currentBoundFramebuffers[target]=framebuffer;// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER
	if(target===gl.DRAW_FRAMEBUFFER){currentBoundFramebuffers[gl.FRAMEBUFFER]=framebuffer;}if(target===gl.FRAMEBUFFER){currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER]=framebuffer;}return true;}return false;}function drawBuffers(renderTarget,framebuffer){let drawBuffers=defaultDrawbuffers;let needsUpdate=false;if(renderTarget){drawBuffers=currentDrawbuffers.get(framebuffer);if(drawBuffers===undefined){drawBuffers=[];currentDrawbuffers.set(framebuffer,drawBuffers);}const textures=renderTarget.textures;if(drawBuffers.length!==textures.length||drawBuffers[0]!==gl.COLOR_ATTACHMENT0){for(let i=0,il=textures.length;i<il;i++){drawBuffers[i]=gl.COLOR_ATTACHMENT0+i;}drawBuffers.length=textures.length;needsUpdate=true;}}else {if(drawBuffers[0]!==gl.BACK){drawBuffers[0]=gl.BACK;needsUpdate=true;}}if(needsUpdate){gl.drawBuffers(drawBuffers);}}function useProgram(program){if(currentProgram!==program){gl.useProgram(program);currentProgram=program;return true;}return false;}const equationToGL={[AddEquation]:gl.FUNC_ADD,[SubtractEquation]:gl.FUNC_SUBTRACT,[ReverseSubtractEquation]:gl.FUNC_REVERSE_SUBTRACT};equationToGL[MinEquation]=gl.MIN;equationToGL[MaxEquation]=gl.MAX;const factorToGL={[ZeroFactor]:gl.ZERO,[OneFactor]:gl.ONE,[SrcColorFactor]:gl.SRC_COLOR,[SrcAlphaFactor]:gl.SRC_ALPHA,[SrcAlphaSaturateFactor]:gl.SRC_ALPHA_SATURATE,[DstColorFactor]:gl.DST_COLOR,[DstAlphaFactor]:gl.DST_ALPHA,[OneMinusSrcColorFactor]:gl.ONE_MINUS_SRC_COLOR,[OneMinusSrcAlphaFactor]:gl.ONE_MINUS_SRC_ALPHA,[OneMinusDstColorFactor]:gl.ONE_MINUS_DST_COLOR,[OneMinusDstAlphaFactor]:gl.ONE_MINUS_DST_ALPHA,[ConstantColorFactor]:gl.CONSTANT_COLOR,[OneMinusConstantColorFactor]:gl.ONE_MINUS_CONSTANT_COLOR,[ConstantAlphaFactor]:gl.CONSTANT_ALPHA,[OneMinusConstantAlphaFactor]:gl.ONE_MINUS_CONSTANT_ALPHA};function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,blendColor,blendAlpha,premultipliedAlpha){if(blending===NoBlending){if(currentBlendingEnabled===true){disable(gl.BLEND);currentBlendingEnabled=false;}return;}if(currentBlendingEnabled===false){enable(gl.BLEND);currentBlendingEnabled=true;}if(blending!==CustomBlending){if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){if(currentBlendEquation!==AddEquation||currentBlendEquationAlpha!==AddEquation){gl.blendEquation(gl.FUNC_ADD);currentBlendEquation=AddEquation;currentBlendEquationAlpha=AddEquation;}if(premultipliedAlpha){switch(blending){case NormalBlending:gl.blendFuncSeparate(gl.ONE,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:gl.blendFunc(gl.ONE,gl.ONE);break;case SubtractiveBlending:gl.blendFuncSeparate(gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ZERO,gl.ONE);break;case MultiplyBlending:gl.blendFuncSeparate(gl.ZERO,gl.SRC_COLOR,gl.ZERO,gl.SRC_ALPHA);break;default:console.error('THREE.WebGLState: Invalid blending: ',blending);break;}}else {switch(blending){case NormalBlending:gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:gl.blendFunc(gl.SRC_ALPHA,gl.ONE);break;case SubtractiveBlending:gl.blendFuncSeparate(gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ZERO,gl.ONE);break;case MultiplyBlending:gl.blendFunc(gl.ZERO,gl.SRC_COLOR);break;default:console.error('THREE.WebGLState: Invalid blending: ',blending);break;}}currentBlendSrc=null;currentBlendDst=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;currentBlendColor.set(0,0,0);currentBlendAlpha=0;currentBlending=blending;currentPremultipledAlpha=premultipliedAlpha;}return;}// custom blending
	blendEquationAlpha=blendEquationAlpha||blendEquation;blendSrcAlpha=blendSrcAlpha||blendSrc;blendDstAlpha=blendDstAlpha||blendDst;if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){gl.blendEquationSeparate(equationToGL[blendEquation],equationToGL[blendEquationAlpha]);currentBlendEquation=blendEquation;currentBlendEquationAlpha=blendEquationAlpha;}if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){gl.blendFuncSeparate(factorToGL[blendSrc],factorToGL[blendDst],factorToGL[blendSrcAlpha],factorToGL[blendDstAlpha]);currentBlendSrc=blendSrc;currentBlendDst=blendDst;currentBlendSrcAlpha=blendSrcAlpha;currentBlendDstAlpha=blendDstAlpha;}if(blendColor.equals(currentBlendColor)===false||blendAlpha!==currentBlendAlpha){gl.blendColor(blendColor.r,blendColor.g,blendColor.b,blendAlpha);currentBlendColor.copy(blendColor);currentBlendAlpha=blendAlpha;}currentBlending=blending;currentPremultipledAlpha=false;}function setMaterial(material,frontFaceCW){material.side===DoubleSide?disable(gl.CULL_FACE):enable(gl.CULL_FACE);let flipSided=material.side===BackSide;if(frontFaceCW)flipSided=!flipSided;setFlipSided(flipSided);material.blending===NormalBlending&&material.transparent===false?setBlending(NoBlending):setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.blendColor,material.blendAlpha,material.premultipliedAlpha);depthBuffer.setFunc(material.depthFunc);depthBuffer.setTest(material.depthTest);depthBuffer.setMask(material.depthWrite);colorBuffer.setMask(material.colorWrite);const stencilWrite=material.stencilWrite;stencilBuffer.setTest(stencilWrite);if(stencilWrite){stencilBuffer.setMask(material.stencilWriteMask);stencilBuffer.setFunc(material.stencilFunc,material.stencilRef,material.stencilFuncMask);stencilBuffer.setOp(material.stencilFail,material.stencilZFail,material.stencilZPass);}setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);material.alphaToCoverage===true?enable(gl.SAMPLE_ALPHA_TO_COVERAGE):disable(gl.SAMPLE_ALPHA_TO_COVERAGE);}//
	function setFlipSided(flipSided){if(currentFlipSided!==flipSided){if(flipSided){gl.frontFace(gl.CW);}else {gl.frontFace(gl.CCW);}currentFlipSided=flipSided;}}function setCullFace(cullFace){if(cullFace!==CullFaceNone){enable(gl.CULL_FACE);if(cullFace!==currentCullFace){if(cullFace===CullFaceBack){gl.cullFace(gl.BACK);}else if(cullFace===CullFaceFront){gl.cullFace(gl.FRONT);}else {gl.cullFace(gl.FRONT_AND_BACK);}}}else {disable(gl.CULL_FACE);}currentCullFace=cullFace;}function setLineWidth(width){if(width!==currentLineWidth){if(lineWidthAvailable)gl.lineWidth(width);currentLineWidth=width;}}function setPolygonOffset(polygonOffset,factor,units){if(polygonOffset){enable(gl.POLYGON_OFFSET_FILL);if(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){gl.polygonOffset(factor,units);currentPolygonOffsetFactor=factor;currentPolygonOffsetUnits=units;}}else {disable(gl.POLYGON_OFFSET_FILL);}}function setScissorTest(scissorTest){if(scissorTest){enable(gl.SCISSOR_TEST);}else {disable(gl.SCISSOR_TEST);}}// texture
	function activeTexture(webglSlot){if(webglSlot===undefined)webglSlot=gl.TEXTURE0+maxTextures-1;if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}}function bindTexture(webglType,webglTexture,webglSlot){if(webglSlot===undefined){if(currentTextureSlot===null){webglSlot=gl.TEXTURE0+maxTextures-1;}else {webglSlot=currentTextureSlot;}}let boundTexture=currentBoundTextures[webglSlot];if(boundTexture===undefined){boundTexture={type:undefined,texture:undefined};currentBoundTextures[webglSlot]=boundTexture;}if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);boundTexture.type=webglType;boundTexture.texture=webglTexture;}}function unbindTexture(){const boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture!==undefined&&boundTexture.type!==undefined){gl.bindTexture(boundTexture.type,null);boundTexture.type=undefined;boundTexture.texture=undefined;}}function compressedTexImage2D(){try{gl.compressedTexImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function compressedTexImage3D(){try{gl.compressedTexImage3D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texSubImage2D(){try{gl.texSubImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texSubImage3D(){try{gl.texSubImage3D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function compressedTexSubImage2D(){try{gl.compressedTexSubImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function compressedTexSubImage3D(){try{gl.compressedTexSubImage3D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texStorage2D(){try{gl.texStorage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texStorage3D(){try{gl.texStorage3D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage2D(){try{gl.texImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage3D(){try{gl.texImage3D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}//
	function scissor(scissor){if(currentScissor.equals(scissor)===false){gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);currentScissor.copy(scissor);}}function viewport(viewport){if(currentViewport.equals(viewport)===false){gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);currentViewport.copy(viewport);}}function updateUBOMapping(uniformsGroup,program){let mapping=uboProgramMap.get(program);if(mapping===undefined){mapping=new WeakMap();uboProgramMap.set(program,mapping);}let blockIndex=mapping.get(uniformsGroup);if(blockIndex===undefined){blockIndex=gl.getUniformBlockIndex(program,uniformsGroup.name);mapping.set(uniformsGroup,blockIndex);}}function uniformBlockBinding(uniformsGroup,program){const mapping=uboProgramMap.get(program);const blockIndex=mapping.get(uniformsGroup);if(uboBindings.get(program)!==blockIndex){// bind shader specific block index to global block point
	gl.uniformBlockBinding(program,blockIndex,uniformsGroup.__bindingPointIndex);uboBindings.set(program,blockIndex);}}//
	function reset(){// reset state
	gl.disable(gl.BLEND);gl.disable(gl.CULL_FACE);gl.disable(gl.DEPTH_TEST);gl.disable(gl.POLYGON_OFFSET_FILL);gl.disable(gl.SCISSOR_TEST);gl.disable(gl.STENCIL_TEST);gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ONE,gl.ZERO);gl.blendFuncSeparate(gl.ONE,gl.ZERO,gl.ONE,gl.ZERO);gl.blendColor(0,0,0,0);gl.colorMask(true,true,true,true);gl.clearColor(0,0,0,0);gl.depthMask(true);gl.depthFunc(gl.LESS);depthBuffer.setReversed(false);gl.clearDepth(1);gl.stencilMask(0xffffffff);gl.stencilFunc(gl.ALWAYS,0,0xffffffff);gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);gl.clearStencil(0);gl.cullFace(gl.BACK);gl.frontFace(gl.CCW);gl.polygonOffset(0,0);gl.activeTexture(gl.TEXTURE0);gl.bindFramebuffer(gl.FRAMEBUFFER,null);gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER,null);gl.bindFramebuffer(gl.READ_FRAMEBUFFER,null);gl.useProgram(null);gl.lineWidth(1);gl.scissor(0,0,gl.canvas.width,gl.canvas.height);gl.viewport(0,0,gl.canvas.width,gl.canvas.height);// reset internals
	enabledCapabilities={};currentTextureSlot=null;currentBoundTextures={};currentBoundFramebuffers={};currentDrawbuffers=new WeakMap();defaultDrawbuffers=[];currentProgram=null;currentBlendingEnabled=false;currentBlending=null;currentBlendEquation=null;currentBlendSrc=null;currentBlendDst=null;currentBlendEquationAlpha=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;currentBlendColor=new Color(0,0,0);currentBlendAlpha=0;currentPremultipledAlpha=false;currentFlipSided=null;currentCullFace=null;currentLineWidth=null;currentPolygonOffsetFactor=null;currentPolygonOffsetUnits=null;currentScissor.set(0,0,gl.canvas.width,gl.canvas.height);currentViewport.set(0,0,gl.canvas.width,gl.canvas.height);colorBuffer.reset();depthBuffer.reset();stencilBuffer.reset();}return {buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},enable:enable,disable:disable,bindFramebuffer:bindFramebuffer,drawBuffers:drawBuffers,useProgram:useProgram,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,unbindTexture:unbindTexture,compressedTexImage2D:compressedTexImage2D,compressedTexImage3D:compressedTexImage3D,texImage2D:texImage2D,texImage3D:texImage3D,updateUBOMapping:updateUBOMapping,uniformBlockBinding:uniformBlockBinding,texStorage2D:texStorage2D,texStorage3D:texStorage3D,texSubImage2D:texSubImage2D,texSubImage3D:texSubImage3D,compressedTexSubImage2D:compressedTexSubImage2D,compressedTexSubImage3D:compressedTexSubImage3D,scissor:scissor,viewport:viewport,reset:reset};}function WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info){const multisampledRTTExt=extensions.has('WEBGL_multisampled_render_to_texture')?extensions.get('WEBGL_multisampled_render_to_texture'):null;const supportsInvalidateFramebuffer=typeof navigator==='undefined'?false:/OculusBrowser/g.test(navigator.userAgent);const _imageDimensions=new Vector2$1();const _videoTextures=new WeakMap();let _canvas;const _sources=new WeakMap();// maps WebglTexture objects to instances of Source
	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
	let useOffscreenCanvas=false;try{useOffscreenCanvas=typeof OffscreenCanvas!=='undefined'// eslint-disable-next-line compat/compat
	&&new OffscreenCanvas(1,1).getContext('2d')!==null;}catch(err){// Ignore any errors
	}function createCanvas(width,height){// Use OffscreenCanvas when available. Specially needed in web workers
	return useOffscreenCanvas?// eslint-disable-next-line compat/compat
	new OffscreenCanvas(width,height):createElementNS('canvas');}function resizeImage(image,needsNewCanvas,maxSize){let scale=1;const dimensions=getDimensions(image);// handle case if texture exceeds max size
	if(dimensions.width>maxSize||dimensions.height>maxSize){scale=maxSize/Math.max(dimensions.width,dimensions.height);}// only perform resize if necessary
	if(scale<1){// only perform resize for certain image types
	if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap||typeof VideoFrame!=='undefined'&&image instanceof VideoFrame){const width=Math.floor(scale*dimensions.width);const height=Math.floor(scale*dimensions.height);if(_canvas===undefined)_canvas=createCanvas(width,height);// cube textures can't reuse the same canvas
	const canvas=needsNewCanvas?createCanvas(width,height):_canvas;canvas.width=width;canvas.height=height;const context=canvas.getContext('2d');context.drawImage(image,0,0,width,height);console.warn('THREE.WebGLRenderer: Texture has been resized from ('+dimensions.width+'x'+dimensions.height+') to ('+width+'x'+height+').');return canvas;}else {if('data'in image){console.warn('THREE.WebGLRenderer: Image in DataTexture is too big ('+dimensions.width+'x'+dimensions.height+').');}return image;}}return image;}function textureNeedsGenerateMipmaps(texture){return texture.generateMipmaps;}function generateMipmap(target){_gl.generateMipmap(target);}function getTargetType(texture){if(texture.isWebGLCubeRenderTarget)return _gl.TEXTURE_CUBE_MAP;if(texture.isWebGL3DRenderTarget)return _gl.TEXTURE_3D;if(texture.isWebGLArrayRenderTarget||texture.isCompressedArrayTexture)return _gl.TEXTURE_2D_ARRAY;return _gl.TEXTURE_2D;}function getInternalFormat(internalFormatName,glFormat,glType,colorSpace,forceLinearTransfer=false){if(internalFormatName!==null){if(_gl[internalFormatName]!==undefined)return _gl[internalFormatName];console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \''+internalFormatName+'\'');}let internalFormat=glFormat;if(glFormat===_gl.RED){if(glType===_gl.FLOAT)internalFormat=_gl.R32F;if(glType===_gl.HALF_FLOAT)internalFormat=_gl.R16F;if(glType===_gl.UNSIGNED_BYTE)internalFormat=_gl.R8;}if(glFormat===_gl.RED_INTEGER){if(glType===_gl.UNSIGNED_BYTE)internalFormat=_gl.R8UI;if(glType===_gl.UNSIGNED_SHORT)internalFormat=_gl.R16UI;if(glType===_gl.UNSIGNED_INT)internalFormat=_gl.R32UI;if(glType===_gl.BYTE)internalFormat=_gl.R8I;if(glType===_gl.SHORT)internalFormat=_gl.R16I;if(glType===_gl.INT)internalFormat=_gl.R32I;}if(glFormat===_gl.RG){if(glType===_gl.FLOAT)internalFormat=_gl.RG32F;if(glType===_gl.HALF_FLOAT)internalFormat=_gl.RG16F;if(glType===_gl.UNSIGNED_BYTE)internalFormat=_gl.RG8;}if(glFormat===_gl.RG_INTEGER){if(glType===_gl.UNSIGNED_BYTE)internalFormat=_gl.RG8UI;if(glType===_gl.UNSIGNED_SHORT)internalFormat=_gl.RG16UI;if(glType===_gl.UNSIGNED_INT)internalFormat=_gl.RG32UI;if(glType===_gl.BYTE)internalFormat=_gl.RG8I;if(glType===_gl.SHORT)internalFormat=_gl.RG16I;if(glType===_gl.INT)internalFormat=_gl.RG32I;}if(glFormat===_gl.RGB_INTEGER){if(glType===_gl.UNSIGNED_BYTE)internalFormat=_gl.RGB8UI;if(glType===_gl.UNSIGNED_SHORT)internalFormat=_gl.RGB16UI;if(glType===_gl.UNSIGNED_INT)internalFormat=_gl.RGB32UI;if(glType===_gl.BYTE)internalFormat=_gl.RGB8I;if(glType===_gl.SHORT)internalFormat=_gl.RGB16I;if(glType===_gl.INT)internalFormat=_gl.RGB32I;}if(glFormat===_gl.RGBA_INTEGER){if(glType===_gl.UNSIGNED_BYTE)internalFormat=_gl.RGBA8UI;if(glType===_gl.UNSIGNED_SHORT)internalFormat=_gl.RGBA16UI;if(glType===_gl.UNSIGNED_INT)internalFormat=_gl.RGBA32UI;if(glType===_gl.BYTE)internalFormat=_gl.RGBA8I;if(glType===_gl.SHORT)internalFormat=_gl.RGBA16I;if(glType===_gl.INT)internalFormat=_gl.RGBA32I;}if(glFormat===_gl.RGB){if(glType===_gl.UNSIGNED_INT_5_9_9_9_REV)internalFormat=_gl.RGB9_E5;}if(glFormat===_gl.RGBA){const transfer=forceLinearTransfer?LinearTransfer:ColorManagement.getTransfer(colorSpace);if(glType===_gl.FLOAT)internalFormat=_gl.RGBA32F;if(glType===_gl.HALF_FLOAT)internalFormat=_gl.RGBA16F;if(glType===_gl.UNSIGNED_BYTE)internalFormat=transfer===SRGBTransfer?_gl.SRGB8_ALPHA8:_gl.RGBA8;if(glType===_gl.UNSIGNED_SHORT_4_4_4_4)internalFormat=_gl.RGBA4;if(glType===_gl.UNSIGNED_SHORT_5_5_5_1)internalFormat=_gl.RGB5_A1;}if(internalFormat===_gl.R16F||internalFormat===_gl.R32F||internalFormat===_gl.RG16F||internalFormat===_gl.RG32F||internalFormat===_gl.RGBA16F||internalFormat===_gl.RGBA32F){extensions.get('EXT_color_buffer_float');}return internalFormat;}function getInternalDepthFormat(useStencil,depthType){let glInternalFormat;if(useStencil){if(depthType===null||depthType===UnsignedIntType||depthType===UnsignedInt248Type){glInternalFormat=_gl.DEPTH24_STENCIL8;}else if(depthType===FloatType$1){glInternalFormat=_gl.DEPTH32F_STENCIL8;}else if(depthType===UnsignedShortType){glInternalFormat=_gl.DEPTH24_STENCIL8;console.warn('DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.');}}else {if(depthType===null||depthType===UnsignedIntType||depthType===UnsignedInt248Type){glInternalFormat=_gl.DEPTH_COMPONENT24;}else if(depthType===FloatType$1){glInternalFormat=_gl.DEPTH_COMPONENT32F;}else if(depthType===UnsignedShortType){glInternalFormat=_gl.DEPTH_COMPONENT16;}}return glInternalFormat;}function getMipLevels(texture,image){if(textureNeedsGenerateMipmaps(texture)===true||texture.isFramebufferTexture&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){return Math.log2(Math.max(image.width,image.height))+1;}else if(texture.mipmaps!==undefined&&texture.mipmaps.length>0){// user-defined mipmaps
	return texture.mipmaps.length;}else if(texture.isCompressedTexture&&Array.isArray(texture.image)){return image.mipmaps.length;}else {// texture without mipmaps (only base level)
	return 1;}}//
	function onTextureDispose(event){const texture=event.target;texture.removeEventListener('dispose',onTextureDispose);deallocateTexture(texture);if(texture.isVideoTexture){_videoTextures.delete(texture);}}function onRenderTargetDispose(event){const renderTarget=event.target;renderTarget.removeEventListener('dispose',onRenderTargetDispose);deallocateRenderTarget(renderTarget);}//
	function deallocateTexture(texture){const textureProperties=properties.get(texture);if(textureProperties.__webglInit===undefined)return;// check if it's necessary to remove the WebGLTexture object
	const source=texture.source;const webglTextures=_sources.get(source);if(webglTextures){const webglTexture=webglTextures[textureProperties.__cacheKey];webglTexture.usedTimes--;// the WebGLTexture object is not used anymore, remove it
	if(webglTexture.usedTimes===0){deleteTexture(texture);}// remove the weak map entry if no WebGLTexture uses the source anymore
	if(Object.keys(webglTextures).length===0){_sources.delete(source);}}properties.remove(texture);}function deleteTexture(texture){const textureProperties=properties.get(texture);_gl.deleteTexture(textureProperties.__webglTexture);const source=texture.source;const webglTextures=_sources.get(source);delete webglTextures[textureProperties.__cacheKey];info.memory.textures--;}function deallocateRenderTarget(renderTarget){const renderTargetProperties=properties.get(renderTarget);if(renderTarget.depthTexture){renderTarget.depthTexture.dispose();properties.remove(renderTarget.depthTexture);}if(renderTarget.isWebGLCubeRenderTarget){for(let i=0;i<6;i++){if(Array.isArray(renderTargetProperties.__webglFramebuffer[i])){for(let level=0;level<renderTargetProperties.__webglFramebuffer[i].length;level++)_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);}else {_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);}if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);}}else {if(Array.isArray(renderTargetProperties.__webglFramebuffer)){for(let level=0;level<renderTargetProperties.__webglFramebuffer.length;level++)_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);}else {_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);}if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);if(renderTargetProperties.__webglMultisampledFramebuffer)_gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);if(renderTargetProperties.__webglColorRenderbuffer){for(let i=0;i<renderTargetProperties.__webglColorRenderbuffer.length;i++){if(renderTargetProperties.__webglColorRenderbuffer[i])_gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);}}if(renderTargetProperties.__webglDepthRenderbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);}const textures=renderTarget.textures;for(let i=0,il=textures.length;i<il;i++){const attachmentProperties=properties.get(textures[i]);if(attachmentProperties.__webglTexture){_gl.deleteTexture(attachmentProperties.__webglTexture);info.memory.textures--;}properties.remove(textures[i]);}properties.remove(renderTarget);}//
	let textureUnits=0;function resetTextureUnits(){textureUnits=0;}function allocateTextureUnit(){const textureUnit=textureUnits;if(textureUnit>=capabilities.maxTextures){console.warn('THREE.WebGLTextures: Trying to use '+textureUnit+' texture units while this GPU supports only '+capabilities.maxTextures);}textureUnits+=1;return textureUnit;}function getTextureCacheKey(texture){const array=[];array.push(texture.wrapS);array.push(texture.wrapT);array.push(texture.wrapR||0);array.push(texture.magFilter);array.push(texture.minFilter);array.push(texture.anisotropy);array.push(texture.internalFormat);array.push(texture.format);array.push(texture.type);array.push(texture.generateMipmaps);array.push(texture.premultiplyAlpha);array.push(texture.flipY);array.push(texture.unpackAlignment);array.push(texture.colorSpace);return array.join();}//
	function setTexture2D(texture,slot){const textureProperties=properties.get(texture);if(texture.isVideoTexture)updateVideoTexture(texture);if(texture.isRenderTargetTexture===false&&texture.version>0&&textureProperties.__version!==texture.version){const image=texture.image;if(image===null){console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.');}else if(image.complete===false){console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');}else {uploadTexture(textureProperties,texture,slot);return;}}state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture,_gl.TEXTURE0+slot);}function setTexture2DArray(texture,slot){const textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}state.bindTexture(_gl.TEXTURE_2D_ARRAY,textureProperties.__webglTexture,_gl.TEXTURE0+slot);}function setTexture3D(texture,slot){const textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}state.bindTexture(_gl.TEXTURE_3D,textureProperties.__webglTexture,_gl.TEXTURE0+slot);}function setTextureCube(texture,slot){const textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadCubeTexture(textureProperties,texture,slot);return;}state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture,_gl.TEXTURE0+slot);}const wrappingToGL={[RepeatWrapping]:_gl.REPEAT,[ClampToEdgeWrapping]:_gl.CLAMP_TO_EDGE,[MirroredRepeatWrapping]:_gl.MIRRORED_REPEAT};const filterToGL={[NearestFilter]:_gl.NEAREST,[NearestMipmapNearestFilter]:_gl.NEAREST_MIPMAP_NEAREST,[NearestMipmapLinearFilter]:_gl.NEAREST_MIPMAP_LINEAR,[LinearFilter]:_gl.LINEAR,[LinearMipmapNearestFilter]:_gl.LINEAR_MIPMAP_NEAREST,[LinearMipmapLinearFilter]:_gl.LINEAR_MIPMAP_LINEAR};const compareToGL={[NeverCompare]:_gl.NEVER,[AlwaysCompare]:_gl.ALWAYS,[LessCompare]:_gl.LESS,[LessEqualCompare]:_gl.LEQUAL,[EqualCompare]:_gl.EQUAL,[GreaterEqualCompare]:_gl.GEQUAL,[GreaterCompare]:_gl.GREATER,[NotEqualCompare]:_gl.NOTEQUAL};function setTextureParameters(textureType,texture){if(texture.type===FloatType$1&&extensions.has('OES_texture_float_linear')===false&&(texture.magFilter===LinearFilter||texture.magFilter===LinearMipmapNearestFilter||texture.magFilter===NearestMipmapLinearFilter||texture.magFilter===LinearMipmapLinearFilter||texture.minFilter===LinearFilter||texture.minFilter===LinearMipmapNearestFilter||texture.minFilter===NearestMipmapLinearFilter||texture.minFilter===LinearMipmapLinearFilter)){console.warn('THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.');}_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,wrappingToGL[texture.wrapS]);_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,wrappingToGL[texture.wrapT]);if(textureType===_gl.TEXTURE_3D||textureType===_gl.TEXTURE_2D_ARRAY){_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_R,wrappingToGL[texture.wrapR]);}_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,filterToGL[texture.magFilter]);_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,filterToGL[texture.minFilter]);if(texture.compareFunction){_gl.texParameteri(textureType,_gl.TEXTURE_COMPARE_MODE,_gl.COMPARE_REF_TO_TEXTURE);_gl.texParameteri(textureType,_gl.TEXTURE_COMPARE_FUNC,compareToGL[texture.compareFunction]);}if(extensions.has('EXT_texture_filter_anisotropic')===true){if(texture.magFilter===NearestFilter)return;if(texture.minFilter!==NearestMipmapLinearFilter&&texture.minFilter!==LinearMipmapLinearFilter)return;if(texture.type===FloatType$1&&extensions.has('OES_texture_float_linear')===false)return;// verify extension
	if(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){const extension=extensions.get('EXT_texture_filter_anisotropic');_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));properties.get(texture).__currentAnisotropy=texture.anisotropy;}}}function initTexture(textureProperties,texture){let forceUpload=false;if(textureProperties.__webglInit===undefined){textureProperties.__webglInit=true;texture.addEventListener('dispose',onTextureDispose);}// create Source <-> WebGLTextures mapping if necessary
	const source=texture.source;let webglTextures=_sources.get(source);if(webglTextures===undefined){webglTextures={};_sources.set(source,webglTextures);}// check if there is already a WebGLTexture object for the given texture parameters
	const textureCacheKey=getTextureCacheKey(texture);if(textureCacheKey!==textureProperties.__cacheKey){// if not, create a new instance of WebGLTexture
	if(webglTextures[textureCacheKey]===undefined){// create new entry
	webglTextures[textureCacheKey]={texture:_gl.createTexture(),usedTimes:0};info.memory.textures++;// when a new instance of WebGLTexture was created, a texture upload is required
	// even if the image contents are identical
	forceUpload=true;}webglTextures[textureCacheKey].usedTimes++;// every time the texture cache key changes, it's necessary to check if an instance of
	// WebGLTexture can be deleted in order to avoid a memory leak.
	const webglTexture=webglTextures[textureProperties.__cacheKey];if(webglTexture!==undefined){webglTextures[textureProperties.__cacheKey].usedTimes--;if(webglTexture.usedTimes===0){deleteTexture(texture);}}// store references to cache key and WebGLTexture object
	textureProperties.__cacheKey=textureCacheKey;textureProperties.__webglTexture=webglTextures[textureCacheKey].texture;}return forceUpload;}function uploadTexture(textureProperties,texture,slot){let textureType=_gl.TEXTURE_2D;if(texture.isDataArrayTexture||texture.isCompressedArrayTexture)textureType=_gl.TEXTURE_2D_ARRAY;if(texture.isData3DTexture)textureType=_gl.TEXTURE_3D;const forceUpload=initTexture(textureProperties,texture);const source=texture.source;state.bindTexture(textureType,textureProperties.__webglTexture,_gl.TEXTURE0+slot);const sourceProperties=properties.get(source);if(source.version!==sourceProperties.__version||forceUpload===true){state.activeTexture(_gl.TEXTURE0+slot);const workingPrimaries=ColorManagement.getPrimaries(ColorManagement.workingColorSpace);const texturePrimaries=texture.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(texture.colorSpace);const unpackConversion=texture.colorSpace===NoColorSpace||workingPrimaries===texturePrimaries?_gl.NONE:_gl.BROWSER_DEFAULT_WEBGL;_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,texture.unpackAlignment);_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,unpackConversion);let image=resizeImage(texture.image,false,capabilities.maxTextureSize);image=verifyColorSpace(texture,image);const glFormat=utils.convert(texture.format,texture.colorSpace);const glType=utils.convert(texture.type);let glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace,texture.isVideoTexture);setTextureParameters(textureType,texture);let mipmap;const mipmaps=texture.mipmaps;const useTexStorage=texture.isVideoTexture!==true;const allocateMemory=sourceProperties.__version===undefined||forceUpload===true;const dataReady=source.dataReady;const levels=getMipLevels(texture,image);if(texture.isDepthTexture){glInternalFormat=getInternalDepthFormat(texture.format===DepthStencilFormat,texture.type);//
	if(allocateMemory){if(useTexStorage){state.texStorage2D(_gl.TEXTURE_2D,1,glInternalFormat,image.width,image.height);}else {state.texImage2D(_gl.TEXTURE_2D,0,glInternalFormat,image.width,image.height,0,glFormat,glType,null);}}}else if(texture.isDataTexture){// use manually created mipmaps if available
	// if there are no manual mipmaps
	// set 0 level mipmap and then use GL to generate other mipmap levels
	if(mipmaps.length>0){if(useTexStorage&&allocateMemory){state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height);}for(let i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_2D,i,0,0,mipmap.width,mipmap.height,glFormat,glType,mipmap.data);}}else {state.texImage2D(_gl.TEXTURE_2D,i,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}texture.generateMipmaps=false;}else {if(useTexStorage){if(allocateMemory){state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,image.width,image.height);}if(dataReady){state.texSubImage2D(_gl.TEXTURE_2D,0,0,0,image.width,image.height,glFormat,glType,image.data);}}else {state.texImage2D(_gl.TEXTURE_2D,0,glInternalFormat,image.width,image.height,0,glFormat,glType,image.data);}}}else if(texture.isCompressedTexture){if(texture.isCompressedArrayTexture){if(useTexStorage&&allocateMemory){state.texStorage3D(_gl.TEXTURE_2D_ARRAY,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height,image.depth);}for(let i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(texture.format!==RGBAFormat){if(glFormat!==null){if(useTexStorage){if(dataReady){if(texture.layerUpdates.size>0){const layerByteLength=getByteLength(mipmap.width,mipmap.height,texture.format,texture.type);for(const layerIndex of texture.layerUpdates){const layerData=mipmap.data.subarray(layerIndex*layerByteLength/mipmap.data.BYTES_PER_ELEMENT,(layerIndex+1)*layerByteLength/mipmap.data.BYTES_PER_ELEMENT);state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY,i,0,0,layerIndex,mipmap.width,mipmap.height,1,glFormat,layerData);}texture.clearLayerUpdates();}else {state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY,i,0,0,0,mipmap.width,mipmap.height,image.depth,glFormat,mipmap.data);}}}else {state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY,i,glInternalFormat,mipmap.width,mipmap.height,image.depth,0,mipmap.data,0,0);}}else {console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');}}else {if(useTexStorage){if(dataReady){state.texSubImage3D(_gl.TEXTURE_2D_ARRAY,i,0,0,0,mipmap.width,mipmap.height,image.depth,glFormat,glType,mipmap.data);}}else {state.texImage3D(_gl.TEXTURE_2D_ARRAY,i,glInternalFormat,mipmap.width,mipmap.height,image.depth,0,glFormat,glType,mipmap.data);}}}}else {if(useTexStorage&&allocateMemory){state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height);}for(let i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(texture.format!==RGBAFormat){if(glFormat!==null){if(useTexStorage){if(dataReady){state.compressedTexSubImage2D(_gl.TEXTURE_2D,i,0,0,mipmap.width,mipmap.height,glFormat,mipmap.data);}}else {state.compressedTexImage2D(_gl.TEXTURE_2D,i,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}}else {console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');}}else {if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_2D,i,0,0,mipmap.width,mipmap.height,glFormat,glType,mipmap.data);}}else {state.texImage2D(_gl.TEXTURE_2D,i,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}}}else if(texture.isDataArrayTexture){if(useTexStorage){if(allocateMemory){state.texStorage3D(_gl.TEXTURE_2D_ARRAY,levels,glInternalFormat,image.width,image.height,image.depth);}if(dataReady){if(texture.layerUpdates.size>0){const layerByteLength=getByteLength(image.width,image.height,texture.format,texture.type);for(const layerIndex of texture.layerUpdates){const layerData=image.data.subarray(layerIndex*layerByteLength/image.data.BYTES_PER_ELEMENT,(layerIndex+1)*layerByteLength/image.data.BYTES_PER_ELEMENT);state.texSubImage3D(_gl.TEXTURE_2D_ARRAY,0,0,0,layerIndex,image.width,image.height,1,glFormat,glType,layerData);}texture.clearLayerUpdates();}else {state.texSubImage3D(_gl.TEXTURE_2D_ARRAY,0,0,0,0,image.width,image.height,image.depth,glFormat,glType,image.data);}}}else {state.texImage3D(_gl.TEXTURE_2D_ARRAY,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);}}else if(texture.isData3DTexture){if(useTexStorage){if(allocateMemory){state.texStorage3D(_gl.TEXTURE_3D,levels,glInternalFormat,image.width,image.height,image.depth);}if(dataReady){state.texSubImage3D(_gl.TEXTURE_3D,0,0,0,0,image.width,image.height,image.depth,glFormat,glType,image.data);}}else {state.texImage3D(_gl.TEXTURE_3D,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);}}else if(texture.isFramebufferTexture){if(allocateMemory){if(useTexStorage){state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,image.width,image.height);}else {let width=image.width,height=image.height;for(let i=0;i<levels;i++){state.texImage2D(_gl.TEXTURE_2D,i,glInternalFormat,width,height,0,glFormat,glType,null);width>>=1;height>>=1;}}}}else {// regular Texture (image, video, canvas)
	// use manually created mipmaps if available
	// if there are no manual mipmaps
	// set 0 level mipmap and then use GL to generate other mipmap levels
	if(mipmaps.length>0){if(useTexStorage&&allocateMemory){const dimensions=getDimensions(mipmaps[0]);state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,dimensions.width,dimensions.height);}for(let i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_2D,i,0,0,glFormat,glType,mipmap);}}else {state.texImage2D(_gl.TEXTURE_2D,i,glInternalFormat,glFormat,glType,mipmap);}}texture.generateMipmaps=false;}else {if(useTexStorage){if(allocateMemory){const dimensions=getDimensions(image);state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,dimensions.width,dimensions.height);}if(dataReady){state.texSubImage2D(_gl.TEXTURE_2D,0,0,0,glFormat,glType,image);}}else {state.texImage2D(_gl.TEXTURE_2D,0,glInternalFormat,glFormat,glType,image);}}}if(textureNeedsGenerateMipmaps(texture)){generateMipmap(textureType);}sourceProperties.__version=source.version;if(texture.onUpdate)texture.onUpdate(texture);}textureProperties.__version=texture.version;}function uploadCubeTexture(textureProperties,texture,slot){if(texture.image.length!==6)return;const forceUpload=initTexture(textureProperties,texture);const source=texture.source;state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture,_gl.TEXTURE0+slot);const sourceProperties=properties.get(source);if(source.version!==sourceProperties.__version||forceUpload===true){state.activeTexture(_gl.TEXTURE0+slot);const workingPrimaries=ColorManagement.getPrimaries(ColorManagement.workingColorSpace);const texturePrimaries=texture.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(texture.colorSpace);const unpackConversion=texture.colorSpace===NoColorSpace||workingPrimaries===texturePrimaries?_gl.NONE:_gl.BROWSER_DEFAULT_WEBGL;_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,texture.unpackAlignment);_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,unpackConversion);const isCompressed=texture.isCompressedTexture||texture.image[0].isCompressedTexture;const isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;const cubeImage=[];for(let i=0;i<6;i++){if(!isCompressed&&!isDataTexture){cubeImage[i]=resizeImage(texture.image[i],true,capabilities.maxCubemapSize);}else {cubeImage[i]=isDataTexture?texture.image[i].image:texture.image[i];}cubeImage[i]=verifyColorSpace(texture,cubeImage[i]);}const image=cubeImage[0],glFormat=utils.convert(texture.format,texture.colorSpace),glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace);const useTexStorage=texture.isVideoTexture!==true;const allocateMemory=sourceProperties.__version===undefined||forceUpload===true;const dataReady=source.dataReady;let levels=getMipLevels(texture,image);setTextureParameters(_gl.TEXTURE_CUBE_MAP,texture);let mipmaps;if(isCompressed){if(useTexStorage&&allocateMemory){state.texStorage2D(_gl.TEXTURE_CUBE_MAP,levels,glInternalFormat,image.width,image.height);}for(let i=0;i<6;i++){mipmaps=cubeImage[i].mipmaps;for(let j=0;j<mipmaps.length;j++){const mipmap=mipmaps[j];if(texture.format!==RGBAFormat){if(glFormat!==null){if(useTexStorage){if(dataReady){state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,0,0,mipmap.width,mipmap.height,glFormat,mipmap.data);}}else {state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}}else {console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');}}else {if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,0,0,mipmap.width,mipmap.height,glFormat,glType,mipmap.data);}}else {state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}}}else {mipmaps=texture.mipmaps;if(useTexStorage&&allocateMemory){// TODO: Uniformly handle mipmap definitions
	// Normal textures and compressed cube textures define base level + mips with their mipmap array
	// Uncompressed cube textures use their mipmap array only for mips (no base level)
	if(mipmaps.length>0)levels++;const dimensions=getDimensions(cubeImage[0]);state.texStorage2D(_gl.TEXTURE_CUBE_MAP,levels,glInternalFormat,dimensions.width,dimensions.height);}for(let i=0;i<6;i++){if(isDataTexture){if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,0,0,cubeImage[i].width,cubeImage[i].height,glFormat,glType,cubeImage[i].data);}}else {state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glInternalFormat,cubeImage[i].width,cubeImage[i].height,0,glFormat,glType,cubeImage[i].data);}for(let j=0;j<mipmaps.length;j++){const mipmap=mipmaps[j];const mipmapImage=mipmap.image[i].image;if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j+1,0,0,mipmapImage.width,mipmapImage.height,glFormat,glType,mipmapImage.data);}}else {state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j+1,glInternalFormat,mipmapImage.width,mipmapImage.height,0,glFormat,glType,mipmapImage.data);}}}else {if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,0,0,glFormat,glType,cubeImage[i]);}}else {state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glInternalFormat,glFormat,glType,cubeImage[i]);}for(let j=0;j<mipmaps.length;j++){const mipmap=mipmaps[j];if(useTexStorage){if(dataReady){state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j+1,0,0,glFormat,glType,mipmap.image[i]);}}else {state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j+1,glInternalFormat,glFormat,glType,mipmap.image[i]);}}}}}if(textureNeedsGenerateMipmaps(texture)){// We assume images for cube map have the same size.
	generateMipmap(_gl.TEXTURE_CUBE_MAP);}sourceProperties.__version=source.version;if(texture.onUpdate)texture.onUpdate(texture);}textureProperties.__version=texture.version;}// Render targets
	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture(framebuffer,renderTarget,texture,attachment,textureTarget,level){const glFormat=utils.convert(texture.format,texture.colorSpace);const glType=utils.convert(texture.type);const glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace);const renderTargetProperties=properties.get(renderTarget);const textureProperties=properties.get(texture);textureProperties.__renderTarget=renderTarget;if(!renderTargetProperties.__hasExternalTextures){const width=Math.max(1,renderTarget.width>>level);const height=Math.max(1,renderTarget.height>>level);if(textureTarget===_gl.TEXTURE_3D||textureTarget===_gl.TEXTURE_2D_ARRAY){state.texImage3D(textureTarget,level,glInternalFormat,width,height,renderTarget.depth,0,glFormat,glType,null);}else {state.texImage2D(textureTarget,level,glInternalFormat,width,height,0,glFormat,glType,null);}}state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);if(useMultisampledRTT(renderTarget)){multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER,attachment,textureTarget,textureProperties.__webglTexture,0,getRenderTargetSamples(renderTarget));}else if(textureTarget===_gl.TEXTURE_2D||textureTarget>=_gl.TEXTURE_CUBE_MAP_POSITIVE_X&&textureTarget<=_gl.TEXTURE_CUBE_MAP_NEGATIVE_Z){// see #24753
	_gl.framebufferTexture2D(_gl.FRAMEBUFFER,attachment,textureTarget,textureProperties.__webglTexture,level);}state.bindFramebuffer(_gl.FRAMEBUFFER,null);}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage(renderbuffer,renderTarget,isMultisample){_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer);if(renderTarget.depthBuffer){// retrieve the depth attachment types
	const depthTexture=renderTarget.depthTexture;const depthType=depthTexture&&depthTexture.isDepthTexture?depthTexture.type:null;const glInternalFormat=getInternalDepthFormat(renderTarget.stencilBuffer,depthType);const glAttachmentType=renderTarget.stencilBuffer?_gl.DEPTH_STENCIL_ATTACHMENT:_gl.DEPTH_ATTACHMENT;// set up the attachment
	const samples=getRenderTargetSamples(renderTarget);const isUseMultisampledRTT=useMultisampledRTT(renderTarget);if(isUseMultisampledRTT){multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else if(isMultisample){_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else {_gl.renderbufferStorage(_gl.RENDERBUFFER,glInternalFormat,renderTarget.width,renderTarget.height);}_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,glAttachmentType,_gl.RENDERBUFFER,renderbuffer);}else {const textures=renderTarget.textures;for(let i=0;i<textures.length;i++){const texture=textures[i];const glFormat=utils.convert(texture.format,texture.colorSpace);const glType=utils.convert(texture.type);const glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace);const samples=getRenderTargetSamples(renderTarget);if(isMultisample&&useMultisampledRTT(renderTarget)===false){_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else if(useMultisampledRTT(renderTarget)){multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else {_gl.renderbufferStorage(_gl.RENDERBUFFER,glInternalFormat,renderTarget.width,renderTarget.height);}}}_gl.bindRenderbuffer(_gl.RENDERBUFFER,null);}// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture(framebuffer,renderTarget){const isCube=renderTarget&&renderTarget.isWebGLCubeRenderTarget;if(isCube)throw new Error('Depth Texture with cube render targets is not supported');state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);if(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');}const textureProperties=properties.get(renderTarget.depthTexture);textureProperties.__renderTarget=renderTarget;// upload an empty depth texture with framebuffer size
	if(!textureProperties.__webglTexture||renderTarget.depthTexture.image.width!==renderTarget.width||renderTarget.depthTexture.image.height!==renderTarget.height){renderTarget.depthTexture.image.width=renderTarget.width;renderTarget.depthTexture.image.height=renderTarget.height;renderTarget.depthTexture.needsUpdate=true;}setTexture2D(renderTarget.depthTexture,0);const webglDepthTexture=textureProperties.__webglTexture;const samples=getRenderTargetSamples(renderTarget);if(renderTarget.depthTexture.format===DepthFormat){if(useMultisampledRTT(renderTarget)){multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0,samples);}else {_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}}else if(renderTarget.depthTexture.format===DepthStencilFormat){if(useMultisampledRTT(renderTarget)){multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0,samples);}else {_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}}else {throw new Error('Unknown depthTexture format');}}// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer(renderTarget){const renderTargetProperties=properties.get(renderTarget);const isCube=renderTarget.isWebGLCubeRenderTarget===true;// if the bound depth texture has changed
	if(renderTargetProperties.__boundDepthTexture!==renderTarget.depthTexture){// fire the dispose event to get rid of stored state associated with the previously bound depth buffer
	const depthTexture=renderTarget.depthTexture;if(renderTargetProperties.__depthDisposeCallback){renderTargetProperties.__depthDisposeCallback();}// set up dispose listeners to track when the currently attached buffer is implicitly unbound
	if(depthTexture){const disposeEvent=()=>{delete renderTargetProperties.__boundDepthTexture;delete renderTargetProperties.__depthDisposeCallback;depthTexture.removeEventListener('dispose',disposeEvent);};depthTexture.addEventListener('dispose',disposeEvent);renderTargetProperties.__depthDisposeCallback=disposeEvent;}renderTargetProperties.__boundDepthTexture=depthTexture;}if(renderTarget.depthTexture&&!renderTargetProperties.__autoAllocateDepthBuffer){if(isCube)throw new Error('target.depthTexture not supported in Cube render targets');setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);}else {if(isCube){renderTargetProperties.__webglDepthbuffer=[];for(let i=0;i<6;i++){state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer[i]);if(renderTargetProperties.__webglDepthbuffer[i]===undefined){renderTargetProperties.__webglDepthbuffer[i]=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i],renderTarget,false);}else {// attach buffer if it's been created already
	const glAttachmentType=renderTarget.stencilBuffer?_gl.DEPTH_STENCIL_ATTACHMENT:_gl.DEPTH_ATTACHMENT;const renderbuffer=renderTargetProperties.__webglDepthbuffer[i];_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,glAttachmentType,_gl.RENDERBUFFER,renderbuffer);}}}else {state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);if(renderTargetProperties.__webglDepthbuffer===undefined){renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget,false);}else {// attach buffer if it's been created already
	const glAttachmentType=renderTarget.stencilBuffer?_gl.DEPTH_STENCIL_ATTACHMENT:_gl.DEPTH_ATTACHMENT;const renderbuffer=renderTargetProperties.__webglDepthbuffer;_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,glAttachmentType,_gl.RENDERBUFFER,renderbuffer);}}}state.bindFramebuffer(_gl.FRAMEBUFFER,null);}// rebind framebuffer with external textures
	function rebindTextures(renderTarget,colorTexture,depthTexture){const renderTargetProperties=properties.get(renderTarget);if(colorTexture!==undefined){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,renderTarget.texture,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D,0);}if(depthTexture!==undefined){setupDepthRenderbuffer(renderTarget);}}// Set up GL resources for the render target
	function setupRenderTarget(renderTarget){const texture=renderTarget.texture;const renderTargetProperties=properties.get(renderTarget);const textureProperties=properties.get(texture);renderTarget.addEventListener('dispose',onRenderTargetDispose);const textures=renderTarget.textures;const isCube=renderTarget.isWebGLCubeRenderTarget===true;const isMultipleRenderTargets=textures.length>1;if(!isMultipleRenderTargets){if(textureProperties.__webglTexture===undefined){textureProperties.__webglTexture=_gl.createTexture();}textureProperties.__version=texture.version;info.memory.textures++;}// Setup framebuffer
	if(isCube){renderTargetProperties.__webglFramebuffer=[];for(let i=0;i<6;i++){if(texture.mipmaps&&texture.mipmaps.length>0){renderTargetProperties.__webglFramebuffer[i]=[];for(let level=0;level<texture.mipmaps.length;level++){renderTargetProperties.__webglFramebuffer[i][level]=_gl.createFramebuffer();}}else {renderTargetProperties.__webglFramebuffer[i]=_gl.createFramebuffer();}}}else {if(texture.mipmaps&&texture.mipmaps.length>0){renderTargetProperties.__webglFramebuffer=[];for(let level=0;level<texture.mipmaps.length;level++){renderTargetProperties.__webglFramebuffer[level]=_gl.createFramebuffer();}}else {renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();}if(isMultipleRenderTargets){for(let i=0,il=textures.length;i<il;i++){const attachmentProperties=properties.get(textures[i]);if(attachmentProperties.__webglTexture===undefined){attachmentProperties.__webglTexture=_gl.createTexture();info.memory.textures++;}}}if(renderTarget.samples>0&&useMultisampledRTT(renderTarget)===false){renderTargetProperties.__webglMultisampledFramebuffer=_gl.createFramebuffer();renderTargetProperties.__webglColorRenderbuffer=[];state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer);for(let i=0;i<textures.length;i++){const texture=textures[i];renderTargetProperties.__webglColorRenderbuffer[i]=_gl.createRenderbuffer();_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[i]);const glFormat=utils.convert(texture.format,texture.colorSpace);const glType=utils.convert(texture.type);const glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace,renderTarget.isXRRenderTarget===true);const samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i,_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[i]);}_gl.bindRenderbuffer(_gl.RENDERBUFFER,null);if(renderTarget.depthBuffer){renderTargetProperties.__webglDepthRenderbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer,renderTarget,true);}state.bindFramebuffer(_gl.FRAMEBUFFER,null);}}// Setup color buffer
	if(isCube){state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_CUBE_MAP,texture);for(let i=0;i<6;i++){if(texture.mipmaps&&texture.mipmaps.length>0){for(let level=0;level<texture.mipmaps.length;level++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level],renderTarget,texture,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,level);}}else {setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i],renderTarget,texture,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0);}}if(textureNeedsGenerateMipmaps(texture)){generateMipmap(_gl.TEXTURE_CUBE_MAP);}state.unbindTexture();}else if(isMultipleRenderTargets){for(let i=0,il=textures.length;i<il;i++){const attachment=textures[i];const attachmentProperties=properties.get(attachment);state.bindTexture(_gl.TEXTURE_2D,attachmentProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_2D,attachment);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,attachment,_gl.COLOR_ATTACHMENT0+i,_gl.TEXTURE_2D,0);if(textureNeedsGenerateMipmaps(attachment)){generateMipmap(_gl.TEXTURE_2D);}}state.unbindTexture();}else {let glTextureType=_gl.TEXTURE_2D;if(renderTarget.isWebGL3DRenderTarget||renderTarget.isWebGLArrayRenderTarget){glTextureType=renderTarget.isWebGL3DRenderTarget?_gl.TEXTURE_3D:_gl.TEXTURE_2D_ARRAY;}state.bindTexture(glTextureType,textureProperties.__webglTexture);setTextureParameters(glTextureType,texture);if(texture.mipmaps&&texture.mipmaps.length>0){for(let level=0;level<texture.mipmaps.length;level++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level],renderTarget,texture,_gl.COLOR_ATTACHMENT0,glTextureType,level);}}else {setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,texture,_gl.COLOR_ATTACHMENT0,glTextureType,0);}if(textureNeedsGenerateMipmaps(texture)){generateMipmap(glTextureType);}state.unbindTexture();}// Setup depth and stencil buffers
	if(renderTarget.depthBuffer){setupDepthRenderbuffer(renderTarget);}}function updateRenderTargetMipmap(renderTarget){const textures=renderTarget.textures;for(let i=0,il=textures.length;i<il;i++){const texture=textures[i];if(textureNeedsGenerateMipmaps(texture)){const targetType=getTargetType(renderTarget);const webglTexture=properties.get(texture).__webglTexture;state.bindTexture(targetType,webglTexture);generateMipmap(targetType);state.unbindTexture();}}}const invalidationArrayRead=[];const invalidationArrayDraw=[];function updateMultisampleRenderTarget(renderTarget){if(renderTarget.samples>0){if(useMultisampledRTT(renderTarget)===false){const textures=renderTarget.textures;const width=renderTarget.width;const height=renderTarget.height;let mask=_gl.COLOR_BUFFER_BIT;const depthStyle=renderTarget.stencilBuffer?_gl.DEPTH_STENCIL_ATTACHMENT:_gl.DEPTH_ATTACHMENT;const renderTargetProperties=properties.get(renderTarget);const isMultipleRenderTargets=textures.length>1;// If MRT we need to remove FBO attachments
	if(isMultipleRenderTargets){for(let i=0;i<textures.length;i++){state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i,_gl.RENDERBUFFER,null);state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i,_gl.TEXTURE_2D,null,0);}}state.bindFramebuffer(_gl.READ_FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);for(let i=0;i<textures.length;i++){if(renderTarget.resolveDepthBuffer){if(renderTarget.depthBuffer)mask|=_gl.DEPTH_BUFFER_BIT;// resolving stencil is slow with a D3D backend. disable it for all transmission render targets (see #27799)
	if(renderTarget.stencilBuffer&&renderTarget.resolveStencilBuffer)mask|=_gl.STENCIL_BUFFER_BIT;}if(isMultipleRenderTargets){_gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[i]);const webglTexture=properties.get(textures[i]).__webglTexture;_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D,webglTexture,0);}_gl.blitFramebuffer(0,0,width,height,0,0,width,height,mask,_gl.NEAREST);if(supportsInvalidateFramebuffer===true){invalidationArrayRead.length=0;invalidationArrayDraw.length=0;invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0+i);if(renderTarget.depthBuffer&&renderTarget.resolveDepthBuffer===false){invalidationArrayRead.push(depthStyle);invalidationArrayDraw.push(depthStyle);_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER,invalidationArrayDraw);}_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER,invalidationArrayRead);}}state.bindFramebuffer(_gl.READ_FRAMEBUFFER,null);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,null);// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
	if(isMultipleRenderTargets){for(let i=0;i<textures.length;i++){state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i,_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[i]);const webglTexture=properties.get(textures[i]).__webglTexture;state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i,_gl.TEXTURE_2D,webglTexture,0);}}state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer);}else {if(renderTarget.depthBuffer&&renderTarget.resolveDepthBuffer===false&&supportsInvalidateFramebuffer){const depthStyle=renderTarget.stencilBuffer?_gl.DEPTH_STENCIL_ATTACHMENT:_gl.DEPTH_ATTACHMENT;_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER,[depthStyle]);}}}}function getRenderTargetSamples(renderTarget){return Math.min(capabilities.maxSamples,renderTarget.samples);}function useMultisampledRTT(renderTarget){const renderTargetProperties=properties.get(renderTarget);return renderTarget.samples>0&&extensions.has('WEBGL_multisampled_render_to_texture')===true&&renderTargetProperties.__useRenderToTexture!==false;}function updateVideoTexture(texture){const frame=info.render.frame;// Check the last frame we updated the VideoTexture
	if(_videoTextures.get(texture)!==frame){_videoTextures.set(texture,frame);texture.update();}}function verifyColorSpace(texture,image){const colorSpace=texture.colorSpace;const format=texture.format;const type=texture.type;if(texture.isCompressedTexture===true||texture.isVideoTexture===true)return image;if(colorSpace!==LinearSRGBColorSpace&&colorSpace!==NoColorSpace){// sRGB
	if(ColorManagement.getTransfer(colorSpace)===SRGBTransfer){// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format
	if(format!==RGBAFormat||type!==UnsignedByteType){console.warn('THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.');}}else {console.error('THREE.WebGLTextures: Unsupported texture color space:',colorSpace);}}return image;}function getDimensions(image){if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement){// if intrinsic data are not available, fallback to width/height
	_imageDimensions.width=image.naturalWidth||image.width;_imageDimensions.height=image.naturalHeight||image.height;}else if(typeof VideoFrame!=='undefined'&&image instanceof VideoFrame){_imageDimensions.width=image.displayWidth;_imageDimensions.height=image.displayHeight;}else {_imageDimensions.width=image.width;_imageDimensions.height=image.height;}return _imageDimensions;}//
	this.allocateTextureUnit=allocateTextureUnit;this.resetTextureUnits=resetTextureUnits;this.setTexture2D=setTexture2D;this.setTexture2DArray=setTexture2DArray;this.setTexture3D=setTexture3D;this.setTextureCube=setTextureCube;this.rebindTextures=rebindTextures;this.setupRenderTarget=setupRenderTarget;this.updateRenderTargetMipmap=updateRenderTargetMipmap;this.updateMultisampleRenderTarget=updateMultisampleRenderTarget;this.setupDepthRenderbuffer=setupDepthRenderbuffer;this.setupFrameBufferTexture=setupFrameBufferTexture;this.useMultisampledRTT=useMultisampledRTT;}function WebGLUtils(gl,extensions){function convert(p,colorSpace=NoColorSpace){let extension;const transfer=ColorManagement.getTransfer(colorSpace);if(p===UnsignedByteType)return gl.UNSIGNED_BYTE;if(p===UnsignedShort4444Type)return gl.UNSIGNED_SHORT_4_4_4_4;if(p===UnsignedShort5551Type)return gl.UNSIGNED_SHORT_5_5_5_1;if(p===UnsignedInt5999Type)return gl.UNSIGNED_INT_5_9_9_9_REV;if(p===ByteType)return gl.BYTE;if(p===ShortType)return gl.SHORT;if(p===UnsignedShortType)return gl.UNSIGNED_SHORT;if(p===IntType)return gl.INT;if(p===UnsignedIntType)return gl.UNSIGNED_INT;if(p===FloatType$1)return gl.FLOAT;if(p===HalfFloatType)return gl.HALF_FLOAT;if(p===AlphaFormat)return gl.ALPHA;if(p===RGBFormat)return gl.RGB;if(p===RGBAFormat)return gl.RGBA;if(p===LuminanceFormat)return gl.LUMINANCE;if(p===LuminanceAlphaFormat)return gl.LUMINANCE_ALPHA;if(p===DepthFormat)return gl.DEPTH_COMPONENT;if(p===DepthStencilFormat)return gl.DEPTH_STENCIL;// WebGL2 formats.
	if(p===RedFormat)return gl.RED;if(p===RedIntegerFormat)return gl.RED_INTEGER;if(p===RGFormat)return gl.RG;if(p===RGIntegerFormat)return gl.RG_INTEGER;if(p===RGBAIntegerFormat)return gl.RGBA_INTEGER;// S3TC
	if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){if(transfer===SRGBTransfer){extension=extensions.get('WEBGL_compressed_texture_s3tc_srgb');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;}else {return null;}}else {extension=extensions.get('WEBGL_compressed_texture_s3tc');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;}else {return null;}}}// PVRTC
	if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){extension=extensions.get('WEBGL_compressed_texture_pvrtc');if(extension!==null){if(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;}else {return null;}}// ETC
	if(p===RGB_ETC1_Format||p===RGB_ETC2_Format||p===RGBA_ETC2_EAC_Format){extension=extensions.get('WEBGL_compressed_texture_etc');if(extension!==null){if(p===RGB_ETC1_Format||p===RGB_ETC2_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ETC2:extension.COMPRESSED_RGB8_ETC2;if(p===RGBA_ETC2_EAC_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:extension.COMPRESSED_RGBA8_ETC2_EAC;}else {return null;}}// ASTC
	if(p===RGBA_ASTC_4x4_Format||p===RGBA_ASTC_5x4_Format||p===RGBA_ASTC_5x5_Format||p===RGBA_ASTC_6x5_Format||p===RGBA_ASTC_6x6_Format||p===RGBA_ASTC_8x5_Format||p===RGBA_ASTC_8x6_Format||p===RGBA_ASTC_8x8_Format||p===RGBA_ASTC_10x5_Format||p===RGBA_ASTC_10x6_Format||p===RGBA_ASTC_10x8_Format||p===RGBA_ASTC_10x10_Format||p===RGBA_ASTC_12x10_Format||p===RGBA_ASTC_12x12_Format){extension=extensions.get('WEBGL_compressed_texture_astc');if(extension!==null){if(p===RGBA_ASTC_4x4_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:extension.COMPRESSED_RGBA_ASTC_4x4_KHR;if(p===RGBA_ASTC_5x4_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:extension.COMPRESSED_RGBA_ASTC_5x4_KHR;if(p===RGBA_ASTC_5x5_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:extension.COMPRESSED_RGBA_ASTC_5x5_KHR;if(p===RGBA_ASTC_6x5_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:extension.COMPRESSED_RGBA_ASTC_6x5_KHR;if(p===RGBA_ASTC_6x6_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:extension.COMPRESSED_RGBA_ASTC_6x6_KHR;if(p===RGBA_ASTC_8x5_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:extension.COMPRESSED_RGBA_ASTC_8x5_KHR;if(p===RGBA_ASTC_8x6_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:extension.COMPRESSED_RGBA_ASTC_8x6_KHR;if(p===RGBA_ASTC_8x8_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:extension.COMPRESSED_RGBA_ASTC_8x8_KHR;if(p===RGBA_ASTC_10x5_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:extension.COMPRESSED_RGBA_ASTC_10x5_KHR;if(p===RGBA_ASTC_10x6_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:extension.COMPRESSED_RGBA_ASTC_10x6_KHR;if(p===RGBA_ASTC_10x8_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:extension.COMPRESSED_RGBA_ASTC_10x8_KHR;if(p===RGBA_ASTC_10x10_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:extension.COMPRESSED_RGBA_ASTC_10x10_KHR;if(p===RGBA_ASTC_12x10_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:extension.COMPRESSED_RGBA_ASTC_12x10_KHR;if(p===RGBA_ASTC_12x12_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:extension.COMPRESSED_RGBA_ASTC_12x12_KHR;}else {return null;}}// BPTC
	if(p===RGBA_BPTC_Format||p===RGB_BPTC_SIGNED_Format||p===RGB_BPTC_UNSIGNED_Format){extension=extensions.get('EXT_texture_compression_bptc');if(extension!==null){if(p===RGBA_BPTC_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(p===RGB_BPTC_SIGNED_Format)return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(p===RGB_BPTC_UNSIGNED_Format)return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;}else {return null;}}// RGTC
	if(p===RED_RGTC1_Format||p===SIGNED_RED_RGTC1_Format||p===RED_GREEN_RGTC2_Format||p===SIGNED_RED_GREEN_RGTC2_Format){extension=extensions.get('EXT_texture_compression_rgtc');if(extension!==null){if(p===RGBA_BPTC_Format)return extension.COMPRESSED_RED_RGTC1_EXT;if(p===SIGNED_RED_RGTC1_Format)return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(p===RED_GREEN_RGTC2_Format)return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;if(p===SIGNED_RED_GREEN_RGTC2_Format)return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;}else {return null;}}//
	if(p===UnsignedInt248Type)return gl.UNSIGNED_INT_24_8;// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)
	return gl[p]!==undefined?gl[p]:null;}return {convert:convert};}const _moveEvent={type:'move'};class WebXRController{constructor(){this._targetRay=null;this._grip=null;this._hand=null;}getHandSpace(){if(this._hand===null){this._hand=new Group();this._hand.matrixAutoUpdate=false;this._hand.visible=false;this._hand.joints={};this._hand.inputState={pinching:false};}return this._hand;}getTargetRaySpace(){if(this._targetRay===null){this._targetRay=new Group();this._targetRay.matrixAutoUpdate=false;this._targetRay.visible=false;this._targetRay.hasLinearVelocity=false;this._targetRay.linearVelocity=new Vector3$1();this._targetRay.hasAngularVelocity=false;this._targetRay.angularVelocity=new Vector3$1();}return this._targetRay;}getGripSpace(){if(this._grip===null){this._grip=new Group();this._grip.matrixAutoUpdate=false;this._grip.visible=false;this._grip.hasLinearVelocity=false;this._grip.linearVelocity=new Vector3$1();this._grip.hasAngularVelocity=false;this._grip.angularVelocity=new Vector3$1();}return this._grip;}dispatchEvent(event){if(this._targetRay!==null){this._targetRay.dispatchEvent(event);}if(this._grip!==null){this._grip.dispatchEvent(event);}if(this._hand!==null){this._hand.dispatchEvent(event);}return this;}connect(inputSource){if(inputSource&&inputSource.hand){const hand=this._hand;if(hand){for(const inputjoint of inputSource.hand.values()){// Initialize hand with joints when connected
	this._getHandJoint(hand,inputjoint);}}}this.dispatchEvent({type:'connected',data:inputSource});return this;}disconnect(inputSource){this.dispatchEvent({type:'disconnected',data:inputSource});if(this._targetRay!==null){this._targetRay.visible=false;}if(this._grip!==null){this._grip.visible=false;}if(this._hand!==null){this._hand.visible=false;}return this;}update(inputSource,frame,referenceSpace){let inputPose=null;let gripPose=null;let handPose=null;const targetRay=this._targetRay;const grip=this._grip;const hand=this._hand;if(inputSource&&frame.session.visibilityState!=='visible-blurred'){if(hand&&inputSource.hand){handPose=true;for(const inputjoint of inputSource.hand.values()){// Update the joints groups with the XRJoint poses
	const jointPose=frame.getJointPose(inputjoint,referenceSpace);// The transform of this joint will be updated with the joint pose on each frame
	const joint=this._getHandJoint(hand,inputjoint);if(jointPose!==null){joint.matrix.fromArray(jointPose.transform.matrix);joint.matrix.decompose(joint.position,joint.rotation,joint.scale);joint.matrixWorldNeedsUpdate=true;joint.jointRadius=jointPose.radius;}joint.visible=jointPose!==null;}// Custom events
	// Check pinchz
	const indexTip=hand.joints['index-finger-tip'];const thumbTip=hand.joints['thumb-tip'];const distance=indexTip.position.distanceTo(thumbTip.position);const distanceToPinch=0.02;const threshold=0.005;if(hand.inputState.pinching&&distance>distanceToPinch+threshold){hand.inputState.pinching=false;this.dispatchEvent({type:'pinchend',handedness:inputSource.handedness,target:this});}else if(!hand.inputState.pinching&&distance<=distanceToPinch-threshold){hand.inputState.pinching=true;this.dispatchEvent({type:'pinchstart',handedness:inputSource.handedness,target:this});}}else {if(grip!==null&&inputSource.gripSpace){gripPose=frame.getPose(inputSource.gripSpace,referenceSpace);if(gripPose!==null){grip.matrix.fromArray(gripPose.transform.matrix);grip.matrix.decompose(grip.position,grip.rotation,grip.scale);grip.matrixWorldNeedsUpdate=true;if(gripPose.linearVelocity){grip.hasLinearVelocity=true;grip.linearVelocity.copy(gripPose.linearVelocity);}else {grip.hasLinearVelocity=false;}if(gripPose.angularVelocity){grip.hasAngularVelocity=true;grip.angularVelocity.copy(gripPose.angularVelocity);}else {grip.hasAngularVelocity=false;}}}}if(targetRay!==null){inputPose=frame.getPose(inputSource.targetRaySpace,referenceSpace);// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
	if(inputPose===null&&gripPose!==null){inputPose=gripPose;}if(inputPose!==null){targetRay.matrix.fromArray(inputPose.transform.matrix);targetRay.matrix.decompose(targetRay.position,targetRay.rotation,targetRay.scale);targetRay.matrixWorldNeedsUpdate=true;if(inputPose.linearVelocity){targetRay.hasLinearVelocity=true;targetRay.linearVelocity.copy(inputPose.linearVelocity);}else {targetRay.hasLinearVelocity=false;}if(inputPose.angularVelocity){targetRay.hasAngularVelocity=true;targetRay.angularVelocity.copy(inputPose.angularVelocity);}else {targetRay.hasAngularVelocity=false;}this.dispatchEvent(_moveEvent);}}}if(targetRay!==null){targetRay.visible=inputPose!==null;}if(grip!==null){grip.visible=gripPose!==null;}if(hand!==null){hand.visible=handPose!==null;}return this;}// private method
	_getHandJoint(hand,inputjoint){if(hand.joints[inputjoint.jointName]===undefined){const joint=new Group();joint.matrixAutoUpdate=false;joint.visible=false;hand.joints[inputjoint.jointName]=joint;hand.add(joint);}return hand.joints[inputjoint.jointName];}}const _occlusion_vertex=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`;const _occlusion_fragment=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class WebXRDepthSensing{constructor(){this.texture=null;this.mesh=null;this.depthNear=0;this.depthFar=0;}init(renderer,depthData,renderState){if(this.texture===null){const texture=new Texture();const texProps=renderer.properties.get(texture);texProps.__webglTexture=depthData.texture;if(depthData.depthNear!=renderState.depthNear||depthData.depthFar!=renderState.depthFar){this.depthNear=depthData.depthNear;this.depthFar=depthData.depthFar;}this.texture=texture;}}getMesh(cameraXR){if(this.texture!==null){if(this.mesh===null){const viewport=cameraXR.cameras[0].viewport;const material=new ShaderMaterial({vertexShader:_occlusion_vertex,fragmentShader:_occlusion_fragment,uniforms:{depthColor:{value:this.texture},depthWidth:{value:viewport.z},depthHeight:{value:viewport.w}}});this.mesh=new Mesh(new PlaneGeometry(20,20),material);}}return this.mesh;}reset(){this.texture=null;this.mesh=null;}getDepthTexture(){return this.texture;}}class WebXRManager extends EventDispatcher$1{constructor(renderer,gl){super();const scope=this;let session=null;let framebufferScaleFactor=1.0;let referenceSpace=null;let referenceSpaceType='local-floor';// Set default foveation to maximum.
	let foveation=1.0;let customReferenceSpace=null;let pose=null;let glBinding=null;let glProjLayer=null;let glBaseLayer=null;let xrFrame=null;const depthSensing=new WebXRDepthSensing();const attributes=gl.getContextAttributes();let initialRenderTarget=null;let newRenderTarget=null;const controllers=[];const controllerInputSources=[];const currentSize=new Vector2$1();let currentPixelRatio=null;//
	const cameraL=new PerspectiveCamera();cameraL.viewport=new Vector4();const cameraR=new PerspectiveCamera();cameraR.viewport=new Vector4();const cameras=[cameraL,cameraR];const cameraXR=new ArrayCamera();let _currentDepthNear=null;let _currentDepthFar=null;//
	this.cameraAutoUpdate=true;this.enabled=false;this.isPresenting=false;this.getController=function(index){let controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getTargetRaySpace();};this.getControllerGrip=function(index){let controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getGripSpace();};this.getHand=function(index){let controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getHandSpace();};//
	function onSessionEvent(event){const controllerIndex=controllerInputSources.indexOf(event.inputSource);if(controllerIndex===-1){return;}const controller=controllers[controllerIndex];if(controller!==undefined){controller.update(event.inputSource,event.frame,customReferenceSpace||referenceSpace);controller.dispatchEvent({type:event.type,data:event.inputSource});}}function onSessionEnd(){session.removeEventListener('select',onSessionEvent);session.removeEventListener('selectstart',onSessionEvent);session.removeEventListener('selectend',onSessionEvent);session.removeEventListener('squeeze',onSessionEvent);session.removeEventListener('squeezestart',onSessionEvent);session.removeEventListener('squeezeend',onSessionEvent);session.removeEventListener('end',onSessionEnd);session.removeEventListener('inputsourceschange',onInputSourcesChange);for(let i=0;i<controllers.length;i++){const inputSource=controllerInputSources[i];if(inputSource===null)continue;controllerInputSources[i]=null;controllers[i].disconnect(inputSource);}_currentDepthNear=null;_currentDepthFar=null;depthSensing.reset();// restore framebuffer/rendering state
	renderer.setRenderTarget(initialRenderTarget);glBaseLayer=null;glProjLayer=null;glBinding=null;session=null;newRenderTarget=null;//
	animation.stop();scope.isPresenting=false;renderer.setPixelRatio(currentPixelRatio);renderer.setSize(currentSize.width,currentSize.height,false);scope.dispatchEvent({type:'sessionend'});}this.setFramebufferScaleFactor=function(value){framebufferScaleFactor=value;if(scope.isPresenting===true){console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');}};this.setReferenceSpaceType=function(value){referenceSpaceType=value;if(scope.isPresenting===true){console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');}};this.getReferenceSpace=function(){return customReferenceSpace||referenceSpace;};this.setReferenceSpace=function(space){customReferenceSpace=space;};this.getBaseLayer=function(){return glProjLayer!==null?glProjLayer:glBaseLayer;};this.getBinding=function(){return glBinding;};this.getFrame=function(){return xrFrame;};this.getSession=function(){return session;};this.setSession=async function(value){session=value;if(session!==null){initialRenderTarget=renderer.getRenderTarget();session.addEventListener('select',onSessionEvent);session.addEventListener('selectstart',onSessionEvent);session.addEventListener('selectend',onSessionEvent);session.addEventListener('squeeze',onSessionEvent);session.addEventListener('squeezestart',onSessionEvent);session.addEventListener('squeezeend',onSessionEvent);session.addEventListener('end',onSessionEnd);session.addEventListener('inputsourceschange',onInputSourcesChange);if(attributes.xrCompatible!==true){await gl.makeXRCompatible();}currentPixelRatio=renderer.getPixelRatio();renderer.getSize(currentSize);if(session.renderState.layers===undefined){const layerInit={antialias:attributes.antialias,alpha:true,depth:attributes.depth,stencil:attributes.stencil,framebufferScaleFactor:framebufferScaleFactor};glBaseLayer=new XRWebGLLayer(session,gl,layerInit);session.updateRenderState({baseLayer:glBaseLayer});renderer.setPixelRatio(1);renderer.setSize(glBaseLayer.framebufferWidth,glBaseLayer.framebufferHeight,false);newRenderTarget=new WebGLRenderTarget(glBaseLayer.framebufferWidth,glBaseLayer.framebufferHeight,{format:RGBAFormat,type:UnsignedByteType,colorSpace:renderer.outputColorSpace,stencilBuffer:attributes.stencil});}else {let depthFormat=null;let depthType=null;let glDepthFormat=null;if(attributes.depth){glDepthFormat=attributes.stencil?gl.DEPTH24_STENCIL8:gl.DEPTH_COMPONENT24;depthFormat=attributes.stencil?DepthStencilFormat:DepthFormat;depthType=attributes.stencil?UnsignedInt248Type:UnsignedIntType;}const projectionlayerInit={colorFormat:gl.RGBA8,depthFormat:glDepthFormat,scaleFactor:framebufferScaleFactor};glBinding=new XRWebGLBinding(session,gl);glProjLayer=glBinding.createProjectionLayer(projectionlayerInit);session.updateRenderState({layers:[glProjLayer]});renderer.setPixelRatio(1);renderer.setSize(glProjLayer.textureWidth,glProjLayer.textureHeight,false);newRenderTarget=new WebGLRenderTarget(glProjLayer.textureWidth,glProjLayer.textureHeight,{format:RGBAFormat,type:UnsignedByteType,depthTexture:new DepthTexture(glProjLayer.textureWidth,glProjLayer.textureHeight,depthType,undefined,undefined,undefined,undefined,undefined,undefined,depthFormat),stencilBuffer:attributes.stencil,colorSpace:renderer.outputColorSpace,samples:attributes.antialias?4:0,resolveDepthBuffer:glProjLayer.ignoreDepthValues===false});}newRenderTarget.isXRRenderTarget=true;// TODO Remove this when possible, see #23278
	this.setFoveation(foveation);customReferenceSpace=null;referenceSpace=await session.requestReferenceSpace(referenceSpaceType);animation.setContext(session);animation.start();scope.isPresenting=true;scope.dispatchEvent({type:'sessionstart'});}};this.getEnvironmentBlendMode=function(){if(session!==null){return session.environmentBlendMode;}};this.getDepthTexture=function(){return depthSensing.getDepthTexture();};function onInputSourcesChange(event){// Notify disconnected
	for(let i=0;i<event.removed.length;i++){const inputSource=event.removed[i];const index=controllerInputSources.indexOf(inputSource);if(index>=0){controllerInputSources[index]=null;controllers[index].disconnect(inputSource);}}// Notify connected
	for(let i=0;i<event.added.length;i++){const inputSource=event.added[i];let controllerIndex=controllerInputSources.indexOf(inputSource);if(controllerIndex===-1){// Assign input source a controller that currently has no input source
	for(let i=0;i<controllers.length;i++){if(i>=controllerInputSources.length){controllerInputSources.push(inputSource);controllerIndex=i;break;}else if(controllerInputSources[i]===null){controllerInputSources[i]=inputSource;controllerIndex=i;break;}}// If all controllers do currently receive input we ignore new ones
	if(controllerIndex===-1)break;}const controller=controllers[controllerIndex];if(controller){controller.connect(inputSource);}}}//
	const cameraLPos=new Vector3$1();const cameraRPos=new Vector3$1();/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */function setProjectionFromUnion(camera,cameraL,cameraR){cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);const ipd=cameraLPos.distanceTo(cameraRPos);const projL=cameraL.projectionMatrix.elements;const projR=cameraR.projectionMatrix.elements;// VR systems will have identical far and near planes, and
	// most likely identical top and bottom frustum extents.
	// Use the left camera for these values.
	const near=projL[14]/(projL[10]-1);const far=projL[14]/(projL[10]+1);const topFov=(projL[9]+1)/projL[5];const bottomFov=(projL[9]-1)/projL[5];const leftFov=(projL[8]-1)/projL[0];const rightFov=(projR[8]+1)/projR[0];const left=near*leftFov;const right=near*rightFov;// Calculate the new camera's position offset from the
	// left camera. xOffset should be roughly half `ipd`.
	const zOffset=ipd/(-leftFov+rightFov);const xOffset=zOffset*-leftFov;// TODO: Better way to apply this offset?
	cameraL.matrixWorld.decompose(camera.position,camera.quaternion,camera.scale);camera.translateX(xOffset);camera.translateZ(zOffset);camera.matrixWorld.compose(camera.position,camera.quaternion,camera.scale);camera.matrixWorldInverse.copy(camera.matrixWorld).invert();// Check if the projection uses an infinite far plane.
	if(projL[10]===-1.0){// Use the projection matrix from the left eye.
	// The camera offset is sufficient to include the view volumes
	// of both eyes (assuming symmetric projections).
	camera.projectionMatrix.copy(cameraL.projectionMatrix);camera.projectionMatrixInverse.copy(cameraL.projectionMatrixInverse);}else {// Find the union of the frustum values of the cameras and scale
	// the values so that the near plane's position does not change in world space,
	// although must now be relative to the new union camera.
	const near2=near+zOffset;const far2=far+zOffset;const left2=left-xOffset;const right2=right+(ipd-xOffset);const top2=topFov*far/far2*near2;const bottom2=bottomFov*far/far2*near2;camera.projectionMatrix.makePerspective(left2,right2,top2,bottom2,near2,far2);camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();}}function updateCamera(camera,parent){if(parent===null){camera.matrixWorld.copy(camera.matrix);}else {camera.matrixWorld.multiplyMatrices(parent.matrixWorld,camera.matrix);}camera.matrixWorldInverse.copy(camera.matrixWorld).invert();}this.updateCamera=function(camera){if(session===null)return;let depthNear=camera.near;let depthFar=camera.far;if(depthSensing.texture!==null){if(depthSensing.depthNear>0)depthNear=depthSensing.depthNear;if(depthSensing.depthFar>0)depthFar=depthSensing.depthFar;}cameraXR.near=cameraR.near=cameraL.near=depthNear;cameraXR.far=cameraR.far=cameraL.far=depthFar;if(_currentDepthNear!==cameraXR.near||_currentDepthFar!==cameraXR.far){// Note that the new renderState won't apply until the next frame. See #18320
	session.updateRenderState({depthNear:cameraXR.near,depthFar:cameraXR.far});_currentDepthNear=cameraXR.near;_currentDepthFar=cameraXR.far;}cameraL.layers.mask=camera.layers.mask|0b010;cameraR.layers.mask=camera.layers.mask|0b100;cameraXR.layers.mask=cameraL.layers.mask|cameraR.layers.mask;const parent=camera.parent;const cameras=cameraXR.cameras;updateCamera(cameraXR,parent);for(let i=0;i<cameras.length;i++){updateCamera(cameras[i],parent);}// update projection matrix for proper view frustum culling
	if(cameras.length===2){setProjectionFromUnion(cameraXR,cameraL,cameraR);}else {// assume single camera setup (AR)
	cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);}// update user camera and its children
	updateUserCamera(camera,cameraXR,parent);};function updateUserCamera(camera,cameraXR,parent){if(parent===null){camera.matrix.copy(cameraXR.matrixWorld);}else {camera.matrix.copy(parent.matrixWorld);camera.matrix.invert();camera.matrix.multiply(cameraXR.matrixWorld);}camera.matrix.decompose(camera.position,camera.quaternion,camera.scale);camera.updateMatrixWorld(true);camera.projectionMatrix.copy(cameraXR.projectionMatrix);camera.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse);if(camera.isPerspectiveCamera){camera.fov=RAD2DEG*2*Math.atan(1/camera.projectionMatrix.elements[5]);camera.zoom=1;}}this.getCamera=function(){return cameraXR;};this.getFoveation=function(){if(glProjLayer===null&&glBaseLayer===null){return undefined;}return foveation;};this.setFoveation=function(value){// 0 = no foveation = full resolution
	// 1 = maximum foveation = the edges render at lower resolution
	foveation=value;if(glProjLayer!==null){glProjLayer.fixedFoveation=value;}if(glBaseLayer!==null&&glBaseLayer.fixedFoveation!==undefined){glBaseLayer.fixedFoveation=value;}};this.hasDepthSensing=function(){return depthSensing.texture!==null;};this.getDepthSensingMesh=function(){return depthSensing.getMesh(cameraXR);};// Animation Loop
	let onAnimationFrameCallback=null;function onAnimationFrame(time,frame){pose=frame.getViewerPose(customReferenceSpace||referenceSpace);xrFrame=frame;if(pose!==null){const views=pose.views;if(glBaseLayer!==null){renderer.setRenderTargetFramebuffer(newRenderTarget,glBaseLayer.framebuffer);renderer.setRenderTarget(newRenderTarget);}let cameraXRNeedsUpdate=false;// check if it's necessary to rebuild cameraXR's camera list
	if(views.length!==cameraXR.cameras.length){cameraXR.cameras.length=0;cameraXRNeedsUpdate=true;}for(let i=0;i<views.length;i++){const view=views[i];let viewport=null;if(glBaseLayer!==null){viewport=glBaseLayer.getViewport(view);}else {const glSubImage=glBinding.getViewSubImage(glProjLayer,view);viewport=glSubImage.viewport;// For side-by-side projection, we only produce a single texture for both eyes.
	if(i===0){renderer.setRenderTargetTextures(newRenderTarget,glSubImage.colorTexture,glProjLayer.ignoreDepthValues?undefined:glSubImage.depthStencilTexture);renderer.setRenderTarget(newRenderTarget);}}let camera=cameras[i];if(camera===undefined){camera=new PerspectiveCamera();camera.layers.enable(i);camera.viewport=new Vector4();cameras[i]=camera;}camera.matrix.fromArray(view.transform.matrix);camera.matrix.decompose(camera.position,camera.quaternion,camera.scale);camera.projectionMatrix.fromArray(view.projectionMatrix);camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();camera.viewport.set(viewport.x,viewport.y,viewport.width,viewport.height);if(i===0){cameraXR.matrix.copy(camera.matrix);cameraXR.matrix.decompose(cameraXR.position,cameraXR.quaternion,cameraXR.scale);}if(cameraXRNeedsUpdate===true){cameraXR.cameras.push(camera);}}//
	const enabledFeatures=session.enabledFeatures;if(enabledFeatures&&enabledFeatures.includes('depth-sensing')){const depthData=glBinding.getDepthInformation(views[0]);if(depthData&&depthData.isValid&&depthData.texture){depthSensing.init(renderer,depthData,session.renderState);}}}//
	for(let i=0;i<controllers.length;i++){const inputSource=controllerInputSources[i];const controller=controllers[i];if(inputSource!==null&&controller!==undefined){controller.update(inputSource,frame,customReferenceSpace||referenceSpace);}}if(onAnimationFrameCallback)onAnimationFrameCallback(time,frame);if(frame.detectedPlanes){scope.dispatchEvent({type:'planesdetected',data:frame});}xrFrame=null;}const animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;};this.dispose=function(){};}}const _e1=/*@__PURE__*/new Euler$1();const _m1$3=/*@__PURE__*/new Matrix4$1();function WebGLMaterials(renderer,properties){function refreshTransformUniform(map,uniform){if(map.matrixAutoUpdate===true){map.updateMatrix();}uniform.value.copy(map.matrix);}function refreshFogUniforms(uniforms,fog){fog.color.getRGB(uniforms.fogColor.value,getUnlitUniformColorSpace(renderer));if(fog.isFog){uniforms.fogNear.value=fog.near;uniforms.fogFar.value=fog.far;}else if(fog.isFogExp2){uniforms.fogDensity.value=fog.density;}}function refreshMaterialUniforms(uniforms,material,pixelRatio,height,transmissionRenderTarget){if(material.isMeshBasicMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isMeshLambertMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isMeshToonMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsToon(uniforms,material);}else if(material.isMeshPhongMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsPhong(uniforms,material);}else if(material.isMeshStandardMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsStandard(uniforms,material);if(material.isMeshPhysicalMaterial){refreshUniformsPhysical(uniforms,material,transmissionRenderTarget);}}else if(material.isMeshMatcapMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsMatcap(uniforms,material);}else if(material.isMeshDepthMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isMeshDistanceMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsDistance(uniforms,material);}else if(material.isMeshNormalMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isLineBasicMaterial){refreshUniformsLine(uniforms,material);if(material.isLineDashedMaterial){refreshUniformsDash(uniforms,material);}}else if(material.isPointsMaterial){refreshUniformsPoints(uniforms,material,pixelRatio,height);}else if(material.isSpriteMaterial){refreshUniformsSprites(uniforms,material);}else if(material.isShadowMaterial){uniforms.color.value.copy(material.color);uniforms.opacity.value=material.opacity;}else if(material.isShaderMaterial){material.uniformsNeedUpdate=false;// #15581
	}}function refreshUniformsCommon(uniforms,material){uniforms.opacity.value=material.opacity;if(material.color){uniforms.diffuse.value.copy(material.color);}if(material.emissive){uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);}if(material.map){uniforms.map.value=material.map;refreshTransformUniform(material.map,uniforms.mapTransform);}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;refreshTransformUniform(material.alphaMap,uniforms.alphaMapTransform);}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;refreshTransformUniform(material.bumpMap,uniforms.bumpMapTransform);uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide){uniforms.bumpScale.value*=-1;}}if(material.normalMap){uniforms.normalMap.value=material.normalMap;refreshTransformUniform(material.normalMap,uniforms.normalMapTransform);uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide){uniforms.normalScale.value.negate();}}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;refreshTransformUniform(material.displacementMap,uniforms.displacementMapTransform);uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;refreshTransformUniform(material.emissiveMap,uniforms.emissiveMapTransform);}if(material.specularMap){uniforms.specularMap.value=material.specularMap;refreshTransformUniform(material.specularMap,uniforms.specularMapTransform);}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}const materialProperties=properties.get(material);const envMap=materialProperties.envMap;const envMapRotation=materialProperties.envMapRotation;if(envMap){uniforms.envMap.value=envMap;_e1.copy(envMapRotation);// accommodate left-handed frame
	_e1.x*=-1;_e1.y*=-1;_e1.z*=-1;if(envMap.isCubeTexture&&envMap.isRenderTargetTexture===false){// environment maps which are not cube render targets or PMREMs follow a different convention
	_e1.y*=-1;_e1.z*=-1;}uniforms.envMapRotation.value.setFromMatrix4(_m1$3.makeRotationFromEuler(_e1));uniforms.flipEnvMap.value=envMap.isCubeTexture&&envMap.isRenderTargetTexture===false?-1:1;uniforms.reflectivity.value=material.reflectivity;uniforms.ior.value=material.ior;uniforms.refractionRatio.value=material.refractionRatio;}if(material.lightMap){uniforms.lightMap.value=material.lightMap;uniforms.lightMapIntensity.value=material.lightMapIntensity;refreshTransformUniform(material.lightMap,uniforms.lightMapTransform);}if(material.aoMap){uniforms.aoMap.value=material.aoMap;uniforms.aoMapIntensity.value=material.aoMapIntensity;refreshTransformUniform(material.aoMap,uniforms.aoMapTransform);}}function refreshUniformsLine(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;if(material.map){uniforms.map.value=material.map;refreshTransformUniform(material.map,uniforms.mapTransform);}}function refreshUniformsDash(uniforms,material){uniforms.dashSize.value=material.dashSize;uniforms.totalSize.value=material.dashSize+material.gapSize;uniforms.scale.value=material.scale;}function refreshUniformsPoints(uniforms,material,pixelRatio,height){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.size.value=material.size*pixelRatio;uniforms.scale.value=height*0.5;if(material.map){uniforms.map.value=material.map;refreshTransformUniform(material.map,uniforms.uvTransform);}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;refreshTransformUniform(material.alphaMap,uniforms.alphaMapTransform);}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}}function refreshUniformsSprites(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.rotation.value=material.rotation;if(material.map){uniforms.map.value=material.map;refreshTransformUniform(material.map,uniforms.mapTransform);}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;refreshTransformUniform(material.alphaMap,uniforms.alphaMapTransform);}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}}function refreshUniformsPhong(uniforms,material){uniforms.specular.value.copy(material.specular);uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )
	}function refreshUniformsToon(uniforms,material){if(material.gradientMap){uniforms.gradientMap.value=material.gradientMap;}}function refreshUniformsStandard(uniforms,material){uniforms.metalness.value=material.metalness;if(material.metalnessMap){uniforms.metalnessMap.value=material.metalnessMap;refreshTransformUniform(material.metalnessMap,uniforms.metalnessMapTransform);}uniforms.roughness.value=material.roughness;if(material.roughnessMap){uniforms.roughnessMap.value=material.roughnessMap;refreshTransformUniform(material.roughnessMap,uniforms.roughnessMapTransform);}if(material.envMap){//uniforms.envMap.value = material.envMap; // part of uniforms common
	uniforms.envMapIntensity.value=material.envMapIntensity;}}function refreshUniformsPhysical(uniforms,material,transmissionRenderTarget){uniforms.ior.value=material.ior;// also part of uniforms common
	if(material.sheen>0){uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);uniforms.sheenRoughness.value=material.sheenRoughness;if(material.sheenColorMap){uniforms.sheenColorMap.value=material.sheenColorMap;refreshTransformUniform(material.sheenColorMap,uniforms.sheenColorMapTransform);}if(material.sheenRoughnessMap){uniforms.sheenRoughnessMap.value=material.sheenRoughnessMap;refreshTransformUniform(material.sheenRoughnessMap,uniforms.sheenRoughnessMapTransform);}}if(material.clearcoat>0){uniforms.clearcoat.value=material.clearcoat;uniforms.clearcoatRoughness.value=material.clearcoatRoughness;if(material.clearcoatMap){uniforms.clearcoatMap.value=material.clearcoatMap;refreshTransformUniform(material.clearcoatMap,uniforms.clearcoatMapTransform);}if(material.clearcoatRoughnessMap){uniforms.clearcoatRoughnessMap.value=material.clearcoatRoughnessMap;refreshTransformUniform(material.clearcoatRoughnessMap,uniforms.clearcoatRoughnessMapTransform);}if(material.clearcoatNormalMap){uniforms.clearcoatNormalMap.value=material.clearcoatNormalMap;refreshTransformUniform(material.clearcoatNormalMap,uniforms.clearcoatNormalMapTransform);uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);if(material.side===BackSide){uniforms.clearcoatNormalScale.value.negate();}}}if(material.dispersion>0){uniforms.dispersion.value=material.dispersion;}if(material.iridescence>0){uniforms.iridescence.value=material.iridescence;uniforms.iridescenceIOR.value=material.iridescenceIOR;uniforms.iridescenceThicknessMinimum.value=material.iridescenceThicknessRange[0];uniforms.iridescenceThicknessMaximum.value=material.iridescenceThicknessRange[1];if(material.iridescenceMap){uniforms.iridescenceMap.value=material.iridescenceMap;refreshTransformUniform(material.iridescenceMap,uniforms.iridescenceMapTransform);}if(material.iridescenceThicknessMap){uniforms.iridescenceThicknessMap.value=material.iridescenceThicknessMap;refreshTransformUniform(material.iridescenceThicknessMap,uniforms.iridescenceThicknessMapTransform);}}if(material.transmission>0){uniforms.transmission.value=material.transmission;uniforms.transmissionSamplerMap.value=transmissionRenderTarget.texture;uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width,transmissionRenderTarget.height);if(material.transmissionMap){uniforms.transmissionMap.value=material.transmissionMap;refreshTransformUniform(material.transmissionMap,uniforms.transmissionMapTransform);}uniforms.thickness.value=material.thickness;if(material.thicknessMap){uniforms.thicknessMap.value=material.thicknessMap;refreshTransformUniform(material.thicknessMap,uniforms.thicknessMapTransform);}uniforms.attenuationDistance.value=material.attenuationDistance;uniforms.attenuationColor.value.copy(material.attenuationColor);}if(material.anisotropy>0){uniforms.anisotropyVector.value.set(material.anisotropy*Math.cos(material.anisotropyRotation),material.anisotropy*Math.sin(material.anisotropyRotation));if(material.anisotropyMap){uniforms.anisotropyMap.value=material.anisotropyMap;refreshTransformUniform(material.anisotropyMap,uniforms.anisotropyMapTransform);}}uniforms.specularIntensity.value=material.specularIntensity;uniforms.specularColor.value.copy(material.specularColor);if(material.specularColorMap){uniforms.specularColorMap.value=material.specularColorMap;refreshTransformUniform(material.specularColorMap,uniforms.specularColorMapTransform);}if(material.specularIntensityMap){uniforms.specularIntensityMap.value=material.specularIntensityMap;refreshTransformUniform(material.specularIntensityMap,uniforms.specularIntensityMapTransform);}}function refreshUniformsMatcap(uniforms,material){if(material.matcap){uniforms.matcap.value=material.matcap;}}function refreshUniformsDistance(uniforms,material){const light=properties.get(material).light;uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);uniforms.nearDistance.value=light.shadow.camera.near;uniforms.farDistance.value=light.shadow.camera.far;}return {refreshFogUniforms:refreshFogUniforms,refreshMaterialUniforms:refreshMaterialUniforms};}function WebGLUniformsGroups(gl,info,capabilities,state){let buffers={};let updateList={};let allocatedBindingPoints=[];const maxBindingPoints=gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);// binding points are global whereas block indices are per shader program
	function bind(uniformsGroup,program){const webglProgram=program.program;state.uniformBlockBinding(uniformsGroup,webglProgram);}function update(uniformsGroup,program){let buffer=buffers[uniformsGroup.id];if(buffer===undefined){prepareUniformsGroup(uniformsGroup);buffer=createBuffer(uniformsGroup);buffers[uniformsGroup.id]=buffer;uniformsGroup.addEventListener('dispose',onUniformsGroupsDispose);}// ensure to update the binding points/block indices mapping for this program
	const webglProgram=program.program;state.updateUBOMapping(uniformsGroup,webglProgram);// update UBO once per frame
	const frame=info.render.frame;if(updateList[uniformsGroup.id]!==frame){updateBufferData(uniformsGroup);updateList[uniformsGroup.id]=frame;}}function createBuffer(uniformsGroup){// the setup of an UBO is independent of a particular shader program but global
	const bindingPointIndex=allocateBindingPointIndex();uniformsGroup.__bindingPointIndex=bindingPointIndex;const buffer=gl.createBuffer();const size=uniformsGroup.__size;const usage=uniformsGroup.usage;gl.bindBuffer(gl.UNIFORM_BUFFER,buffer);gl.bufferData(gl.UNIFORM_BUFFER,size,usage);gl.bindBuffer(gl.UNIFORM_BUFFER,null);gl.bindBufferBase(gl.UNIFORM_BUFFER,bindingPointIndex,buffer);return buffer;}function allocateBindingPointIndex(){for(let i=0;i<maxBindingPoints;i++){if(allocatedBindingPoints.indexOf(i)===-1){allocatedBindingPoints.push(i);return i;}}console.error('THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.');return 0;}function updateBufferData(uniformsGroup){const buffer=buffers[uniformsGroup.id];const uniforms=uniformsGroup.uniforms;const cache=uniformsGroup.__cache;gl.bindBuffer(gl.UNIFORM_BUFFER,buffer);for(let i=0,il=uniforms.length;i<il;i++){const uniformArray=Array.isArray(uniforms[i])?uniforms[i]:[uniforms[i]];for(let j=0,jl=uniformArray.length;j<jl;j++){const uniform=uniformArray[j];if(hasUniformChanged(uniform,i,j,cache)===true){const offset=uniform.__offset;const values=Array.isArray(uniform.value)?uniform.value:[uniform.value];let arrayOffset=0;for(let k=0;k<values.length;k++){const value=values[k];const info=getUniformSize(value);// TODO add integer and struct support
	if(typeof value==='number'||typeof value==='boolean'){uniform.__data[0]=value;gl.bufferSubData(gl.UNIFORM_BUFFER,offset+arrayOffset,uniform.__data);}else if(value.isMatrix3){// manually converting 3x3 to 3x4
	uniform.__data[0]=value.elements[0];uniform.__data[1]=value.elements[1];uniform.__data[2]=value.elements[2];uniform.__data[3]=0;uniform.__data[4]=value.elements[3];uniform.__data[5]=value.elements[4];uniform.__data[6]=value.elements[5];uniform.__data[7]=0;uniform.__data[8]=value.elements[6];uniform.__data[9]=value.elements[7];uniform.__data[10]=value.elements[8];uniform.__data[11]=0;}else {value.toArray(uniform.__data,arrayOffset);arrayOffset+=info.storage/Float32Array.BYTES_PER_ELEMENT;}}gl.bufferSubData(gl.UNIFORM_BUFFER,offset,uniform.__data);}}}gl.bindBuffer(gl.UNIFORM_BUFFER,null);}function hasUniformChanged(uniform,index,indexArray,cache){const value=uniform.value;const indexString=index+'_'+indexArray;if(cache[indexString]===undefined){// cache entry does not exist so far
	if(typeof value==='number'||typeof value==='boolean'){cache[indexString]=value;}else {cache[indexString]=value.clone();}return true;}else {const cachedObject=cache[indexString];// compare current value with cached entry
	if(typeof value==='number'||typeof value==='boolean'){if(cachedObject!==value){cache[indexString]=value;return true;}}else {if(cachedObject.equals(value)===false){cachedObject.copy(value);return true;}}}return false;}function prepareUniformsGroup(uniformsGroup){// determine total buffer size according to the STD140 layout
	// Hint: STD140 is the only supported layout in WebGL 2
	const uniforms=uniformsGroup.uniforms;let offset=0;// global buffer offset in bytes
	const chunkSize=16;// size of a chunk in bytes
	for(let i=0,l=uniforms.length;i<l;i++){const uniformArray=Array.isArray(uniforms[i])?uniforms[i]:[uniforms[i]];for(let j=0,jl=uniformArray.length;j<jl;j++){const uniform=uniformArray[j];const values=Array.isArray(uniform.value)?uniform.value:[uniform.value];for(let k=0,kl=values.length;k<kl;k++){const value=values[k];const info=getUniformSize(value);const chunkOffset=offset%chunkSize;// offset in the current chunk
	const chunkPadding=chunkOffset%info.boundary;// required padding to match boundary
	const chunkStart=chunkOffset+chunkPadding;// the start position in the current chunk for the data
	offset+=chunkPadding;// Check for chunk overflow
	if(chunkStart!==0&&chunkSize-chunkStart<info.storage){// Add padding and adjust offset
	offset+=chunkSize-chunkStart;}// the following two properties will be used for partial buffer updates
	uniform.__data=new Float32Array(info.storage/Float32Array.BYTES_PER_ELEMENT);uniform.__offset=offset;// Update the global offset
	offset+=info.storage;}}}// ensure correct final padding
	const chunkOffset=offset%chunkSize;if(chunkOffset>0)offset+=chunkSize-chunkOffset;//
	uniformsGroup.__size=offset;uniformsGroup.__cache={};return this;}function getUniformSize(value){const info={boundary:0,// bytes
	storage:0// bytes
	};// determine sizes according to STD140
	if(typeof value==='number'||typeof value==='boolean'){// float/int/bool
	info.boundary=4;info.storage=4;}else if(value.isVector2){// vec2
	info.boundary=8;info.storage=8;}else if(value.isVector3||value.isColor){// vec3
	info.boundary=16;info.storage=12;// evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes
	}else if(value.isVector4){// vec4
	info.boundary=16;info.storage=16;}else if(value.isMatrix3){// mat3 (in STD140 a 3x3 matrix is represented as 3x4)
	info.boundary=48;info.storage=48;}else if(value.isMatrix4){// mat4
	info.boundary=64;info.storage=64;}else if(value.isTexture){console.warn('THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.');}else {console.warn('THREE.WebGLRenderer: Unsupported uniform value type.',value);}return info;}function onUniformsGroupsDispose(event){const uniformsGroup=event.target;uniformsGroup.removeEventListener('dispose',onUniformsGroupsDispose);const index=allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);allocatedBindingPoints.splice(index,1);gl.deleteBuffer(buffers[uniformsGroup.id]);delete buffers[uniformsGroup.id];delete updateList[uniformsGroup.id];}function dispose(){for(const id in buffers){gl.deleteBuffer(buffers[id]);}allocatedBindingPoints=[];buffers={};updateList={};}return {bind:bind,update:update,dispose:dispose};}class WebGLRenderer{constructor(parameters={}){const{canvas=createCanvasElement(),context=null,depth=true,stencil=false,alpha=false,antialias=false,premultipliedAlpha=true,preserveDrawingBuffer=false,powerPreference='default',failIfMajorPerformanceCaveat=false,reverseDepthBuffer=false}=parameters;this.isWebGLRenderer=true;let _alpha;if(context!==null){if(typeof WebGLRenderingContext!=='undefined'&&context instanceof WebGLRenderingContext){throw new Error('THREE.WebGLRenderer: WebGL 1 is not supported since r163.');}_alpha=context.getContextAttributes().alpha;}else {_alpha=alpha;}const uintClearColor=new Uint32Array(4);const intClearColor=new Int32Array(4);let currentRenderList=null;let currentRenderState=null;// render() can be called from within a callback triggered by another render.
	// We track this so that the nested render call gets its list and state isolated from the parent render call.
	const renderListStack=[];const renderStateStack=[];// public properties
	this.domElement=canvas;// Debug configuration container
	this.debug={/**
				 * Enables error checking and reporting when shader programs are being compiled
				 * @type {boolean}
				 */checkShaderErrors:true,/**
				 * Callback for custom error reporting.
				 * @type {?Function}
				 */onShaderError:null};// clearing
	this.autoClear=true;this.autoClearColor=true;this.autoClearDepth=true;this.autoClearStencil=true;// scene graph
	this.sortObjects=true;// user-defined clipping
	this.clippingPlanes=[];this.localClippingEnabled=false;// physically based shading
	this._outputColorSpace=SRGBColorSpace;// tone mapping
	this.toneMapping=NoToneMapping;this.toneMappingExposure=1.0;// internal properties
	const _this=this;let _isContextLost=false;// internal state cache
	let _currentActiveCubeFace=0;let _currentActiveMipmapLevel=0;let _currentRenderTarget=null;let _currentMaterialId=-1;let _currentCamera=null;const _currentViewport=new Vector4();const _currentScissor=new Vector4();let _currentScissorTest=null;const _currentClearColor=new Color(0x000000);let _currentClearAlpha=0;//
	let _width=canvas.width;let _height=canvas.height;let _pixelRatio=1;let _opaqueSort=null;let _transparentSort=null;const _viewport=new Vector4(0,0,_width,_height);const _scissor=new Vector4(0,0,_width,_height);let _scissorTest=false;// frustum
	const _frustum=new Frustum();// clipping
	let _clippingEnabled=false;let _localClippingEnabled=false;// camera matrices cache
	const _currentProjectionMatrix=new Matrix4$1();const _projScreenMatrix=new Matrix4$1();const _vector3=new Vector3$1();const _vector4=new Vector4();const _emptyScene={background:null,fog:null,environment:null,overrideMaterial:null,isScene:true};let _renderBackground=false;function getTargetPixelRatio(){return _currentRenderTarget===null?_pixelRatio:1;}// initialize
	let _gl=context;function getContext(contextName,contextAttributes){return canvas.getContext(contextName,contextAttributes);}try{const contextAttributes={alpha:true,depth,stencil,antialias,premultipliedAlpha,preserveDrawingBuffer,powerPreference,failIfMajorPerformanceCaveat};// OffscreenCanvas does not have setAttribute, see #22811
	if('setAttribute'in canvas)canvas.setAttribute('data-engine',`three.js r${REVISION}`);// event listeners must be registered before WebGL context is created, see #12753
	canvas.addEventListener('webglcontextlost',onContextLost,false);canvas.addEventListener('webglcontextrestored',onContextRestore,false);canvas.addEventListener('webglcontextcreationerror',onContextCreationError,false);if(_gl===null){const contextName='webgl2';_gl=getContext(contextName,contextAttributes);if(_gl===null){if(getContext(contextName)){throw new Error('Error creating WebGL context with your selected attributes.');}else {throw new Error('Error creating WebGL context.');}}}}catch(error){console.error('THREE.WebGLRenderer: '+error.message);throw error;}let extensions,capabilities,state,info;let properties,textures,cubemaps,cubeuvmaps,attributes,geometries,objects;let programCache,materials,renderLists,renderStates,clipping,shadowMap;let background,morphtargets,bufferRenderer,indexedBufferRenderer;let utils,bindingStates,uniformsGroups;function initGLContext(){extensions=new WebGLExtensions(_gl);extensions.init();utils=new WebGLUtils(_gl,extensions);capabilities=new WebGLCapabilities(_gl,extensions,parameters,utils);state=new WebGLState(_gl,extensions);if(capabilities.reverseDepthBuffer&&reverseDepthBuffer){state.buffers.depth.setReversed(true);}info=new WebGLInfo(_gl);properties=new WebGLProperties();textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info);cubemaps=new WebGLCubeMaps(_this);cubeuvmaps=new WebGLCubeUVMaps(_this);attributes=new WebGLAttributes(_gl);bindingStates=new WebGLBindingStates(_gl,attributes);geometries=new WebGLGeometries(_gl,attributes,info,bindingStates);objects=new WebGLObjects(_gl,geometries,attributes,info);morphtargets=new WebGLMorphtargets(_gl,capabilities,textures);clipping=new WebGLClipping(properties);programCache=new WebGLPrograms(_this,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping);materials=new WebGLMaterials(_this,properties);renderLists=new WebGLRenderLists();renderStates=new WebGLRenderStates(extensions);background=new WebGLBackground(_this,cubemaps,cubeuvmaps,state,objects,_alpha,premultipliedAlpha);shadowMap=new WebGLShadowMap(_this,objects,capabilities);uniformsGroups=new WebGLUniformsGroups(_gl,info,capabilities,state);bufferRenderer=new WebGLBufferRenderer(_gl,extensions,info);indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,info);info.programs=programCache.programs;_this.capabilities=capabilities;_this.extensions=extensions;_this.properties=properties;_this.renderLists=renderLists;_this.shadowMap=shadowMap;_this.state=state;_this.info=info;}initGLContext();// xr
	const xr=new WebXRManager(_this,_gl);this.xr=xr;// API
	this.getContext=function(){return _gl;};this.getContextAttributes=function(){return _gl.getContextAttributes();};this.forceContextLoss=function(){const extension=extensions.get('WEBGL_lose_context');if(extension)extension.loseContext();};this.forceContextRestore=function(){const extension=extensions.get('WEBGL_lose_context');if(extension)extension.restoreContext();};this.getPixelRatio=function(){return _pixelRatio;};this.setPixelRatio=function(value){if(value===undefined)return;_pixelRatio=value;this.setSize(_width,_height,false);};this.getSize=function(target){return target.set(_width,_height);};this.setSize=function(width,height,updateStyle=true){if(xr.isPresenting){console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');return;}_width=width;_height=height;canvas.width=Math.floor(width*_pixelRatio);canvas.height=Math.floor(height*_pixelRatio);if(updateStyle===true){canvas.style.width=width+'px';canvas.style.height=height+'px';}this.setViewport(0,0,width,height);};this.getDrawingBufferSize=function(target){return target.set(_width*_pixelRatio,_height*_pixelRatio).floor();};this.setDrawingBufferSize=function(width,height,pixelRatio){_width=width;_height=height;_pixelRatio=pixelRatio;canvas.width=Math.floor(width*pixelRatio);canvas.height=Math.floor(height*pixelRatio);this.setViewport(0,0,width,height);};this.getCurrentViewport=function(target){return target.copy(_currentViewport);};this.getViewport=function(target){return target.copy(_viewport);};this.setViewport=function(x,y,width,height){if(x.isVector4){_viewport.set(x.x,x.y,x.z,x.w);}else {_viewport.set(x,y,width,height);}state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round());};this.getScissor=function(target){return target.copy(_scissor);};this.setScissor=function(x,y,width,height){if(x.isVector4){_scissor.set(x.x,x.y,x.z,x.w);}else {_scissor.set(x,y,width,height);}state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());};this.getScissorTest=function(){return _scissorTest;};this.setScissorTest=function(boolean){state.setScissorTest(_scissorTest=boolean);};this.setOpaqueSort=function(method){_opaqueSort=method;};this.setTransparentSort=function(method){_transparentSort=method;};// Clearing
	this.getClearColor=function(target){return target.copy(background.getClearColor());};this.setClearColor=function(){background.setClearColor.apply(background,arguments);};this.getClearAlpha=function(){return background.getClearAlpha();};this.setClearAlpha=function(){background.setClearAlpha.apply(background,arguments);};this.clear=function(color=true,depth=true,stencil=true){let bits=0;if(color){// check if we're trying to clear an integer target
	let isIntegerFormat=false;if(_currentRenderTarget!==null){const targetFormat=_currentRenderTarget.texture.format;isIntegerFormat=targetFormat===RGBAIntegerFormat||targetFormat===RGIntegerFormat||targetFormat===RedIntegerFormat;}// use the appropriate clear functions to clear the target if it's a signed
	// or unsigned integer target
	if(isIntegerFormat){const targetType=_currentRenderTarget.texture.type;const isUnsignedType=targetType===UnsignedByteType||targetType===UnsignedIntType||targetType===UnsignedShortType||targetType===UnsignedInt248Type||targetType===UnsignedShort4444Type||targetType===UnsignedShort5551Type;const clearColor=background.getClearColor();const a=background.getClearAlpha();const r=clearColor.r;const g=clearColor.g;const b=clearColor.b;if(isUnsignedType){uintClearColor[0]=r;uintClearColor[1]=g;uintClearColor[2]=b;uintClearColor[3]=a;_gl.clearBufferuiv(_gl.COLOR,0,uintClearColor);}else {intClearColor[0]=r;intClearColor[1]=g;intClearColor[2]=b;intClearColor[3]=a;_gl.clearBufferiv(_gl.COLOR,0,intClearColor);}}else {bits|=_gl.COLOR_BUFFER_BIT;}}if(depth){bits|=_gl.DEPTH_BUFFER_BIT;}if(stencil){bits|=_gl.STENCIL_BUFFER_BIT;this.state.buffers.stencil.setMask(0xffffffff);}_gl.clear(bits);};this.clearColor=function(){this.clear(true,false,false);};this.clearDepth=function(){this.clear(false,true,false);};this.clearStencil=function(){this.clear(false,false,true);};//
	this.dispose=function(){canvas.removeEventListener('webglcontextlost',onContextLost,false);canvas.removeEventListener('webglcontextrestored',onContextRestore,false);canvas.removeEventListener('webglcontextcreationerror',onContextCreationError,false);background.dispose();renderLists.dispose();renderStates.dispose();properties.dispose();cubemaps.dispose();cubeuvmaps.dispose();objects.dispose();bindingStates.dispose();uniformsGroups.dispose();programCache.dispose();xr.dispose();xr.removeEventListener('sessionstart',onXRSessionStart);xr.removeEventListener('sessionend',onXRSessionEnd);animation.stop();};// Events
	function onContextLost(event){event.preventDefault();console.log('THREE.WebGLRenderer: Context Lost.');_isContextLost=true;}function onContextRestore(/* event */){console.log('THREE.WebGLRenderer: Context Restored.');_isContextLost=false;const infoAutoReset=info.autoReset;const shadowMapEnabled=shadowMap.enabled;const shadowMapAutoUpdate=shadowMap.autoUpdate;const shadowMapNeedsUpdate=shadowMap.needsUpdate;const shadowMapType=shadowMap.type;initGLContext();info.autoReset=infoAutoReset;shadowMap.enabled=shadowMapEnabled;shadowMap.autoUpdate=shadowMapAutoUpdate;shadowMap.needsUpdate=shadowMapNeedsUpdate;shadowMap.type=shadowMapType;}function onContextCreationError(event){console.error('THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',event.statusMessage);}function onMaterialDispose(event){const material=event.target;material.removeEventListener('dispose',onMaterialDispose);deallocateMaterial(material);}// Buffer deallocation
	function deallocateMaterial(material){releaseMaterialProgramReferences(material);properties.remove(material);}function releaseMaterialProgramReferences(material){const programs=properties.get(material).programs;if(programs!==undefined){programs.forEach(function(program){programCache.releaseProgram(program);});if(material.isShaderMaterial){programCache.releaseShaderCache(material);}}}// Buffer rendering
	this.renderBufferDirect=function(camera,scene,geometry,material,object,group){if(scene===null)scene=_emptyScene;// renderBufferDirect second parameter used to be fog (could be null)
	const frontFaceCW=object.isMesh&&object.matrixWorld.determinant()<0;const program=setProgram(camera,scene,geometry,material,object);state.setMaterial(material,frontFaceCW);//
	let index=geometry.index;let rangeFactor=1;if(material.wireframe===true){index=geometries.getWireframeAttribute(geometry);if(index===undefined)return;rangeFactor=2;}//
	const drawRange=geometry.drawRange;const position=geometry.attributes.position;let drawStart=drawRange.start*rangeFactor;let drawEnd=(drawRange.start+drawRange.count)*rangeFactor;if(group!==null){drawStart=Math.max(drawStart,group.start*rangeFactor);drawEnd=Math.min(drawEnd,(group.start+group.count)*rangeFactor);}if(index!==null){drawStart=Math.max(drawStart,0);drawEnd=Math.min(drawEnd,index.count);}else if(position!==undefined&&position!==null){drawStart=Math.max(drawStart,0);drawEnd=Math.min(drawEnd,position.count);}const drawCount=drawEnd-drawStart;if(drawCount<0||drawCount===Infinity)return;//
	bindingStates.setup(object,material,program,geometry,index);let attribute;let renderer=bufferRenderer;if(index!==null){attribute=attributes.get(index);renderer=indexedBufferRenderer;renderer.setIndex(attribute);}//
	if(object.isMesh){if(material.wireframe===true){state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());renderer.setMode(_gl.LINES);}else {renderer.setMode(_gl.TRIANGLES);}}else if(object.isLine){let lineWidth=material.linewidth;if(lineWidth===undefined)lineWidth=1;// Not using Line*Material
	state.setLineWidth(lineWidth*getTargetPixelRatio());if(object.isLineSegments){renderer.setMode(_gl.LINES);}else if(object.isLineLoop){renderer.setMode(_gl.LINE_LOOP);}else {renderer.setMode(_gl.LINE_STRIP);}}else if(object.isPoints){renderer.setMode(_gl.POINTS);}else if(object.isSprite){renderer.setMode(_gl.TRIANGLES);}if(object.isBatchedMesh){if(object._multiDrawInstances!==null){renderer.renderMultiDrawInstances(object._multiDrawStarts,object._multiDrawCounts,object._multiDrawCount,object._multiDrawInstances);}else {if(!extensions.get('WEBGL_multi_draw')){const starts=object._multiDrawStarts;const counts=object._multiDrawCounts;const drawCount=object._multiDrawCount;const bytesPerElement=index?attributes.get(index).bytesPerElement:1;const uniforms=properties.get(material).currentProgram.getUniforms();for(let i=0;i<drawCount;i++){uniforms.setValue(_gl,'_gl_DrawID',i);renderer.render(starts[i]/bytesPerElement,counts[i]);}}else {renderer.renderMultiDraw(object._multiDrawStarts,object._multiDrawCounts,object._multiDrawCount);}}}else if(object.isInstancedMesh){renderer.renderInstances(drawStart,drawCount,object.count);}else if(geometry.isInstancedBufferGeometry){const maxInstanceCount=geometry._maxInstanceCount!==undefined?geometry._maxInstanceCount:Infinity;const instanceCount=Math.min(geometry.instanceCount,maxInstanceCount);renderer.renderInstances(drawStart,drawCount,instanceCount);}else {renderer.render(drawStart,drawCount);}};// Compile
	function prepareMaterial(material,scene,object){if(material.transparent===true&&material.side===DoubleSide&&material.forceSinglePass===false){material.side=BackSide;material.needsUpdate=true;getProgram(material,scene,object);material.side=FrontSide;material.needsUpdate=true;getProgram(material,scene,object);material.side=DoubleSide;}else {getProgram(material,scene,object);}}this.compile=function(scene,camera,targetScene=null){if(targetScene===null)targetScene=scene;currentRenderState=renderStates.get(targetScene);currentRenderState.init(camera);renderStateStack.push(currentRenderState);// gather lights from both the target scene and the new object that will be added to the scene.
	targetScene.traverseVisible(function(object){if(object.isLight&&object.layers.test(camera.layers)){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}});if(scene!==targetScene){scene.traverseVisible(function(object){if(object.isLight&&object.layers.test(camera.layers)){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}});}currentRenderState.setupLights();// Only initialize materials in the new scene, not the targetScene.
	const materials=new Set();scene.traverse(function(object){if(!(object.isMesh||object.isPoints||object.isLine||object.isSprite)){return;}const material=object.material;if(material){if(Array.isArray(material)){for(let i=0;i<material.length;i++){const material2=material[i];prepareMaterial(material2,targetScene,object);materials.add(material2);}}else {prepareMaterial(material,targetScene,object);materials.add(material);}}});renderStateStack.pop();currentRenderState=null;return materials;};// compileAsync
	this.compileAsync=function(scene,camera,targetScene=null){const materials=this.compile(scene,camera,targetScene);// Wait for all the materials in the new object to indicate that they're
	// ready to be used before resolving the promise.
	return new Promise(resolve=>{function checkMaterialsReady(){materials.forEach(function(material){const materialProperties=properties.get(material);const program=materialProperties.currentProgram;if(program.isReady()){// remove any programs that report they're ready to use from the list
	materials.delete(material);}});// once the list of compiling materials is empty, call the callback
	if(materials.size===0){resolve(scene);return;}// if some materials are still not ready, wait a bit and check again
	setTimeout(checkMaterialsReady,10);}if(extensions.get('KHR_parallel_shader_compile')!==null){// If we can check the compilation status of the materials without
	// blocking then do so right away.
	checkMaterialsReady();}else {// Otherwise start by waiting a bit to give the materials we just
	// initialized a chance to finish.
	setTimeout(checkMaterialsReady,10);}});};// Animation Loop
	let onAnimationFrameCallback=null;function onAnimationFrame(time){if(onAnimationFrameCallback)onAnimationFrameCallback(time);}function onXRSessionStart(){animation.stop();}function onXRSessionEnd(){animation.start();}const animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);if(typeof self!=='undefined')animation.setContext(self);this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;xr.setAnimationLoop(callback);callback===null?animation.stop():animation.start();};xr.addEventListener('sessionstart',onXRSessionStart);xr.addEventListener('sessionend',onXRSessionEnd);// Rendering
	this.render=function(scene,camera){if(camera!==undefined&&camera.isCamera!==true){console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');return;}if(_isContextLost===true)return;// update scene graph
	if(scene.matrixWorldAutoUpdate===true)scene.updateMatrixWorld();// update camera matrices and frustum
	if(camera.parent===null&&camera.matrixWorldAutoUpdate===true)camera.updateMatrixWorld();if(xr.enabled===true&&xr.isPresenting===true){if(xr.cameraAutoUpdate===true)xr.updateCamera(camera);camera=xr.getCamera();// use XR camera for rendering
	}//
	if(scene.isScene===true)scene.onBeforeRender(_this,scene,camera,_currentRenderTarget);currentRenderState=renderStates.get(scene,renderStateStack.length);currentRenderState.init(camera);renderStateStack.push(currentRenderState);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);_frustum.setFromProjectionMatrix(_projScreenMatrix);_localClippingEnabled=this.localClippingEnabled;_clippingEnabled=clipping.init(this.clippingPlanes,_localClippingEnabled);currentRenderList=renderLists.get(scene,renderListStack.length);currentRenderList.init();renderListStack.push(currentRenderList);if(xr.enabled===true&&xr.isPresenting===true){const depthSensingMesh=_this.xr.getDepthSensingMesh();if(depthSensingMesh!==null){projectObject(depthSensingMesh,camera,-Infinity,_this.sortObjects);}}projectObject(scene,camera,0,_this.sortObjects);currentRenderList.finish();if(_this.sortObjects===true){currentRenderList.sort(_opaqueSort,_transparentSort);}_renderBackground=xr.enabled===false||xr.isPresenting===false||xr.hasDepthSensing()===false;if(_renderBackground){background.addToRenderList(currentRenderList,scene);}//
	this.info.render.frame++;if(_clippingEnabled===true)clipping.beginShadows();const shadowsArray=currentRenderState.state.shadowsArray;shadowMap.render(shadowsArray,scene,camera);if(_clippingEnabled===true)clipping.endShadows();//
	if(this.info.autoReset===true)this.info.reset();// render scene
	const opaqueObjects=currentRenderList.opaque;const transmissiveObjects=currentRenderList.transmissive;currentRenderState.setupLights();if(camera.isArrayCamera){const cameras=camera.cameras;if(transmissiveObjects.length>0){for(let i=0,l=cameras.length;i<l;i++){const camera2=cameras[i];renderTransmissionPass(opaqueObjects,transmissiveObjects,scene,camera2);}}if(_renderBackground)background.render(scene);for(let i=0,l=cameras.length;i<l;i++){const camera2=cameras[i];renderScene(currentRenderList,scene,camera2,camera2.viewport);}}else {if(transmissiveObjects.length>0)renderTransmissionPass(opaqueObjects,transmissiveObjects,scene,camera);if(_renderBackground)background.render(scene);renderScene(currentRenderList,scene,camera);}//
	if(_currentRenderTarget!==null){// resolve multisample renderbuffers to a single-sample texture if necessary
	textures.updateMultisampleRenderTarget(_currentRenderTarget);// Generate mipmap if we're using any kind of mipmap filtering
	textures.updateRenderTargetMipmap(_currentRenderTarget);}//
	if(scene.isScene===true)scene.onAfterRender(_this,scene,camera);// _gl.finish();
	bindingStates.resetDefaultState();_currentMaterialId=-1;_currentCamera=null;renderStateStack.pop();if(renderStateStack.length>0){currentRenderState=renderStateStack[renderStateStack.length-1];if(_clippingEnabled===true)clipping.setGlobalState(_this.clippingPlanes,currentRenderState.state.camera);}else {currentRenderState=null;}renderListStack.pop();if(renderListStack.length>0){currentRenderList=renderListStack[renderListStack.length-1];}else {currentRenderList=null;}};function projectObject(object,camera,groupOrder,sortObjects){if(object.visible===false)return;const visible=object.layers.test(camera.layers);if(visible){if(object.isGroup){groupOrder=object.renderOrder;}else if(object.isLOD){if(object.autoUpdate===true)object.update(camera);}else if(object.isLight){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}else if(object.isSprite){if(!object.frustumCulled||_frustum.intersectsSprite(object)){if(sortObjects){_vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}const geometry=objects.update(object);const material=object.material;if(material.visible){currentRenderList.push(object,geometry,material,groupOrder,_vector4.z,null);}}}else if(object.isMesh||object.isLine||object.isPoints){if(!object.frustumCulled||_frustum.intersectsObject(object)){const geometry=objects.update(object);const material=object.material;if(sortObjects){if(object.boundingSphere!==undefined){if(object.boundingSphere===null)object.computeBoundingSphere();_vector4.copy(object.boundingSphere.center);}else {if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_vector4.copy(geometry.boundingSphere.center);}_vector4.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);}if(Array.isArray(material)){const groups=geometry.groups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i];const groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){currentRenderList.push(object,geometry,groupMaterial,groupOrder,_vector4.z,group);}}}else if(material.visible){currentRenderList.push(object,geometry,material,groupOrder,_vector4.z,null);}}}}const children=object.children;for(let i=0,l=children.length;i<l;i++){projectObject(children[i],camera,groupOrder,sortObjects);}}function renderScene(currentRenderList,scene,camera,viewport){const opaqueObjects=currentRenderList.opaque;const transmissiveObjects=currentRenderList.transmissive;const transparentObjects=currentRenderList.transparent;currentRenderState.setupLightsView(camera);if(_clippingEnabled===true)clipping.setGlobalState(_this.clippingPlanes,camera);if(viewport)state.viewport(_currentViewport.copy(viewport));if(opaqueObjects.length>0)renderObjects(opaqueObjects,scene,camera);if(transmissiveObjects.length>0)renderObjects(transmissiveObjects,scene,camera);if(transparentObjects.length>0)renderObjects(transparentObjects,scene,camera);// Ensure depth buffer writing is enabled so it can be cleared on next render
	state.buffers.depth.setTest(true);state.buffers.depth.setMask(true);state.buffers.color.setMask(true);state.setPolygonOffset(false);}function renderTransmissionPass(opaqueObjects,transmissiveObjects,scene,camera){const overrideMaterial=scene.isScene===true?scene.overrideMaterial:null;if(overrideMaterial!==null){return;}if(currentRenderState.state.transmissionRenderTarget[camera.id]===undefined){currentRenderState.state.transmissionRenderTarget[camera.id]=new WebGLRenderTarget(1,1,{generateMipmaps:true,type:extensions.has('EXT_color_buffer_half_float')||extensions.has('EXT_color_buffer_float')?HalfFloatType:UnsignedByteType,minFilter:LinearMipmapLinearFilter,samples:4,stencilBuffer:stencil,resolveDepthBuffer:false,resolveStencilBuffer:false,colorSpace:ColorManagement.workingColorSpace});// debug
	/*
					const geometry = new PlaneGeometry();
					const material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );

					const mesh = new Mesh( geometry, material );
					scene.add( mesh );
					*/}const transmissionRenderTarget=currentRenderState.state.transmissionRenderTarget[camera.id];const activeViewport=camera.viewport||_currentViewport;transmissionRenderTarget.setSize(activeViewport.z,activeViewport.w);//
	const currentRenderTarget=_this.getRenderTarget();_this.setRenderTarget(transmissionRenderTarget);_this.getClearColor(_currentClearColor);_currentClearAlpha=_this.getClearAlpha();if(_currentClearAlpha<1)_this.setClearColor(0xffffff,0.5);_this.clear();if(_renderBackground)background.render(scene);// Turn off the features which can affect the frag color for opaque objects pass.
	// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
	const currentToneMapping=_this.toneMapping;_this.toneMapping=NoToneMapping;// Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).
	// Transmission render pass requires viewport to match the transmissionRenderTarget.
	const currentCameraViewport=camera.viewport;if(camera.viewport!==undefined)camera.viewport=undefined;currentRenderState.setupLightsView(camera);if(_clippingEnabled===true)clipping.setGlobalState(_this.clippingPlanes,camera);renderObjects(opaqueObjects,scene,camera);textures.updateMultisampleRenderTarget(transmissionRenderTarget);textures.updateRenderTargetMipmap(transmissionRenderTarget);if(extensions.has('WEBGL_multisampled_render_to_texture')===false){// see #28131
	let renderTargetNeedsUpdate=false;for(let i=0,l=transmissiveObjects.length;i<l;i++){const renderItem=transmissiveObjects[i];const object=renderItem.object;const geometry=renderItem.geometry;const material=renderItem.material;const group=renderItem.group;if(material.side===DoubleSide&&object.layers.test(camera.layers)){const currentSide=material.side;material.side=BackSide;material.needsUpdate=true;renderObject(object,scene,camera,geometry,material,group);material.side=currentSide;material.needsUpdate=true;renderTargetNeedsUpdate=true;}}if(renderTargetNeedsUpdate===true){textures.updateMultisampleRenderTarget(transmissionRenderTarget);textures.updateRenderTargetMipmap(transmissionRenderTarget);}}_this.setRenderTarget(currentRenderTarget);_this.setClearColor(_currentClearColor,_currentClearAlpha);if(currentCameraViewport!==undefined)camera.viewport=currentCameraViewport;_this.toneMapping=currentToneMapping;}function renderObjects(renderList,scene,camera){const overrideMaterial=scene.isScene===true?scene.overrideMaterial:null;for(let i=0,l=renderList.length;i<l;i++){const renderItem=renderList[i];const object=renderItem.object;const geometry=renderItem.geometry;const material=overrideMaterial===null?renderItem.material:overrideMaterial;const group=renderItem.group;if(object.layers.test(camera.layers)){renderObject(object,scene,camera,geometry,material,group);}}}function renderObject(object,scene,camera,geometry,material,group){object.onBeforeRender(_this,scene,camera,geometry,material,group);object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);object.normalMatrix.getNormalMatrix(object.modelViewMatrix);material.onBeforeRender(_this,scene,camera,geometry,object,group);if(material.transparent===true&&material.side===DoubleSide&&material.forceSinglePass===false){material.side=BackSide;material.needsUpdate=true;_this.renderBufferDirect(camera,scene,geometry,material,object,group);material.side=FrontSide;material.needsUpdate=true;_this.renderBufferDirect(camera,scene,geometry,material,object,group);material.side=DoubleSide;}else {_this.renderBufferDirect(camera,scene,geometry,material,object,group);}object.onAfterRender(_this,scene,camera,geometry,material,group);}function getProgram(material,scene,object){if(scene.isScene!==true)scene=_emptyScene;// scene could be a Mesh, Line, Points, ...
	const materialProperties=properties.get(material);const lights=currentRenderState.state.lights;const shadowsArray=currentRenderState.state.shadowsArray;const lightsStateVersion=lights.state.version;const parameters=programCache.getParameters(material,lights.state,shadowsArray,scene,object);const programCacheKey=programCache.getProgramCacheKey(parameters);let programs=materialProperties.programs;// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
	materialProperties.environment=material.isMeshStandardMaterial?scene.environment:null;materialProperties.fog=scene.fog;materialProperties.envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||materialProperties.environment);materialProperties.envMapRotation=materialProperties.environment!==null&&material.envMap===null?scene.environmentRotation:material.envMapRotation;if(programs===undefined){// new material
	material.addEventListener('dispose',onMaterialDispose);programs=new Map();materialProperties.programs=programs;}let program=programs.get(programCacheKey);if(program!==undefined){// early out if program and light state is identical
	if(materialProperties.currentProgram===program&&materialProperties.lightsStateVersion===lightsStateVersion){updateCommonMaterialProperties(material,parameters);return program;}}else {parameters.uniforms=programCache.getUniforms(material);material.onBeforeCompile(parameters,_this);program=programCache.acquireProgram(parameters,programCacheKey);programs.set(programCacheKey,program);materialProperties.uniforms=parameters.uniforms;}const uniforms=materialProperties.uniforms;if(!material.isShaderMaterial&&!material.isRawShaderMaterial||material.clipping===true){uniforms.clippingPlanes=clipping.uniform;}updateCommonMaterialProperties(material,parameters);// store the light setup it was created for
	materialProperties.needsLights=materialNeedsLights(material);materialProperties.lightsStateVersion=lightsStateVersion;if(materialProperties.needsLights){// wire up the material to this renderer's lighting state
	uniforms.ambientLightColor.value=lights.state.ambient;uniforms.lightProbe.value=lights.state.probe;uniforms.directionalLights.value=lights.state.directional;uniforms.directionalLightShadows.value=lights.state.directionalShadow;uniforms.spotLights.value=lights.state.spot;uniforms.spotLightShadows.value=lights.state.spotShadow;uniforms.rectAreaLights.value=lights.state.rectArea;uniforms.ltc_1.value=lights.state.rectAreaLTC1;uniforms.ltc_2.value=lights.state.rectAreaLTC2;uniforms.pointLights.value=lights.state.point;uniforms.pointLightShadows.value=lights.state.pointShadow;uniforms.hemisphereLights.value=lights.state.hemi;uniforms.directionalShadowMap.value=lights.state.directionalShadowMap;uniforms.directionalShadowMatrix.value=lights.state.directionalShadowMatrix;uniforms.spotShadowMap.value=lights.state.spotShadowMap;uniforms.spotLightMatrix.value=lights.state.spotLightMatrix;uniforms.spotLightMap.value=lights.state.spotLightMap;uniforms.pointShadowMap.value=lights.state.pointShadowMap;uniforms.pointShadowMatrix.value=lights.state.pointShadowMatrix;// TODO (abelnation): add area lights shadow info to uniforms
	}materialProperties.currentProgram=program;materialProperties.uniformsList=null;return program;}function getUniformList(materialProperties){if(materialProperties.uniformsList===null){const progUniforms=materialProperties.currentProgram.getUniforms();materialProperties.uniformsList=WebGLUniforms.seqWithValue(progUniforms.seq,materialProperties.uniforms);}return materialProperties.uniformsList;}function updateCommonMaterialProperties(material,parameters){const materialProperties=properties.get(material);materialProperties.outputColorSpace=parameters.outputColorSpace;materialProperties.batching=parameters.batching;materialProperties.batchingColor=parameters.batchingColor;materialProperties.instancing=parameters.instancing;materialProperties.instancingColor=parameters.instancingColor;materialProperties.instancingMorph=parameters.instancingMorph;materialProperties.skinning=parameters.skinning;materialProperties.morphTargets=parameters.morphTargets;materialProperties.morphNormals=parameters.morphNormals;materialProperties.morphColors=parameters.morphColors;materialProperties.morphTargetsCount=parameters.morphTargetsCount;materialProperties.numClippingPlanes=parameters.numClippingPlanes;materialProperties.numIntersection=parameters.numClipIntersection;materialProperties.vertexAlphas=parameters.vertexAlphas;materialProperties.vertexTangents=parameters.vertexTangents;materialProperties.toneMapping=parameters.toneMapping;}function setProgram(camera,scene,geometry,material,object){if(scene.isScene!==true)scene=_emptyScene;// scene could be a Mesh, Line, Points, ...
	textures.resetTextureUnits();const fog=scene.fog;const environment=material.isMeshStandardMaterial?scene.environment:null;const colorSpace=_currentRenderTarget===null?_this.outputColorSpace:_currentRenderTarget.isXRRenderTarget===true?_currentRenderTarget.texture.colorSpace:LinearSRGBColorSpace;const envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment);const vertexAlphas=material.vertexColors===true&&!!geometry.attributes.color&&geometry.attributes.color.itemSize===4;const vertexTangents=!!geometry.attributes.tangent&&(!!material.normalMap||material.anisotropy>0);const morphTargets=!!geometry.morphAttributes.position;const morphNormals=!!geometry.morphAttributes.normal;const morphColors=!!geometry.morphAttributes.color;let toneMapping=NoToneMapping;if(material.toneMapped){if(_currentRenderTarget===null||_currentRenderTarget.isXRRenderTarget===true){toneMapping=_this.toneMapping;}}const morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color;const morphTargetsCount=morphAttribute!==undefined?morphAttribute.length:0;const materialProperties=properties.get(material);const lights=currentRenderState.state.lights;if(_clippingEnabled===true){if(_localClippingEnabled===true||camera!==_currentCamera){const useCache=camera===_currentCamera&&material.id===_currentMaterialId;// we might want to call this function with some ClippingGroup
	// object instead of the material, once it becomes feasible
	// (#8465, #8379)
	clipping.setState(material,camera,useCache);}}//
	let needsProgramChange=false;if(material.version===materialProperties.__version){if(materialProperties.needsLights&&materialProperties.lightsStateVersion!==lights.state.version){needsProgramChange=true;}else if(materialProperties.outputColorSpace!==colorSpace){needsProgramChange=true;}else if(object.isBatchedMesh&&materialProperties.batching===false){needsProgramChange=true;}else if(!object.isBatchedMesh&&materialProperties.batching===true){needsProgramChange=true;}else if(object.isBatchedMesh&&materialProperties.batchingColor===true&&object.colorTexture===null){needsProgramChange=true;}else if(object.isBatchedMesh&&materialProperties.batchingColor===false&&object.colorTexture!==null){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancing===false){needsProgramChange=true;}else if(!object.isInstancedMesh&&materialProperties.instancing===true){needsProgramChange=true;}else if(object.isSkinnedMesh&&materialProperties.skinning===false){needsProgramChange=true;}else if(!object.isSkinnedMesh&&materialProperties.skinning===true){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancingColor===true&&object.instanceColor===null){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancingColor===false&&object.instanceColor!==null){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancingMorph===true&&object.morphTexture===null){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancingMorph===false&&object.morphTexture!==null){needsProgramChange=true;}else if(materialProperties.envMap!==envMap){needsProgramChange=true;}else if(material.fog===true&&materialProperties.fog!==fog){needsProgramChange=true;}else if(materialProperties.numClippingPlanes!==undefined&&(materialProperties.numClippingPlanes!==clipping.numPlanes||materialProperties.numIntersection!==clipping.numIntersection)){needsProgramChange=true;}else if(materialProperties.vertexAlphas!==vertexAlphas){needsProgramChange=true;}else if(materialProperties.vertexTangents!==vertexTangents){needsProgramChange=true;}else if(materialProperties.morphTargets!==morphTargets){needsProgramChange=true;}else if(materialProperties.morphNormals!==morphNormals){needsProgramChange=true;}else if(materialProperties.morphColors!==morphColors){needsProgramChange=true;}else if(materialProperties.toneMapping!==toneMapping){needsProgramChange=true;}else if(materialProperties.morphTargetsCount!==morphTargetsCount){needsProgramChange=true;}}else {needsProgramChange=true;materialProperties.__version=material.version;}//
	let program=materialProperties.currentProgram;if(needsProgramChange===true){program=getProgram(material,scene,object);}let refreshProgram=false;let refreshMaterial=false;let refreshLights=false;const p_uniforms=program.getUniforms(),m_uniforms=materialProperties.uniforms;if(state.useProgram(program.program)){refreshProgram=true;refreshMaterial=true;refreshLights=true;}if(material.id!==_currentMaterialId){_currentMaterialId=material.id;refreshMaterial=true;}if(refreshProgram||_currentCamera!==camera){// common camera uniforms
	const reverseDepthBuffer=state.buffers.depth.getReversed();if(reverseDepthBuffer){_currentProjectionMatrix.copy(camera.projectionMatrix);toNormalizedProjectionMatrix(_currentProjectionMatrix);toReversedProjectionMatrix(_currentProjectionMatrix);p_uniforms.setValue(_gl,'projectionMatrix',_currentProjectionMatrix);}else {p_uniforms.setValue(_gl,'projectionMatrix',camera.projectionMatrix);}p_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);const uCamPos=p_uniforms.map.cameraPosition;if(uCamPos!==undefined){uCamPos.setValue(_gl,_vector3.setFromMatrixPosition(camera.matrixWorld));}if(capabilities.logarithmicDepthBuffer){p_uniforms.setValue(_gl,'logDepthBufFC',2.0/(Math.log(camera.far+1.0)/Math.LN2));}// consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067
	if(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial){p_uniforms.setValue(_gl,'isOrthographic',camera.isOrthographicCamera===true);}if(_currentCamera!==camera){_currentCamera=camera;// lighting uniforms depend on the camera so enforce an update
	// now, in case this material supports lights - or later, when
	// the next material that does gets activated:
	refreshMaterial=true;// set to true on material change
	refreshLights=true;// remains set until update done
	}}// skinning and morph target uniforms must be set even if material didn't change
	// auto-setting of texture unit for bone and morph texture must go before other textures
	// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures
	if(object.isSkinnedMesh){p_uniforms.setOptional(_gl,object,'bindMatrix');p_uniforms.setOptional(_gl,object,'bindMatrixInverse');const skeleton=object.skeleton;if(skeleton){if(skeleton.boneTexture===null)skeleton.computeBoneTexture();p_uniforms.setValue(_gl,'boneTexture',skeleton.boneTexture,textures);}}if(object.isBatchedMesh){p_uniforms.setOptional(_gl,object,'batchingTexture');p_uniforms.setValue(_gl,'batchingTexture',object._matricesTexture,textures);p_uniforms.setOptional(_gl,object,'batchingIdTexture');p_uniforms.setValue(_gl,'batchingIdTexture',object._indirectTexture,textures);p_uniforms.setOptional(_gl,object,'batchingColorTexture');if(object._colorsTexture!==null){p_uniforms.setValue(_gl,'batchingColorTexture',object._colorsTexture,textures);}}const morphAttributes=geometry.morphAttributes;if(morphAttributes.position!==undefined||morphAttributes.normal!==undefined||morphAttributes.color!==undefined){morphtargets.update(object,geometry,program);}if(refreshMaterial||materialProperties.receiveShadow!==object.receiveShadow){materialProperties.receiveShadow=object.receiveShadow;p_uniforms.setValue(_gl,'receiveShadow',object.receiveShadow);}// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512
	if(material.isMeshGouraudMaterial&&material.envMap!==null){m_uniforms.envMap.value=envMap;m_uniforms.flipEnvMap.value=envMap.isCubeTexture&&envMap.isRenderTargetTexture===false?-1:1;}if(material.isMeshStandardMaterial&&material.envMap===null&&scene.environment!==null){m_uniforms.envMapIntensity.value=scene.environmentIntensity;}if(refreshMaterial){p_uniforms.setValue(_gl,'toneMappingExposure',_this.toneMappingExposure);if(materialProperties.needsLights){// the current material requires lighting info
	// note: all lighting uniforms are always set correctly
	// they simply reference the renderer's state for their
	// values
	//
	// use the current material's .needsUpdate flags to set
	// the GL state when required
	markUniformsLightsNeedsUpdate(m_uniforms,refreshLights);}// refresh uniforms common to several materials
	if(fog&&material.fog===true){materials.refreshFogUniforms(m_uniforms,fog);}materials.refreshMaterialUniforms(m_uniforms,material,_pixelRatio,_height,currentRenderState.state.transmissionRenderTarget[camera.id]);WebGLUniforms.upload(_gl,getUniformList(materialProperties),m_uniforms,textures);}if(material.isShaderMaterial&&material.uniformsNeedUpdate===true){WebGLUniforms.upload(_gl,getUniformList(materialProperties),m_uniforms,textures);material.uniformsNeedUpdate=false;}if(material.isSpriteMaterial){p_uniforms.setValue(_gl,'center',object.center);}// common matrices
	p_uniforms.setValue(_gl,'modelViewMatrix',object.modelViewMatrix);p_uniforms.setValue(_gl,'normalMatrix',object.normalMatrix);p_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);// UBOs
	if(material.isShaderMaterial||material.isRawShaderMaterial){const groups=material.uniformsGroups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i];uniformsGroups.update(group,program);uniformsGroups.bind(group,program);}}return program;}// If uniforms are marked as clean, they don't need to be loaded to the GPU.
	function markUniformsLightsNeedsUpdate(uniforms,value){uniforms.ambientLightColor.needsUpdate=value;uniforms.lightProbe.needsUpdate=value;uniforms.directionalLights.needsUpdate=value;uniforms.directionalLightShadows.needsUpdate=value;uniforms.pointLights.needsUpdate=value;uniforms.pointLightShadows.needsUpdate=value;uniforms.spotLights.needsUpdate=value;uniforms.spotLightShadows.needsUpdate=value;uniforms.rectAreaLights.needsUpdate=value;uniforms.hemisphereLights.needsUpdate=value;}function materialNeedsLights(material){return material.isMeshLambertMaterial||material.isMeshToonMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.isShadowMaterial||material.isShaderMaterial&&material.lights===true;}this.getActiveCubeFace=function(){return _currentActiveCubeFace;};this.getActiveMipmapLevel=function(){return _currentActiveMipmapLevel;};this.getRenderTarget=function(){return _currentRenderTarget;};this.setRenderTargetTextures=function(renderTarget,colorTexture,depthTexture){properties.get(renderTarget.texture).__webglTexture=colorTexture;properties.get(renderTarget.depthTexture).__webglTexture=depthTexture;const renderTargetProperties=properties.get(renderTarget);renderTargetProperties.__hasExternalTextures=true;renderTargetProperties.__autoAllocateDepthBuffer=depthTexture===undefined;if(!renderTargetProperties.__autoAllocateDepthBuffer){// The multisample_render_to_texture extension doesn't work properly if there
	// are midframe flushes and an external depth buffer. Disable use of the extension.
	if(extensions.has('WEBGL_multisampled_render_to_texture')===true){console.warn('THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided');renderTargetProperties.__useRenderToTexture=false;}}};this.setRenderTargetFramebuffer=function(renderTarget,defaultFramebuffer){const renderTargetProperties=properties.get(renderTarget);renderTargetProperties.__webglFramebuffer=defaultFramebuffer;renderTargetProperties.__useDefaultFramebuffer=defaultFramebuffer===undefined;};this.setRenderTarget=function(renderTarget,activeCubeFace=0,activeMipmapLevel=0){_currentRenderTarget=renderTarget;_currentActiveCubeFace=activeCubeFace;_currentActiveMipmapLevel=activeMipmapLevel;let useDefaultFramebuffer=true;let framebuffer=null;let isCube=false;let isRenderTarget3D=false;if(renderTarget){const renderTargetProperties=properties.get(renderTarget);if(renderTargetProperties.__useDefaultFramebuffer!==undefined){// We need to make sure to rebind the framebuffer.
	state.bindFramebuffer(_gl.FRAMEBUFFER,null);useDefaultFramebuffer=false;}else if(renderTargetProperties.__webglFramebuffer===undefined){textures.setupRenderTarget(renderTarget);}else if(renderTargetProperties.__hasExternalTextures){// Color and depth texture must be rebound in order for the swapchain to update.
	textures.rebindTextures(renderTarget,properties.get(renderTarget.texture).__webglTexture,properties.get(renderTarget.depthTexture).__webglTexture);}else if(renderTarget.depthBuffer){// check if the depth texture is already bound to the frame buffer and that it's been initialized
	const depthTexture=renderTarget.depthTexture;if(renderTargetProperties.__boundDepthTexture!==depthTexture){// check if the depth texture is compatible
	if(depthTexture!==null&&properties.has(depthTexture)&&(renderTarget.width!==depthTexture.image.width||renderTarget.height!==depthTexture.image.height)){throw new Error('WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.');}// Swap the depth buffer to the currently attached one
	textures.setupDepthRenderbuffer(renderTarget);}}const texture=renderTarget.texture;if(texture.isData3DTexture||texture.isDataArrayTexture||texture.isCompressedArrayTexture){isRenderTarget3D=true;}const __webglFramebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget){if(Array.isArray(__webglFramebuffer[activeCubeFace])){framebuffer=__webglFramebuffer[activeCubeFace][activeMipmapLevel];}else {framebuffer=__webglFramebuffer[activeCubeFace];}isCube=true;}else if(renderTarget.samples>0&&textures.useMultisampledRTT(renderTarget)===false){framebuffer=properties.get(renderTarget).__webglMultisampledFramebuffer;}else {if(Array.isArray(__webglFramebuffer)){framebuffer=__webglFramebuffer[activeMipmapLevel];}else {framebuffer=__webglFramebuffer;}}_currentViewport.copy(renderTarget.viewport);_currentScissor.copy(renderTarget.scissor);_currentScissorTest=renderTarget.scissorTest;}else {_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();_currentScissorTest=_scissorTest;}const framebufferBound=state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);if(framebufferBound&&useDefaultFramebuffer){state.drawBuffers(renderTarget,framebuffer);}state.viewport(_currentViewport);state.scissor(_currentScissor);state.setScissorTest(_currentScissorTest);if(isCube){const textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+activeCubeFace,textureProperties.__webglTexture,activeMipmapLevel);}else if(isRenderTarget3D){const textureProperties=properties.get(renderTarget.texture);const layer=activeCubeFace||0;_gl.framebufferTextureLayer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,textureProperties.__webglTexture,activeMipmapLevel||0,layer);}_currentMaterialId=-1;// reset current material to ensure correct uniform bindings
	};this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer,activeCubeFaceIndex){if(!(renderTarget&&renderTarget.isWebGLRenderTarget)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');return;}let framebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget&&activeCubeFaceIndex!==undefined){framebuffer=framebuffer[activeCubeFaceIndex];}if(framebuffer){state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);try{const texture=renderTarget.texture;const textureFormat=texture.format;const textureType=texture.type;if(!capabilities.textureFormatReadable(textureFormat)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');return;}if(!capabilities.textureTypeReadable(textureType)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');return;}// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
	if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){_gl.readPixels(x,y,width,height,utils.convert(textureFormat),utils.convert(textureType),buffer);}}finally{// restore framebuffer of current render target if necessary
	const framebuffer=_currentRenderTarget!==null?properties.get(_currentRenderTarget).__webglFramebuffer:null;state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);}}};this.readRenderTargetPixelsAsync=async function(renderTarget,x,y,width,height,buffer,activeCubeFaceIndex){if(!(renderTarget&&renderTarget.isWebGLRenderTarget)){throw new Error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');}let framebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget&&activeCubeFaceIndex!==undefined){framebuffer=framebuffer[activeCubeFaceIndex];}if(framebuffer){const texture=renderTarget.texture;const textureFormat=texture.format;const textureType=texture.type;if(!capabilities.textureFormatReadable(textureFormat)){throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.');}if(!capabilities.textureTypeReadable(textureType)){throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.');}// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
	if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){// set the active frame buffer to the one we want to read
	state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);const glBuffer=_gl.createBuffer();_gl.bindBuffer(_gl.PIXEL_PACK_BUFFER,glBuffer);_gl.bufferData(_gl.PIXEL_PACK_BUFFER,buffer.byteLength,_gl.STREAM_READ);_gl.readPixels(x,y,width,height,utils.convert(textureFormat),utils.convert(textureType),0);// reset the frame buffer to the currently set buffer before waiting
	const currFramebuffer=_currentRenderTarget!==null?properties.get(_currentRenderTarget).__webglFramebuffer:null;state.bindFramebuffer(_gl.FRAMEBUFFER,currFramebuffer);// check if the commands have finished every 8 ms
	const sync=_gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE,0);_gl.flush();await probeAsync(_gl,sync,4);// read the data and delete the buffer
	_gl.bindBuffer(_gl.PIXEL_PACK_BUFFER,glBuffer);_gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER,0,buffer);_gl.deleteBuffer(glBuffer);_gl.deleteSync(sync);return buffer;}else {throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.');}}};this.copyFramebufferToTexture=function(texture,position=null,level=0){// support previous signature with position first
	if(texture.isTexture!==true){// @deprecated, r165
	warnOnce('WebGLRenderer: copyFramebufferToTexture function signature has changed.');position=arguments[0]||null;texture=arguments[1];}const levelScale=Math.pow(2,-level);const width=Math.floor(texture.image.width*levelScale);const height=Math.floor(texture.image.height*levelScale);const x=position!==null?position.x:0;const y=position!==null?position.y:0;textures.setTexture2D(texture,0);_gl.copyTexSubImage2D(_gl.TEXTURE_2D,level,0,0,x,y,width,height);state.unbindTexture();};const _srcFramebuffer=_gl.createFramebuffer();const _dstFramebuffer=_gl.createFramebuffer();this.copyTextureToTexture=function(srcTexture,dstTexture,srcRegion=null,dstPosition=null,srcLevel=0,dstLevel=null){// support previous signature with dstPosition first
	if(srcTexture.isTexture!==true){// @deprecated, r165
	warnOnce('WebGLRenderer: copyTextureToTexture function signature has changed.');dstPosition=arguments[0]||null;srcTexture=arguments[1];dstTexture=arguments[2];dstLevel=arguments[3]||0;srcRegion=null;}// support the previous signature with just a single dst mipmap level
	if(dstLevel===null){if(srcLevel!==0){// @deprecated, r171
	warnOnce('WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.');dstLevel=srcLevel;srcLevel=0;}else {dstLevel=0;}}// gather the necessary dimensions to copy
	let width,height,depth,minX,minY,minZ;let dstX,dstY,dstZ;const image=srcTexture.isCompressedTexture?srcTexture.mipmaps[dstLevel]:srcTexture.image;if(srcRegion!==null){width=srcRegion.max.x-srcRegion.min.x;height=srcRegion.max.y-srcRegion.min.y;depth=srcRegion.isBox3?srcRegion.max.z-srcRegion.min.z:1;minX=srcRegion.min.x;minY=srcRegion.min.y;minZ=srcRegion.isBox3?srcRegion.min.z:0;}else {const levelScale=Math.pow(2,-srcLevel);width=Math.floor(image.width*levelScale);height=Math.floor(image.height*levelScale);if(srcTexture.isDataArrayTexture){depth=image.depth;}else if(srcTexture.isData3DTexture){depth=Math.floor(image.depth*levelScale);}else {depth=1;}minX=0;minY=0;minZ=0;}if(dstPosition!==null){dstX=dstPosition.x;dstY=dstPosition.y;dstZ=dstPosition.z;}else {dstX=0;dstY=0;dstZ=0;}// Set up the destination target
	const glFormat=utils.convert(dstTexture.format);const glType=utils.convert(dstTexture.type);let glTarget;if(dstTexture.isData3DTexture){textures.setTexture3D(dstTexture,0);glTarget=_gl.TEXTURE_3D;}else if(dstTexture.isDataArrayTexture||dstTexture.isCompressedArrayTexture){textures.setTexture2DArray(dstTexture,0);glTarget=_gl.TEXTURE_2D_ARRAY;}else {textures.setTexture2D(dstTexture,0);glTarget=_gl.TEXTURE_2D;}_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,dstTexture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,dstTexture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,dstTexture.unpackAlignment);// used for copying data from cpu
	const currentUnpackRowLen=_gl.getParameter(_gl.UNPACK_ROW_LENGTH);const currentUnpackImageHeight=_gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);const currentUnpackSkipPixels=_gl.getParameter(_gl.UNPACK_SKIP_PIXELS);const currentUnpackSkipRows=_gl.getParameter(_gl.UNPACK_SKIP_ROWS);const currentUnpackSkipImages=_gl.getParameter(_gl.UNPACK_SKIP_IMAGES);_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH,image.width);_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT,image.height);_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS,minX);_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS,minY);_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES,minZ);// set up the src texture
	const isSrc3D=srcTexture.isDataArrayTexture||srcTexture.isData3DTexture;const isDst3D=dstTexture.isDataArrayTexture||dstTexture.isData3DTexture;if(srcTexture.isDepthTexture){const srcTextureProperties=properties.get(srcTexture);const dstTextureProperties=properties.get(dstTexture);const srcRenderTargetProperties=properties.get(srcTextureProperties.__renderTarget);const dstRenderTargetProperties=properties.get(dstTextureProperties.__renderTarget);state.bindFramebuffer(_gl.READ_FRAMEBUFFER,srcRenderTargetProperties.__webglFramebuffer);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,dstRenderTargetProperties.__webglFramebuffer);for(let i=0;i<depth;i++){// if the source or destination are a 3d target then a layer needs to be bound
	if(isSrc3D){_gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,properties.get(srcTexture).__webglTexture,srcLevel,minZ+i);_gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,properties.get(dstTexture).__webglTexture,dstLevel,dstZ+i);}_gl.blitFramebuffer(minX,minY,width,height,dstX,dstY,width,height,_gl.DEPTH_BUFFER_BIT,_gl.NEAREST);}state.bindFramebuffer(_gl.READ_FRAMEBUFFER,null);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,null);}else if(srcLevel!==0||srcTexture.isRenderTargetTexture||properties.has(srcTexture)){// get the appropriate frame buffers
	const srcTextureProperties=properties.get(srcTexture);const dstTextureProperties=properties.get(dstTexture);// bind the frame buffer targets
	state.bindFramebuffer(_gl.READ_FRAMEBUFFER,_srcFramebuffer);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,_dstFramebuffer);for(let i=0;i<depth;i++){// assign the correct layers and mip maps to the frame buffers
	if(isSrc3D){_gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,srcTextureProperties.__webglTexture,srcLevel,minZ+i);}else {_gl.framebufferTexture2D(_gl.READ_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D,srcTextureProperties.__webglTexture,srcLevel);}if(isDst3D){_gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,dstTextureProperties.__webglTexture,dstLevel,dstZ+i);}else {_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D,dstTextureProperties.__webglTexture,dstLevel);}// copy the data using the fastest function that can achieve the copy
	if(srcLevel!==0){_gl.blitFramebuffer(minX,minY,width,height,dstX,dstY,width,height,_gl.COLOR_BUFFER_BIT,_gl.NEAREST);}else if(isDst3D){_gl.copyTexSubImage3D(glTarget,dstLevel,dstX,dstY,dstZ+i,minX,minY,width,height);}else {_gl.copyTexSubImage2D(glTarget,dstLevel,dstX,dstY,minX,minY,width,height);}}// unbind read, draw buffers
	state.bindFramebuffer(_gl.READ_FRAMEBUFFER,null);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,null);}else {if(isDst3D){// copy data into the 3d texture
	if(srcTexture.isDataTexture||srcTexture.isData3DTexture){_gl.texSubImage3D(glTarget,dstLevel,dstX,dstY,dstZ,width,height,depth,glFormat,glType,image.data);}else if(dstTexture.isCompressedArrayTexture){_gl.compressedTexSubImage3D(glTarget,dstLevel,dstX,dstY,dstZ,width,height,depth,glFormat,image.data);}else {_gl.texSubImage3D(glTarget,dstLevel,dstX,dstY,dstZ,width,height,depth,glFormat,glType,image);}}else {// copy data into the 2d texture
	if(srcTexture.isDataTexture){_gl.texSubImage2D(_gl.TEXTURE_2D,dstLevel,dstX,dstY,width,height,glFormat,glType,image.data);}else if(srcTexture.isCompressedTexture){_gl.compressedTexSubImage2D(_gl.TEXTURE_2D,dstLevel,dstX,dstY,image.width,image.height,glFormat,image.data);}else {_gl.texSubImage2D(_gl.TEXTURE_2D,dstLevel,dstX,dstY,width,height,glFormat,glType,image);}}}// reset values
	_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH,currentUnpackRowLen);_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT,currentUnpackImageHeight);_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS,currentUnpackSkipPixels);_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS,currentUnpackSkipRows);_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES,currentUnpackSkipImages);// Generate mipmaps only when copying level 0
	if(dstLevel===0&&dstTexture.generateMipmaps){_gl.generateMipmap(glTarget);}state.unbindTexture();};this.copyTextureToTexture3D=function(srcTexture,dstTexture,srcRegion=null,dstPosition=null,level=0){// support previous signature with source box first
	if(srcTexture.isTexture!==true){// @deprecated, r165
	warnOnce('WebGLRenderer: copyTextureToTexture3D function signature has changed.');srcRegion=arguments[0]||null;dstPosition=arguments[1]||null;srcTexture=arguments[2];dstTexture=arguments[3];level=arguments[4]||0;}// @deprecated, r170
	warnOnce('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.');return this.copyTextureToTexture(srcTexture,dstTexture,srcRegion,dstPosition,level);};this.initRenderTarget=function(target){if(properties.get(target).__webglFramebuffer===undefined){textures.setupRenderTarget(target);}};this.initTexture=function(texture){if(texture.isCubeTexture){textures.setTextureCube(texture,0);}else if(texture.isData3DTexture){textures.setTexture3D(texture,0);}else if(texture.isDataArrayTexture||texture.isCompressedArrayTexture){textures.setTexture2DArray(texture,0);}else {textures.setTexture2D(texture,0);}state.unbindTexture();};this.resetState=function(){_currentActiveCubeFace=0;_currentActiveMipmapLevel=0;_currentRenderTarget=null;state.reset();bindingStates.reset();};if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:this}));}}get coordinateSystem(){return WebGLCoordinateSystem$1;}get outputColorSpace(){return this._outputColorSpace;}set outputColorSpace(colorSpace){this._outputColorSpace=colorSpace;const gl=this.getContext();gl.drawingBufferColorspace=ColorManagement._getDrawingBufferColorSpace(colorSpace);gl.unpackColorSpace=ColorManagement._getUnpackColorSpace();}}

	// OrbitControls performs orbiting, dollying (zooming), and panning.
	// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
	//
	//    Orbit - left mouse / touch: one-finger move
	//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
	//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

	const _changeEvent = {
	  type: 'change'
	};
	const _startEvent = {
	  type: 'start'
	};
	const _endEvent = {
	  type: 'end'
	};
	const _ray = new Ray();
	const _plane = new Plane();
	const _TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);
	const _v = new Vector3$1();
	const _twoPI = 2 * Math.PI;
	const _STATE = {
	  NONE: -1,
	  ROTATE: 0,
	  DOLLY: 1,
	  PAN: 2,
	  TOUCH_ROTATE: 3,
	  TOUCH_PAN: 4,
	  TOUCH_DOLLY_PAN: 5,
	  TOUCH_DOLLY_ROTATE: 6
	};
	const _EPS = 0.000001;
	class OrbitControls extends Controls {
	  constructor(object, domElement = null) {
	    super(object, domElement);
	    this.state = _STATE.NONE;

	    // Set to false to disable this control
	    this.enabled = true;

	    // "target" sets the location of focus, where the object orbits around
	    this.target = new Vector3$1();

	    // Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect
	    this.cursor = new Vector3$1();

	    // How far you can dolly in and out ( PerspectiveCamera only )
	    this.minDistance = 0;
	    this.maxDistance = Infinity;

	    // How far you can zoom in and out ( OrthographicCamera only )
	    this.minZoom = 0;
	    this.maxZoom = Infinity;

	    // Limit camera target within a spherical area around the cursor
	    this.minTargetRadius = 0;
	    this.maxTargetRadius = Infinity;

	    // How far you can orbit vertically, upper and lower limits.
	    // Range is 0 to Math.PI radians.
	    this.minPolarAngle = 0; // radians
	    this.maxPolarAngle = Math.PI; // radians

	    // How far you can orbit horizontally, upper and lower limits.
	    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
	    this.minAzimuthAngle = -Infinity; // radians
	    this.maxAzimuthAngle = Infinity; // radians

	    // Set to true to enable damping (inertia)
	    // If damping is enabled, you must call controls.update() in your animation loop
	    this.enableDamping = false;
	    this.dampingFactor = 0.05;

	    // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
	    // Set to false to disable zooming
	    this.enableZoom = true;
	    this.zoomSpeed = 1.0;

	    // Set to false to disable rotating
	    this.enableRotate = true;
	    this.rotateSpeed = 1.0;

	    // Set to false to disable panning
	    this.enablePan = true;
	    this.panSpeed = 1.0;
	    this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
	    this.keyPanSpeed = 7.0; // pixels moved per arrow key push
	    this.zoomToCursor = false;

	    // Set to true to automatically rotate around the target
	    // If auto-rotate is enabled, you must call controls.update() in your animation loop
	    this.autoRotate = false;
	    this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

	    // The four arrow keys
	    this.keys = {
	      LEFT: 'ArrowLeft',
	      UP: 'ArrowUp',
	      RIGHT: 'ArrowRight',
	      BOTTOM: 'ArrowDown'
	    };

	    // Mouse buttons
	    this.mouseButtons = {
	      LEFT: MOUSE.ROTATE,
	      MIDDLE: MOUSE.DOLLY,
	      RIGHT: MOUSE.PAN
	    };

	    // Touch fingers
	    this.touches = {
	      ONE: TOUCH.ROTATE,
	      TWO: TOUCH.DOLLY_PAN
	    };

	    // for reset
	    this.target0 = this.target.clone();
	    this.position0 = this.object.position.clone();
	    this.zoom0 = this.object.zoom;

	    // the target DOM element for key events
	    this._domElementKeyEvents = null;

	    // internals

	    this._lastPosition = new Vector3$1();
	    this._lastQuaternion = new Quaternion$1();
	    this._lastTargetPosition = new Vector3$1();

	    // so camera.up is the orbit axis
	    this._quat = new Quaternion$1().setFromUnitVectors(object.up, new Vector3$1(0, 1, 0));
	    this._quatInverse = this._quat.clone().invert();

	    // current position in spherical coordinates
	    this._spherical = new Spherical();
	    this._sphericalDelta = new Spherical();
	    this._scale = 1;
	    this._panOffset = new Vector3$1();
	    this._rotateStart = new Vector2$1();
	    this._rotateEnd = new Vector2$1();
	    this._rotateDelta = new Vector2$1();
	    this._panStart = new Vector2$1();
	    this._panEnd = new Vector2$1();
	    this._panDelta = new Vector2$1();
	    this._dollyStart = new Vector2$1();
	    this._dollyEnd = new Vector2$1();
	    this._dollyDelta = new Vector2$1();
	    this._dollyDirection = new Vector3$1();
	    this._mouse = new Vector2$1();
	    this._performCursorZoom = false;
	    this._pointers = [];
	    this._pointerPositions = {};
	    this._controlActive = false;

	    // event listeners

	    this._onPointerMove = onPointerMove.bind(this);
	    this._onPointerDown = onPointerDown.bind(this);
	    this._onPointerUp = onPointerUp.bind(this);
	    this._onContextMenu = onContextMenu.bind(this);
	    this._onMouseWheel = onMouseWheel.bind(this);
	    this._onKeyDown = onKeyDown.bind(this);
	    this._onTouchStart = onTouchStart.bind(this);
	    this._onTouchMove = onTouchMove.bind(this);
	    this._onMouseDown = onMouseDown.bind(this);
	    this._onMouseMove = onMouseMove.bind(this);
	    this._interceptControlDown = interceptControlDown.bind(this);
	    this._interceptControlUp = interceptControlUp.bind(this);

	    //

	    if (this.domElement !== null) {
	      this.connect();
	    }
	    this.update();
	  }
	  connect() {
	    this.domElement.addEventListener('pointerdown', this._onPointerDown);
	    this.domElement.addEventListener('pointercancel', this._onPointerUp);
	    this.domElement.addEventListener('contextmenu', this._onContextMenu);
	    this.domElement.addEventListener('wheel', this._onMouseWheel, {
	      passive: false
	    });
	    const document = this.domElement.getRootNode(); // offscreen canvas compatibility
	    document.addEventListener('keydown', this._interceptControlDown, {
	      passive: true,
	      capture: true
	    });
	    this.domElement.style.touchAction = 'none'; // disable touch scroll
	  }
	  disconnect() {
	    this.domElement.removeEventListener('pointerdown', this._onPointerDown);
	    this.domElement.removeEventListener('pointermove', this._onPointerMove);
	    this.domElement.removeEventListener('pointerup', this._onPointerUp);
	    this.domElement.removeEventListener('pointercancel', this._onPointerUp);
	    this.domElement.removeEventListener('wheel', this._onMouseWheel);
	    this.domElement.removeEventListener('contextmenu', this._onContextMenu);
	    this.stopListenToKeyEvents();
	    const document = this.domElement.getRootNode(); // offscreen canvas compatibility
	    document.removeEventListener('keydown', this._interceptControlDown, {
	      capture: true
	    });
	    this.domElement.style.touchAction = 'auto';
	  }
	  dispose() {
	    this.disconnect();
	  }
	  getPolarAngle() {
	    return this._spherical.phi;
	  }
	  getAzimuthalAngle() {
	    return this._spherical.theta;
	  }
	  getDistance() {
	    return this.object.position.distanceTo(this.target);
	  }
	  listenToKeyEvents(domElement) {
	    domElement.addEventListener('keydown', this._onKeyDown);
	    this._domElementKeyEvents = domElement;
	  }
	  stopListenToKeyEvents() {
	    if (this._domElementKeyEvents !== null) {
	      this._domElementKeyEvents.removeEventListener('keydown', this._onKeyDown);
	      this._domElementKeyEvents = null;
	    }
	  }
	  saveState() {
	    this.target0.copy(this.target);
	    this.position0.copy(this.object.position);
	    this.zoom0 = this.object.zoom;
	  }
	  reset() {
	    this.target.copy(this.target0);
	    this.object.position.copy(this.position0);
	    this.object.zoom = this.zoom0;
	    this.object.updateProjectionMatrix();
	    this.dispatchEvent(_changeEvent);
	    this.update();
	    this.state = _STATE.NONE;
	  }
	  update(deltaTime = null) {
	    const position = this.object.position;
	    _v.copy(position).sub(this.target);

	    // rotate offset to "y-axis-is-up" space
	    _v.applyQuaternion(this._quat);

	    // angle from z-axis around y-axis
	    this._spherical.setFromVector3(_v);
	    if (this.autoRotate && this.state === _STATE.NONE) {
	      this._rotateLeft(this._getAutoRotationAngle(deltaTime));
	    }
	    if (this.enableDamping) {
	      this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
	      this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;
	    } else {
	      this._spherical.theta += this._sphericalDelta.theta;
	      this._spherical.phi += this._sphericalDelta.phi;
	    }

	    // restrict theta to be between desired limits

	    let min = this.minAzimuthAngle;
	    let max = this.maxAzimuthAngle;
	    if (isFinite(min) && isFinite(max)) {
	      if (min < -Math.PI) min += _twoPI;else if (min > Math.PI) min -= _twoPI;
	      if (max < -Math.PI) max += _twoPI;else if (max > Math.PI) max -= _twoPI;
	      if (min <= max) {
	        this._spherical.theta = Math.max(min, Math.min(max, this._spherical.theta));
	      } else {
	        this._spherical.theta = this._spherical.theta > (min + max) / 2 ? Math.max(min, this._spherical.theta) : Math.min(max, this._spherical.theta);
	      }
	    }

	    // restrict phi to be between desired limits
	    this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));
	    this._spherical.makeSafe();

	    // move target to panned location

	    if (this.enableDamping === true) {
	      this.target.addScaledVector(this._panOffset, this.dampingFactor);
	    } else {
	      this.target.add(this._panOffset);
	    }

	    // Limit the target distance from the cursor to create a sphere around the center of interest
	    this.target.sub(this.cursor);
	    this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);
	    this.target.add(this.cursor);
	    let zoomChanged = false;
	    // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
	    // we adjust zoom later in these cases
	    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) {
	      this._spherical.radius = this._clampDistance(this._spherical.radius);
	    } else {
	      const prevRadius = this._spherical.radius;
	      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale);
	      zoomChanged = prevRadius != this._spherical.radius;
	    }
	    _v.setFromSpherical(this._spherical);

	    // rotate offset back to "camera-up-vector-is-up" space
	    _v.applyQuaternion(this._quatInverse);
	    position.copy(this.target).add(_v);
	    this.object.lookAt(this.target);
	    if (this.enableDamping === true) {
	      this._sphericalDelta.theta *= 1 - this.dampingFactor;
	      this._sphericalDelta.phi *= 1 - this.dampingFactor;
	      this._panOffset.multiplyScalar(1 - this.dampingFactor);
	    } else {
	      this._sphericalDelta.set(0, 0, 0);
	      this._panOffset.set(0, 0, 0);
	    }

	    // adjust camera position
	    if (this.zoomToCursor && this._performCursorZoom) {
	      let newRadius = null;
	      if (this.object.isPerspectiveCamera) {
	        // move the camera down the pointer ray
	        // this method avoids floating point error
	        const prevRadius = _v.length();
	        newRadius = this._clampDistance(prevRadius * this._scale);
	        const radiusDelta = prevRadius - newRadius;
	        this.object.position.addScaledVector(this._dollyDirection, radiusDelta);
	        this.object.updateMatrixWorld();
	        zoomChanged = !!radiusDelta;
	      } else if (this.object.isOrthographicCamera) {
	        // adjust the ortho camera position based on zoom changes
	        const mouseBefore = new Vector3$1(this._mouse.x, this._mouse.y, 0);
	        mouseBefore.unproject(this.object);
	        const prevZoom = this.object.zoom;
	        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
	        this.object.updateProjectionMatrix();
	        zoomChanged = prevZoom !== this.object.zoom;
	        const mouseAfter = new Vector3$1(this._mouse.x, this._mouse.y, 0);
	        mouseAfter.unproject(this.object);
	        this.object.position.sub(mouseAfter).add(mouseBefore);
	        this.object.updateMatrixWorld();
	        newRadius = _v.length();
	      } else {
	        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.');
	        this.zoomToCursor = false;
	      }

	      // handle the placement of the target
	      if (newRadius !== null) {
	        if (this.screenSpacePanning) {
	          // position the orbit target in front of the new camera position
	          this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this.object.position);
	        } else {
	          // get the ray and translation plane to compute target
	          _ray.origin.copy(this.object.position);
	          _ray.direction.set(0, 0, -1).transformDirection(this.object.matrix);

	          // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
	          // extremely large values
	          if (Math.abs(this.object.up.dot(_ray.direction)) < _TILT_LIMIT) {
	            this.object.lookAt(this.target);
	          } else {
	            _plane.setFromNormalAndCoplanarPoint(this.object.up, this.target);
	            _ray.intersectPlane(_plane, this.target);
	          }
	        }
	      }
	    } else if (this.object.isOrthographicCamera) {
	      const prevZoom = this.object.zoom;
	      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
	      if (prevZoom !== this.object.zoom) {
	        this.object.updateProjectionMatrix();
	        zoomChanged = true;
	      }
	    }
	    this._scale = 1;
	    this._performCursorZoom = false;

	    // update condition is:
	    // min(camera displacement, camera rotation in radians)^2 > EPS
	    // using small-angle approximation cos(x/2) = 1 - x^2 / 8

	    if (zoomChanged || this._lastPosition.distanceToSquared(this.object.position) > _EPS || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS || this._lastTargetPosition.distanceToSquared(this.target) > _EPS) {
	      this.dispatchEvent(_changeEvent);
	      this._lastPosition.copy(this.object.position);
	      this._lastQuaternion.copy(this.object.quaternion);
	      this._lastTargetPosition.copy(this.target);
	      return true;
	    }
	    return false;
	  }
	  _getAutoRotationAngle(deltaTime) {
	    if (deltaTime !== null) {
	      return _twoPI / 60 * this.autoRotateSpeed * deltaTime;
	    } else {
	      return _twoPI / 60 / 60 * this.autoRotateSpeed;
	    }
	  }
	  _getZoomScale(delta) {
	    const normalizedDelta = Math.abs(delta * 0.01);
	    return Math.pow(0.95, this.zoomSpeed * normalizedDelta);
	  }
	  _rotateLeft(angle) {
	    this._sphericalDelta.theta -= angle;
	  }
	  _rotateUp(angle) {
	    this._sphericalDelta.phi -= angle;
	  }
	  _panLeft(distance, objectMatrix) {
	    _v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
	    _v.multiplyScalar(-distance);
	    this._panOffset.add(_v);
	  }
	  _panUp(distance, objectMatrix) {
	    if (this.screenSpacePanning === true) {
	      _v.setFromMatrixColumn(objectMatrix, 1);
	    } else {
	      _v.setFromMatrixColumn(objectMatrix, 0);
	      _v.crossVectors(this.object.up, _v);
	    }
	    _v.multiplyScalar(distance);
	    this._panOffset.add(_v);
	  }

	  // deltaX and deltaY are in pixels; right and down are positive
	  _pan(deltaX, deltaY) {
	    const element = this.domElement;
	    if (this.object.isPerspectiveCamera) {
	      // perspective
	      const position = this.object.position;
	      _v.copy(position).sub(this.target);
	      let targetDistance = _v.length();

	      // half of the fov is center to top of screen
	      targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180.0);

	      // we use only clientHeight here so aspect ratio does not distort speed
	      this._panLeft(2 * deltaX * targetDistance / element.clientHeight, this.object.matrix);
	      this._panUp(2 * deltaY * targetDistance / element.clientHeight, this.object.matrix);
	    } else if (this.object.isOrthographicCamera) {
	      // orthographic
	      this._panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element.clientWidth, this.object.matrix);
	      this._panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element.clientHeight, this.object.matrix);
	    } else {
	      // camera neither orthographic nor perspective
	      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
	      this.enablePan = false;
	    }
	  }
	  _dollyOut(dollyScale) {
	    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
	      this._scale /= dollyScale;
	    } else {
	      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
	      this.enableZoom = false;
	    }
	  }
	  _dollyIn(dollyScale) {
	    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
	      this._scale *= dollyScale;
	    } else {
	      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
	      this.enableZoom = false;
	    }
	  }
	  _updateZoomParameters(x, y) {
	    if (!this.zoomToCursor) {
	      return;
	    }
	    this._performCursorZoom = true;
	    const rect = this.domElement.getBoundingClientRect();
	    const dx = x - rect.left;
	    const dy = y - rect.top;
	    const w = rect.width;
	    const h = rect.height;
	    this._mouse.x = dx / w * 2 - 1;
	    this._mouse.y = -(dy / h) * 2 + 1;
	    this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
	  }
	  _clampDistance(dist) {
	    return Math.max(this.minDistance, Math.min(this.maxDistance, dist));
	  }

	  //
	  // event callbacks - update the object state
	  //

	  _handleMouseDownRotate(event) {
	    this._rotateStart.set(event.clientX, event.clientY);
	  }
	  _handleMouseDownDolly(event) {
	    this._updateZoomParameters(event.clientX, event.clientX);
	    this._dollyStart.set(event.clientX, event.clientY);
	  }
	  _handleMouseDownPan(event) {
	    this._panStart.set(event.clientX, event.clientY);
	  }
	  _handleMouseMoveRotate(event) {
	    this._rotateEnd.set(event.clientX, event.clientY);
	    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
	    const element = this.domElement;
	    this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight); // yes, height

	    this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);
	    this._rotateStart.copy(this._rotateEnd);
	    this.update();
	  }
	  _handleMouseMoveDolly(event) {
	    this._dollyEnd.set(event.clientX, event.clientY);
	    this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);
	    if (this._dollyDelta.y > 0) {
	      this._dollyOut(this._getZoomScale(this._dollyDelta.y));
	    } else if (this._dollyDelta.y < 0) {
	      this._dollyIn(this._getZoomScale(this._dollyDelta.y));
	    }
	    this._dollyStart.copy(this._dollyEnd);
	    this.update();
	  }
	  _handleMouseMovePan(event) {
	    this._panEnd.set(event.clientX, event.clientY);
	    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
	    this._pan(this._panDelta.x, this._panDelta.y);
	    this._panStart.copy(this._panEnd);
	    this.update();
	  }
	  _handleMouseWheel(event) {
	    this._updateZoomParameters(event.clientX, event.clientY);
	    if (event.deltaY < 0) {
	      this._dollyIn(this._getZoomScale(event.deltaY));
	    } else if (event.deltaY > 0) {
	      this._dollyOut(this._getZoomScale(event.deltaY));
	    }
	    this.update();
	  }
	  _handleKeyDown(event) {
	    let needsUpdate = false;
	    switch (event.code) {
	      case this.keys.UP:
	        if (event.ctrlKey || event.metaKey || event.shiftKey) {
	          if (this.enableRotate) {
	            this._rotateUp(_twoPI * this.rotateSpeed / this.domElement.clientHeight);
	          }
	        } else {
	          if (this.enablePan) {
	            this._pan(0, this.keyPanSpeed);
	          }
	        }
	        needsUpdate = true;
	        break;
	      case this.keys.BOTTOM:
	        if (event.ctrlKey || event.metaKey || event.shiftKey) {
	          if (this.enableRotate) {
	            this._rotateUp(-_twoPI * this.rotateSpeed / this.domElement.clientHeight);
	          }
	        } else {
	          if (this.enablePan) {
	            this._pan(0, -this.keyPanSpeed);
	          }
	        }
	        needsUpdate = true;
	        break;
	      case this.keys.LEFT:
	        if (event.ctrlKey || event.metaKey || event.shiftKey) {
	          if (this.enableRotate) {
	            this._rotateLeft(_twoPI * this.rotateSpeed / this.domElement.clientHeight);
	          }
	        } else {
	          if (this.enablePan) {
	            this._pan(this.keyPanSpeed, 0);
	          }
	        }
	        needsUpdate = true;
	        break;
	      case this.keys.RIGHT:
	        if (event.ctrlKey || event.metaKey || event.shiftKey) {
	          if (this.enableRotate) {
	            this._rotateLeft(-_twoPI * this.rotateSpeed / this.domElement.clientHeight);
	          }
	        } else {
	          if (this.enablePan) {
	            this._pan(-this.keyPanSpeed, 0);
	          }
	        }
	        needsUpdate = true;
	        break;
	    }
	    if (needsUpdate) {
	      // prevent the browser from scrolling on cursor keys
	      event.preventDefault();
	      this.update();
	    }
	  }
	  _handleTouchStartRotate(event) {
	    if (this._pointers.length === 1) {
	      this._rotateStart.set(event.pageX, event.pageY);
	    } else {
	      const position = this._getSecondPointerPosition(event);
	      const x = 0.5 * (event.pageX + position.x);
	      const y = 0.5 * (event.pageY + position.y);
	      this._rotateStart.set(x, y);
	    }
	  }
	  _handleTouchStartPan(event) {
	    if (this._pointers.length === 1) {
	      this._panStart.set(event.pageX, event.pageY);
	    } else {
	      const position = this._getSecondPointerPosition(event);
	      const x = 0.5 * (event.pageX + position.x);
	      const y = 0.5 * (event.pageY + position.y);
	      this._panStart.set(x, y);
	    }
	  }
	  _handleTouchStartDolly(event) {
	    const position = this._getSecondPointerPosition(event);
	    const dx = event.pageX - position.x;
	    const dy = event.pageY - position.y;
	    const distance = Math.sqrt(dx * dx + dy * dy);
	    this._dollyStart.set(0, distance);
	  }
	  _handleTouchStartDollyPan(event) {
	    if (this.enableZoom) this._handleTouchStartDolly(event);
	    if (this.enablePan) this._handleTouchStartPan(event);
	  }
	  _handleTouchStartDollyRotate(event) {
	    if (this.enableZoom) this._handleTouchStartDolly(event);
	    if (this.enableRotate) this._handleTouchStartRotate(event);
	  }
	  _handleTouchMoveRotate(event) {
	    if (this._pointers.length == 1) {
	      this._rotateEnd.set(event.pageX, event.pageY);
	    } else {
	      const position = this._getSecondPointerPosition(event);
	      const x = 0.5 * (event.pageX + position.x);
	      const y = 0.5 * (event.pageY + position.y);
	      this._rotateEnd.set(x, y);
	    }
	    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
	    const element = this.domElement;
	    this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight); // yes, height

	    this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);
	    this._rotateStart.copy(this._rotateEnd);
	  }
	  _handleTouchMovePan(event) {
	    if (this._pointers.length === 1) {
	      this._panEnd.set(event.pageX, event.pageY);
	    } else {
	      const position = this._getSecondPointerPosition(event);
	      const x = 0.5 * (event.pageX + position.x);
	      const y = 0.5 * (event.pageY + position.y);
	      this._panEnd.set(x, y);
	    }
	    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
	    this._pan(this._panDelta.x, this._panDelta.y);
	    this._panStart.copy(this._panEnd);
	  }
	  _handleTouchMoveDolly(event) {
	    const position = this._getSecondPointerPosition(event);
	    const dx = event.pageX - position.x;
	    const dy = event.pageY - position.y;
	    const distance = Math.sqrt(dx * dx + dy * dy);
	    this._dollyEnd.set(0, distance);
	    this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed));
	    this._dollyOut(this._dollyDelta.y);
	    this._dollyStart.copy(this._dollyEnd);
	    const centerX = (event.pageX + position.x) * 0.5;
	    const centerY = (event.pageY + position.y) * 0.5;
	    this._updateZoomParameters(centerX, centerY);
	  }
	  _handleTouchMoveDollyPan(event) {
	    if (this.enableZoom) this._handleTouchMoveDolly(event);
	    if (this.enablePan) this._handleTouchMovePan(event);
	  }
	  _handleTouchMoveDollyRotate(event) {
	    if (this.enableZoom) this._handleTouchMoveDolly(event);
	    if (this.enableRotate) this._handleTouchMoveRotate(event);
	  }

	  // pointers

	  _addPointer(event) {
	    this._pointers.push(event.pointerId);
	  }
	  _removePointer(event) {
	    delete this._pointerPositions[event.pointerId];
	    for (let i = 0; i < this._pointers.length; i++) {
	      if (this._pointers[i] == event.pointerId) {
	        this._pointers.splice(i, 1);
	        return;
	      }
	    }
	  }
	  _isTrackingPointer(event) {
	    for (let i = 0; i < this._pointers.length; i++) {
	      if (this._pointers[i] == event.pointerId) return true;
	    }
	    return false;
	  }
	  _trackPointer(event) {
	    let position = this._pointerPositions[event.pointerId];
	    if (position === undefined) {
	      position = new Vector2$1();
	      this._pointerPositions[event.pointerId] = position;
	    }
	    position.set(event.pageX, event.pageY);
	  }
	  _getSecondPointerPosition(event) {
	    const pointerId = event.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
	    return this._pointerPositions[pointerId];
	  }

	  //

	  _customWheelEvent(event) {
	    const mode = event.deltaMode;

	    // minimal wheel event altered to meet delta-zoom demand
	    const newEvent = {
	      clientX: event.clientX,
	      clientY: event.clientY,
	      deltaY: event.deltaY
	    };
	    switch (mode) {
	      case 1:
	        // LINE_MODE
	        newEvent.deltaY *= 16;
	        break;
	      case 2:
	        // PAGE_MODE
	        newEvent.deltaY *= 100;
	        break;
	    }

	    // detect if event was triggered by pinching
	    if (event.ctrlKey && !this._controlActive) {
	      newEvent.deltaY *= 10;
	    }
	    return newEvent;
	  }
	}
	function onPointerDown(event) {
	  if (this.enabled === false) return;
	  if (this._pointers.length === 0) {
	    this.domElement.setPointerCapture(event.pointerId);
	    this.domElement.addEventListener('pointermove', this._onPointerMove);
	    this.domElement.addEventListener('pointerup', this._onPointerUp);
	  }

	  //

	  if (this._isTrackingPointer(event)) return;

	  //

	  this._addPointer(event);
	  if (event.pointerType === 'touch') {
	    this._onTouchStart(event);
	  } else {
	    this._onMouseDown(event);
	  }
	}
	function onPointerMove(event) {
	  if (this.enabled === false) return;
	  if (event.pointerType === 'touch') {
	    this._onTouchMove(event);
	  } else {
	    this._onMouseMove(event);
	  }
	}
	function onPointerUp(event) {
	  this._removePointer(event);
	  switch (this._pointers.length) {
	    case 0:
	      this.domElement.releasePointerCapture(event.pointerId);
	      this.domElement.removeEventListener('pointermove', this._onPointerMove);
	      this.domElement.removeEventListener('pointerup', this._onPointerUp);
	      this.dispatchEvent(_endEvent);
	      this.state = _STATE.NONE;
	      break;
	    case 1:
	      const pointerId = this._pointers[0];
	      const position = this._pointerPositions[pointerId];

	      // minimal placeholder event - allows state correction on pointer-up
	      this._onTouchStart({
	        pointerId: pointerId,
	        pageX: position.x,
	        pageY: position.y
	      });
	      break;
	  }
	}
	function onMouseDown(event) {
	  let mouseAction;
	  switch (event.button) {
	    case 0:
	      mouseAction = this.mouseButtons.LEFT;
	      break;
	    case 1:
	      mouseAction = this.mouseButtons.MIDDLE;
	      break;
	    case 2:
	      mouseAction = this.mouseButtons.RIGHT;
	      break;
	    default:
	      mouseAction = -1;
	  }
	  switch (mouseAction) {
	    case MOUSE.DOLLY:
	      if (this.enableZoom === false) return;
	      this._handleMouseDownDolly(event);
	      this.state = _STATE.DOLLY;
	      break;
	    case MOUSE.ROTATE:
	      if (event.ctrlKey || event.metaKey || event.shiftKey) {
	        if (this.enablePan === false) return;
	        this._handleMouseDownPan(event);
	        this.state = _STATE.PAN;
	      } else {
	        if (this.enableRotate === false) return;
	        this._handleMouseDownRotate(event);
	        this.state = _STATE.ROTATE;
	      }
	      break;
	    case MOUSE.PAN:
	      if (event.ctrlKey || event.metaKey || event.shiftKey) {
	        if (this.enableRotate === false) return;
	        this._handleMouseDownRotate(event);
	        this.state = _STATE.ROTATE;
	      } else {
	        if (this.enablePan === false) return;
	        this._handleMouseDownPan(event);
	        this.state = _STATE.PAN;
	      }
	      break;
	    default:
	      this.state = _STATE.NONE;
	  }
	  if (this.state !== _STATE.NONE) {
	    this.dispatchEvent(_startEvent);
	  }
	}
	function onMouseMove(event) {
	  switch (this.state) {
	    case _STATE.ROTATE:
	      if (this.enableRotate === false) return;
	      this._handleMouseMoveRotate(event);
	      break;
	    case _STATE.DOLLY:
	      if (this.enableZoom === false) return;
	      this._handleMouseMoveDolly(event);
	      break;
	    case _STATE.PAN:
	      if (this.enablePan === false) return;
	      this._handleMouseMovePan(event);
	      break;
	  }
	}
	function onMouseWheel(event) {
	  if (this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE) return;
	  event.preventDefault();
	  this.dispatchEvent(_startEvent);
	  this._handleMouseWheel(this._customWheelEvent(event));
	  this.dispatchEvent(_endEvent);
	}
	function onKeyDown(event) {
	  if (this.enabled === false) return;
	  this._handleKeyDown(event);
	}
	function onTouchStart(event) {
	  this._trackPointer(event);
	  switch (this._pointers.length) {
	    case 1:
	      switch (this.touches.ONE) {
	        case TOUCH.ROTATE:
	          if (this.enableRotate === false) return;
	          this._handleTouchStartRotate(event);
	          this.state = _STATE.TOUCH_ROTATE;
	          break;
	        case TOUCH.PAN:
	          if (this.enablePan === false) return;
	          this._handleTouchStartPan(event);
	          this.state = _STATE.TOUCH_PAN;
	          break;
	        default:
	          this.state = _STATE.NONE;
	      }
	      break;
	    case 2:
	      switch (this.touches.TWO) {
	        case TOUCH.DOLLY_PAN:
	          if (this.enableZoom === false && this.enablePan === false) return;
	          this._handleTouchStartDollyPan(event);
	          this.state = _STATE.TOUCH_DOLLY_PAN;
	          break;
	        case TOUCH.DOLLY_ROTATE:
	          if (this.enableZoom === false && this.enableRotate === false) return;
	          this._handleTouchStartDollyRotate(event);
	          this.state = _STATE.TOUCH_DOLLY_ROTATE;
	          break;
	        default:
	          this.state = _STATE.NONE;
	      }
	      break;
	    default:
	      this.state = _STATE.NONE;
	  }
	  if (this.state !== _STATE.NONE) {
	    this.dispatchEvent(_startEvent);
	  }
	}
	function onTouchMove(event) {
	  this._trackPointer(event);
	  switch (this.state) {
	    case _STATE.TOUCH_ROTATE:
	      if (this.enableRotate === false) return;
	      this._handleTouchMoveRotate(event);
	      this.update();
	      break;
	    case _STATE.TOUCH_PAN:
	      if (this.enablePan === false) return;
	      this._handleTouchMovePan(event);
	      this.update();
	      break;
	    case _STATE.TOUCH_DOLLY_PAN:
	      if (this.enableZoom === false && this.enablePan === false) return;
	      this._handleTouchMoveDollyPan(event);
	      this.update();
	      break;
	    case _STATE.TOUCH_DOLLY_ROTATE:
	      if (this.enableZoom === false && this.enableRotate === false) return;
	      this._handleTouchMoveDollyRotate(event);
	      this.update();
	      break;
	    default:
	      this.state = _STATE.NONE;
	  }
	}
	function onContextMenu(event) {
	  if (this.enabled === false) return;
	  event.preventDefault();
	}
	function interceptControlDown(event) {
	  if (event.key === 'Control') {
	    this._controlActive = true;
	    const document = this.domElement.getRootNode(); // offscreen canvas compatibility

	    document.addEventListener('keyup', this._interceptControlUp, {
	      passive: true,
	      capture: true
	    });
	  }
	}
	function interceptControlUp(event) {
	  if (event.key === 'Control') {
	    this._controlActive = false;
	    const document = this.domElement.getRootNode(); // offscreen canvas compatibility

	    document.removeEventListener('keyup', this._interceptControlUp, {
	      passive: true,
	      capture: true
	    });
	  }
	}

	const _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];

	// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
	function generateUUID() {
	  const d0 = Math.random() * 0xffffffff | 0;
	  const d1 = Math.random() * 0xffffffff | 0;
	  const d2 = Math.random() * 0xffffffff | 0;
	  const d3 = Math.random() * 0xffffffff | 0;
	  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];

	  // .toLowerCase() here flattens concatenated strings to save heap memory space.
	  return uuid.toLowerCase();
	}
	function clamp(value, min, max) {
	  return Math.max(min, Math.min(max, value));
	}
	function denormalize(value, array) {
	  switch (array.constructor) {
	    case Float32Array:
	      return value;
	    case Uint32Array:
	      return value / 4294967295.0;
	    case Uint16Array:
	      return value / 65535.0;
	    case Uint8Array:
	      return value / 255.0;
	    case Int32Array:
	      return Math.max(value / 2147483647.0, -1.0);
	    case Int16Array:
	      return Math.max(value / 32767.0, -1.0);
	    case Int8Array:
	      return Math.max(value / 127.0, -1.0);
	    default:
	      throw new Error('Invalid component type.');
	  }
	}
	function normalize(value, array) {
	  switch (array.constructor) {
	    case Float32Array:
	      return value;
	    case Uint32Array:
	      return Math.round(value * 4294967295.0);
	    case Uint16Array:
	      return Math.round(value * 65535.0);
	    case Uint8Array:
	      return Math.round(value * 255.0);
	    case Int32Array:
	      return Math.round(value * 2147483647.0);
	    case Int16Array:
	      return Math.round(value * 32767.0);
	    case Int8Array:
	      return Math.round(value * 127.0);
	    default:
	      throw new Error('Invalid component type.');
	  }
	}

	class Quaternion {
	  constructor(x = 0, y = 0, z = 0, w = 1) {
	    this.isQuaternion = true;
	    this._x = x;
	    this._y = y;
	    this._z = z;
	    this._w = w;
	  }
	  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
	    // fuzz-free, array-based Quaternion SLERP operation

	    let x0 = src0[srcOffset0 + 0],
	      y0 = src0[srcOffset0 + 1],
	      z0 = src0[srcOffset0 + 2],
	      w0 = src0[srcOffset0 + 3];
	    const x1 = src1[srcOffset1 + 0],
	      y1 = src1[srcOffset1 + 1],
	      z1 = src1[srcOffset1 + 2],
	      w1 = src1[srcOffset1 + 3];
	    if (t === 0) {
	      dst[dstOffset + 0] = x0;
	      dst[dstOffset + 1] = y0;
	      dst[dstOffset + 2] = z0;
	      dst[dstOffset + 3] = w0;
	      return;
	    }
	    if (t === 1) {
	      dst[dstOffset + 0] = x1;
	      dst[dstOffset + 1] = y1;
	      dst[dstOffset + 2] = z1;
	      dst[dstOffset + 3] = w1;
	      return;
	    }
	    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
	      let s = 1 - t;
	      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
	        dir = cos >= 0 ? 1 : -1,
	        sqrSin = 1 - cos * cos;

	      // Skip the Slerp for tiny steps to avoid numeric problems:
	      if (sqrSin > Number.EPSILON) {
	        const sin = Math.sqrt(sqrSin),
	          len = Math.atan2(sin, cos * dir);
	        s = Math.sin(s * len) / sin;
	        t = Math.sin(t * len) / sin;
	      }
	      const tDir = t * dir;
	      x0 = x0 * s + x1 * tDir;
	      y0 = y0 * s + y1 * tDir;
	      z0 = z0 * s + z1 * tDir;
	      w0 = w0 * s + w1 * tDir;

	      // Normalize in case we just did a lerp:
	      if (s === 1 - t) {
	        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
	        x0 *= f;
	        y0 *= f;
	        z0 *= f;
	        w0 *= f;
	      }
	    }
	    dst[dstOffset] = x0;
	    dst[dstOffset + 1] = y0;
	    dst[dstOffset + 2] = z0;
	    dst[dstOffset + 3] = w0;
	  }
	  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
	    const x0 = src0[srcOffset0];
	    const y0 = src0[srcOffset0 + 1];
	    const z0 = src0[srcOffset0 + 2];
	    const w0 = src0[srcOffset0 + 3];
	    const x1 = src1[srcOffset1];
	    const y1 = src1[srcOffset1 + 1];
	    const z1 = src1[srcOffset1 + 2];
	    const w1 = src1[srcOffset1 + 3];
	    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
	    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
	    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
	    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
	    return dst;
	  }
	  get x() {
	    return this._x;
	  }
	  set x(value) {
	    this._x = value;
	    this._onChangeCallback();
	  }
	  get y() {
	    return this._y;
	  }
	  set y(value) {
	    this._y = value;
	    this._onChangeCallback();
	  }
	  get z() {
	    return this._z;
	  }
	  set z(value) {
	    this._z = value;
	    this._onChangeCallback();
	  }
	  get w() {
	    return this._w;
	  }
	  set w(value) {
	    this._w = value;
	    this._onChangeCallback();
	  }
	  set(x, y, z, w) {
	    this._x = x;
	    this._y = y;
	    this._z = z;
	    this._w = w;
	    this._onChangeCallback();
	    return this;
	  }
	  clone() {
	    return new this.constructor(this._x, this._y, this._z, this._w);
	  }
	  copy(quaternion) {
	    this._x = quaternion.x;
	    this._y = quaternion.y;
	    this._z = quaternion.z;
	    this._w = quaternion.w;
	    this._onChangeCallback();
	    return this;
	  }
	  setFromEuler(euler, update = true) {
	    const x = euler._x,
	      y = euler._y,
	      z = euler._z,
	      order = euler._order;

	    // http://www.mathworks.com/matlabcentral/fileexchange/
	    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
	    //	content/SpinCalc.m

	    const cos = Math.cos;
	    const sin = Math.sin;
	    const c1 = cos(x / 2);
	    const c2 = cos(y / 2);
	    const c3 = cos(z / 2);
	    const s1 = sin(x / 2);
	    const s2 = sin(y / 2);
	    const s3 = sin(z / 2);
	    switch (order) {
	      case 'XYZ':
	        this._x = s1 * c2 * c3 + c1 * s2 * s3;
	        this._y = c1 * s2 * c3 - s1 * c2 * s3;
	        this._z = c1 * c2 * s3 + s1 * s2 * c3;
	        this._w = c1 * c2 * c3 - s1 * s2 * s3;
	        break;
	      case 'YXZ':
	        this._x = s1 * c2 * c3 + c1 * s2 * s3;
	        this._y = c1 * s2 * c3 - s1 * c2 * s3;
	        this._z = c1 * c2 * s3 - s1 * s2 * c3;
	        this._w = c1 * c2 * c3 + s1 * s2 * s3;
	        break;
	      case 'ZXY':
	        this._x = s1 * c2 * c3 - c1 * s2 * s3;
	        this._y = c1 * s2 * c3 + s1 * c2 * s3;
	        this._z = c1 * c2 * s3 + s1 * s2 * c3;
	        this._w = c1 * c2 * c3 - s1 * s2 * s3;
	        break;
	      case 'ZYX':
	        this._x = s1 * c2 * c3 - c1 * s2 * s3;
	        this._y = c1 * s2 * c3 + s1 * c2 * s3;
	        this._z = c1 * c2 * s3 - s1 * s2 * c3;
	        this._w = c1 * c2 * c3 + s1 * s2 * s3;
	        break;
	      case 'YZX':
	        this._x = s1 * c2 * c3 + c1 * s2 * s3;
	        this._y = c1 * s2 * c3 + s1 * c2 * s3;
	        this._z = c1 * c2 * s3 - s1 * s2 * c3;
	        this._w = c1 * c2 * c3 - s1 * s2 * s3;
	        break;
	      case 'XZY':
	        this._x = s1 * c2 * c3 - c1 * s2 * s3;
	        this._y = c1 * s2 * c3 - s1 * c2 * s3;
	        this._z = c1 * c2 * s3 + s1 * s2 * c3;
	        this._w = c1 * c2 * c3 + s1 * s2 * s3;
	        break;
	      default:
	        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
	    }
	    if (update === true) this._onChangeCallback();
	    return this;
	  }
	  setFromAxisAngle(axis, angle) {
	    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

	    // assumes axis is normalized

	    const halfAngle = angle / 2,
	      s = Math.sin(halfAngle);
	    this._x = axis.x * s;
	    this._y = axis.y * s;
	    this._z = axis.z * s;
	    this._w = Math.cos(halfAngle);
	    this._onChangeCallback();
	    return this;
	  }
	  setFromRotationMatrix(m) {
	    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

	    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

	    const te = m.elements,
	      m11 = te[0],
	      m12 = te[4],
	      m13 = te[8],
	      m21 = te[1],
	      m22 = te[5],
	      m23 = te[9],
	      m31 = te[2],
	      m32 = te[6],
	      m33 = te[10],
	      trace = m11 + m22 + m33;
	    if (trace > 0) {
	      const s = 0.5 / Math.sqrt(trace + 1.0);
	      this._w = 0.25 / s;
	      this._x = (m32 - m23) * s;
	      this._y = (m13 - m31) * s;
	      this._z = (m21 - m12) * s;
	    } else if (m11 > m22 && m11 > m33) {
	      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
	      this._w = (m32 - m23) / s;
	      this._x = 0.25 * s;
	      this._y = (m12 + m21) / s;
	      this._z = (m13 + m31) / s;
	    } else if (m22 > m33) {
	      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
	      this._w = (m13 - m31) / s;
	      this._x = (m12 + m21) / s;
	      this._y = 0.25 * s;
	      this._z = (m23 + m32) / s;
	    } else {
	      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
	      this._w = (m21 - m12) / s;
	      this._x = (m13 + m31) / s;
	      this._y = (m23 + m32) / s;
	      this._z = 0.25 * s;
	    }
	    this._onChangeCallback();
	    return this;
	  }
	  setFromUnitVectors(vFrom, vTo) {
	    // assumes direction vectors vFrom and vTo are normalized

	    let r = vFrom.dot(vTo) + 1;
	    if (r < Number.EPSILON) {
	      // vFrom and vTo point in opposite directions

	      r = 0;
	      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
	        this._x = -vFrom.y;
	        this._y = vFrom.x;
	        this._z = 0;
	        this._w = r;
	      } else {
	        this._x = 0;
	        this._y = -vFrom.z;
	        this._z = vFrom.y;
	        this._w = r;
	      }
	    } else {
	      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

	      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
	      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
	      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
	      this._w = r;
	    }
	    return this.normalize();
	  }
	  angleTo(q) {
	    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
	  }
	  rotateTowards(q, step) {
	    const angle = this.angleTo(q);
	    if (angle === 0) return this;
	    const t = Math.min(1, step / angle);
	    this.slerp(q, t);
	    return this;
	  }
	  identity() {
	    return this.set(0, 0, 0, 1);
	  }
	  invert() {
	    // quaternion is assumed to have unit length

	    return this.conjugate();
	  }
	  conjugate() {
	    this._x *= -1;
	    this._y *= -1;
	    this._z *= -1;
	    this._onChangeCallback();
	    return this;
	  }
	  dot(v) {
	    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	  }
	  lengthSq() {
	    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	  }
	  length() {
	    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
	  }
	  normalize() {
	    let l = this.length();
	    if (l === 0) {
	      this._x = 0;
	      this._y = 0;
	      this._z = 0;
	      this._w = 1;
	    } else {
	      l = 1 / l;
	      this._x = this._x * l;
	      this._y = this._y * l;
	      this._z = this._z * l;
	      this._w = this._w * l;
	    }
	    this._onChangeCallback();
	    return this;
	  }
	  multiply(q) {
	    return this.multiplyQuaternions(this, q);
	  }
	  premultiply(q) {
	    return this.multiplyQuaternions(q, this);
	  }
	  multiplyQuaternions(a, b) {
	    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

	    const qax = a._x,
	      qay = a._y,
	      qaz = a._z,
	      qaw = a._w;
	    const qbx = b._x,
	      qby = b._y,
	      qbz = b._z,
	      qbw = b._w;
	    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
	    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
	    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
	    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	    this._onChangeCallback();
	    return this;
	  }
	  slerp(qb, t) {
	    if (t === 0) return this;
	    if (t === 1) return this.copy(qb);
	    const x = this._x,
	      y = this._y,
	      z = this._z,
	      w = this._w;

	    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

	    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	    if (cosHalfTheta < 0) {
	      this._w = -qb._w;
	      this._x = -qb._x;
	      this._y = -qb._y;
	      this._z = -qb._z;
	      cosHalfTheta = -cosHalfTheta;
	    } else {
	      this.copy(qb);
	    }
	    if (cosHalfTheta >= 1.0) {
	      this._w = w;
	      this._x = x;
	      this._y = y;
	      this._z = z;
	      return this;
	    }
	    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
	    if (sqrSinHalfTheta <= Number.EPSILON) {
	      const s = 1 - t;
	      this._w = s * w + t * this._w;
	      this._x = s * x + t * this._x;
	      this._y = s * y + t * this._y;
	      this._z = s * z + t * this._z;
	      this.normalize(); // normalize calls _onChangeCallback()

	      return this;
	    }
	    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
	    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
	    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
	      ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
	    this._w = w * ratioA + this._w * ratioB;
	    this._x = x * ratioA + this._x * ratioB;
	    this._y = y * ratioA + this._y * ratioB;
	    this._z = z * ratioA + this._z * ratioB;
	    this._onChangeCallback();
	    return this;
	  }
	  slerpQuaternions(qa, qb, t) {
	    return this.copy(qa).slerp(qb, t);
	  }
	  random() {
	    // sets this quaternion to a uniform random unit quaternnion

	    // Ken Shoemake
	    // Uniform random rotations
	    // D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

	    const theta1 = 2 * Math.PI * Math.random();
	    const theta2 = 2 * Math.PI * Math.random();
	    const x0 = Math.random();
	    const r1 = Math.sqrt(1 - x0);
	    const r2 = Math.sqrt(x0);
	    return this.set(r1 * Math.sin(theta1), r1 * Math.cos(theta1), r2 * Math.sin(theta2), r2 * Math.cos(theta2));
	  }
	  equals(quaternion) {
	    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
	  }
	  fromArray(array, offset = 0) {
	    this._x = array[offset];
	    this._y = array[offset + 1];
	    this._z = array[offset + 2];
	    this._w = array[offset + 3];
	    this._onChangeCallback();
	    return this;
	  }
	  toArray(array = [], offset = 0) {
	    array[offset] = this._x;
	    array[offset + 1] = this._y;
	    array[offset + 2] = this._z;
	    array[offset + 3] = this._w;
	    return array;
	  }
	  fromBufferAttribute(attribute, index) {
	    this._x = attribute.getX(index);
	    this._y = attribute.getY(index);
	    this._z = attribute.getZ(index);
	    this._w = attribute.getW(index);
	    this._onChangeCallback();
	    return this;
	  }
	  toJSON() {
	    return this.toArray();
	  }
	  _onChange(callback) {
	    this._onChangeCallback = callback;
	    return this;
	  }
	  _onChangeCallback() {}
	  *[Symbol.iterator]() {
	    yield this._x;
	    yield this._y;
	    yield this._z;
	    yield this._w;
	  }
	}

	class Vector3 {
	  constructor(x = 0, y = 0, z = 0) {
	    Vector3.prototype.isVector3 = true;
	    this.x = x;
	    this.y = y;
	    this.z = z;
	  }
	  set(x, y, z) {
	    if (z === undefined) z = this.z; // sprite.scale.set(x,y)

	    this.x = x;
	    this.y = y;
	    this.z = z;
	    return this;
	  }
	  setScalar(scalar) {
	    this.x = scalar;
	    this.y = scalar;
	    this.z = scalar;
	    return this;
	  }
	  setX(x) {
	    this.x = x;
	    return this;
	  }
	  setY(y) {
	    this.y = y;
	    return this;
	  }
	  setZ(z) {
	    this.z = z;
	    return this;
	  }
	  setComponent(index, value) {
	    switch (index) {
	      case 0:
	        this.x = value;
	        break;
	      case 1:
	        this.y = value;
	        break;
	      case 2:
	        this.z = value;
	        break;
	      default:
	        throw new Error('index is out of range: ' + index);
	    }
	    return this;
	  }
	  getComponent(index) {
	    switch (index) {
	      case 0:
	        return this.x;
	      case 1:
	        return this.y;
	      case 2:
	        return this.z;
	      default:
	        throw new Error('index is out of range: ' + index);
	    }
	  }
	  clone() {
	    return new this.constructor(this.x, this.y, this.z);
	  }
	  copy(v) {
	    this.x = v.x;
	    this.y = v.y;
	    this.z = v.z;
	    return this;
	  }
	  add(v) {
	    this.x += v.x;
	    this.y += v.y;
	    this.z += v.z;
	    return this;
	  }
	  addScalar(s) {
	    this.x += s;
	    this.y += s;
	    this.z += s;
	    return this;
	  }
	  addVectors(a, b) {
	    this.x = a.x + b.x;
	    this.y = a.y + b.y;
	    this.z = a.z + b.z;
	    return this;
	  }
	  addScaledVector(v, s) {
	    this.x += v.x * s;
	    this.y += v.y * s;
	    this.z += v.z * s;
	    return this;
	  }
	  sub(v) {
	    this.x -= v.x;
	    this.y -= v.y;
	    this.z -= v.z;
	    return this;
	  }
	  subScalar(s) {
	    this.x -= s;
	    this.y -= s;
	    this.z -= s;
	    return this;
	  }
	  subVectors(a, b) {
	    this.x = a.x - b.x;
	    this.y = a.y - b.y;
	    this.z = a.z - b.z;
	    return this;
	  }
	  multiply(v) {
	    this.x *= v.x;
	    this.y *= v.y;
	    this.z *= v.z;
	    return this;
	  }
	  multiplyScalar(scalar) {
	    this.x *= scalar;
	    this.y *= scalar;
	    this.z *= scalar;
	    return this;
	  }
	  multiplyVectors(a, b) {
	    this.x = a.x * b.x;
	    this.y = a.y * b.y;
	    this.z = a.z * b.z;
	    return this;
	  }
	  applyEuler(euler) {
	    return this.applyQuaternion(_quaternion$2.setFromEuler(euler));
	  }
	  applyAxisAngle(axis, angle) {
	    return this.applyQuaternion(_quaternion$2.setFromAxisAngle(axis, angle));
	  }
	  applyMatrix3(m) {
	    const x = this.x,
	      y = this.y,
	      z = this.z;
	    const e = m.elements;
	    this.x = e[0] * x + e[3] * y + e[6] * z;
	    this.y = e[1] * x + e[4] * y + e[7] * z;
	    this.z = e[2] * x + e[5] * y + e[8] * z;
	    return this;
	  }
	  applyNormalMatrix(m) {
	    return this.applyMatrix3(m).normalize();
	  }
	  applyMatrix4(m) {
	    const x = this.x,
	      y = this.y,
	      z = this.z;
	    const e = m.elements;
	    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
	    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
	    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
	    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
	    return this;
	  }
	  applyQuaternion(q) {
	    // quaternion q is assumed to have unit length

	    const vx = this.x,
	      vy = this.y,
	      vz = this.z;
	    const qx = q.x,
	      qy = q.y,
	      qz = q.z,
	      qw = q.w;

	    // t = 2 * cross( q.xyz, v );
	    const tx = 2 * (qy * vz - qz * vy);
	    const ty = 2 * (qz * vx - qx * vz);
	    const tz = 2 * (qx * vy - qy * vx);

	    // v + q.w * t + cross( q.xyz, t );
	    this.x = vx + qw * tx + qy * tz - qz * ty;
	    this.y = vy + qw * ty + qz * tx - qx * tz;
	    this.z = vz + qw * tz + qx * ty - qy * tx;
	    return this;
	  }
	  project(camera) {
	    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
	  }
	  unproject(camera) {
	    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
	  }
	  transformDirection(m) {
	    // input: THREE.Matrix4 affine matrix
	    // vector interpreted as a direction

	    const x = this.x,
	      y = this.y,
	      z = this.z;
	    const e = m.elements;
	    this.x = e[0] * x + e[4] * y + e[8] * z;
	    this.y = e[1] * x + e[5] * y + e[9] * z;
	    this.z = e[2] * x + e[6] * y + e[10] * z;
	    return this.normalize();
	  }
	  divide(v) {
	    this.x /= v.x;
	    this.y /= v.y;
	    this.z /= v.z;
	    return this;
	  }
	  divideScalar(scalar) {
	    return this.multiplyScalar(1 / scalar);
	  }
	  min(v) {
	    this.x = Math.min(this.x, v.x);
	    this.y = Math.min(this.y, v.y);
	    this.z = Math.min(this.z, v.z);
	    return this;
	  }
	  max(v) {
	    this.x = Math.max(this.x, v.x);
	    this.y = Math.max(this.y, v.y);
	    this.z = Math.max(this.z, v.z);
	    return this;
	  }
	  clamp(min, max) {
	    // assumes min < max, componentwise

	    this.x = clamp(this.x, min.x, max.x);
	    this.y = clamp(this.y, min.y, max.y);
	    this.z = clamp(this.z, min.z, max.z);
	    return this;
	  }
	  clampScalar(minVal, maxVal) {
	    this.x = clamp(this.x, minVal, maxVal);
	    this.y = clamp(this.y, minVal, maxVal);
	    this.z = clamp(this.z, minVal, maxVal);
	    return this;
	  }
	  clampLength(min, max) {
	    const length = this.length();
	    return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
	  }
	  floor() {
	    this.x = Math.floor(this.x);
	    this.y = Math.floor(this.y);
	    this.z = Math.floor(this.z);
	    return this;
	  }
	  ceil() {
	    this.x = Math.ceil(this.x);
	    this.y = Math.ceil(this.y);
	    this.z = Math.ceil(this.z);
	    return this;
	  }
	  round() {
	    this.x = Math.round(this.x);
	    this.y = Math.round(this.y);
	    this.z = Math.round(this.z);
	    return this;
	  }
	  roundToZero() {
	    this.x = Math.trunc(this.x);
	    this.y = Math.trunc(this.y);
	    this.z = Math.trunc(this.z);
	    return this;
	  }
	  negate() {
	    this.x = -this.x;
	    this.y = -this.y;
	    this.z = -this.z;
	    return this;
	  }
	  dot(v) {
	    return this.x * v.x + this.y * v.y + this.z * v.z;
	  }

	  // TODO lengthSquared?

	  lengthSq() {
	    return this.x * this.x + this.y * this.y + this.z * this.z;
	  }
	  length() {
	    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	  }
	  manhattanLength() {
	    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
	  }
	  normalize() {
	    return this.divideScalar(this.length() || 1);
	  }
	  setLength(length) {
	    return this.normalize().multiplyScalar(length);
	  }
	  lerp(v, alpha) {
	    this.x += (v.x - this.x) * alpha;
	    this.y += (v.y - this.y) * alpha;
	    this.z += (v.z - this.z) * alpha;
	    return this;
	  }
	  lerpVectors(v1, v2, alpha) {
	    this.x = v1.x + (v2.x - v1.x) * alpha;
	    this.y = v1.y + (v2.y - v1.y) * alpha;
	    this.z = v1.z + (v2.z - v1.z) * alpha;
	    return this;
	  }
	  cross(v) {
	    return this.crossVectors(this, v);
	  }
	  crossVectors(a, b) {
	    const ax = a.x,
	      ay = a.y,
	      az = a.z;
	    const bx = b.x,
	      by = b.y,
	      bz = b.z;
	    this.x = ay * bz - az * by;
	    this.y = az * bx - ax * bz;
	    this.z = ax * by - ay * bx;
	    return this;
	  }
	  projectOnVector(v) {
	    const denominator = v.lengthSq();
	    if (denominator === 0) return this.set(0, 0, 0);
	    const scalar = v.dot(this) / denominator;
	    return this.copy(v).multiplyScalar(scalar);
	  }
	  projectOnPlane(planeNormal) {
	    _vector$3.copy(this).projectOnVector(planeNormal);
	    return this.sub(_vector$3);
	  }
	  reflect(normal) {
	    // reflect incident vector off plane orthogonal to normal
	    // normal is assumed to have unit length

	    return this.sub(_vector$3.copy(normal).multiplyScalar(2 * this.dot(normal)));
	  }
	  angleTo(v) {
	    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
	    if (denominator === 0) return Math.PI / 2;
	    const theta = this.dot(v) / denominator;

	    // clamp, to handle numerical problems

	    return Math.acos(clamp(theta, -1, 1));
	  }
	  distanceTo(v) {
	    return Math.sqrt(this.distanceToSquared(v));
	  }
	  distanceToSquared(v) {
	    const dx = this.x - v.x,
	      dy = this.y - v.y,
	      dz = this.z - v.z;
	    return dx * dx + dy * dy + dz * dz;
	  }
	  manhattanDistanceTo(v) {
	    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
	  }
	  setFromSpherical(s) {
	    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
	  }
	  setFromSphericalCoords(radius, phi, theta) {
	    const sinPhiRadius = Math.sin(phi) * radius;
	    this.x = sinPhiRadius * Math.sin(theta);
	    this.y = Math.cos(phi) * radius;
	    this.z = sinPhiRadius * Math.cos(theta);
	    return this;
	  }
	  setFromCylindrical(c) {
	    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
	  }
	  setFromCylindricalCoords(radius, theta, y) {
	    this.x = radius * Math.sin(theta);
	    this.y = y;
	    this.z = radius * Math.cos(theta);
	    return this;
	  }
	  setFromMatrixPosition(m) {
	    const e = m.elements;
	    this.x = e[12];
	    this.y = e[13];
	    this.z = e[14];
	    return this;
	  }
	  setFromMatrixScale(m) {
	    const sx = this.setFromMatrixColumn(m, 0).length();
	    const sy = this.setFromMatrixColumn(m, 1).length();
	    const sz = this.setFromMatrixColumn(m, 2).length();
	    this.x = sx;
	    this.y = sy;
	    this.z = sz;
	    return this;
	  }
	  setFromMatrixColumn(m, index) {
	    return this.fromArray(m.elements, index * 4);
	  }
	  setFromMatrix3Column(m, index) {
	    return this.fromArray(m.elements, index * 3);
	  }
	  setFromEuler(e) {
	    this.x = e._x;
	    this.y = e._y;
	    this.z = e._z;
	    return this;
	  }
	  setFromColor(c) {
	    this.x = c.r;
	    this.y = c.g;
	    this.z = c.b;
	    return this;
	  }
	  equals(v) {
	    return v.x === this.x && v.y === this.y && v.z === this.z;
	  }
	  fromArray(array, offset = 0) {
	    this.x = array[offset];
	    this.y = array[offset + 1];
	    this.z = array[offset + 2];
	    return this;
	  }
	  toArray(array = [], offset = 0) {
	    array[offset] = this.x;
	    array[offset + 1] = this.y;
	    array[offset + 2] = this.z;
	    return array;
	  }
	  fromBufferAttribute(attribute, index) {
	    this.x = attribute.getX(index);
	    this.y = attribute.getY(index);
	    this.z = attribute.getZ(index);
	    return this;
	  }
	  random() {
	    this.x = Math.random();
	    this.y = Math.random();
	    this.z = Math.random();
	    return this;
	  }
	  randomDirection() {
	    // https://mathworld.wolfram.com/SpherePointPicking.html

	    const theta = Math.random() * Math.PI * 2;
	    const u = Math.random() * 2 - 1;
	    const c = Math.sqrt(1 - u * u);
	    this.x = c * Math.cos(theta);
	    this.y = u;
	    this.z = c * Math.sin(theta);
	    return this;
	  }
	  *[Symbol.iterator]() {
	    yield this.x;
	    yield this.y;
	    yield this.z;
	  }
	}
	const _vector$3 = /*@__PURE__*/new Vector3();
	const _quaternion$2 = /*@__PURE__*/new Quaternion();

	class Vector2 {
	  constructor(x = 0, y = 0) {
	    Vector2.prototype.isVector2 = true;
	    this.x = x;
	    this.y = y;
	  }
	  get width() {
	    return this.x;
	  }
	  set width(value) {
	    this.x = value;
	  }
	  get height() {
	    return this.y;
	  }
	  set height(value) {
	    this.y = value;
	  }
	  set(x, y) {
	    this.x = x;
	    this.y = y;
	    return this;
	  }
	  setScalar(scalar) {
	    this.x = scalar;
	    this.y = scalar;
	    return this;
	  }
	  setX(x) {
	    this.x = x;
	    return this;
	  }
	  setY(y) {
	    this.y = y;
	    return this;
	  }
	  setComponent(index, value) {
	    switch (index) {
	      case 0:
	        this.x = value;
	        break;
	      case 1:
	        this.y = value;
	        break;
	      default:
	        throw new Error('index is out of range: ' + index);
	    }
	    return this;
	  }
	  getComponent(index) {
	    switch (index) {
	      case 0:
	        return this.x;
	      case 1:
	        return this.y;
	      default:
	        throw new Error('index is out of range: ' + index);
	    }
	  }
	  clone() {
	    return new this.constructor(this.x, this.y);
	  }
	  copy(v) {
	    this.x = v.x;
	    this.y = v.y;
	    return this;
	  }
	  add(v) {
	    this.x += v.x;
	    this.y += v.y;
	    return this;
	  }
	  addScalar(s) {
	    this.x += s;
	    this.y += s;
	    return this;
	  }
	  addVectors(a, b) {
	    this.x = a.x + b.x;
	    this.y = a.y + b.y;
	    return this;
	  }
	  addScaledVector(v, s) {
	    this.x += v.x * s;
	    this.y += v.y * s;
	    return this;
	  }
	  sub(v) {
	    this.x -= v.x;
	    this.y -= v.y;
	    return this;
	  }
	  subScalar(s) {
	    this.x -= s;
	    this.y -= s;
	    return this;
	  }
	  subVectors(a, b) {
	    this.x = a.x - b.x;
	    this.y = a.y - b.y;
	    return this;
	  }
	  multiply(v) {
	    this.x *= v.x;
	    this.y *= v.y;
	    return this;
	  }
	  multiplyScalar(scalar) {
	    this.x *= scalar;
	    this.y *= scalar;
	    return this;
	  }
	  divide(v) {
	    this.x /= v.x;
	    this.y /= v.y;
	    return this;
	  }
	  divideScalar(scalar) {
	    return this.multiplyScalar(1 / scalar);
	  }
	  applyMatrix3(m) {
	    const x = this.x,
	      y = this.y;
	    const e = m.elements;
	    this.x = e[0] * x + e[3] * y + e[6];
	    this.y = e[1] * x + e[4] * y + e[7];
	    return this;
	  }
	  min(v) {
	    this.x = Math.min(this.x, v.x);
	    this.y = Math.min(this.y, v.y);
	    return this;
	  }
	  max(v) {
	    this.x = Math.max(this.x, v.x);
	    this.y = Math.max(this.y, v.y);
	    return this;
	  }
	  clamp(min, max) {
	    // assumes min < max, componentwise

	    this.x = clamp(this.x, min.x, max.x);
	    this.y = clamp(this.y, min.y, max.y);
	    return this;
	  }
	  clampScalar(minVal, maxVal) {
	    this.x = clamp(this.x, minVal, maxVal);
	    this.y = clamp(this.y, minVal, maxVal);
	    return this;
	  }
	  clampLength(min, max) {
	    const length = this.length();
	    return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
	  }
	  floor() {
	    this.x = Math.floor(this.x);
	    this.y = Math.floor(this.y);
	    return this;
	  }
	  ceil() {
	    this.x = Math.ceil(this.x);
	    this.y = Math.ceil(this.y);
	    return this;
	  }
	  round() {
	    this.x = Math.round(this.x);
	    this.y = Math.round(this.y);
	    return this;
	  }
	  roundToZero() {
	    this.x = Math.trunc(this.x);
	    this.y = Math.trunc(this.y);
	    return this;
	  }
	  negate() {
	    this.x = -this.x;
	    this.y = -this.y;
	    return this;
	  }
	  dot(v) {
	    return this.x * v.x + this.y * v.y;
	  }
	  cross(v) {
	    return this.x * v.y - this.y * v.x;
	  }
	  lengthSq() {
	    return this.x * this.x + this.y * this.y;
	  }
	  length() {
	    return Math.sqrt(this.x * this.x + this.y * this.y);
	  }
	  manhattanLength() {
	    return Math.abs(this.x) + Math.abs(this.y);
	  }
	  normalize() {
	    return this.divideScalar(this.length() || 1);
	  }
	  angle() {
	    // computes the angle in radians with respect to the positive x-axis

	    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
	    return angle;
	  }
	  angleTo(v) {
	    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
	    if (denominator === 0) return Math.PI / 2;
	    const theta = this.dot(v) / denominator;

	    // clamp, to handle numerical problems

	    return Math.acos(clamp(theta, -1, 1));
	  }
	  distanceTo(v) {
	    return Math.sqrt(this.distanceToSquared(v));
	  }
	  distanceToSquared(v) {
	    const dx = this.x - v.x,
	      dy = this.y - v.y;
	    return dx * dx + dy * dy;
	  }
	  manhattanDistanceTo(v) {
	    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
	  }
	  setLength(length) {
	    return this.normalize().multiplyScalar(length);
	  }
	  lerp(v, alpha) {
	    this.x += (v.x - this.x) * alpha;
	    this.y += (v.y - this.y) * alpha;
	    return this;
	  }
	  lerpVectors(v1, v2, alpha) {
	    this.x = v1.x + (v2.x - v1.x) * alpha;
	    this.y = v1.y + (v2.y - v1.y) * alpha;
	    return this;
	  }
	  equals(v) {
	    return v.x === this.x && v.y === this.y;
	  }
	  fromArray(array, offset = 0) {
	    this.x = array[offset];
	    this.y = array[offset + 1];
	    return this;
	  }
	  toArray(array = [], offset = 0) {
	    array[offset] = this.x;
	    array[offset + 1] = this.y;
	    return array;
	  }
	  fromBufferAttribute(attribute, index) {
	    this.x = attribute.getX(index);
	    this.y = attribute.getY(index);
	    return this;
	  }
	  rotateAround(center, angle) {
	    const c = Math.cos(angle),
	      s = Math.sin(angle);
	    const x = this.x - center.x;
	    const y = this.y - center.y;
	    this.x = x * c - y * s + center.x;
	    this.y = x * s + y * c + center.y;
	    return this;
	  }
	  random() {
	    this.x = Math.random();
	    this.y = Math.random();
	    return this;
	  }
	  *[Symbol.iterator]() {
	    yield this.x;
	    yield this.y;
	  }
	}

	class Box3 {
	  constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
	    this.isBox3 = true;
	    this.min = min;
	    this.max = max;
	  }
	  set(min, max) {
	    this.min.copy(min);
	    this.max.copy(max);
	    return this;
	  }
	  setFromArray(array) {
	    this.makeEmpty();
	    for (let i = 0, il = array.length; i < il; i += 3) {
	      this.expandByPoint(_vector$2.fromArray(array, i));
	    }
	    return this;
	  }
	  setFromBufferAttribute(attribute) {
	    this.makeEmpty();
	    for (let i = 0, il = attribute.count; i < il; i++) {
	      this.expandByPoint(_vector$2.fromBufferAttribute(attribute, i));
	    }
	    return this;
	  }
	  setFromPoints(points) {
	    this.makeEmpty();
	    for (let i = 0, il = points.length; i < il; i++) {
	      this.expandByPoint(points[i]);
	    }
	    return this;
	  }
	  setFromCenterAndSize(center, size) {
	    const halfSize = _vector$2.copy(size).multiplyScalar(0.5);
	    this.min.copy(center).sub(halfSize);
	    this.max.copy(center).add(halfSize);
	    return this;
	  }
	  setFromObject(object, precise = false) {
	    this.makeEmpty();
	    return this.expandByObject(object, precise);
	  }
	  clone() {
	    return new this.constructor().copy(this);
	  }
	  copy(box) {
	    this.min.copy(box.min);
	    this.max.copy(box.max);
	    return this;
	  }
	  makeEmpty() {
	    this.min.x = this.min.y = this.min.z = +Infinity;
	    this.max.x = this.max.y = this.max.z = -Infinity;
	    return this;
	  }
	  isEmpty() {
	    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

	    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
	  }
	  getCenter(target) {
	    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
	  }
	  getSize(target) {
	    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
	  }
	  expandByPoint(point) {
	    this.min.min(point);
	    this.max.max(point);
	    return this;
	  }
	  expandByVector(vector) {
	    this.min.sub(vector);
	    this.max.add(vector);
	    return this;
	  }
	  expandByScalar(scalar) {
	    this.min.addScalar(-scalar);
	    this.max.addScalar(scalar);
	    return this;
	  }
	  expandByObject(object, precise = false) {
	    // Computes the world-axis-aligned bounding box of an object (including its children),
	    // accounting for both the object's, and children's, world transforms

	    object.updateWorldMatrix(false, false);
	    const geometry = object.geometry;
	    if (geometry !== undefined) {
	      const positionAttribute = geometry.getAttribute('position');

	      // precise AABB computation based on vertex data requires at least a position attribute.
	      // instancing isn't supported so far and uses the normal (conservative) code path.

	      if (precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true) {
	        for (let i = 0, l = positionAttribute.count; i < l; i++) {
	          if (object.isMesh === true) {
	            object.getVertexPosition(i, _vector$2);
	          } else {
	            _vector$2.fromBufferAttribute(positionAttribute, i);
	          }
	          _vector$2.applyMatrix4(object.matrixWorld);
	          this.expandByPoint(_vector$2);
	        }
	      } else {
	        if (object.boundingBox !== undefined) {
	          // object-level bounding box

	          if (object.boundingBox === null) {
	            object.computeBoundingBox();
	          }
	          _box$2.copy(object.boundingBox);
	        } else {
	          // geometry-level bounding box

	          if (geometry.boundingBox === null) {
	            geometry.computeBoundingBox();
	          }
	          _box$2.copy(geometry.boundingBox);
	        }
	        _box$2.applyMatrix4(object.matrixWorld);
	        this.union(_box$2);
	      }
	    }
	    const children = object.children;
	    for (let i = 0, l = children.length; i < l; i++) {
	      this.expandByObject(children[i], precise);
	    }
	    return this;
	  }
	  containsPoint(point) {
	    return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
	  }
	  containsBox(box) {
	    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
	  }
	  getParameter(point, target) {
	    // This can potentially have a divide by zero if the box
	    // has a size dimension of 0.

	    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
	  }
	  intersectsBox(box) {
	    // using 6 splitting planes to rule out intersections.
	    return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
	  }
	  intersectsSphere(sphere) {
	    // Find the point on the AABB closest to the sphere center.
	    this.clampPoint(sphere.center, _vector$2);

	    // If that point is inside the sphere, the AABB and sphere intersect.
	    return _vector$2.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
	  }
	  intersectsPlane(plane) {
	    // We compute the minimum and maximum dot product values. If those values
	    // are on the same side (back or front) of the plane, then there is no intersection.

	    let min, max;
	    if (plane.normal.x > 0) {
	      min = plane.normal.x * this.min.x;
	      max = plane.normal.x * this.max.x;
	    } else {
	      min = plane.normal.x * this.max.x;
	      max = plane.normal.x * this.min.x;
	    }
	    if (plane.normal.y > 0) {
	      min += plane.normal.y * this.min.y;
	      max += plane.normal.y * this.max.y;
	    } else {
	      min += plane.normal.y * this.max.y;
	      max += plane.normal.y * this.min.y;
	    }
	    if (plane.normal.z > 0) {
	      min += plane.normal.z * this.min.z;
	      max += plane.normal.z * this.max.z;
	    } else {
	      min += plane.normal.z * this.max.z;
	      max += plane.normal.z * this.min.z;
	    }
	    return min <= -plane.constant && max >= -plane.constant;
	  }
	  intersectsTriangle(triangle) {
	    if (this.isEmpty()) {
	      return false;
	    }

	    // compute box center and extents
	    this.getCenter(_center);
	    _extents.subVectors(this.max, _center);

	    // translate triangle to aabb origin
	    _v0.subVectors(triangle.a, _center);
	    _v1$3.subVectors(triangle.b, _center);
	    _v2$1.subVectors(triangle.c, _center);

	    // compute edge vectors for triangle
	    _f0.subVectors(_v1$3, _v0);
	    _f1.subVectors(_v2$1, _v1$3);
	    _f2.subVectors(_v0, _v2$1);

	    // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
	    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
	    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
	    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
	    if (!satForAxes(axes, _v0, _v1$3, _v2$1, _extents)) {
	      return false;
	    }

	    // test 3 face normals from the aabb
	    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	    if (!satForAxes(axes, _v0, _v1$3, _v2$1, _extents)) {
	      return false;
	    }

	    // finally testing the face normal of the triangle
	    // use already existing triangle edge vectors here
	    _triangleNormal.crossVectors(_f0, _f1);
	    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
	    return satForAxes(axes, _v0, _v1$3, _v2$1, _extents);
	  }
	  clampPoint(point, target) {
	    return target.copy(point).clamp(this.min, this.max);
	  }
	  distanceToPoint(point) {
	    return this.clampPoint(point, _vector$2).distanceTo(point);
	  }
	  getBoundingSphere(target) {
	    if (this.isEmpty()) {
	      target.makeEmpty();
	    } else {
	      this.getCenter(target.center);
	      target.radius = this.getSize(_vector$2).length() * 0.5;
	    }
	    return target;
	  }
	  intersect(box) {
	    this.min.max(box.min);
	    this.max.min(box.max);

	    // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
	    if (this.isEmpty()) this.makeEmpty();
	    return this;
	  }
	  union(box) {
	    this.min.min(box.min);
	    this.max.max(box.max);
	    return this;
	  }
	  applyMatrix4(matrix) {
	    // transform of empty box is an empty box.
	    if (this.isEmpty()) return this;

	    // NOTE: I am using a binary pattern to specify all 2^3 combinations below
	    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
	    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
	    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
	    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
	    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
	    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
	    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
	    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

	    this.setFromPoints(_points);
	    return this;
	  }
	  translate(offset) {
	    this.min.add(offset);
	    this.max.add(offset);
	    return this;
	  }
	  equals(box) {
	    return box.min.equals(this.min) && box.max.equals(this.max);
	  }
	}
	const _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];
	const _vector$2 = /*@__PURE__*/new Vector3();
	const _box$2 = /*@__PURE__*/new Box3();

	// triangle centered vertices

	const _v0 = /*@__PURE__*/new Vector3();
	const _v1$3 = /*@__PURE__*/new Vector3();
	const _v2$1 = /*@__PURE__*/new Vector3();

	// triangle edge vectors

	const _f0 = /*@__PURE__*/new Vector3();
	const _f1 = /*@__PURE__*/new Vector3();
	const _f2 = /*@__PURE__*/new Vector3();
	const _center = /*@__PURE__*/new Vector3();
	const _extents = /*@__PURE__*/new Vector3();
	const _triangleNormal = /*@__PURE__*/new Vector3();
	const _testAxis = /*@__PURE__*/new Vector3();
	function satForAxes(axes, v0, v1, v2, extents) {
	  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
	    _testAxis.fromArray(axes, i);
	    // project the aabb onto the separating axis
	    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
	    // project all 3 vertices of the triangle onto the separating axis
	    const p0 = v0.dot(_testAxis);
	    const p1 = v1.dot(_testAxis);
	    const p2 = v2.dot(_testAxis);
	    // actual test, basically see if either of the most extreme of the triangle points intersects r
	    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
	      // points of the projected triangle are outside the projected half-length of the aabb
	      // the axis is separating and we can exit
	      return false;
	    }
	  }
	  return true;
	}

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	class EventDispatcher {
	  addEventListener(type, listener) {
	    if (this._listeners === undefined) this._listeners = {};
	    const listeners = this._listeners;
	    if (listeners[type] === undefined) {
	      listeners[type] = [];
	    }
	    if (listeners[type].indexOf(listener) === -1) {
	      listeners[type].push(listener);
	    }
	  }
	  hasEventListener(type, listener) {
	    if (this._listeners === undefined) return false;
	    const listeners = this._listeners;
	    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
	  }
	  removeEventListener(type, listener) {
	    if (this._listeners === undefined) return;
	    const listeners = this._listeners;
	    const listenerArray = listeners[type];
	    if (listenerArray !== undefined) {
	      const index = listenerArray.indexOf(listener);
	      if (index !== -1) {
	        listenerArray.splice(index, 1);
	      }
	    }
	  }
	  dispatchEvent(event) {
	    if (this._listeners === undefined) return;
	    const listeners = this._listeners;
	    const listenerArray = listeners[event.type];
	    if (listenerArray !== undefined) {
	      event.target = this;

	      // Make a copy, in case listeners are removed while iterating.
	      const array = listenerArray.slice(0);
	      for (let i = 0, l = array.length; i < l; i++) {
	        array[i].call(this, event);
	      }
	      event.target = null;
	    }
	  }
	}

	const FloatType = 1015;
	const StaticDrawUsage = 35044;
	const WebGLCoordinateSystem = 2000;
	const WebGPUCoordinateSystem = 2001;

	const _vector$1 = /*@__PURE__*/new Vector3();
	const _vector2 = /*@__PURE__*/new Vector2();
	class BufferAttribute {
	  constructor(array, itemSize, normalized = false) {
	    if (Array.isArray(array)) {
	      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
	    }
	    this.isBufferAttribute = true;
	    this.name = '';
	    this.array = array;
	    this.itemSize = itemSize;
	    this.count = array !== undefined ? array.length / itemSize : 0;
	    this.normalized = normalized;
	    this.usage = StaticDrawUsage;
	    this.updateRanges = [];
	    this.gpuType = FloatType;
	    this.version = 0;
	  }
	  onUploadCallback() {}
	  set needsUpdate(value) {
	    if (value === true) this.version++;
	  }
	  setUsage(value) {
	    this.usage = value;
	    return this;
	  }
	  addUpdateRange(start, count) {
	    this.updateRanges.push({
	      start,
	      count
	    });
	  }
	  clearUpdateRanges() {
	    this.updateRanges.length = 0;
	  }
	  copy(source) {
	    this.name = source.name;
	    this.array = new source.array.constructor(source.array);
	    this.itemSize = source.itemSize;
	    this.count = source.count;
	    this.normalized = source.normalized;
	    this.usage = source.usage;
	    this.gpuType = source.gpuType;
	    return this;
	  }
	  copyAt(index1, attribute, index2) {
	    index1 *= this.itemSize;
	    index2 *= attribute.itemSize;
	    for (let i = 0, l = this.itemSize; i < l; i++) {
	      this.array[index1 + i] = attribute.array[index2 + i];
	    }
	    return this;
	  }
	  copyArray(array) {
	    this.array.set(array);
	    return this;
	  }
	  applyMatrix3(m) {
	    if (this.itemSize === 2) {
	      for (let i = 0, l = this.count; i < l; i++) {
	        _vector2.fromBufferAttribute(this, i);
	        _vector2.applyMatrix3(m);
	        this.setXY(i, _vector2.x, _vector2.y);
	      }
	    } else if (this.itemSize === 3) {
	      for (let i = 0, l = this.count; i < l; i++) {
	        _vector$1.fromBufferAttribute(this, i);
	        _vector$1.applyMatrix3(m);
	        this.setXYZ(i, _vector$1.x, _vector$1.y, _vector$1.z);
	      }
	    }
	    return this;
	  }
	  applyMatrix4(m) {
	    for (let i = 0, l = this.count; i < l; i++) {
	      _vector$1.fromBufferAttribute(this, i);
	      _vector$1.applyMatrix4(m);
	      this.setXYZ(i, _vector$1.x, _vector$1.y, _vector$1.z);
	    }
	    return this;
	  }
	  applyNormalMatrix(m) {
	    for (let i = 0, l = this.count; i < l; i++) {
	      _vector$1.fromBufferAttribute(this, i);
	      _vector$1.applyNormalMatrix(m);
	      this.setXYZ(i, _vector$1.x, _vector$1.y, _vector$1.z);
	    }
	    return this;
	  }
	  transformDirection(m) {
	    for (let i = 0, l = this.count; i < l; i++) {
	      _vector$1.fromBufferAttribute(this, i);
	      _vector$1.transformDirection(m);
	      this.setXYZ(i, _vector$1.x, _vector$1.y, _vector$1.z);
	    }
	    return this;
	  }
	  set(value, offset = 0) {
	    // Matching BufferAttribute constructor, do not normalize the array.
	    this.array.set(value, offset);
	    return this;
	  }
	  getComponent(index, component) {
	    let value = this.array[index * this.itemSize + component];
	    if (this.normalized) value = denormalize(value, this.array);
	    return value;
	  }
	  setComponent(index, component, value) {
	    if (this.normalized) value = normalize(value, this.array);
	    this.array[index * this.itemSize + component] = value;
	    return this;
	  }
	  getX(index) {
	    let x = this.array[index * this.itemSize];
	    if (this.normalized) x = denormalize(x, this.array);
	    return x;
	  }
	  setX(index, x) {
	    if (this.normalized) x = normalize(x, this.array);
	    this.array[index * this.itemSize] = x;
	    return this;
	  }
	  getY(index) {
	    let y = this.array[index * this.itemSize + 1];
	    if (this.normalized) y = denormalize(y, this.array);
	    return y;
	  }
	  setY(index, y) {
	    if (this.normalized) y = normalize(y, this.array);
	    this.array[index * this.itemSize + 1] = y;
	    return this;
	  }
	  getZ(index) {
	    let z = this.array[index * this.itemSize + 2];
	    if (this.normalized) z = denormalize(z, this.array);
	    return z;
	  }
	  setZ(index, z) {
	    if (this.normalized) z = normalize(z, this.array);
	    this.array[index * this.itemSize + 2] = z;
	    return this;
	  }
	  getW(index) {
	    let w = this.array[index * this.itemSize + 3];
	    if (this.normalized) w = denormalize(w, this.array);
	    return w;
	  }
	  setW(index, w) {
	    if (this.normalized) w = normalize(w, this.array);
	    this.array[index * this.itemSize + 3] = w;
	    return this;
	  }
	  setXY(index, x, y) {
	    index *= this.itemSize;
	    if (this.normalized) {
	      x = normalize(x, this.array);
	      y = normalize(y, this.array);
	    }
	    this.array[index + 0] = x;
	    this.array[index + 1] = y;
	    return this;
	  }
	  setXYZ(index, x, y, z) {
	    index *= this.itemSize;
	    if (this.normalized) {
	      x = normalize(x, this.array);
	      y = normalize(y, this.array);
	      z = normalize(z, this.array);
	    }
	    this.array[index + 0] = x;
	    this.array[index + 1] = y;
	    this.array[index + 2] = z;
	    return this;
	  }
	  setXYZW(index, x, y, z, w) {
	    index *= this.itemSize;
	    if (this.normalized) {
	      x = normalize(x, this.array);
	      y = normalize(y, this.array);
	      z = normalize(z, this.array);
	      w = normalize(w, this.array);
	    }
	    this.array[index + 0] = x;
	    this.array[index + 1] = y;
	    this.array[index + 2] = z;
	    this.array[index + 3] = w;
	    return this;
	  }
	  onUpload(callback) {
	    this.onUploadCallback = callback;
	    return this;
	  }
	  clone() {
	    return new this.constructor(this.array, this.itemSize).copy(this);
	  }
	  toJSON() {
	    const data = {
	      itemSize: this.itemSize,
	      type: this.array.constructor.name,
	      array: Array.from(this.array),
	      normalized: this.normalized
	    };
	    if (this.name !== '') data.name = this.name;
	    if (this.usage !== StaticDrawUsage) data.usage = this.usage;
	    return data;
	  }
	}
	class Uint16BufferAttribute extends BufferAttribute {
	  constructor(array, itemSize, normalized) {
	    super(new Uint16Array(array), itemSize, normalized);
	  }
	}
	class Uint32BufferAttribute extends BufferAttribute {
	  constructor(array, itemSize, normalized) {
	    super(new Uint32Array(array), itemSize, normalized);
	  }
	}
	class Float32BufferAttribute extends BufferAttribute {
	  constructor(array, itemSize, normalized) {
	    super(new Float32Array(array), itemSize, normalized);
	  }
	}

	const _box$1 = /*@__PURE__*/new Box3();
	const _v1$2 = /*@__PURE__*/new Vector3();
	const _v2 = /*@__PURE__*/new Vector3();
	class Sphere {
	  constructor(center = new Vector3(), radius = -1) {
	    this.isSphere = true;
	    this.center = center;
	    this.radius = radius;
	  }
	  set(center, radius) {
	    this.center.copy(center);
	    this.radius = radius;
	    return this;
	  }
	  setFromPoints(points, optionalCenter) {
	    const center = this.center;
	    if (optionalCenter !== undefined) {
	      center.copy(optionalCenter);
	    } else {
	      _box$1.setFromPoints(points).getCenter(center);
	    }
	    let maxRadiusSq = 0;
	    for (let i = 0, il = points.length; i < il; i++) {
	      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
	    }
	    this.radius = Math.sqrt(maxRadiusSq);
	    return this;
	  }
	  copy(sphere) {
	    this.center.copy(sphere.center);
	    this.radius = sphere.radius;
	    return this;
	  }
	  isEmpty() {
	    return this.radius < 0;
	  }
	  makeEmpty() {
	    this.center.set(0, 0, 0);
	    this.radius = -1;
	    return this;
	  }
	  containsPoint(point) {
	    return point.distanceToSquared(this.center) <= this.radius * this.radius;
	  }
	  distanceToPoint(point) {
	    return point.distanceTo(this.center) - this.radius;
	  }
	  intersectsSphere(sphere) {
	    const radiusSum = this.radius + sphere.radius;
	    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
	  }
	  intersectsBox(box) {
	    return box.intersectsSphere(this);
	  }
	  intersectsPlane(plane) {
	    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
	  }
	  clampPoint(point, target) {
	    const deltaLengthSq = this.center.distanceToSquared(point);
	    target.copy(point);
	    if (deltaLengthSq > this.radius * this.radius) {
	      target.sub(this.center).normalize();
	      target.multiplyScalar(this.radius).add(this.center);
	    }
	    return target;
	  }
	  getBoundingBox(target) {
	    if (this.isEmpty()) {
	      // Empty sphere produces empty bounding box
	      target.makeEmpty();
	      return target;
	    }
	    target.set(this.center, this.center);
	    target.expandByScalar(this.radius);
	    return target;
	  }
	  applyMatrix4(matrix) {
	    this.center.applyMatrix4(matrix);
	    this.radius = this.radius * matrix.getMaxScaleOnAxis();
	    return this;
	  }
	  translate(offset) {
	    this.center.add(offset);
	    return this;
	  }
	  expandByPoint(point) {
	    if (this.isEmpty()) {
	      this.center.copy(point);
	      this.radius = 0;
	      return this;
	    }
	    _v1$2.subVectors(point, this.center);
	    const lengthSq = _v1$2.lengthSq();
	    if (lengthSq > this.radius * this.radius) {
	      // calculate the minimal sphere

	      const length = Math.sqrt(lengthSq);
	      const delta = (length - this.radius) * 0.5;
	      this.center.addScaledVector(_v1$2, delta / length);
	      this.radius += delta;
	    }
	    return this;
	  }
	  union(sphere) {
	    if (sphere.isEmpty()) {
	      return this;
	    }
	    if (this.isEmpty()) {
	      this.copy(sphere);
	      return this;
	    }
	    if (this.center.equals(sphere.center) === true) {
	      this.radius = Math.max(this.radius, sphere.radius);
	    } else {
	      _v2.subVectors(sphere.center, this.center).setLength(sphere.radius);
	      this.expandByPoint(_v1$2.copy(sphere.center).add(_v2));
	      this.expandByPoint(_v1$2.copy(sphere.center).sub(_v2));
	    }
	    return this;
	  }
	  equals(sphere) {
	    return sphere.center.equals(this.center) && sphere.radius === this.radius;
	  }
	  clone() {
	    return new this.constructor().copy(this);
	  }
	}

	class Matrix4 {
	  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
	    Matrix4.prototype.isMatrix4 = true;
	    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	    if (n11 !== undefined) {
	      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
	    }
	  }
	  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
	    const te = this.elements;
	    te[0] = n11;
	    te[4] = n12;
	    te[8] = n13;
	    te[12] = n14;
	    te[1] = n21;
	    te[5] = n22;
	    te[9] = n23;
	    te[13] = n24;
	    te[2] = n31;
	    te[6] = n32;
	    te[10] = n33;
	    te[14] = n34;
	    te[3] = n41;
	    te[7] = n42;
	    te[11] = n43;
	    te[15] = n44;
	    return this;
	  }
	  identity() {
	    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	    return this;
	  }
	  clone() {
	    return new Matrix4().fromArray(this.elements);
	  }
	  copy(m) {
	    const te = this.elements;
	    const me = m.elements;
	    te[0] = me[0];
	    te[1] = me[1];
	    te[2] = me[2];
	    te[3] = me[3];
	    te[4] = me[4];
	    te[5] = me[5];
	    te[6] = me[6];
	    te[7] = me[7];
	    te[8] = me[8];
	    te[9] = me[9];
	    te[10] = me[10];
	    te[11] = me[11];
	    te[12] = me[12];
	    te[13] = me[13];
	    te[14] = me[14];
	    te[15] = me[15];
	    return this;
	  }
	  copyPosition(m) {
	    const te = this.elements,
	      me = m.elements;
	    te[12] = me[12];
	    te[13] = me[13];
	    te[14] = me[14];
	    return this;
	  }
	  setFromMatrix3(m) {
	    const me = m.elements;
	    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
	    return this;
	  }
	  extractBasis(xAxis, yAxis, zAxis) {
	    xAxis.setFromMatrixColumn(this, 0);
	    yAxis.setFromMatrixColumn(this, 1);
	    zAxis.setFromMatrixColumn(this, 2);
	    return this;
	  }
	  makeBasis(xAxis, yAxis, zAxis) {
	    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
	    return this;
	  }
	  extractRotation(m) {
	    // this method does not support reflection matrices

	    const te = this.elements;
	    const me = m.elements;
	    const scaleX = 1 / _v1$1.setFromMatrixColumn(m, 0).length();
	    const scaleY = 1 / _v1$1.setFromMatrixColumn(m, 1).length();
	    const scaleZ = 1 / _v1$1.setFromMatrixColumn(m, 2).length();
	    te[0] = me[0] * scaleX;
	    te[1] = me[1] * scaleX;
	    te[2] = me[2] * scaleX;
	    te[3] = 0;
	    te[4] = me[4] * scaleY;
	    te[5] = me[5] * scaleY;
	    te[6] = me[6] * scaleY;
	    te[7] = 0;
	    te[8] = me[8] * scaleZ;
	    te[9] = me[9] * scaleZ;
	    te[10] = me[10] * scaleZ;
	    te[11] = 0;
	    te[12] = 0;
	    te[13] = 0;
	    te[14] = 0;
	    te[15] = 1;
	    return this;
	  }
	  makeRotationFromEuler(euler) {
	    const te = this.elements;
	    const x = euler.x,
	      y = euler.y,
	      z = euler.z;
	    const a = Math.cos(x),
	      b = Math.sin(x);
	    const c = Math.cos(y),
	      d = Math.sin(y);
	    const e = Math.cos(z),
	      f = Math.sin(z);
	    if (euler.order === 'XYZ') {
	      const ae = a * e,
	        af = a * f,
	        be = b * e,
	        bf = b * f;
	      te[0] = c * e;
	      te[4] = -c * f;
	      te[8] = d;
	      te[1] = af + be * d;
	      te[5] = ae - bf * d;
	      te[9] = -b * c;
	      te[2] = bf - ae * d;
	      te[6] = be + af * d;
	      te[10] = a * c;
	    } else if (euler.order === 'YXZ') {
	      const ce = c * e,
	        cf = c * f,
	        de = d * e,
	        df = d * f;
	      te[0] = ce + df * b;
	      te[4] = de * b - cf;
	      te[8] = a * d;
	      te[1] = a * f;
	      te[5] = a * e;
	      te[9] = -b;
	      te[2] = cf * b - de;
	      te[6] = df + ce * b;
	      te[10] = a * c;
	    } else if (euler.order === 'ZXY') {
	      const ce = c * e,
	        cf = c * f,
	        de = d * e,
	        df = d * f;
	      te[0] = ce - df * b;
	      te[4] = -a * f;
	      te[8] = de + cf * b;
	      te[1] = cf + de * b;
	      te[5] = a * e;
	      te[9] = df - ce * b;
	      te[2] = -a * d;
	      te[6] = b;
	      te[10] = a * c;
	    } else if (euler.order === 'ZYX') {
	      const ae = a * e,
	        af = a * f,
	        be = b * e,
	        bf = b * f;
	      te[0] = c * e;
	      te[4] = be * d - af;
	      te[8] = ae * d + bf;
	      te[1] = c * f;
	      te[5] = bf * d + ae;
	      te[9] = af * d - be;
	      te[2] = -d;
	      te[6] = b * c;
	      te[10] = a * c;
	    } else if (euler.order === 'YZX') {
	      const ac = a * c,
	        ad = a * d,
	        bc = b * c,
	        bd = b * d;
	      te[0] = c * e;
	      te[4] = bd - ac * f;
	      te[8] = bc * f + ad;
	      te[1] = f;
	      te[5] = a * e;
	      te[9] = -b * e;
	      te[2] = -d * e;
	      te[6] = ad * f + bc;
	      te[10] = ac - bd * f;
	    } else if (euler.order === 'XZY') {
	      const ac = a * c,
	        ad = a * d,
	        bc = b * c,
	        bd = b * d;
	      te[0] = c * e;
	      te[4] = -f;
	      te[8] = d * e;
	      te[1] = ac * f + bd;
	      te[5] = a * e;
	      te[9] = ad * f - bc;
	      te[2] = bc * f - ad;
	      te[6] = b * e;
	      te[10] = bd * f + ac;
	    }

	    // bottom row
	    te[3] = 0;
	    te[7] = 0;
	    te[11] = 0;

	    // last column
	    te[12] = 0;
	    te[13] = 0;
	    te[14] = 0;
	    te[15] = 1;
	    return this;
	  }
	  makeRotationFromQuaternion(q) {
	    return this.compose(_zero, q, _one);
	  }
	  lookAt(eye, target, up) {
	    const te = this.elements;
	    _z.subVectors(eye, target);
	    if (_z.lengthSq() === 0) {
	      // eye and target are in the same position

	      _z.z = 1;
	    }
	    _z.normalize();
	    _x.crossVectors(up, _z);
	    if (_x.lengthSq() === 0) {
	      // up and z are parallel

	      if (Math.abs(up.z) === 1) {
	        _z.x += 0.0001;
	      } else {
	        _z.z += 0.0001;
	      }
	      _z.normalize();
	      _x.crossVectors(up, _z);
	    }
	    _x.normalize();
	    _y.crossVectors(_z, _x);
	    te[0] = _x.x;
	    te[4] = _y.x;
	    te[8] = _z.x;
	    te[1] = _x.y;
	    te[5] = _y.y;
	    te[9] = _z.y;
	    te[2] = _x.z;
	    te[6] = _y.z;
	    te[10] = _z.z;
	    return this;
	  }
	  multiply(m) {
	    return this.multiplyMatrices(this, m);
	  }
	  premultiply(m) {
	    return this.multiplyMatrices(m, this);
	  }
	  multiplyMatrices(a, b) {
	    const ae = a.elements;
	    const be = b.elements;
	    const te = this.elements;
	    const a11 = ae[0],
	      a12 = ae[4],
	      a13 = ae[8],
	      a14 = ae[12];
	    const a21 = ae[1],
	      a22 = ae[5],
	      a23 = ae[9],
	      a24 = ae[13];
	    const a31 = ae[2],
	      a32 = ae[6],
	      a33 = ae[10],
	      a34 = ae[14];
	    const a41 = ae[3],
	      a42 = ae[7],
	      a43 = ae[11],
	      a44 = ae[15];
	    const b11 = be[0],
	      b12 = be[4],
	      b13 = be[8],
	      b14 = be[12];
	    const b21 = be[1],
	      b22 = be[5],
	      b23 = be[9],
	      b24 = be[13];
	    const b31 = be[2],
	      b32 = be[6],
	      b33 = be[10],
	      b34 = be[14];
	    const b41 = be[3],
	      b42 = be[7],
	      b43 = be[11],
	      b44 = be[15];
	    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
	    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
	    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
	    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
	    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
	    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
	    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
	    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
	    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
	    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
	    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
	    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
	    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	    return this;
	  }
	  multiplyScalar(s) {
	    const te = this.elements;
	    te[0] *= s;
	    te[4] *= s;
	    te[8] *= s;
	    te[12] *= s;
	    te[1] *= s;
	    te[5] *= s;
	    te[9] *= s;
	    te[13] *= s;
	    te[2] *= s;
	    te[6] *= s;
	    te[10] *= s;
	    te[14] *= s;
	    te[3] *= s;
	    te[7] *= s;
	    te[11] *= s;
	    te[15] *= s;
	    return this;
	  }
	  determinant() {
	    const te = this.elements;
	    const n11 = te[0],
	      n12 = te[4],
	      n13 = te[8],
	      n14 = te[12];
	    const n21 = te[1],
	      n22 = te[5],
	      n23 = te[9],
	      n24 = te[13];
	    const n31 = te[2],
	      n32 = te[6],
	      n33 = te[10],
	      n34 = te[14];
	    const n41 = te[3],
	      n42 = te[7],
	      n43 = te[11],
	      n44 = te[15];

	    //TODO: make this more efficient
	    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

	    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
	  }
	  transpose() {
	    const te = this.elements;
	    let tmp;
	    tmp = te[1];
	    te[1] = te[4];
	    te[4] = tmp;
	    tmp = te[2];
	    te[2] = te[8];
	    te[8] = tmp;
	    tmp = te[6];
	    te[6] = te[9];
	    te[9] = tmp;
	    tmp = te[3];
	    te[3] = te[12];
	    te[12] = tmp;
	    tmp = te[7];
	    te[7] = te[13];
	    te[13] = tmp;
	    tmp = te[11];
	    te[11] = te[14];
	    te[14] = tmp;
	    return this;
	  }
	  setPosition(x, y, z) {
	    const te = this.elements;
	    if (x.isVector3) {
	      te[12] = x.x;
	      te[13] = x.y;
	      te[14] = x.z;
	    } else {
	      te[12] = x;
	      te[13] = y;
	      te[14] = z;
	    }
	    return this;
	  }
	  invert() {
	    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
	    const te = this.elements,
	      n11 = te[0],
	      n21 = te[1],
	      n31 = te[2],
	      n41 = te[3],
	      n12 = te[4],
	      n22 = te[5],
	      n32 = te[6],
	      n42 = te[7],
	      n13 = te[8],
	      n23 = te[9],
	      n33 = te[10],
	      n43 = te[11],
	      n14 = te[12],
	      n24 = te[13],
	      n34 = te[14],
	      n44 = te[15],
	      t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
	      t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
	      t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
	      t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
	    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
	    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	    const detInv = 1 / det;
	    te[0] = t11 * detInv;
	    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
	    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
	    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
	    te[4] = t12 * detInv;
	    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
	    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
	    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
	    te[8] = t13 * detInv;
	    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
	    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
	    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
	    te[12] = t14 * detInv;
	    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
	    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
	    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
	    return this;
	  }
	  scale(v) {
	    const te = this.elements;
	    const x = v.x,
	      y = v.y,
	      z = v.z;
	    te[0] *= x;
	    te[4] *= y;
	    te[8] *= z;
	    te[1] *= x;
	    te[5] *= y;
	    te[9] *= z;
	    te[2] *= x;
	    te[6] *= y;
	    te[10] *= z;
	    te[3] *= x;
	    te[7] *= y;
	    te[11] *= z;
	    return this;
	  }
	  getMaxScaleOnAxis() {
	    const te = this.elements;
	    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
	    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
	    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
	    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
	  }
	  makeTranslation(x, y, z) {
	    if (x.isVector3) {
	      this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
	    } else {
	      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
	    }
	    return this;
	  }
	  makeRotationX(theta) {
	    const c = Math.cos(theta),
	      s = Math.sin(theta);
	    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
	    return this;
	  }
	  makeRotationY(theta) {
	    const c = Math.cos(theta),
	      s = Math.sin(theta);
	    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
	    return this;
	  }
	  makeRotationZ(theta) {
	    const c = Math.cos(theta),
	      s = Math.sin(theta);
	    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	    return this;
	  }
	  makeRotationAxis(axis, angle) {
	    // Based on http://www.gamedev.net/reference/articles/article1199.asp

	    const c = Math.cos(angle);
	    const s = Math.sin(angle);
	    const t = 1 - c;
	    const x = axis.x,
	      y = axis.y,
	      z = axis.z;
	    const tx = t * x,
	      ty = t * y;
	    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
	    return this;
	  }
	  makeScale(x, y, z) {
	    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
	    return this;
	  }
	  makeShear(xy, xz, yx, yz, zx, zy) {
	    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
	    return this;
	  }
	  compose(position, quaternion, scale) {
	    const te = this.elements;
	    const x = quaternion._x,
	      y = quaternion._y,
	      z = quaternion._z,
	      w = quaternion._w;
	    const x2 = x + x,
	      y2 = y + y,
	      z2 = z + z;
	    const xx = x * x2,
	      xy = x * y2,
	      xz = x * z2;
	    const yy = y * y2,
	      yz = y * z2,
	      zz = z * z2;
	    const wx = w * x2,
	      wy = w * y2,
	      wz = w * z2;
	    const sx = scale.x,
	      sy = scale.y,
	      sz = scale.z;
	    te[0] = (1 - (yy + zz)) * sx;
	    te[1] = (xy + wz) * sx;
	    te[2] = (xz - wy) * sx;
	    te[3] = 0;
	    te[4] = (xy - wz) * sy;
	    te[5] = (1 - (xx + zz)) * sy;
	    te[6] = (yz + wx) * sy;
	    te[7] = 0;
	    te[8] = (xz + wy) * sz;
	    te[9] = (yz - wx) * sz;
	    te[10] = (1 - (xx + yy)) * sz;
	    te[11] = 0;
	    te[12] = position.x;
	    te[13] = position.y;
	    te[14] = position.z;
	    te[15] = 1;
	    return this;
	  }
	  decompose(position, quaternion, scale) {
	    const te = this.elements;
	    let sx = _v1$1.set(te[0], te[1], te[2]).length();
	    const sy = _v1$1.set(te[4], te[5], te[6]).length();
	    const sz = _v1$1.set(te[8], te[9], te[10]).length();

	    // if determine is negative, we need to invert one scale
	    const det = this.determinant();
	    if (det < 0) sx = -sx;
	    position.x = te[12];
	    position.y = te[13];
	    position.z = te[14];

	    // scale the rotation part
	    _m1$2.copy(this);
	    const invSX = 1 / sx;
	    const invSY = 1 / sy;
	    const invSZ = 1 / sz;
	    _m1$2.elements[0] *= invSX;
	    _m1$2.elements[1] *= invSX;
	    _m1$2.elements[2] *= invSX;
	    _m1$2.elements[4] *= invSY;
	    _m1$2.elements[5] *= invSY;
	    _m1$2.elements[6] *= invSY;
	    _m1$2.elements[8] *= invSZ;
	    _m1$2.elements[9] *= invSZ;
	    _m1$2.elements[10] *= invSZ;
	    quaternion.setFromRotationMatrix(_m1$2);
	    scale.x = sx;
	    scale.y = sy;
	    scale.z = sz;
	    return this;
	  }
	  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
	    const te = this.elements;
	    const x = 2 * near / (right - left);
	    const y = 2 * near / (top - bottom);
	    const a = (right + left) / (right - left);
	    const b = (top + bottom) / (top - bottom);
	    let c, d;
	    if (coordinateSystem === WebGLCoordinateSystem) {
	      c = -(far + near) / (far - near);
	      d = -2 * far * near / (far - near);
	    } else if (coordinateSystem === WebGPUCoordinateSystem) {
	      c = -far / (far - near);
	      d = -far * near / (far - near);
	    } else {
	      throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem);
	    }
	    te[0] = x;
	    te[4] = 0;
	    te[8] = a;
	    te[12] = 0;
	    te[1] = 0;
	    te[5] = y;
	    te[9] = b;
	    te[13] = 0;
	    te[2] = 0;
	    te[6] = 0;
	    te[10] = c;
	    te[14] = d;
	    te[3] = 0;
	    te[7] = 0;
	    te[11] = -1;
	    te[15] = 0;
	    return this;
	  }
	  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
	    const te = this.elements;
	    const w = 1.0 / (right - left);
	    const h = 1.0 / (top - bottom);
	    const p = 1.0 / (far - near);
	    const x = (right + left) * w;
	    const y = (top + bottom) * h;
	    let z, zInv;
	    if (coordinateSystem === WebGLCoordinateSystem) {
	      z = (far + near) * p;
	      zInv = -2 * p;
	    } else if (coordinateSystem === WebGPUCoordinateSystem) {
	      z = near * p;
	      zInv = -1 * p;
	    } else {
	      throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem);
	    }
	    te[0] = 2 * w;
	    te[4] = 0;
	    te[8] = 0;
	    te[12] = -x;
	    te[1] = 0;
	    te[5] = 2 * h;
	    te[9] = 0;
	    te[13] = -y;
	    te[2] = 0;
	    te[6] = 0;
	    te[10] = zInv;
	    te[14] = -z;
	    te[3] = 0;
	    te[7] = 0;
	    te[11] = 0;
	    te[15] = 1;
	    return this;
	  }
	  equals(matrix) {
	    const te = this.elements;
	    const me = matrix.elements;
	    for (let i = 0; i < 16; i++) {
	      if (te[i] !== me[i]) return false;
	    }
	    return true;
	  }
	  fromArray(array, offset = 0) {
	    for (let i = 0; i < 16; i++) {
	      this.elements[i] = array[i + offset];
	    }
	    return this;
	  }
	  toArray(array = [], offset = 0) {
	    const te = this.elements;
	    array[offset] = te[0];
	    array[offset + 1] = te[1];
	    array[offset + 2] = te[2];
	    array[offset + 3] = te[3];
	    array[offset + 4] = te[4];
	    array[offset + 5] = te[5];
	    array[offset + 6] = te[6];
	    array[offset + 7] = te[7];
	    array[offset + 8] = te[8];
	    array[offset + 9] = te[9];
	    array[offset + 10] = te[10];
	    array[offset + 11] = te[11];
	    array[offset + 12] = te[12];
	    array[offset + 13] = te[13];
	    array[offset + 14] = te[14];
	    array[offset + 15] = te[15];
	    return array;
	  }
	}
	const _v1$1 = /*@__PURE__*/new Vector3();
	const _m1$2 = /*@__PURE__*/new Matrix4();
	const _zero = /*@__PURE__*/new Vector3(0, 0, 0);
	const _one = /*@__PURE__*/new Vector3(1, 1, 1);
	const _x = /*@__PURE__*/new Vector3();
	const _y = /*@__PURE__*/new Vector3();
	const _z = /*@__PURE__*/new Vector3();

	const _matrix = /*@__PURE__*/new Matrix4();
	const _quaternion$1 = /*@__PURE__*/new Quaternion();
	class Euler {
	  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
	    this.isEuler = true;
	    this._x = x;
	    this._y = y;
	    this._z = z;
	    this._order = order;
	  }
	  get x() {
	    return this._x;
	  }
	  set x(value) {
	    this._x = value;
	    this._onChangeCallback();
	  }
	  get y() {
	    return this._y;
	  }
	  set y(value) {
	    this._y = value;
	    this._onChangeCallback();
	  }
	  get z() {
	    return this._z;
	  }
	  set z(value) {
	    this._z = value;
	    this._onChangeCallback();
	  }
	  get order() {
	    return this._order;
	  }
	  set order(value) {
	    this._order = value;
	    this._onChangeCallback();
	  }
	  set(x, y, z, order = this._order) {
	    this._x = x;
	    this._y = y;
	    this._z = z;
	    this._order = order;
	    this._onChangeCallback();
	    return this;
	  }
	  clone() {
	    return new this.constructor(this._x, this._y, this._z, this._order);
	  }
	  copy(euler) {
	    this._x = euler._x;
	    this._y = euler._y;
	    this._z = euler._z;
	    this._order = euler._order;
	    this._onChangeCallback();
	    return this;
	  }
	  setFromRotationMatrix(m, order = this._order, update = true) {
	    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

	    const te = m.elements;
	    const m11 = te[0],
	      m12 = te[4],
	      m13 = te[8];
	    const m21 = te[1],
	      m22 = te[5],
	      m23 = te[9];
	    const m31 = te[2],
	      m32 = te[6],
	      m33 = te[10];
	    switch (order) {
	      case 'XYZ':
	        this._y = Math.asin(clamp(m13, -1, 1));
	        if (Math.abs(m13) < 0.9999999) {
	          this._x = Math.atan2(-m23, m33);
	          this._z = Math.atan2(-m12, m11);
	        } else {
	          this._x = Math.atan2(m32, m22);
	          this._z = 0;
	        }
	        break;
	      case 'YXZ':
	        this._x = Math.asin(-clamp(m23, -1, 1));
	        if (Math.abs(m23) < 0.9999999) {
	          this._y = Math.atan2(m13, m33);
	          this._z = Math.atan2(m21, m22);
	        } else {
	          this._y = Math.atan2(-m31, m11);
	          this._z = 0;
	        }
	        break;
	      case 'ZXY':
	        this._x = Math.asin(clamp(m32, -1, 1));
	        if (Math.abs(m32) < 0.9999999) {
	          this._y = Math.atan2(-m31, m33);
	          this._z = Math.atan2(-m12, m22);
	        } else {
	          this._y = 0;
	          this._z = Math.atan2(m21, m11);
	        }
	        break;
	      case 'ZYX':
	        this._y = Math.asin(-clamp(m31, -1, 1));
	        if (Math.abs(m31) < 0.9999999) {
	          this._x = Math.atan2(m32, m33);
	          this._z = Math.atan2(m21, m11);
	        } else {
	          this._x = 0;
	          this._z = Math.atan2(-m12, m22);
	        }
	        break;
	      case 'YZX':
	        this._z = Math.asin(clamp(m21, -1, 1));
	        if (Math.abs(m21) < 0.9999999) {
	          this._x = Math.atan2(-m23, m22);
	          this._y = Math.atan2(-m31, m11);
	        } else {
	          this._x = 0;
	          this._y = Math.atan2(m13, m33);
	        }
	        break;
	      case 'XZY':
	        this._z = Math.asin(-clamp(m12, -1, 1));
	        if (Math.abs(m12) < 0.9999999) {
	          this._x = Math.atan2(m32, m22);
	          this._y = Math.atan2(m13, m11);
	        } else {
	          this._x = Math.atan2(-m23, m33);
	          this._y = 0;
	        }
	        break;
	      default:
	        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
	    }
	    this._order = order;
	    if (update === true) this._onChangeCallback();
	    return this;
	  }
	  setFromQuaternion(q, order, update) {
	    _matrix.makeRotationFromQuaternion(q);
	    return this.setFromRotationMatrix(_matrix, order, update);
	  }
	  setFromVector3(v, order = this._order) {
	    return this.set(v.x, v.y, v.z, order);
	  }
	  reorder(newOrder) {
	    // WARNING: this discards revolution information -bhouston

	    _quaternion$1.setFromEuler(this);
	    return this.setFromQuaternion(_quaternion$1, newOrder);
	  }
	  equals(euler) {
	    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
	  }
	  fromArray(array) {
	    this._x = array[0];
	    this._y = array[1];
	    this._z = array[2];
	    if (array[3] !== undefined) this._order = array[3];
	    this._onChangeCallback();
	    return this;
	  }
	  toArray(array = [], offset = 0) {
	    array[offset] = this._x;
	    array[offset + 1] = this._y;
	    array[offset + 2] = this._z;
	    array[offset + 3] = this._order;
	    return array;
	  }
	  _onChange(callback) {
	    this._onChangeCallback = callback;
	    return this;
	  }
	  _onChangeCallback() {}
	  *[Symbol.iterator]() {
	    yield this._x;
	    yield this._y;
	    yield this._z;
	    yield this._order;
	  }
	}
	Euler.DEFAULT_ORDER = 'XYZ';

	class Layers {
	  constructor() {
	    this.mask = 1 | 0;
	  }
	  set(channel) {
	    this.mask = (1 << channel | 0) >>> 0;
	  }
	  enable(channel) {
	    this.mask |= 1 << channel | 0;
	  }
	  enableAll() {
	    this.mask = 0xffffffff | 0;
	  }
	  toggle(channel) {
	    this.mask ^= 1 << channel | 0;
	  }
	  disable(channel) {
	    this.mask &= ~(1 << channel | 0);
	  }
	  disableAll() {
	    this.mask = 0;
	  }
	  test(layers) {
	    return (this.mask & layers.mask) !== 0;
	  }
	  isEnabled(channel) {
	    return (this.mask & (1 << channel | 0)) !== 0;
	  }
	}

	class Matrix3 {
	  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
	    Matrix3.prototype.isMatrix3 = true;
	    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	    if (n11 !== undefined) {
	      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
	    }
	  }
	  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
	    const te = this.elements;
	    te[0] = n11;
	    te[1] = n21;
	    te[2] = n31;
	    te[3] = n12;
	    te[4] = n22;
	    te[5] = n32;
	    te[6] = n13;
	    te[7] = n23;
	    te[8] = n33;
	    return this;
	  }
	  identity() {
	    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
	    return this;
	  }
	  copy(m) {
	    const te = this.elements;
	    const me = m.elements;
	    te[0] = me[0];
	    te[1] = me[1];
	    te[2] = me[2];
	    te[3] = me[3];
	    te[4] = me[4];
	    te[5] = me[5];
	    te[6] = me[6];
	    te[7] = me[7];
	    te[8] = me[8];
	    return this;
	  }
	  extractBasis(xAxis, yAxis, zAxis) {
	    xAxis.setFromMatrix3Column(this, 0);
	    yAxis.setFromMatrix3Column(this, 1);
	    zAxis.setFromMatrix3Column(this, 2);
	    return this;
	  }
	  setFromMatrix4(m) {
	    const me = m.elements;
	    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
	    return this;
	  }
	  multiply(m) {
	    return this.multiplyMatrices(this, m);
	  }
	  premultiply(m) {
	    return this.multiplyMatrices(m, this);
	  }
	  multiplyMatrices(a, b) {
	    const ae = a.elements;
	    const be = b.elements;
	    const te = this.elements;
	    const a11 = ae[0],
	      a12 = ae[3],
	      a13 = ae[6];
	    const a21 = ae[1],
	      a22 = ae[4],
	      a23 = ae[7];
	    const a31 = ae[2],
	      a32 = ae[5],
	      a33 = ae[8];
	    const b11 = be[0],
	      b12 = be[3],
	      b13 = be[6];
	    const b21 = be[1],
	      b22 = be[4],
	      b23 = be[7];
	    const b31 = be[2],
	      b32 = be[5],
	      b33 = be[8];
	    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
	    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
	    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
	    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
	    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
	    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
	    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
	    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
	    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
	    return this;
	  }
	  multiplyScalar(s) {
	    const te = this.elements;
	    te[0] *= s;
	    te[3] *= s;
	    te[6] *= s;
	    te[1] *= s;
	    te[4] *= s;
	    te[7] *= s;
	    te[2] *= s;
	    te[5] *= s;
	    te[8] *= s;
	    return this;
	  }
	  determinant() {
	    const te = this.elements;
	    const a = te[0],
	      b = te[1],
	      c = te[2],
	      d = te[3],
	      e = te[4],
	      f = te[5],
	      g = te[6],
	      h = te[7],
	      i = te[8];
	    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	  }
	  invert() {
	    const te = this.elements,
	      n11 = te[0],
	      n21 = te[1],
	      n31 = te[2],
	      n12 = te[3],
	      n22 = te[4],
	      n32 = te[5],
	      n13 = te[6],
	      n23 = te[7],
	      n33 = te[8],
	      t11 = n33 * n22 - n32 * n23,
	      t12 = n32 * n13 - n33 * n12,
	      t13 = n23 * n12 - n22 * n13,
	      det = n11 * t11 + n21 * t12 + n31 * t13;
	    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
	    const detInv = 1 / det;
	    te[0] = t11 * detInv;
	    te[1] = (n31 * n23 - n33 * n21) * detInv;
	    te[2] = (n32 * n21 - n31 * n22) * detInv;
	    te[3] = t12 * detInv;
	    te[4] = (n33 * n11 - n31 * n13) * detInv;
	    te[5] = (n31 * n12 - n32 * n11) * detInv;
	    te[6] = t13 * detInv;
	    te[7] = (n21 * n13 - n23 * n11) * detInv;
	    te[8] = (n22 * n11 - n21 * n12) * detInv;
	    return this;
	  }
	  transpose() {
	    let tmp;
	    const m = this.elements;
	    tmp = m[1];
	    m[1] = m[3];
	    m[3] = tmp;
	    tmp = m[2];
	    m[2] = m[6];
	    m[6] = tmp;
	    tmp = m[5];
	    m[5] = m[7];
	    m[7] = tmp;
	    return this;
	  }
	  getNormalMatrix(matrix4) {
	    return this.setFromMatrix4(matrix4).invert().transpose();
	  }
	  transposeIntoArray(r) {
	    const m = this.elements;
	    r[0] = m[0];
	    r[1] = m[3];
	    r[2] = m[6];
	    r[3] = m[1];
	    r[4] = m[4];
	    r[5] = m[7];
	    r[6] = m[2];
	    r[7] = m[5];
	    r[8] = m[8];
	    return this;
	  }
	  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
	    const c = Math.cos(rotation);
	    const s = Math.sin(rotation);
	    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
	    return this;
	  }

	  //

	  scale(sx, sy) {
	    this.premultiply(_m3.makeScale(sx, sy));
	    return this;
	  }
	  rotate(theta) {
	    this.premultiply(_m3.makeRotation(-theta));
	    return this;
	  }
	  translate(tx, ty) {
	    this.premultiply(_m3.makeTranslation(tx, ty));
	    return this;
	  }

	  // for 2D Transforms

	  makeTranslation(x, y) {
	    if (x.isVector2) {
	      this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
	    } else {
	      this.set(1, 0, x, 0, 1, y, 0, 0, 1);
	    }
	    return this;
	  }
	  makeRotation(theta) {
	    // counterclockwise

	    const c = Math.cos(theta);
	    const s = Math.sin(theta);
	    this.set(c, -s, 0, s, c, 0, 0, 0, 1);
	    return this;
	  }
	  makeScale(x, y) {
	    this.set(x, 0, 0, 0, y, 0, 0, 0, 1);
	    return this;
	  }

	  //

	  equals(matrix) {
	    const te = this.elements;
	    const me = matrix.elements;
	    for (let i = 0; i < 9; i++) {
	      if (te[i] !== me[i]) return false;
	    }
	    return true;
	  }
	  fromArray(array, offset = 0) {
	    for (let i = 0; i < 9; i++) {
	      this.elements[i] = array[i + offset];
	    }
	    return this;
	  }
	  toArray(array = [], offset = 0) {
	    const te = this.elements;
	    array[offset] = te[0];
	    array[offset + 1] = te[1];
	    array[offset + 2] = te[2];
	    array[offset + 3] = te[3];
	    array[offset + 4] = te[4];
	    array[offset + 5] = te[5];
	    array[offset + 6] = te[6];
	    array[offset + 7] = te[7];
	    array[offset + 8] = te[8];
	    return array;
	  }
	  clone() {
	    return new this.constructor().fromArray(this.elements);
	  }
	}
	const _m3 = /*@__PURE__*/new Matrix3();

	let _object3DId = 0;
	const _v1 = /*@__PURE__*/new Vector3();
	const _q1 = /*@__PURE__*/new Quaternion();
	const _m1$1 = /*@__PURE__*/new Matrix4();
	const _target = /*@__PURE__*/new Vector3();
	const _position = /*@__PURE__*/new Vector3();
	const _scale = /*@__PURE__*/new Vector3();
	const _quaternion = /*@__PURE__*/new Quaternion();
	const _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);
	const _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);
	const _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);
	const _addedEvent = {
	  type: 'added'
	};
	const _removedEvent = {
	  type: 'removed'
	};
	const _childaddedEvent = {
	  type: 'childadded',
	  child: null
	};
	const _childremovedEvent = {
	  type: 'childremoved',
	  child: null
	};
	class Object3D extends EventDispatcher {
	  constructor() {
	    super();
	    this.isObject3D = true;
	    Object.defineProperty(this, 'id', {
	      value: _object3DId++
	    });
	    this.uuid = generateUUID();
	    this.name = '';
	    this.type = 'Object3D';
	    this.parent = null;
	    this.children = [];
	    this.up = Object3D.DEFAULT_UP.clone();
	    const position = new Vector3();
	    const rotation = new Euler();
	    const quaternion = new Quaternion();
	    const scale = new Vector3(1, 1, 1);
	    function onRotationChange() {
	      quaternion.setFromEuler(rotation, false);
	    }
	    function onQuaternionChange() {
	      rotation.setFromQuaternion(quaternion, undefined, false);
	    }
	    rotation._onChange(onRotationChange);
	    quaternion._onChange(onQuaternionChange);
	    Object.defineProperties(this, {
	      position: {
	        configurable: true,
	        enumerable: true,
	        value: position
	      },
	      rotation: {
	        configurable: true,
	        enumerable: true,
	        value: rotation
	      },
	      quaternion: {
	        configurable: true,
	        enumerable: true,
	        value: quaternion
	      },
	      scale: {
	        configurable: true,
	        enumerable: true,
	        value: scale
	      },
	      modelViewMatrix: {
	        value: new Matrix4()
	      },
	      normalMatrix: {
	        value: new Matrix3()
	      }
	    });
	    this.matrix = new Matrix4();
	    this.matrixWorld = new Matrix4();
	    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
	    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer
	    this.matrixWorldNeedsUpdate = false;
	    this.layers = new Layers();
	    this.visible = true;
	    this.castShadow = false;
	    this.receiveShadow = false;
	    this.frustumCulled = true;
	    this.renderOrder = 0;
	    this.animations = [];
	    this.userData = {};
	  }
	  onBeforeShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}
	  onAfterShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}
	  onBeforeRender(/* renderer, scene, camera, geometry, material, group */) {}
	  onAfterRender(/* renderer, scene, camera, geometry, material, group */) {}
	  applyMatrix4(matrix) {
	    if (this.matrixAutoUpdate) this.updateMatrix();
	    this.matrix.premultiply(matrix);
	    this.matrix.decompose(this.position, this.quaternion, this.scale);
	  }
	  applyQuaternion(q) {
	    this.quaternion.premultiply(q);
	    return this;
	  }
	  setRotationFromAxisAngle(axis, angle) {
	    // assumes axis is normalized

	    this.quaternion.setFromAxisAngle(axis, angle);
	  }
	  setRotationFromEuler(euler) {
	    this.quaternion.setFromEuler(euler, true);
	  }
	  setRotationFromMatrix(m) {
	    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

	    this.quaternion.setFromRotationMatrix(m);
	  }
	  setRotationFromQuaternion(q) {
	    // assumes q is normalized

	    this.quaternion.copy(q);
	  }
	  rotateOnAxis(axis, angle) {
	    // rotate object on axis in object space
	    // axis is assumed to be normalized

	    _q1.setFromAxisAngle(axis, angle);
	    this.quaternion.multiply(_q1);
	    return this;
	  }
	  rotateOnWorldAxis(axis, angle) {
	    // rotate object on axis in world space
	    // axis is assumed to be normalized
	    // method assumes no rotated parent

	    _q1.setFromAxisAngle(axis, angle);
	    this.quaternion.premultiply(_q1);
	    return this;
	  }
	  rotateX(angle) {
	    return this.rotateOnAxis(_xAxis, angle);
	  }
	  rotateY(angle) {
	    return this.rotateOnAxis(_yAxis, angle);
	  }
	  rotateZ(angle) {
	    return this.rotateOnAxis(_zAxis, angle);
	  }
	  translateOnAxis(axis, distance) {
	    // translate object by distance along axis in object space
	    // axis is assumed to be normalized

	    _v1.copy(axis).applyQuaternion(this.quaternion);
	    this.position.add(_v1.multiplyScalar(distance));
	    return this;
	  }
	  translateX(distance) {
	    return this.translateOnAxis(_xAxis, distance);
	  }
	  translateY(distance) {
	    return this.translateOnAxis(_yAxis, distance);
	  }
	  translateZ(distance) {
	    return this.translateOnAxis(_zAxis, distance);
	  }
	  localToWorld(vector) {
	    this.updateWorldMatrix(true, false);
	    return vector.applyMatrix4(this.matrixWorld);
	  }
	  worldToLocal(vector) {
	    this.updateWorldMatrix(true, false);
	    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
	  }
	  lookAt(x, y, z) {
	    // This method does not support objects having non-uniformly-scaled parent(s)

	    if (x.isVector3) {
	      _target.copy(x);
	    } else {
	      _target.set(x, y, z);
	    }
	    const parent = this.parent;
	    this.updateWorldMatrix(true, false);
	    _position.setFromMatrixPosition(this.matrixWorld);
	    if (this.isCamera || this.isLight) {
	      _m1$1.lookAt(_position, _target, this.up);
	    } else {
	      _m1$1.lookAt(_target, _position, this.up);
	    }
	    this.quaternion.setFromRotationMatrix(_m1$1);
	    if (parent) {
	      _m1$1.extractRotation(parent.matrixWorld);
	      _q1.setFromRotationMatrix(_m1$1);
	      this.quaternion.premultiply(_q1.invert());
	    }
	  }
	  add(object) {
	    if (arguments.length > 1) {
	      for (let i = 0; i < arguments.length; i++) {
	        this.add(arguments[i]);
	      }
	      return this;
	    }
	    if (object === this) {
	      console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
	      return this;
	    }
	    if (object && object.isObject3D) {
	      object.removeFromParent();
	      object.parent = this;
	      this.children.push(object);
	      object.dispatchEvent(_addedEvent);
	      _childaddedEvent.child = object;
	      this.dispatchEvent(_childaddedEvent);
	      _childaddedEvent.child = null;
	    } else {
	      console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
	    }
	    return this;
	  }
	  remove(object) {
	    if (arguments.length > 1) {
	      for (let i = 0; i < arguments.length; i++) {
	        this.remove(arguments[i]);
	      }
	      return this;
	    }
	    const index = this.children.indexOf(object);
	    if (index !== -1) {
	      object.parent = null;
	      this.children.splice(index, 1);
	      object.dispatchEvent(_removedEvent);
	      _childremovedEvent.child = object;
	      this.dispatchEvent(_childremovedEvent);
	      _childremovedEvent.child = null;
	    }
	    return this;
	  }
	  removeFromParent() {
	    const parent = this.parent;
	    if (parent !== null) {
	      parent.remove(this);
	    }
	    return this;
	  }
	  clear() {
	    return this.remove(...this.children);
	  }
	  attach(object) {
	    // adds object as a child of this, while maintaining the object's world transform

	    // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

	    this.updateWorldMatrix(true, false);
	    _m1$1.copy(this.matrixWorld).invert();
	    if (object.parent !== null) {
	      object.parent.updateWorldMatrix(true, false);
	      _m1$1.multiply(object.parent.matrixWorld);
	    }
	    object.applyMatrix4(_m1$1);
	    object.removeFromParent();
	    object.parent = this;
	    this.children.push(object);
	    object.updateWorldMatrix(false, true);
	    object.dispatchEvent(_addedEvent);
	    _childaddedEvent.child = object;
	    this.dispatchEvent(_childaddedEvent);
	    _childaddedEvent.child = null;
	    return this;
	  }
	  getObjectById(id) {
	    return this.getObjectByProperty('id', id);
	  }
	  getObjectByName(name) {
	    return this.getObjectByProperty('name', name);
	  }
	  getObjectByProperty(name, value) {
	    if (this[name] === value) return this;
	    for (let i = 0, l = this.children.length; i < l; i++) {
	      const child = this.children[i];
	      const object = child.getObjectByProperty(name, value);
	      if (object !== undefined) {
	        return object;
	      }
	    }
	    return undefined;
	  }
	  getObjectsByProperty(name, value, result = []) {
	    if (this[name] === value) result.push(this);
	    const children = this.children;
	    for (let i = 0, l = children.length; i < l; i++) {
	      children[i].getObjectsByProperty(name, value, result);
	    }
	    return result;
	  }
	  getWorldPosition(target) {
	    this.updateWorldMatrix(true, false);
	    return target.setFromMatrixPosition(this.matrixWorld);
	  }
	  getWorldQuaternion(target) {
	    this.updateWorldMatrix(true, false);
	    this.matrixWorld.decompose(_position, target, _scale);
	    return target;
	  }
	  getWorldScale(target) {
	    this.updateWorldMatrix(true, false);
	    this.matrixWorld.decompose(_position, _quaternion, target);
	    return target;
	  }
	  getWorldDirection(target) {
	    this.updateWorldMatrix(true, false);
	    const e = this.matrixWorld.elements;
	    return target.set(e[8], e[9], e[10]).normalize();
	  }
	  raycast(/* raycaster, intersects */) {}
	  traverse(callback) {
	    callback(this);
	    const children = this.children;
	    for (let i = 0, l = children.length; i < l; i++) {
	      children[i].traverse(callback);
	    }
	  }
	  traverseVisible(callback) {
	    if (this.visible === false) return;
	    callback(this);
	    const children = this.children;
	    for (let i = 0, l = children.length; i < l; i++) {
	      children[i].traverseVisible(callback);
	    }
	  }
	  traverseAncestors(callback) {
	    const parent = this.parent;
	    if (parent !== null) {
	      callback(parent);
	      parent.traverseAncestors(callback);
	    }
	  }
	  updateMatrix() {
	    this.matrix.compose(this.position, this.quaternion, this.scale);
	    this.matrixWorldNeedsUpdate = true;
	  }
	  updateMatrixWorld(force) {
	    if (this.matrixAutoUpdate) this.updateMatrix();
	    if (this.matrixWorldNeedsUpdate || force) {
	      if (this.matrixWorldAutoUpdate === true) {
	        if (this.parent === null) {
	          this.matrixWorld.copy(this.matrix);
	        } else {
	          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
	        }
	      }
	      this.matrixWorldNeedsUpdate = false;
	      force = true;
	    }

	    // make sure descendants are updated if required

	    const children = this.children;
	    for (let i = 0, l = children.length; i < l; i++) {
	      const child = children[i];
	      child.updateMatrixWorld(force);
	    }
	  }
	  updateWorldMatrix(updateParents, updateChildren) {
	    const parent = this.parent;
	    if (updateParents === true && parent !== null) {
	      parent.updateWorldMatrix(true, false);
	    }
	    if (this.matrixAutoUpdate) this.updateMatrix();
	    if (this.matrixWorldAutoUpdate === true) {
	      if (this.parent === null) {
	        this.matrixWorld.copy(this.matrix);
	      } else {
	        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
	      }
	    }

	    // make sure descendants are updated

	    if (updateChildren === true) {
	      const children = this.children;
	      for (let i = 0, l = children.length; i < l; i++) {
	        const child = children[i];
	        child.updateWorldMatrix(false, true);
	      }
	    }
	  }
	  toJSON(meta) {
	    // meta is a string when called from JSON.stringify
	    const isRootObject = meta === undefined || typeof meta === 'string';
	    const output = {};

	    // meta is a hash used to collect geometries, materials.
	    // not providing it implies that this is the root object
	    // being serialized.
	    if (isRootObject) {
	      // initialize meta obj
	      meta = {
	        geometries: {},
	        materials: {},
	        textures: {},
	        images: {},
	        shapes: {},
	        skeletons: {},
	        animations: {},
	        nodes: {}
	      };
	      output.metadata = {
	        version: 4.6,
	        type: 'Object',
	        generator: 'Object3D.toJSON'
	      };
	    }

	    // standard Object3D serialization

	    const object = {};
	    object.uuid = this.uuid;
	    object.type = this.type;
	    if (this.name !== '') object.name = this.name;
	    if (this.castShadow === true) object.castShadow = true;
	    if (this.receiveShadow === true) object.receiveShadow = true;
	    if (this.visible === false) object.visible = false;
	    if (this.frustumCulled === false) object.frustumCulled = false;
	    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
	    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
	    object.layers = this.layers.mask;
	    object.matrix = this.matrix.toArray();
	    object.up = this.up.toArray();
	    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

	    // object specific properties

	    if (this.isInstancedMesh) {
	      object.type = 'InstancedMesh';
	      object.count = this.count;
	      object.instanceMatrix = this.instanceMatrix.toJSON();
	      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
	    }
	    if (this.isBatchedMesh) {
	      object.type = 'BatchedMesh';
	      object.perObjectFrustumCulled = this.perObjectFrustumCulled;
	      object.sortObjects = this.sortObjects;
	      object.drawRanges = this._drawRanges;
	      object.reservedRanges = this._reservedRanges;
	      object.visibility = this._visibility;
	      object.active = this._active;
	      object.bounds = this._bounds.map(bound => ({
	        boxInitialized: bound.boxInitialized,
	        boxMin: bound.box.min.toArray(),
	        boxMax: bound.box.max.toArray(),
	        sphereInitialized: bound.sphereInitialized,
	        sphereRadius: bound.sphere.radius,
	        sphereCenter: bound.sphere.center.toArray()
	      }));
	      object.maxInstanceCount = this._maxInstanceCount;
	      object.maxVertexCount = this._maxVertexCount;
	      object.maxIndexCount = this._maxIndexCount;
	      object.geometryInitialized = this._geometryInitialized;
	      object.geometryCount = this._geometryCount;
	      object.matricesTexture = this._matricesTexture.toJSON(meta);
	      if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);
	      if (this.boundingSphere !== null) {
	        object.boundingSphere = {
	          center: object.boundingSphere.center.toArray(),
	          radius: object.boundingSphere.radius
	        };
	      }
	      if (this.boundingBox !== null) {
	        object.boundingBox = {
	          min: object.boundingBox.min.toArray(),
	          max: object.boundingBox.max.toArray()
	        };
	      }
	    }

	    //

	    function serialize(library, element) {
	      if (library[element.uuid] === undefined) {
	        library[element.uuid] = element.toJSON(meta);
	      }
	      return element.uuid;
	    }
	    if (this.isScene) {
	      if (this.background) {
	        if (this.background.isColor) {
	          object.background = this.background.toJSON();
	        } else if (this.background.isTexture) {
	          object.background = this.background.toJSON(meta).uuid;
	        }
	      }
	      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
	        object.environment = this.environment.toJSON(meta).uuid;
	      }
	    } else if (this.isMesh || this.isLine || this.isPoints) {
	      object.geometry = serialize(meta.geometries, this.geometry);
	      const parameters = this.geometry.parameters;
	      if (parameters !== undefined && parameters.shapes !== undefined) {
	        const shapes = parameters.shapes;
	        if (Array.isArray(shapes)) {
	          for (let i = 0, l = shapes.length; i < l; i++) {
	            const shape = shapes[i];
	            serialize(meta.shapes, shape);
	          }
	        } else {
	          serialize(meta.shapes, shapes);
	        }
	      }
	    }
	    if (this.isSkinnedMesh) {
	      object.bindMode = this.bindMode;
	      object.bindMatrix = this.bindMatrix.toArray();
	      if (this.skeleton !== undefined) {
	        serialize(meta.skeletons, this.skeleton);
	        object.skeleton = this.skeleton.uuid;
	      }
	    }
	    if (this.material !== undefined) {
	      if (Array.isArray(this.material)) {
	        const uuids = [];
	        for (let i = 0, l = this.material.length; i < l; i++) {
	          uuids.push(serialize(meta.materials, this.material[i]));
	        }
	        object.material = uuids;
	      } else {
	        object.material = serialize(meta.materials, this.material);
	      }
	    }

	    //

	    if (this.children.length > 0) {
	      object.children = [];
	      for (let i = 0; i < this.children.length; i++) {
	        object.children.push(this.children[i].toJSON(meta).object);
	      }
	    }

	    //

	    if (this.animations.length > 0) {
	      object.animations = [];
	      for (let i = 0; i < this.animations.length; i++) {
	        const animation = this.animations[i];
	        object.animations.push(serialize(meta.animations, animation));
	      }
	    }
	    if (isRootObject) {
	      const geometries = extractFromCache(meta.geometries);
	      const materials = extractFromCache(meta.materials);
	      const textures = extractFromCache(meta.textures);
	      const images = extractFromCache(meta.images);
	      const shapes = extractFromCache(meta.shapes);
	      const skeletons = extractFromCache(meta.skeletons);
	      const animations = extractFromCache(meta.animations);
	      const nodes = extractFromCache(meta.nodes);
	      if (geometries.length > 0) output.geometries = geometries;
	      if (materials.length > 0) output.materials = materials;
	      if (textures.length > 0) output.textures = textures;
	      if (images.length > 0) output.images = images;
	      if (shapes.length > 0) output.shapes = shapes;
	      if (skeletons.length > 0) output.skeletons = skeletons;
	      if (animations.length > 0) output.animations = animations;
	      if (nodes.length > 0) output.nodes = nodes;
	    }
	    output.object = object;
	    return output;

	    // extract data from the cache hash
	    // remove metadata on each item
	    // and return as array
	    function extractFromCache(cache) {
	      const values = [];
	      for (const key in cache) {
	        const data = cache[key];
	        delete data.metadata;
	        values.push(data);
	      }
	      return values;
	    }
	  }
	  clone(recursive) {
	    return new this.constructor().copy(this, recursive);
	  }
	  copy(source, recursive = true) {
	    this.name = source.name;
	    this.up.copy(source.up);
	    this.position.copy(source.position);
	    this.rotation.order = source.rotation.order;
	    this.quaternion.copy(source.quaternion);
	    this.scale.copy(source.scale);
	    this.matrix.copy(source.matrix);
	    this.matrixWorld.copy(source.matrixWorld);
	    this.matrixAutoUpdate = source.matrixAutoUpdate;
	    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
	    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
	    this.layers.mask = source.layers.mask;
	    this.visible = source.visible;
	    this.castShadow = source.castShadow;
	    this.receiveShadow = source.receiveShadow;
	    this.frustumCulled = source.frustumCulled;
	    this.renderOrder = source.renderOrder;
	    this.animations = source.animations.slice();
	    this.userData = JSON.parse(JSON.stringify(source.userData));
	    if (recursive === true) {
	      for (let i = 0; i < source.children.length; i++) {
	        const child = source.children[i];
	        this.add(child.clone());
	      }
	    }
	    return this;
	  }
	}
	Object3D.DEFAULT_UP = /*@__PURE__*/new Vector3(0, 1, 0);
	Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
	Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

	function arrayNeedsUint32(array) {
	  // assumes larger values usually on last

	  for (let i = array.length - 1; i >= 0; --i) {
	    if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
	  }
	  return false;
	}

	let _id = 0;
	const _m1 = /*@__PURE__*/new Matrix4();
	const _obj = /*@__PURE__*/new Object3D();
	const _offset = /*@__PURE__*/new Vector3();
	const _box = /*@__PURE__*/new Box3();
	const _boxMorphTargets = /*@__PURE__*/new Box3();
	const _vector = /*@__PURE__*/new Vector3();
	class BufferGeometry extends EventDispatcher {
	  constructor() {
	    super();
	    this.isBufferGeometry = true;
	    Object.defineProperty(this, 'id', {
	      value: _id++
	    });
	    this.uuid = generateUUID();
	    this.name = '';
	    this.type = 'BufferGeometry';
	    this.index = null;
	    this.indirect = null;
	    this.attributes = {};
	    this.morphAttributes = {};
	    this.morphTargetsRelative = false;
	    this.groups = [];
	    this.boundingBox = null;
	    this.boundingSphere = null;
	    this.drawRange = {
	      start: 0,
	      count: Infinity
	    };
	    this.userData = {};
	  }
	  getIndex() {
	    return this.index;
	  }
	  setIndex(index) {
	    if (Array.isArray(index)) {
	      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
	    } else {
	      this.index = index;
	    }
	    return this;
	  }
	  setIndirect(indirect) {
	    this.indirect = indirect;
	    return this;
	  }
	  getIndirect() {
	    return this.indirect;
	  }
	  getAttribute(name) {
	    return this.attributes[name];
	  }
	  setAttribute(name, attribute) {
	    this.attributes[name] = attribute;
	    return this;
	  }
	  deleteAttribute(name) {
	    delete this.attributes[name];
	    return this;
	  }
	  hasAttribute(name) {
	    return this.attributes[name] !== undefined;
	  }
	  addGroup(start, count, materialIndex = 0) {
	    this.groups.push({
	      start: start,
	      count: count,
	      materialIndex: materialIndex
	    });
	  }
	  clearGroups() {
	    this.groups = [];
	  }
	  setDrawRange(start, count) {
	    this.drawRange.start = start;
	    this.drawRange.count = count;
	  }
	  applyMatrix4(matrix) {
	    const position = this.attributes.position;
	    if (position !== undefined) {
	      position.applyMatrix4(matrix);
	      position.needsUpdate = true;
	    }
	    const normal = this.attributes.normal;
	    if (normal !== undefined) {
	      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
	      normal.applyNormalMatrix(normalMatrix);
	      normal.needsUpdate = true;
	    }
	    const tangent = this.attributes.tangent;
	    if (tangent !== undefined) {
	      tangent.transformDirection(matrix);
	      tangent.needsUpdate = true;
	    }
	    if (this.boundingBox !== null) {
	      this.computeBoundingBox();
	    }
	    if (this.boundingSphere !== null) {
	      this.computeBoundingSphere();
	    }
	    return this;
	  }
	  applyQuaternion(q) {
	    _m1.makeRotationFromQuaternion(q);
	    this.applyMatrix4(_m1);
	    return this;
	  }
	  rotateX(angle) {
	    // rotate geometry around world x-axis

	    _m1.makeRotationX(angle);
	    this.applyMatrix4(_m1);
	    return this;
	  }
	  rotateY(angle) {
	    // rotate geometry around world y-axis

	    _m1.makeRotationY(angle);
	    this.applyMatrix4(_m1);
	    return this;
	  }
	  rotateZ(angle) {
	    // rotate geometry around world z-axis

	    _m1.makeRotationZ(angle);
	    this.applyMatrix4(_m1);
	    return this;
	  }
	  translate(x, y, z) {
	    // translate geometry

	    _m1.makeTranslation(x, y, z);
	    this.applyMatrix4(_m1);
	    return this;
	  }
	  scale(x, y, z) {
	    // scale geometry

	    _m1.makeScale(x, y, z);
	    this.applyMatrix4(_m1);
	    return this;
	  }
	  lookAt(vector) {
	    _obj.lookAt(vector);
	    _obj.updateMatrix();
	    this.applyMatrix4(_obj.matrix);
	    return this;
	  }
	  center() {
	    this.computeBoundingBox();
	    this.boundingBox.getCenter(_offset).negate();
	    this.translate(_offset.x, _offset.y, _offset.z);
	    return this;
	  }
	  setFromPoints(points) {
	    const positionAttribute = this.getAttribute('position');
	    if (positionAttribute === undefined) {
	      const position = [];
	      for (let i = 0, l = points.length; i < l; i++) {
	        const point = points[i];
	        position.push(point.x, point.y, point.z || 0);
	      }
	      this.setAttribute('position', new Float32BufferAttribute(position, 3));
	    } else {
	      const l = Math.min(points.length, positionAttribute.count); // make sure data do not exceed buffer size

	      for (let i = 0; i < l; i++) {
	        const point = points[i];
	        positionAttribute.setXYZ(i, point.x, point.y, point.z || 0);
	      }
	      if (points.length > positionAttribute.count) {
	        console.warn('THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.');
	      }
	      positionAttribute.needsUpdate = true;
	    }
	    return this;
	  }
	  computeBoundingBox() {
	    if (this.boundingBox === null) {
	      this.boundingBox = new Box3();
	    }
	    const position = this.attributes.position;
	    const morphAttributesPosition = this.morphAttributes.position;
	    if (position && position.isGLBufferAttribute) {
	      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this);
	      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
	      return;
	    }
	    if (position !== undefined) {
	      this.boundingBox.setFromBufferAttribute(position);

	      // process morph attributes if present

	      if (morphAttributesPosition) {
	        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
	          const morphAttribute = morphAttributesPosition[i];
	          _box.setFromBufferAttribute(morphAttribute);
	          if (this.morphTargetsRelative) {
	            _vector.addVectors(this.boundingBox.min, _box.min);
	            this.boundingBox.expandByPoint(_vector);
	            _vector.addVectors(this.boundingBox.max, _box.max);
	            this.boundingBox.expandByPoint(_vector);
	          } else {
	            this.boundingBox.expandByPoint(_box.min);
	            this.boundingBox.expandByPoint(_box.max);
	          }
	        }
	      }
	    } else {
	      this.boundingBox.makeEmpty();
	    }
	    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
	      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
	    }
	  }
	  computeBoundingSphere() {
	    if (this.boundingSphere === null) {
	      this.boundingSphere = new Sphere();
	    }
	    const position = this.attributes.position;
	    const morphAttributesPosition = this.morphAttributes.position;
	    if (position && position.isGLBufferAttribute) {
	      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this);
	      this.boundingSphere.set(new Vector3(), Infinity);
	      return;
	    }
	    if (position) {
	      // first, find the center of the bounding sphere

	      const center = this.boundingSphere.center;
	      _box.setFromBufferAttribute(position);

	      // process morph attributes if present

	      if (morphAttributesPosition) {
	        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
	          const morphAttribute = morphAttributesPosition[i];
	          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
	          if (this.morphTargetsRelative) {
	            _vector.addVectors(_box.min, _boxMorphTargets.min);
	            _box.expandByPoint(_vector);
	            _vector.addVectors(_box.max, _boxMorphTargets.max);
	            _box.expandByPoint(_vector);
	          } else {
	            _box.expandByPoint(_boxMorphTargets.min);
	            _box.expandByPoint(_boxMorphTargets.max);
	          }
	        }
	      }
	      _box.getCenter(center);

	      // second, try to find a boundingSphere with a radius smaller than the
	      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

	      let maxRadiusSq = 0;
	      for (let i = 0, il = position.count; i < il; i++) {
	        _vector.fromBufferAttribute(position, i);
	        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
	      }

	      // process morph attributes if present

	      if (morphAttributesPosition) {
	        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
	          const morphAttribute = morphAttributesPosition[i];
	          const morphTargetsRelative = this.morphTargetsRelative;
	          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
	            _vector.fromBufferAttribute(morphAttribute, j);
	            if (morphTargetsRelative) {
	              _offset.fromBufferAttribute(position, j);
	              _vector.add(_offset);
	            }
	            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
	          }
	        }
	      }
	      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
	      if (isNaN(this.boundingSphere.radius)) {
	        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
	      }
	    }
	  }
	  computeTangents() {
	    const index = this.index;
	    const attributes = this.attributes;

	    // based on http://www.terathon.com/code/tangent.html
	    // (per vertex tangents)

	    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
	      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
	      return;
	    }
	    const positionAttribute = attributes.position;
	    const normalAttribute = attributes.normal;
	    const uvAttribute = attributes.uv;
	    if (this.hasAttribute('tangent') === false) {
	      this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
	    }
	    const tangentAttribute = this.getAttribute('tangent');
	    const tan1 = [],
	      tan2 = [];
	    for (let i = 0; i < positionAttribute.count; i++) {
	      tan1[i] = new Vector3();
	      tan2[i] = new Vector3();
	    }
	    const vA = new Vector3(),
	      vB = new Vector3(),
	      vC = new Vector3(),
	      uvA = new Vector2(),
	      uvB = new Vector2(),
	      uvC = new Vector2(),
	      sdir = new Vector3(),
	      tdir = new Vector3();
	    function handleTriangle(a, b, c) {
	      vA.fromBufferAttribute(positionAttribute, a);
	      vB.fromBufferAttribute(positionAttribute, b);
	      vC.fromBufferAttribute(positionAttribute, c);
	      uvA.fromBufferAttribute(uvAttribute, a);
	      uvB.fromBufferAttribute(uvAttribute, b);
	      uvC.fromBufferAttribute(uvAttribute, c);
	      vB.sub(vA);
	      vC.sub(vA);
	      uvB.sub(uvA);
	      uvC.sub(uvA);
	      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);

	      // silently ignore degenerate uv triangles having coincident or colinear vertices

	      if (!isFinite(r)) return;
	      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
	      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
	      tan1[a].add(sdir);
	      tan1[b].add(sdir);
	      tan1[c].add(sdir);
	      tan2[a].add(tdir);
	      tan2[b].add(tdir);
	      tan2[c].add(tdir);
	    }
	    let groups = this.groups;
	    if (groups.length === 0) {
	      groups = [{
	        start: 0,
	        count: index.count
	      }];
	    }
	    for (let i = 0, il = groups.length; i < il; ++i) {
	      const group = groups[i];
	      const start = group.start;
	      const count = group.count;
	      for (let j = start, jl = start + count; j < jl; j += 3) {
	        handleTriangle(index.getX(j + 0), index.getX(j + 1), index.getX(j + 2));
	      }
	    }
	    const tmp = new Vector3(),
	      tmp2 = new Vector3();
	    const n = new Vector3(),
	      n2 = new Vector3();
	    function handleVertex(v) {
	      n.fromBufferAttribute(normalAttribute, v);
	      n2.copy(n);
	      const t = tan1[v];

	      // Gram-Schmidt orthogonalize

	      tmp.copy(t);
	      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();

	      // Calculate handedness

	      tmp2.crossVectors(n2, t);
	      const test = tmp2.dot(tan2[v]);
	      const w = test < 0.0 ? -1.0 : 1.0;
	      tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);
	    }
	    for (let i = 0, il = groups.length; i < il; ++i) {
	      const group = groups[i];
	      const start = group.start;
	      const count = group.count;
	      for (let j = start, jl = start + count; j < jl; j += 3) {
	        handleVertex(index.getX(j + 0));
	        handleVertex(index.getX(j + 1));
	        handleVertex(index.getX(j + 2));
	      }
	    }
	  }
	  computeVertexNormals() {
	    const index = this.index;
	    const positionAttribute = this.getAttribute('position');
	    if (positionAttribute !== undefined) {
	      let normalAttribute = this.getAttribute('normal');
	      if (normalAttribute === undefined) {
	        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
	        this.setAttribute('normal', normalAttribute);
	      } else {
	        // reset existing normals to zero

	        for (let i = 0, il = normalAttribute.count; i < il; i++) {
	          normalAttribute.setXYZ(i, 0, 0, 0);
	        }
	      }
	      const pA = new Vector3(),
	        pB = new Vector3(),
	        pC = new Vector3();
	      const nA = new Vector3(),
	        nB = new Vector3(),
	        nC = new Vector3();
	      const cb = new Vector3(),
	        ab = new Vector3();

	      // indexed elements

	      if (index) {
	        for (let i = 0, il = index.count; i < il; i += 3) {
	          const vA = index.getX(i + 0);
	          const vB = index.getX(i + 1);
	          const vC = index.getX(i + 2);
	          pA.fromBufferAttribute(positionAttribute, vA);
	          pB.fromBufferAttribute(positionAttribute, vB);
	          pC.fromBufferAttribute(positionAttribute, vC);
	          cb.subVectors(pC, pB);
	          ab.subVectors(pA, pB);
	          cb.cross(ab);
	          nA.fromBufferAttribute(normalAttribute, vA);
	          nB.fromBufferAttribute(normalAttribute, vB);
	          nC.fromBufferAttribute(normalAttribute, vC);
	          nA.add(cb);
	          nB.add(cb);
	          nC.add(cb);
	          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
	          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
	          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
	        }
	      } else {
	        // non-indexed elements (unconnected triangle soup)

	        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
	          pA.fromBufferAttribute(positionAttribute, i + 0);
	          pB.fromBufferAttribute(positionAttribute, i + 1);
	          pC.fromBufferAttribute(positionAttribute, i + 2);
	          cb.subVectors(pC, pB);
	          ab.subVectors(pA, pB);
	          cb.cross(ab);
	          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
	          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
	          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
	        }
	      }
	      this.normalizeNormals();
	      normalAttribute.needsUpdate = true;
	    }
	  }
	  normalizeNormals() {
	    const normals = this.attributes.normal;
	    for (let i = 0, il = normals.count; i < il; i++) {
	      _vector.fromBufferAttribute(normals, i);
	      _vector.normalize();
	      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);
	    }
	  }
	  toNonIndexed() {
	    function convertBufferAttribute(attribute, indices) {
	      const array = attribute.array;
	      const itemSize = attribute.itemSize;
	      const normalized = attribute.normalized;
	      const array2 = new array.constructor(indices.length * itemSize);
	      let index = 0,
	        index2 = 0;
	      for (let i = 0, l = indices.length; i < l; i++) {
	        if (attribute.isInterleavedBufferAttribute) {
	          index = indices[i] * attribute.data.stride + attribute.offset;
	        } else {
	          index = indices[i] * itemSize;
	        }
	        for (let j = 0; j < itemSize; j++) {
	          array2[index2++] = array[index++];
	        }
	      }
	      return new BufferAttribute(array2, itemSize, normalized);
	    }

	    //

	    if (this.index === null) {
	      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
	      return this;
	    }
	    const geometry2 = new BufferGeometry();
	    const indices = this.index.array;
	    const attributes = this.attributes;

	    // attributes

	    for (const name in attributes) {
	      const attribute = attributes[name];
	      const newAttribute = convertBufferAttribute(attribute, indices);
	      geometry2.setAttribute(name, newAttribute);
	    }

	    // morph attributes

	    const morphAttributes = this.morphAttributes;
	    for (const name in morphAttributes) {
	      const morphArray = [];
	      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

	      for (let i = 0, il = morphAttribute.length; i < il; i++) {
	        const attribute = morphAttribute[i];
	        const newAttribute = convertBufferAttribute(attribute, indices);
	        morphArray.push(newAttribute);
	      }
	      geometry2.morphAttributes[name] = morphArray;
	    }
	    geometry2.morphTargetsRelative = this.morphTargetsRelative;

	    // groups

	    const groups = this.groups;
	    for (let i = 0, l = groups.length; i < l; i++) {
	      const group = groups[i];
	      geometry2.addGroup(group.start, group.count, group.materialIndex);
	    }
	    return geometry2;
	  }
	  toJSON() {
	    const data = {
	      metadata: {
	        version: 4.6,
	        type: 'BufferGeometry',
	        generator: 'BufferGeometry.toJSON'
	      }
	    };

	    // standard BufferGeometry serialization

	    data.uuid = this.uuid;
	    data.type = this.type;
	    if (this.name !== '') data.name = this.name;
	    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
	    if (this.parameters !== undefined) {
	      const parameters = this.parameters;
	      for (const key in parameters) {
	        if (parameters[key] !== undefined) data[key] = parameters[key];
	      }
	      return data;
	    }

	    // for simplicity the code assumes attributes are not shared across geometries, see #15811

	    data.data = {
	      attributes: {}
	    };
	    const index = this.index;
	    if (index !== null) {
	      data.data.index = {
	        type: index.array.constructor.name,
	        array: Array.prototype.slice.call(index.array)
	      };
	    }
	    const attributes = this.attributes;
	    for (const key in attributes) {
	      const attribute = attributes[key];
	      data.data.attributes[key] = attribute.toJSON(data.data);
	    }
	    const morphAttributes = {};
	    let hasMorphAttributes = false;
	    for (const key in this.morphAttributes) {
	      const attributeArray = this.morphAttributes[key];
	      const array = [];
	      for (let i = 0, il = attributeArray.length; i < il; i++) {
	        const attribute = attributeArray[i];
	        array.push(attribute.toJSON(data.data));
	      }
	      if (array.length > 0) {
	        morphAttributes[key] = array;
	        hasMorphAttributes = true;
	      }
	    }
	    if (hasMorphAttributes) {
	      data.data.morphAttributes = morphAttributes;
	      data.data.morphTargetsRelative = this.morphTargetsRelative;
	    }
	    const groups = this.groups;
	    if (groups.length > 0) {
	      data.data.groups = JSON.parse(JSON.stringify(groups));
	    }
	    const boundingSphere = this.boundingSphere;
	    if (boundingSphere !== null) {
	      data.data.boundingSphere = {
	        center: boundingSphere.center.toArray(),
	        radius: boundingSphere.radius
	      };
	    }
	    return data;
	  }
	  clone() {
	    return new this.constructor().copy(this);
	  }
	  copy(source) {
	    // reset

	    this.index = null;
	    this.attributes = {};
	    this.morphAttributes = {};
	    this.groups = [];
	    this.boundingBox = null;
	    this.boundingSphere = null;

	    // used for storing cloned, shared data

	    const data = {};

	    // name

	    this.name = source.name;

	    // index

	    const index = source.index;
	    if (index !== null) {
	      this.setIndex(index.clone(data));
	    }

	    // attributes

	    const attributes = source.attributes;
	    for (const name in attributes) {
	      const attribute = attributes[name];
	      this.setAttribute(name, attribute.clone(data));
	    }

	    // morph attributes

	    const morphAttributes = source.morphAttributes;
	    for (const name in morphAttributes) {
	      const array = [];
	      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

	      for (let i = 0, l = morphAttribute.length; i < l; i++) {
	        array.push(morphAttribute[i].clone(data));
	      }
	      this.morphAttributes[name] = array;
	    }
	    this.morphTargetsRelative = source.morphTargetsRelative;

	    // groups

	    const groups = source.groups;
	    for (let i = 0, l = groups.length; i < l; i++) {
	      const group = groups[i];
	      this.addGroup(group.start, group.count, group.materialIndex);
	    }

	    // bounding box

	    const boundingBox = source.boundingBox;
	    if (boundingBox !== null) {
	      this.boundingBox = boundingBox.clone();
	    }

	    // bounding sphere

	    const boundingSphere = source.boundingSphere;
	    if (boundingSphere !== null) {
	      this.boundingSphere = boundingSphere.clone();
	    }

	    // draw range

	    this.drawRange.start = source.drawRange.start;
	    this.drawRange.count = source.drawRange.count;

	    // user data

	    this.userData = source.userData;
	    return this;
	  }
	  dispose() {
	    this.dispatchEvent({
	      type: 'dispose'
	    });
	  }
	}

	class BoxGeometry extends BufferGeometry {
	  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
	    super();
	    this.type = 'BoxGeometry';
	    this.parameters = {
	      width: width,
	      height: height,
	      depth: depth,
	      widthSegments: widthSegments,
	      heightSegments: heightSegments,
	      depthSegments: depthSegments
	    };
	    const scope = this;

	    // segments

	    widthSegments = Math.floor(widthSegments);
	    heightSegments = Math.floor(heightSegments);
	    depthSegments = Math.floor(depthSegments);

	    // buffers

	    const indices = [];
	    const vertices = [];
	    const normals = [];
	    const uvs = [];

	    // helper variables

	    let numberOfVertices = 0;
	    let groupStart = 0;

	    // build each side of the box geometry

	    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
	    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
	    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
	    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
	    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
	    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz

	    // build geometry

	    this.setIndex(indices);
	    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
	    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
	    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
	    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
	      const segmentWidth = width / gridX;
	      const segmentHeight = height / gridY;
	      const widthHalf = width / 2;
	      const heightHalf = height / 2;
	      const depthHalf = depth / 2;
	      const gridX1 = gridX + 1;
	      const gridY1 = gridY + 1;
	      let vertexCounter = 0;
	      let groupCount = 0;
	      const vector = new Vector3();

	      // generate vertices, normals and uvs

	      for (let iy = 0; iy < gridY1; iy++) {
	        const y = iy * segmentHeight - heightHalf;
	        for (let ix = 0; ix < gridX1; ix++) {
	          const x = ix * segmentWidth - widthHalf;

	          // set values to correct vector component

	          vector[u] = x * udir;
	          vector[v] = y * vdir;
	          vector[w] = depthHalf;

	          // now apply vector to vertex buffer

	          vertices.push(vector.x, vector.y, vector.z);

	          // set values to correct vector component

	          vector[u] = 0;
	          vector[v] = 0;
	          vector[w] = depth > 0 ? 1 : -1;

	          // now apply vector to normal buffer

	          normals.push(vector.x, vector.y, vector.z);

	          // uvs

	          uvs.push(ix / gridX);
	          uvs.push(1 - iy / gridY);

	          // counters

	          vertexCounter += 1;
	        }
	      }

	      // indices

	      // 1. you need three indices to draw a single face
	      // 2. a single segment consists of two faces
	      // 3. so we need to generate six (2*3) indices per segment

	      for (let iy = 0; iy < gridY; iy++) {
	        for (let ix = 0; ix < gridX; ix++) {
	          const a = numberOfVertices + ix + gridX1 * iy;
	          const b = numberOfVertices + ix + gridX1 * (iy + 1);
	          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
	          const d = numberOfVertices + (ix + 1) + gridX1 * iy;

	          // faces

	          indices.push(a, b, d);
	          indices.push(b, c, d);

	          // increase counter

	          groupCount += 6;
	        }
	      }

	      // add a group to the geometry. this will ensure multi material support

	      scope.addGroup(groupStart, groupCount, materialIndex);

	      // calculate new start value for groups

	      groupStart += groupCount;

	      // update total number of vertices

	      numberOfVertices += vertexCounter;
	    }
	  }
	  copy(source) {
	    super.copy(source);
	    this.parameters = Object.assign({}, source.parameters);
	    return this;
	  }
	  static fromJSON(data) {
	    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
	  }
	}

	var lib$1 = {};

	// Unique ID creation requires a high quality random # generator. In the browser we therefore
	// require the crypto API and do not support built-in fallback to lower quality random number
	// generators (like Math.random()).
	var getRandomValues;
	var rnds8 = new Uint8Array(16);
	function rng() {
	  // lazy load so that environments that need to polyfill have a chance to do so
	  if (!getRandomValues) {
	    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
	    // find the complete implementation of crypto (msCrypto) on IE11.
	    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
	    if (!getRandomValues) {
	      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
	    }
	  }
	  return getRandomValues(rnds8);
	}

	var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

	function validate(uuid) {
	  return typeof uuid === 'string' && REGEX.test(uuid);
	}

	/**
	 * Convert array of 16 byte values to UUID string format of the form:
	 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	 */

	var byteToHex = [];
	for (var i$2 = 0; i$2 < 256; ++i$2) {
	  byteToHex.push((i$2 + 0x100).toString(16).substr(1));
	}
	function stringify(arr) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	  // Note: Be careful editing this code!  It's been tuned for performance
	  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
	  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
	  // of the following:
	  // - One or more input array values don't map to a hex octet (leading to
	  // "undefined" in the uuid)
	  // - Invalid input values for the RFC `version` or `variant` fields

	  if (!validate(uuid)) {
	    throw TypeError('Stringified UUID is invalid');
	  }
	  return uuid;
	}

	//
	// Inspired by https://github.com/LiosK/UUID.js
	// and http://docs.python.org/library/uuid.html

	var _nodeId;
	var _clockseq; // Previous uuid creation time

	var _lastMSecs = 0;
	var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

	function v1(options, buf, offset) {
	  var i = buf && offset || 0;
	  var b = buf || new Array(16);
	  options = options || {};
	  var node = options.node || _nodeId;
	  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
	  // specified.  We do this lazily to minimize issues related to insufficient
	  // system entropy.  See #189

	  if (node == null || clockseq == null) {
	    var seedBytes = options.random || (options.rng || rng)();
	    if (node == null) {
	      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
	    }
	    if (clockseq == null) {
	      // Per 4.2.2, randomize (14 bit) clockseq
	      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
	    }
	  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.

	  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
	  // cycle to simulate higher resolution clock

	  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

	  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

	  if (dt < 0 && options.clockseq === undefined) {
	    clockseq = clockseq + 1 & 0x3fff;
	  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	  // time interval

	  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
	    nsecs = 0;
	  } // Per 4.2.1.2 Throw error if too many uuids are requested

	  if (nsecs >= 10000) {
	    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
	  }
	  _lastMSecs = msecs;
	  _lastNSecs = nsecs;
	  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

	  msecs += 12219292800000; // `time_low`

	  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	  b[i++] = tl >>> 24 & 0xff;
	  b[i++] = tl >>> 16 & 0xff;
	  b[i++] = tl >>> 8 & 0xff;
	  b[i++] = tl & 0xff; // `time_mid`

	  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
	  b[i++] = tmh >>> 8 & 0xff;
	  b[i++] = tmh & 0xff; // `time_high_and_version`

	  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

	  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

	  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

	  b[i++] = clockseq & 0xff; // `node`

	  for (var n = 0; n < 6; ++n) {
	    b[i + n] = node[n];
	  }
	  return buf || stringify(b);
	}

	function parse(uuid) {
	  if (!validate(uuid)) {
	    throw TypeError('Invalid UUID');
	  }
	  var v;
	  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

	  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
	  arr[1] = v >>> 16 & 0xff;
	  arr[2] = v >>> 8 & 0xff;
	  arr[3] = v & 0xff; // Parse ........-####-....-....-............

	  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
	  arr[5] = v & 0xff; // Parse ........-....-####-....-............

	  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
	  arr[7] = v & 0xff; // Parse ........-....-....-####-............

	  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
	  arr[9] = v & 0xff; // Parse ........-....-....-....-############
	  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

	  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
	  arr[11] = v / 0x100000000 & 0xff;
	  arr[12] = v >>> 24 & 0xff;
	  arr[13] = v >>> 16 & 0xff;
	  arr[14] = v >>> 8 & 0xff;
	  arr[15] = v & 0xff;
	  return arr;
	}

	function stringToBytes(str) {
	  str = unescape(encodeURIComponent(str)); // UTF8 escape

	  var bytes = [];
	  for (var i = 0; i < str.length; ++i) {
	    bytes.push(str.charCodeAt(i));
	  }
	  return bytes;
	}
	var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
	var URL$1 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
	function v35 (name, version, hashfunc) {
	  function generateUUID(value, namespace, buf, offset) {
	    if (typeof value === 'string') {
	      value = stringToBytes(value);
	    }
	    if (typeof namespace === 'string') {
	      namespace = parse(namespace);
	    }
	    if (namespace.length !== 16) {
	      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
	    } // Compute hash of namespace and value, Per 4.3
	    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
	    // hashfunc([...namespace, ... value])`

	    var bytes = new Uint8Array(16 + value.length);
	    bytes.set(namespace);
	    bytes.set(value, namespace.length);
	    bytes = hashfunc(bytes);
	    bytes[6] = bytes[6] & 0x0f | version;
	    bytes[8] = bytes[8] & 0x3f | 0x80;
	    if (buf) {
	      offset = offset || 0;
	      for (var i = 0; i < 16; ++i) {
	        buf[offset + i] = bytes[i];
	      }
	      return buf;
	    }
	    return stringify(bytes);
	  } // Function#name is not settable on some platforms (#270)

	  try {
	    generateUUID.name = name; // eslint-disable-next-line no-empty
	  } catch (err) {} // For CommonJS default export support

	  generateUUID.DNS = DNS;
	  generateUUID.URL = URL$1;
	  return generateUUID;
	}

	/*
	 * Browser-compatible JavaScript MD5
	 *
	 * Modification of JavaScript MD5
	 * https://github.com/blueimp/JavaScript-MD5
	 *
	 * Copyright 2011, Sebastian Tschan
	 * https://blueimp.net
	 *
	 * Licensed under the MIT license:
	 * https://opensource.org/licenses/MIT
	 *
	 * Based on
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	function md5(bytes) {
	  if (typeof bytes === 'string') {
	    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

	    bytes = new Uint8Array(msg.length);
	    for (var i = 0; i < msg.length; ++i) {
	      bytes[i] = msg.charCodeAt(i);
	    }
	  }
	  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
	}
	/*
	 * Convert an array of little-endian words to an array of bytes
	 */

	function md5ToHexEncodedArray(input) {
	  var output = [];
	  var length32 = input.length * 32;
	  var hexTab = '0123456789abcdef';
	  for (var i = 0; i < length32; i += 8) {
	    var x = input[i >> 5] >>> i % 32 & 0xff;
	    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
	    output.push(hex);
	  }
	  return output;
	}
	/**
	 * Calculate output length with padding and bit length
	 */

	function getOutputLength(inputLength8) {
	  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
	}
	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length.
	 */

	function wordsToMd5(x, len) {
	  /* append padding */
	  x[len >> 5] |= 0x80 << len % 32;
	  x[getOutputLength(len) - 1] = len;
	  var a = 1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d = 271733878;
	  for (var i = 0; i < x.length; i += 16) {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;
	    a = md5ff(a, b, c, d, x[i], 7, -680876936);
	    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
	    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
	    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
	    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
	    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
	    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
	    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
	    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
	    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
	    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
	    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
	    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
	    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
	    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
	    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
	    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
	    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
	    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
	    b = md5gg(b, c, d, a, x[i], 20, -373897302);
	    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
	    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
	    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
	    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
	    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
	    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
	    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
	    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
	    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
	    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
	    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
	    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
	    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
	    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
	    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
	    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
	    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
	    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
	    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
	    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
	    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
	    d = md5hh(d, a, b, c, x[i], 11, -358537222);
	    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
	    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
	    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
	    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
	    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
	    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
	    a = md5ii(a, b, c, d, x[i], 6, -198630844);
	    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
	    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
	    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
	    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
	    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
	    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
	    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
	    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
	    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
	    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
	    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
	    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
	    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
	    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
	    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
	    a = safeAdd(a, olda);
	    b = safeAdd(b, oldb);
	    c = safeAdd(c, oldc);
	    d = safeAdd(d, oldd);
	  }
	  return [a, b, c, d];
	}
	/*
	 * Convert an array bytes to an array of little-endian words
	 * Characters >255 have their high-byte silently ignored.
	 */

	function bytesToWords(input) {
	  if (input.length === 0) {
	    return [];
	  }
	  var length8 = input.length * 8;
	  var output = new Uint32Array(getOutputLength(length8));
	  for (var i = 0; i < length8; i += 8) {
	    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
	  }
	  return output;
	}
	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */

	function safeAdd(x, y) {
	  var lsw = (x & 0xffff) + (y & 0xffff);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return msw << 16 | lsw & 0xffff;
	}
	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */

	function bitRotateLeft(num, cnt) {
	  return num << cnt | num >>> 32 - cnt;
	}
	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */

	function md5cmn(q, a, b, x, s, t) {
	  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
	}
	function md5ff(a, b, c, d, x, s, t) {
	  return md5cmn(b & c | ~b & d, a, b, x, s, t);
	}
	function md5gg(a, b, c, d, x, s, t) {
	  return md5cmn(b & d | c & ~d, a, b, x, s, t);
	}
	function md5hh(a, b, c, d, x, s, t) {
	  return md5cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5ii(a, b, c, d, x, s, t) {
	  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
	}

	var v3 = v35('v3', 0x30, md5);

	function v4(options, buf, offset) {
	  options = options || {};
	  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

	  rnds[6] = rnds[6] & 0x0f | 0x40;
	  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

	  if (buf) {
	    offset = offset || 0;
	    for (var i = 0; i < 16; ++i) {
	      buf[offset + i] = rnds[i];
	    }
	    return buf;
	  }
	  return stringify(rnds);
	}

	// Adapted from Chris Veness' SHA1 code at
	// http://www.movable-type.co.uk/scripts/sha1.html
	function f$2(s, x, y, z) {
	  switch (s) {
	    case 0:
	      return x & y ^ ~x & z;
	    case 1:
	      return x ^ y ^ z;
	    case 2:
	      return x & y ^ x & z ^ y & z;
	    case 3:
	      return x ^ y ^ z;
	  }
	}
	function ROTL(x, n) {
	  return x << n | x >>> 32 - n;
	}
	function sha1(bytes) {
	  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
	  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
	  if (typeof bytes === 'string') {
	    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

	    bytes = [];
	    for (var i = 0; i < msg.length; ++i) {
	      bytes.push(msg.charCodeAt(i));
	    }
	  } else if (!Array.isArray(bytes)) {
	    // Convert Array-like to Array
	    bytes = Array.prototype.slice.call(bytes);
	  }
	  bytes.push(0x80);
	  var l = bytes.length / 4 + 2;
	  var N = Math.ceil(l / 16);
	  var M = new Array(N);
	  for (var _i = 0; _i < N; ++_i) {
	    var arr = new Uint32Array(16);
	    for (var j = 0; j < 16; ++j) {
	      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
	    }
	    M[_i] = arr;
	  }
	  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
	  M[N - 1][14] = Math.floor(M[N - 1][14]);
	  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
	  for (var _i2 = 0; _i2 < N; ++_i2) {
	    var W = new Uint32Array(80);
	    for (var t = 0; t < 16; ++t) {
	      W[t] = M[_i2][t];
	    }
	    for (var _t = 16; _t < 80; ++_t) {
	      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
	    }
	    var a = H[0];
	    var b = H[1];
	    var c = H[2];
	    var d = H[3];
	    var e = H[4];
	    for (var _t2 = 0; _t2 < 80; ++_t2) {
	      var s = Math.floor(_t2 / 20);
	      var T = ROTL(a, 5) + f$2(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
	      e = d;
	      d = c;
	      c = ROTL(b, 30) >>> 0;
	      b = a;
	      a = T;
	    }
	    H[0] = H[0] + a >>> 0;
	    H[1] = H[1] + b >>> 0;
	    H[2] = H[2] + c >>> 0;
	    H[3] = H[3] + d >>> 0;
	    H[4] = H[4] + e >>> 0;
	  }
	  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
	}

	var v5 = v35('v5', 0x50, sha1);

	var nil = '00000000-0000-0000-0000-000000000000';

	function version(uuid) {
	  if (!validate(uuid)) {
	    throw TypeError('Invalid UUID');
	  }
	  return parseInt(uuid.substr(14, 1), 16);
	}

	var esmBrowser = /*#__PURE__*/Object.freeze({
		__proto__: null,
		NIL: nil,
		parse: parse,
		stringify: stringify,
		v1: v1,
		v3: v3,
		v4: v4,
		v5: v5,
		validate: validate,
		version: version
	});

	var BigInteger = {exports: {}};

	var hasRequiredBigInteger;
	function requireBigInteger() {
	  if (hasRequiredBigInteger) return BigInteger.exports;
	  hasRequiredBigInteger = 1;
	  (function (module) {
	    var bigInt = function (undefined$1) {

	      var BASE = 1e7,
	        LOG_BASE = 7,
	        MAX_INT = 9007199254740992,
	        MAX_INT_ARR = smallToArray(MAX_INT),
	        DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
	      var supportsNativeBigInt = typeof BigInt === "function";
	      function Integer(v, radix, alphabet, caseSensitive) {
	        if (typeof v === "undefined") return Integer[0];
	        if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
	        return parseValue(v);
	      }
	      function BigInteger(value, sign) {
	        this.value = value;
	        this.sign = sign;
	        this.isSmall = false;
	      }
	      BigInteger.prototype = Object.create(Integer.prototype);
	      function SmallInteger(value) {
	        this.value = value;
	        this.sign = value < 0;
	        this.isSmall = true;
	      }
	      SmallInteger.prototype = Object.create(Integer.prototype);
	      function NativeBigInt(value) {
	        this.value = value;
	      }
	      NativeBigInt.prototype = Object.create(Integer.prototype);
	      function isPrecise(n) {
	        return -MAX_INT < n && n < MAX_INT;
	      }
	      function smallToArray(n) {
	        // For performance reasons doesn't reference BASE, need to change this function if BASE changes
	        if (n < 1e7) return [n];
	        if (n < 1e14) return [n % 1e7, Math.floor(n / 1e7)];
	        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
	      }
	      function arrayToSmall(arr) {
	        // If BASE changes this function may need to change
	        trim(arr);
	        var length = arr.length;
	        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
	          switch (length) {
	            case 0:
	              return 0;
	            case 1:
	              return arr[0];
	            case 2:
	              return arr[0] + arr[1] * BASE;
	            default:
	              return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
	          }
	        }
	        return arr;
	      }
	      function trim(v) {
	        var i = v.length;
	        while (v[--i] === 0);
	        v.length = i + 1;
	      }
	      function createArray(length) {
	        // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
	        var x = new Array(length);
	        var i = -1;
	        while (++i < length) {
	          x[i] = 0;
	        }
	        return x;
	      }
	      function truncate(n) {
	        if (n > 0) return Math.floor(n);
	        return Math.ceil(n);
	      }
	      function add(a, b) {
	        // assumes a and b are arrays with a.length >= b.length
	        var l_a = a.length,
	          l_b = b.length,
	          r = new Array(l_a),
	          carry = 0,
	          base = BASE,
	          sum,
	          i;
	        for (i = 0; i < l_b; i++) {
	          sum = a[i] + b[i] + carry;
	          carry = sum >= base ? 1 : 0;
	          r[i] = sum - carry * base;
	        }
	        while (i < l_a) {
	          sum = a[i] + carry;
	          carry = sum === base ? 1 : 0;
	          r[i++] = sum - carry * base;
	        }
	        if (carry > 0) r.push(carry);
	        return r;
	      }
	      function addAny(a, b) {
	        if (a.length >= b.length) return add(a, b);
	        return add(b, a);
	      }
	      function addSmall(a, carry) {
	        // assumes a is array, carry is number with 0 <= carry < MAX_INT
	        var l = a.length,
	          r = new Array(l),
	          base = BASE,
	          sum,
	          i;
	        for (i = 0; i < l; i++) {
	          sum = a[i] - base + carry;
	          carry = Math.floor(sum / base);
	          r[i] = sum - carry * base;
	          carry += 1;
	        }
	        while (carry > 0) {
	          r[i++] = carry % base;
	          carry = Math.floor(carry / base);
	        }
	        return r;
	      }
	      BigInteger.prototype.add = function (v) {
	        var n = parseValue(v);
	        if (this.sign !== n.sign) {
	          return this.subtract(n.negate());
	        }
	        var a = this.value,
	          b = n.value;
	        if (n.isSmall) {
	          return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
	        }
	        return new BigInteger(addAny(a, b), this.sign);
	      };
	      BigInteger.prototype.plus = BigInteger.prototype.add;
	      SmallInteger.prototype.add = function (v) {
	        var n = parseValue(v);
	        var a = this.value;
	        if (a < 0 !== n.sign) {
	          return this.subtract(n.negate());
	        }
	        var b = n.value;
	        if (n.isSmall) {
	          if (isPrecise(a + b)) return new SmallInteger(a + b);
	          b = smallToArray(Math.abs(b));
	        }
	        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
	      };
	      SmallInteger.prototype.plus = SmallInteger.prototype.add;
	      NativeBigInt.prototype.add = function (v) {
	        return new NativeBigInt(this.value + parseValue(v).value);
	      };
	      NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
	      function subtract(a, b) {
	        // assumes a and b are arrays with a >= b
	        var a_l = a.length,
	          b_l = b.length,
	          r = new Array(a_l),
	          borrow = 0,
	          base = BASE,
	          i,
	          difference;
	        for (i = 0; i < b_l; i++) {
	          difference = a[i] - borrow - b[i];
	          if (difference < 0) {
	            difference += base;
	            borrow = 1;
	          } else borrow = 0;
	          r[i] = difference;
	        }
	        for (i = b_l; i < a_l; i++) {
	          difference = a[i] - borrow;
	          if (difference < 0) difference += base;else {
	            r[i++] = difference;
	            break;
	          }
	          r[i] = difference;
	        }
	        for (; i < a_l; i++) {
	          r[i] = a[i];
	        }
	        trim(r);
	        return r;
	      }
	      function subtractAny(a, b, sign) {
	        var value;
	        if (compareAbs(a, b) >= 0) {
	          value = subtract(a, b);
	        } else {
	          value = subtract(b, a);
	          sign = !sign;
	        }
	        value = arrayToSmall(value);
	        if (typeof value === "number") {
	          if (sign) value = -value;
	          return new SmallInteger(value);
	        }
	        return new BigInteger(value, sign);
	      }
	      function subtractSmall(a, b, sign) {
	        // assumes a is array, b is number with 0 <= b < MAX_INT
	        var l = a.length,
	          r = new Array(l),
	          carry = -b,
	          base = BASE,
	          i,
	          difference;
	        for (i = 0; i < l; i++) {
	          difference = a[i] + carry;
	          carry = Math.floor(difference / base);
	          difference %= base;
	          r[i] = difference < 0 ? difference + base : difference;
	        }
	        r = arrayToSmall(r);
	        if (typeof r === "number") {
	          if (sign) r = -r;
	          return new SmallInteger(r);
	        }
	        return new BigInteger(r, sign);
	      }
	      BigInteger.prototype.subtract = function (v) {
	        var n = parseValue(v);
	        if (this.sign !== n.sign) {
	          return this.add(n.negate());
	        }
	        var a = this.value,
	          b = n.value;
	        if (n.isSmall) return subtractSmall(a, Math.abs(b), this.sign);
	        return subtractAny(a, b, this.sign);
	      };
	      BigInteger.prototype.minus = BigInteger.prototype.subtract;
	      SmallInteger.prototype.subtract = function (v) {
	        var n = parseValue(v);
	        var a = this.value;
	        if (a < 0 !== n.sign) {
	          return this.add(n.negate());
	        }
	        var b = n.value;
	        if (n.isSmall) {
	          return new SmallInteger(a - b);
	        }
	        return subtractSmall(b, Math.abs(a), a >= 0);
	      };
	      SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
	      NativeBigInt.prototype.subtract = function (v) {
	        return new NativeBigInt(this.value - parseValue(v).value);
	      };
	      NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
	      BigInteger.prototype.negate = function () {
	        return new BigInteger(this.value, !this.sign);
	      };
	      SmallInteger.prototype.negate = function () {
	        var sign = this.sign;
	        var small = new SmallInteger(-this.value);
	        small.sign = !sign;
	        return small;
	      };
	      NativeBigInt.prototype.negate = function () {
	        return new NativeBigInt(-this.value);
	      };
	      BigInteger.prototype.abs = function () {
	        return new BigInteger(this.value, false);
	      };
	      SmallInteger.prototype.abs = function () {
	        return new SmallInteger(Math.abs(this.value));
	      };
	      NativeBigInt.prototype.abs = function () {
	        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
	      };
	      function multiplyLong(a, b) {
	        var a_l = a.length,
	          b_l = b.length,
	          l = a_l + b_l,
	          r = createArray(l),
	          base = BASE,
	          product,
	          carry,
	          i,
	          a_i,
	          b_j;
	        for (i = 0; i < a_l; ++i) {
	          a_i = a[i];
	          for (var j = 0; j < b_l; ++j) {
	            b_j = b[j];
	            product = a_i * b_j + r[i + j];
	            carry = Math.floor(product / base);
	            r[i + j] = product - carry * base;
	            r[i + j + 1] += carry;
	          }
	        }
	        trim(r);
	        return r;
	      }
	      function multiplySmall(a, b) {
	        // assumes a is array, b is number with |b| < BASE
	        var l = a.length,
	          r = new Array(l),
	          base = BASE,
	          carry = 0,
	          product,
	          i;
	        for (i = 0; i < l; i++) {
	          product = a[i] * b + carry;
	          carry = Math.floor(product / base);
	          r[i] = product - carry * base;
	        }
	        while (carry > 0) {
	          r[i++] = carry % base;
	          carry = Math.floor(carry / base);
	        }
	        return r;
	      }
	      function shiftLeft(x, n) {
	        var r = [];
	        while (n-- > 0) r.push(0);
	        return r.concat(x);
	      }
	      function multiplyKaratsuba(x, y) {
	        var n = Math.max(x.length, y.length);
	        if (n <= 30) return multiplyLong(x, y);
	        n = Math.ceil(n / 2);
	        var b = x.slice(n),
	          a = x.slice(0, n),
	          d = y.slice(n),
	          c = y.slice(0, n);
	        var ac = multiplyKaratsuba(a, c),
	          bd = multiplyKaratsuba(b, d),
	          abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
	        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
	        trim(product);
	        return product;
	      }

	      // The following function is derived from a surface fit of a graph plotting the performance difference
	      // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
	      function useKaratsuba(l1, l2) {
	        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
	      }
	      BigInteger.prototype.multiply = function (v) {
	        var n = parseValue(v),
	          a = this.value,
	          b = n.value,
	          sign = this.sign !== n.sign,
	          abs;
	        if (n.isSmall) {
	          if (b === 0) return Integer[0];
	          if (b === 1) return this;
	          if (b === -1) return this.negate();
	          abs = Math.abs(b);
	          if (abs < BASE) {
	            return new BigInteger(multiplySmall(a, abs), sign);
	          }
	          b = smallToArray(abs);
	        }
	        if (useKaratsuba(a.length, b.length))
	          // Karatsuba is only faster for certain array sizes
	          return new BigInteger(multiplyKaratsuba(a, b), sign);
	        return new BigInteger(multiplyLong(a, b), sign);
	      };
	      BigInteger.prototype.times = BigInteger.prototype.multiply;
	      function multiplySmallAndArray(a, b, sign) {
	        // a >= 0
	        if (a < BASE) {
	          return new BigInteger(multiplySmall(b, a), sign);
	        }
	        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
	      }
	      SmallInteger.prototype._multiplyBySmall = function (a) {
	        if (isPrecise(a.value * this.value)) {
	          return new SmallInteger(a.value * this.value);
	        }
	        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
	      };
	      BigInteger.prototype._multiplyBySmall = function (a) {
	        if (a.value === 0) return Integer[0];
	        if (a.value === 1) return this;
	        if (a.value === -1) return this.negate();
	        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
	      };
	      SmallInteger.prototype.multiply = function (v) {
	        return parseValue(v)._multiplyBySmall(this);
	      };
	      SmallInteger.prototype.times = SmallInteger.prototype.multiply;
	      NativeBigInt.prototype.multiply = function (v) {
	        return new NativeBigInt(this.value * parseValue(v).value);
	      };
	      NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
	      function square(a) {
	        //console.assert(2 * BASE * BASE < MAX_INT);
	        var l = a.length,
	          r = createArray(l + l),
	          base = BASE,
	          product,
	          carry,
	          i,
	          a_i,
	          a_j;
	        for (i = 0; i < l; i++) {
	          a_i = a[i];
	          carry = 0 - a_i * a_i;
	          for (var j = i; j < l; j++) {
	            a_j = a[j];
	            product = 2 * (a_i * a_j) + r[i + j] + carry;
	            carry = Math.floor(product / base);
	            r[i + j] = product - carry * base;
	          }
	          r[i + l] = carry;
	        }
	        trim(r);
	        return r;
	      }
	      BigInteger.prototype.square = function () {
	        return new BigInteger(square(this.value), false);
	      };
	      SmallInteger.prototype.square = function () {
	        var value = this.value * this.value;
	        if (isPrecise(value)) return new SmallInteger(value);
	        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
	      };
	      NativeBigInt.prototype.square = function (v) {
	        return new NativeBigInt(this.value * this.value);
	      };
	      function divMod1(a, b) {
	        // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
	        var a_l = a.length,
	          b_l = b.length,
	          base = BASE,
	          result = createArray(b.length),
	          divisorMostSignificantDigit = b[b_l - 1],
	          // normalization
	          lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
	          remainder = multiplySmall(a, lambda),
	          divisor = multiplySmall(b, lambda),
	          quotientDigit,
	          shift,
	          carry,
	          borrow,
	          i,
	          l,
	          q;
	        if (remainder.length <= a_l) remainder.push(0);
	        divisor.push(0);
	        divisorMostSignificantDigit = divisor[b_l - 1];
	        for (shift = a_l - b_l; shift >= 0; shift--) {
	          quotientDigit = base - 1;
	          if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
	            quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
	          }
	          // quotientDigit <= base - 1
	          carry = 0;
	          borrow = 0;
	          l = divisor.length;
	          for (i = 0; i < l; i++) {
	            carry += quotientDigit * divisor[i];
	            q = Math.floor(carry / base);
	            borrow += remainder[shift + i] - (carry - q * base);
	            carry = q;
	            if (borrow < 0) {
	              remainder[shift + i] = borrow + base;
	              borrow = -1;
	            } else {
	              remainder[shift + i] = borrow;
	              borrow = 0;
	            }
	          }
	          while (borrow !== 0) {
	            quotientDigit -= 1;
	            carry = 0;
	            for (i = 0; i < l; i++) {
	              carry += remainder[shift + i] - base + divisor[i];
	              if (carry < 0) {
	                remainder[shift + i] = carry + base;
	                carry = 0;
	              } else {
	                remainder[shift + i] = carry;
	                carry = 1;
	              }
	            }
	            borrow += carry;
	          }
	          result[shift] = quotientDigit;
	        }
	        // denormalization
	        remainder = divModSmall(remainder, lambda)[0];
	        return [arrayToSmall(result), arrayToSmall(remainder)];
	      }
	      function divMod2(a, b) {
	        // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
	        // Performs faster than divMod1 on larger input sizes.
	        var a_l = a.length,
	          b_l = b.length,
	          result = [],
	          part = [],
	          base = BASE,
	          guess,
	          xlen,
	          highx,
	          highy,
	          check;
	        while (a_l) {
	          part.unshift(a[--a_l]);
	          trim(part);
	          if (compareAbs(part, b) < 0) {
	            result.push(0);
	            continue;
	          }
	          xlen = part.length;
	          highx = part[xlen - 1] * base + part[xlen - 2];
	          highy = b[b_l - 1] * base + b[b_l - 2];
	          if (xlen > b_l) {
	            highx = (highx + 1) * base;
	          }
	          guess = Math.ceil(highx / highy);
	          do {
	            check = multiplySmall(b, guess);
	            if (compareAbs(check, part) <= 0) break;
	            guess--;
	          } while (guess);
	          result.push(guess);
	          part = subtract(part, check);
	        }
	        result.reverse();
	        return [arrayToSmall(result), arrayToSmall(part)];
	      }
	      function divModSmall(value, lambda) {
	        var length = value.length,
	          quotient = createArray(length),
	          base = BASE,
	          i,
	          q,
	          remainder,
	          divisor;
	        remainder = 0;
	        for (i = length - 1; i >= 0; --i) {
	          divisor = remainder * base + value[i];
	          q = truncate(divisor / lambda);
	          remainder = divisor - q * lambda;
	          quotient[i] = q | 0;
	        }
	        return [quotient, remainder | 0];
	      }
	      function divModAny(self, v) {
	        var value,
	          n = parseValue(v);
	        if (supportsNativeBigInt) {
	          return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];
	        }
	        var a = self.value,
	          b = n.value;
	        var quotient;
	        if (b === 0) throw new Error("Cannot divide by zero");
	        if (self.isSmall) {
	          if (n.isSmall) {
	            return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
	          }
	          return [Integer[0], self];
	        }
	        if (n.isSmall) {
	          if (b === 1) return [self, Integer[0]];
	          if (b == -1) return [self.negate(), Integer[0]];
	          var abs = Math.abs(b);
	          if (abs < BASE) {
	            value = divModSmall(a, abs);
	            quotient = arrayToSmall(value[0]);
	            var remainder = value[1];
	            if (self.sign) remainder = -remainder;
	            if (typeof quotient === "number") {
	              if (self.sign !== n.sign) quotient = -quotient;
	              return [new SmallInteger(quotient), new SmallInteger(remainder)];
	            }
	            return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
	          }
	          b = smallToArray(abs);
	        }
	        var comparison = compareAbs(a, b);
	        if (comparison === -1) return [Integer[0], self];
	        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

	        // divMod1 is faster on smaller input sizes
	        if (a.length + b.length <= 200) value = divMod1(a, b);else value = divMod2(a, b);
	        quotient = value[0];
	        var qSign = self.sign !== n.sign,
	          mod = value[1],
	          mSign = self.sign;
	        if (typeof quotient === "number") {
	          if (qSign) quotient = -quotient;
	          quotient = new SmallInteger(quotient);
	        } else quotient = new BigInteger(quotient, qSign);
	        if (typeof mod === "number") {
	          if (mSign) mod = -mod;
	          mod = new SmallInteger(mod);
	        } else mod = new BigInteger(mod, mSign);
	        return [quotient, mod];
	      }
	      BigInteger.prototype.divmod = function (v) {
	        var result = divModAny(this, v);
	        return {
	          quotient: result[0],
	          remainder: result[1]
	        };
	      };
	      NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
	      BigInteger.prototype.divide = function (v) {
	        return divModAny(this, v)[0];
	      };
	      NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {
	        return new NativeBigInt(this.value / parseValue(v).value);
	      };
	      SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
	      BigInteger.prototype.mod = function (v) {
	        return divModAny(this, v)[1];
	      };
	      NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {
	        return new NativeBigInt(this.value % parseValue(v).value);
	      };
	      SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
	      BigInteger.prototype.pow = function (v) {
	        var n = parseValue(v),
	          a = this.value,
	          b = n.value,
	          value,
	          x,
	          y;
	        if (b === 0) return Integer[1];
	        if (a === 0) return Integer[0];
	        if (a === 1) return Integer[1];
	        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
	        if (n.sign) {
	          return Integer[0];
	        }
	        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
	        if (this.isSmall) {
	          if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));
	        }
	        x = this;
	        y = Integer[1];
	        while (true) {
	          if (b & 1 === 1) {
	            y = y.times(x);
	            --b;
	          }
	          if (b === 0) break;
	          b /= 2;
	          x = x.square();
	        }
	        return y;
	      };
	      SmallInteger.prototype.pow = BigInteger.prototype.pow;
	      NativeBigInt.prototype.pow = function (v) {
	        var n = parseValue(v);
	        var a = this.value,
	          b = n.value;
	        var _0 = BigInt(0),
	          _1 = BigInt(1),
	          _2 = BigInt(2);
	        if (b === _0) return Integer[1];
	        if (a === _0) return Integer[0];
	        if (a === _1) return Integer[1];
	        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
	        if (n.isNegative()) return new NativeBigInt(_0);
	        var x = this;
	        var y = Integer[1];
	        while (true) {
	          if ((b & _1) === _1) {
	            y = y.times(x);
	            --b;
	          }
	          if (b === _0) break;
	          b /= _2;
	          x = x.square();
	        }
	        return y;
	      };
	      BigInteger.prototype.modPow = function (exp, mod) {
	        exp = parseValue(exp);
	        mod = parseValue(mod);
	        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
	        var r = Integer[1],
	          base = this.mod(mod);
	        if (exp.isNegative()) {
	          exp = exp.multiply(Integer[-1]);
	          base = base.modInv(mod);
	        }
	        while (exp.isPositive()) {
	          if (base.isZero()) return Integer[0];
	          if (exp.isOdd()) r = r.multiply(base).mod(mod);
	          exp = exp.divide(2);
	          base = base.square().mod(mod);
	        }
	        return r;
	      };
	      NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
	      function compareAbs(a, b) {
	        if (a.length !== b.length) {
	          return a.length > b.length ? 1 : -1;
	        }
	        for (var i = a.length - 1; i >= 0; i--) {
	          if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
	        }
	        return 0;
	      }
	      BigInteger.prototype.compareAbs = function (v) {
	        var n = parseValue(v),
	          a = this.value,
	          b = n.value;
	        if (n.isSmall) return 1;
	        return compareAbs(a, b);
	      };
	      SmallInteger.prototype.compareAbs = function (v) {
	        var n = parseValue(v),
	          a = Math.abs(this.value),
	          b = n.value;
	        if (n.isSmall) {
	          b = Math.abs(b);
	          return a === b ? 0 : a > b ? 1 : -1;
	        }
	        return -1;
	      };
	      NativeBigInt.prototype.compareAbs = function (v) {
	        var a = this.value;
	        var b = parseValue(v).value;
	        a = a >= 0 ? a : -a;
	        b = b >= 0 ? b : -b;
	        return a === b ? 0 : a > b ? 1 : -1;
	      };
	      BigInteger.prototype.compare = function (v) {
	        // See discussion about comparison with Infinity:
	        // https://github.com/peterolson/BigInteger.js/issues/61
	        if (v === Infinity) {
	          return -1;
	        }
	        if (v === -Infinity) {
	          return 1;
	        }
	        var n = parseValue(v),
	          a = this.value,
	          b = n.value;
	        if (this.sign !== n.sign) {
	          return n.sign ? 1 : -1;
	        }
	        if (n.isSmall) {
	          return this.sign ? -1 : 1;
	        }
	        return compareAbs(a, b) * (this.sign ? -1 : 1);
	      };
	      BigInteger.prototype.compareTo = BigInteger.prototype.compare;
	      SmallInteger.prototype.compare = function (v) {
	        if (v === Infinity) {
	          return -1;
	        }
	        if (v === -Infinity) {
	          return 1;
	        }
	        var n = parseValue(v),
	          a = this.value,
	          b = n.value;
	        if (n.isSmall) {
	          return a == b ? 0 : a > b ? 1 : -1;
	        }
	        if (a < 0 !== n.sign) {
	          return a < 0 ? -1 : 1;
	        }
	        return a < 0 ? 1 : -1;
	      };
	      SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
	      NativeBigInt.prototype.compare = function (v) {
	        if (v === Infinity) {
	          return -1;
	        }
	        if (v === -Infinity) {
	          return 1;
	        }
	        var a = this.value;
	        var b = parseValue(v).value;
	        return a === b ? 0 : a > b ? 1 : -1;
	      };
	      NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
	      BigInteger.prototype.equals = function (v) {
	        return this.compare(v) === 0;
	      };
	      NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
	      BigInteger.prototype.notEquals = function (v) {
	        return this.compare(v) !== 0;
	      };
	      NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
	      BigInteger.prototype.greater = function (v) {
	        return this.compare(v) > 0;
	      };
	      NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
	      BigInteger.prototype.lesser = function (v) {
	        return this.compare(v) < 0;
	      };
	      NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
	      BigInteger.prototype.greaterOrEquals = function (v) {
	        return this.compare(v) >= 0;
	      };
	      NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
	      BigInteger.prototype.lesserOrEquals = function (v) {
	        return this.compare(v) <= 0;
	      };
	      NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
	      BigInteger.prototype.isEven = function () {
	        return (this.value[0] & 1) === 0;
	      };
	      SmallInteger.prototype.isEven = function () {
	        return (this.value & 1) === 0;
	      };
	      NativeBigInt.prototype.isEven = function () {
	        return (this.value & BigInt(1)) === BigInt(0);
	      };
	      BigInteger.prototype.isOdd = function () {
	        return (this.value[0] & 1) === 1;
	      };
	      SmallInteger.prototype.isOdd = function () {
	        return (this.value & 1) === 1;
	      };
	      NativeBigInt.prototype.isOdd = function () {
	        return (this.value & BigInt(1)) === BigInt(1);
	      };
	      BigInteger.prototype.isPositive = function () {
	        return !this.sign;
	      };
	      SmallInteger.prototype.isPositive = function () {
	        return this.value > 0;
	      };
	      NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
	      BigInteger.prototype.isNegative = function () {
	        return this.sign;
	      };
	      SmallInteger.prototype.isNegative = function () {
	        return this.value < 0;
	      };
	      NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
	      BigInteger.prototype.isUnit = function () {
	        return false;
	      };
	      SmallInteger.prototype.isUnit = function () {
	        return Math.abs(this.value) === 1;
	      };
	      NativeBigInt.prototype.isUnit = function () {
	        return this.abs().value === BigInt(1);
	      };
	      BigInteger.prototype.isZero = function () {
	        return false;
	      };
	      SmallInteger.prototype.isZero = function () {
	        return this.value === 0;
	      };
	      NativeBigInt.prototype.isZero = function () {
	        return this.value === BigInt(0);
	      };
	      BigInteger.prototype.isDivisibleBy = function (v) {
	        var n = parseValue(v);
	        if (n.isZero()) return false;
	        if (n.isUnit()) return true;
	        if (n.compareAbs(2) === 0) return this.isEven();
	        return this.mod(n).isZero();
	      };
	      NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
	      function isBasicPrime(v) {
	        var n = v.abs();
	        if (n.isUnit()) return false;
	        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
	        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
	        if (n.lesser(49)) return true;
	        // we don't know if it's prime: let the other functions figure it out
	      }
	      function millerRabinTest(n, a) {
	        var nPrev = n.prev(),
	          b = nPrev,
	          r = 0,
	          d,
	          i,
	          x;
	        while (b.isEven()) b = b.divide(2), r++;
	        next: for (i = 0; i < a.length; i++) {
	          if (n.lesser(a[i])) continue;
	          x = bigInt(a[i]).modPow(b, n);
	          if (x.isUnit() || x.equals(nPrev)) continue;
	          for (d = r - 1; d != 0; d--) {
	            x = x.square().mod(n);
	            if (x.isUnit()) return false;
	            if (x.equals(nPrev)) continue next;
	          }
	          return false;
	        }
	        return true;
	      }

	      // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
	      BigInteger.prototype.isPrime = function (strict) {
	        var isPrime = isBasicPrime(this);
	        if (isPrime !== undefined$1) return isPrime;
	        var n = this.abs();
	        var bits = n.bitLength();
	        if (bits <= 64) return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
	        var logN = Math.log(2) * bits.toJSNumber();
	        var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
	        for (var a = [], i = 0; i < t; i++) {
	          a.push(bigInt(i + 2));
	        }
	        return millerRabinTest(n, a);
	      };
	      NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
	      BigInteger.prototype.isProbablePrime = function (iterations, rng) {
	        var isPrime = isBasicPrime(this);
	        if (isPrime !== undefined$1) return isPrime;
	        var n = this.abs();
	        var t = iterations === undefined$1 ? 5 : iterations;
	        for (var a = [], i = 0; i < t; i++) {
	          a.push(bigInt.randBetween(2, n.minus(2), rng));
	        }
	        return millerRabinTest(n, a);
	      };
	      NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
	      BigInteger.prototype.modInv = function (n) {
	        var t = bigInt.zero,
	          newT = bigInt.one,
	          r = parseValue(n),
	          newR = this.abs(),
	          q,
	          lastT,
	          lastR;
	        while (!newR.isZero()) {
	          q = r.divide(newR);
	          lastT = t;
	          lastR = r;
	          t = newT;
	          r = newR;
	          newT = lastT.subtract(q.multiply(newT));
	          newR = lastR.subtract(q.multiply(newR));
	        }
	        if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
	        if (t.compare(0) === -1) {
	          t = t.add(n);
	        }
	        if (this.isNegative()) {
	          return t.negate();
	        }
	        return t;
	      };
	      NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
	      BigInteger.prototype.next = function () {
	        var value = this.value;
	        if (this.sign) {
	          return subtractSmall(value, 1, this.sign);
	        }
	        return new BigInteger(addSmall(value, 1), this.sign);
	      };
	      SmallInteger.prototype.next = function () {
	        var value = this.value;
	        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
	        return new BigInteger(MAX_INT_ARR, false);
	      };
	      NativeBigInt.prototype.next = function () {
	        return new NativeBigInt(this.value + BigInt(1));
	      };
	      BigInteger.prototype.prev = function () {
	        var value = this.value;
	        if (this.sign) {
	          return new BigInteger(addSmall(value, 1), true);
	        }
	        return subtractSmall(value, 1, this.sign);
	      };
	      SmallInteger.prototype.prev = function () {
	        var value = this.value;
	        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
	        return new BigInteger(MAX_INT_ARR, true);
	      };
	      NativeBigInt.prototype.prev = function () {
	        return new NativeBigInt(this.value - BigInt(1));
	      };
	      var powersOfTwo = [1];
	      while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
	      var powers2Length = powersOfTwo.length,
	        highestPower2 = powersOfTwo[powers2Length - 1];
	      function shift_isSmall(n) {
	        return Math.abs(n) <= BASE;
	      }
	      BigInteger.prototype.shiftLeft = function (v) {
	        var n = parseValue(v).toJSNumber();
	        if (!shift_isSmall(n)) {
	          throw new Error(String(n) + " is too large for shifting.");
	        }
	        if (n < 0) return this.shiftRight(-n);
	        var result = this;
	        if (result.isZero()) return result;
	        while (n >= powers2Length) {
	          result = result.multiply(highestPower2);
	          n -= powers2Length - 1;
	        }
	        return result.multiply(powersOfTwo[n]);
	      };
	      NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
	      BigInteger.prototype.shiftRight = function (v) {
	        var remQuo;
	        var n = parseValue(v).toJSNumber();
	        if (!shift_isSmall(n)) {
	          throw new Error(String(n) + " is too large for shifting.");
	        }
	        if (n < 0) return this.shiftLeft(-n);
	        var result = this;
	        while (n >= powers2Length) {
	          if (result.isZero() || result.isNegative() && result.isUnit()) return result;
	          remQuo = divModAny(result, highestPower2);
	          result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
	          n -= powers2Length - 1;
	        }
	        remQuo = divModAny(result, powersOfTwo[n]);
	        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
	      };
	      NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
	      function bitwise(x, y, fn) {
	        y = parseValue(y);
	        var xSign = x.isNegative(),
	          ySign = y.isNegative();
	        var xRem = xSign ? x.not() : x,
	          yRem = ySign ? y.not() : y;
	        var xDigit = 0,
	          yDigit = 0;
	        var xDivMod = null,
	          yDivMod = null;
	        var result = [];
	        while (!xRem.isZero() || !yRem.isZero()) {
	          xDivMod = divModAny(xRem, highestPower2);
	          xDigit = xDivMod[1].toJSNumber();
	          if (xSign) {
	            xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
	          }
	          yDivMod = divModAny(yRem, highestPower2);
	          yDigit = yDivMod[1].toJSNumber();
	          if (ySign) {
	            yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
	          }
	          xRem = xDivMod[0];
	          yRem = yDivMod[0];
	          result.push(fn(xDigit, yDigit));
	        }
	        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
	        for (var i = result.length - 1; i >= 0; i -= 1) {
	          sum = sum.multiply(highestPower2).add(bigInt(result[i]));
	        }
	        return sum;
	      }
	      BigInteger.prototype.not = function () {
	        return this.negate().prev();
	      };
	      NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
	      BigInteger.prototype.and = function (n) {
	        return bitwise(this, n, function (a, b) {
	          return a & b;
	        });
	      };
	      NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
	      BigInteger.prototype.or = function (n) {
	        return bitwise(this, n, function (a, b) {
	          return a | b;
	        });
	      };
	      NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
	      BigInteger.prototype.xor = function (n) {
	        return bitwise(this, n, function (a, b) {
	          return a ^ b;
	        });
	      };
	      NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
	      var LOBMASK_I = 1 << 30,
	        LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
	      function roughLOB(n) {
	        // get lowestOneBit (rough)
	        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
	        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
	        var v = n.value,
	          x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
	        return x & -x;
	      }
	      function integerLogarithm(value, base) {
	        if (base.compareTo(value) <= 0) {
	          var tmp = integerLogarithm(value, base.square(base));
	          var p = tmp.p;
	          var e = tmp.e;
	          var t = p.multiply(base);
	          return t.compareTo(value) <= 0 ? {
	            p: t,
	            e: e * 2 + 1
	          } : {
	            p: p,
	            e: e * 2
	          };
	        }
	        return {
	          p: bigInt(1),
	          e: 0
	        };
	      }
	      BigInteger.prototype.bitLength = function () {
	        var n = this;
	        if (n.compareTo(bigInt(0)) < 0) {
	          n = n.negate().subtract(bigInt(1));
	        }
	        if (n.compareTo(bigInt(0)) === 0) {
	          return bigInt(0);
	        }
	        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
	      };
	      NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
	      function max(a, b) {
	        a = parseValue(a);
	        b = parseValue(b);
	        return a.greater(b) ? a : b;
	      }
	      function min(a, b) {
	        a = parseValue(a);
	        b = parseValue(b);
	        return a.lesser(b) ? a : b;
	      }
	      function gcd(a, b) {
	        a = parseValue(a).abs();
	        b = parseValue(b).abs();
	        if (a.equals(b)) return a;
	        if (a.isZero()) return b;
	        if (b.isZero()) return a;
	        var c = Integer[1],
	          d,
	          t;
	        while (a.isEven() && b.isEven()) {
	          d = min(roughLOB(a), roughLOB(b));
	          a = a.divide(d);
	          b = b.divide(d);
	          c = c.multiply(d);
	        }
	        while (a.isEven()) {
	          a = a.divide(roughLOB(a));
	        }
	        do {
	          while (b.isEven()) {
	            b = b.divide(roughLOB(b));
	          }
	          if (a.greater(b)) {
	            t = b;
	            b = a;
	            a = t;
	          }
	          b = b.subtract(a);
	        } while (!b.isZero());
	        return c.isUnit() ? a : a.multiply(c);
	      }
	      function lcm(a, b) {
	        a = parseValue(a).abs();
	        b = parseValue(b).abs();
	        return a.divide(gcd(a, b)).multiply(b);
	      }
	      function randBetween(a, b, rng) {
	        a = parseValue(a);
	        b = parseValue(b);
	        var usedRNG = rng || Math.random;
	        var low = min(a, b),
	          high = max(a, b);
	        var range = high.subtract(low).add(1);
	        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
	        var digits = toBase(range, BASE).value;
	        var result = [],
	          restricted = true;
	        for (var i = 0; i < digits.length; i++) {
	          var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;
	          var digit = truncate(usedRNG() * top);
	          result.push(digit);
	          if (digit < digits[i]) restricted = false;
	        }
	        return low.add(Integer.fromArray(result, BASE, false));
	      }
	      var parseBase = function (text, base, alphabet, caseSensitive) {
	        alphabet = alphabet || DEFAULT_ALPHABET;
	        text = String(text);
	        if (!caseSensitive) {
	          text = text.toLowerCase();
	          alphabet = alphabet.toLowerCase();
	        }
	        var length = text.length;
	        var i;
	        var absBase = Math.abs(base);
	        var alphabetValues = {};
	        for (i = 0; i < alphabet.length; i++) {
	          alphabetValues[alphabet[i]] = i;
	        }
	        for (i = 0; i < length; i++) {
	          var c = text[i];
	          if (c === "-") continue;
	          if (c in alphabetValues) {
	            if (alphabetValues[c] >= absBase) {
	              if (c === "1" && absBase === 1) continue;
	              throw new Error(c + " is not a valid digit in base " + base + ".");
	            }
	          }
	        }
	        base = parseValue(base);
	        var digits = [];
	        var isNegative = text[0] === "-";
	        for (i = isNegative ? 1 : 0; i < text.length; i++) {
	          var c = text[i];
	          if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));else if (c === "<") {
	            var start = i;
	            do {
	              i++;
	            } while (text[i] !== ">" && i < text.length);
	            digits.push(parseValue(text.slice(start + 1, i)));
	          } else throw new Error(c + " is not a valid character");
	        }
	        return parseBaseFromArray(digits, base, isNegative);
	      };
	      function parseBaseFromArray(digits, base, isNegative) {
	        var val = Integer[0],
	          pow = Integer[1],
	          i;
	        for (i = digits.length - 1; i >= 0; i--) {
	          val = val.add(digits[i].times(pow));
	          pow = pow.times(base);
	        }
	        return isNegative ? val.negate() : val;
	      }
	      function stringify(digit, alphabet) {
	        alphabet = alphabet || DEFAULT_ALPHABET;
	        if (digit < alphabet.length) {
	          return alphabet[digit];
	        }
	        return "<" + digit + ">";
	      }
	      function toBase(n, base) {
	        base = bigInt(base);
	        if (base.isZero()) {
	          if (n.isZero()) return {
	            value: [0],
	            isNegative: false
	          };
	          throw new Error("Cannot convert nonzero numbers to base 0.");
	        }
	        if (base.equals(-1)) {
	          if (n.isZero()) return {
	            value: [0],
	            isNegative: false
	          };
	          if (n.isNegative()) return {
	            value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])),
	            isNegative: false
	          };
	          var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
	          arr.unshift([1]);
	          return {
	            value: [].concat.apply([], arr),
	            isNegative: false
	          };
	        }
	        var neg = false;
	        if (n.isNegative() && base.isPositive()) {
	          neg = true;
	          n = n.abs();
	        }
	        if (base.isUnit()) {
	          if (n.isZero()) return {
	            value: [0],
	            isNegative: false
	          };
	          return {
	            value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
	            isNegative: neg
	          };
	        }
	        var out = [];
	        var left = n,
	          divmod;
	        while (left.isNegative() || left.compareAbs(base) >= 0) {
	          divmod = left.divmod(base);
	          left = divmod.quotient;
	          var digit = divmod.remainder;
	          if (digit.isNegative()) {
	            digit = base.minus(digit).abs();
	            left = left.next();
	          }
	          out.push(digit.toJSNumber());
	        }
	        out.push(left.toJSNumber());
	        return {
	          value: out.reverse(),
	          isNegative: neg
	        };
	      }
	      function toBaseString(n, base, alphabet) {
	        var arr = toBase(n, base);
	        return (arr.isNegative ? "-" : "") + arr.value.map(function (x) {
	          return stringify(x, alphabet);
	        }).join('');
	      }
	      BigInteger.prototype.toArray = function (radix) {
	        return toBase(this, radix);
	      };
	      SmallInteger.prototype.toArray = function (radix) {
	        return toBase(this, radix);
	      };
	      NativeBigInt.prototype.toArray = function (radix) {
	        return toBase(this, radix);
	      };
	      BigInteger.prototype.toString = function (radix, alphabet) {
	        if (radix === undefined$1) radix = 10;
	        if (radix !== 10) return toBaseString(this, radix, alphabet);
	        var v = this.value,
	          l = v.length,
	          str = String(v[--l]),
	          zeros = "0000000",
	          digit;
	        while (--l >= 0) {
	          digit = String(v[l]);
	          str += zeros.slice(digit.length) + digit;
	        }
	        var sign = this.sign ? "-" : "";
	        return sign + str;
	      };
	      SmallInteger.prototype.toString = function (radix, alphabet) {
	        if (radix === undefined$1) radix = 10;
	        if (radix != 10) return toBaseString(this, radix, alphabet);
	        return String(this.value);
	      };
	      NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
	      NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () {
	        return this.toString();
	      };
	      BigInteger.prototype.valueOf = function () {
	        return parseInt(this.toString(), 10);
	      };
	      BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
	      SmallInteger.prototype.valueOf = function () {
	        return this.value;
	      };
	      SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
	      NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {
	        return parseInt(this.toString(), 10);
	      };
	      function parseStringValue(v) {
	        if (isPrecise(+v)) {
	          var x = +v;
	          if (x === truncate(x)) return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
	          throw new Error("Invalid integer: " + v);
	        }
	        var sign = v[0] === "-";
	        if (sign) v = v.slice(1);
	        var split = v.split(/e/i);
	        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
	        if (split.length === 2) {
	          var exp = split[1];
	          if (exp[0] === "+") exp = exp.slice(1);
	          exp = +exp;
	          if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
	          var text = split[0];
	          var decimalPlace = text.indexOf(".");
	          if (decimalPlace >= 0) {
	            exp -= text.length - decimalPlace - 1;
	            text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
	          }
	          if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
	          text += new Array(exp + 1).join("0");
	          v = text;
	        }
	        var isValid = /^([0-9][0-9]*)$/.test(v);
	        if (!isValid) throw new Error("Invalid integer: " + v);
	        if (supportsNativeBigInt) {
	          return new NativeBigInt(BigInt(sign ? "-" + v : v));
	        }
	        var r = [],
	          max = v.length,
	          l = LOG_BASE,
	          min = max - l;
	        while (max > 0) {
	          r.push(+v.slice(min, max));
	          min -= l;
	          if (min < 0) min = 0;
	          max -= l;
	        }
	        trim(r);
	        return new BigInteger(r, sign);
	      }
	      function parseNumberValue(v) {
	        if (supportsNativeBigInt) {
	          return new NativeBigInt(BigInt(v));
	        }
	        if (isPrecise(v)) {
	          if (v !== truncate(v)) throw new Error(v + " is not an integer.");
	          return new SmallInteger(v);
	        }
	        return parseStringValue(v.toString());
	      }
	      function parseValue(v) {
	        if (typeof v === "number") {
	          return parseNumberValue(v);
	        }
	        if (typeof v === "string") {
	          return parseStringValue(v);
	        }
	        if (typeof v === "bigint") {
	          return new NativeBigInt(v);
	        }
	        return v;
	      }
	      // Pre-define numbers in range [-999,999]
	      for (var i = 0; i < 1000; i++) {
	        Integer[i] = parseValue(i);
	        if (i > 0) Integer[-i] = parseValue(-i);
	      }
	      // Backwards compatibility
	      Integer.one = Integer[1];
	      Integer.zero = Integer[0];
	      Integer.minusOne = Integer[-1];
	      Integer.max = max;
	      Integer.min = min;
	      Integer.gcd = gcd;
	      Integer.lcm = lcm;
	      Integer.isInstance = function (x) {
	        return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
	      };
	      Integer.randBetween = randBetween;
	      Integer.fromArray = function (digits, base, isNegative) {
	        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
	      };
	      return Integer;
	    }();

	    // Node.js check
	    if (module.hasOwnProperty("exports")) {
	      module.exports = bigInt;
	    }
	  })(BigInteger);
	  return BigInteger.exports;
	}

	var lib;
	var hasRequiredLib$1;
	function requireLib$1() {
	  if (hasRequiredLib$1) return lib;
	  hasRequiredLib$1 = 1;
	  const bigInt = requireBigInteger();
	  const knownBases = {
	    base64url: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_',
	    base64: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/',
	    base62: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
	    base58: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
	    // Bitcoin base58
	    base36: '0123456789abcdefghijklmnopqrstuvwxyz',
	    base32: '0123456789abcdefghjkmnpqrstvwxyz',
	    // Crockford's base32
	    base16: '0123456789abcdef',
	    base10: '0123456789',
	    base2: '01'
	  };
	  const caseSensitiveBases = {
	    base64url: true,
	    base64: true,
	    base62: true,
	    base58: true,
	    base36: false,
	    base32: false,
	    base16: false,
	    base10: true,
	    base2: true
	  };
	  class UuidEncoder {
	    /**
	     * @public
	     * @param [baseEncodingStr] A string containing all usable letters for encoding
	     * @constructor
	     */
	    constructor(baseEncodingStr = 'base36') {
	      this.setBaseEncodingStr(baseEncodingStr);
	    }

	    /**
	     * Set encoding base
	     * @param {string} baseEncodingStr A string containing all usable letters for encoding
	     * @public
	     */
	    setBaseEncodingStr(baseEncodingStr) {
	      this.encStr = UuidEncoder.resolveEncodingStr(baseEncodingStr);
	      this.isCaseSensitive = UuidEncoder.isCaseSensitiveBase(baseEncodingStr);
	      this.base = this.encStr.length;
	    }

	    /**
	     * @private
	     * @param {string} baseEncodingStr
	     * @returns {string}
	     */
	    static resolveEncodingStr(baseEncodingStr) {
	      return Object.prototype.hasOwnProperty.call(knownBases, baseEncodingStr) ? knownBases[baseEncodingStr] : baseEncodingStr;
	    }

	    /**
	     * @public
	     * @param baseEncodingStr
	     * @returns {boolean}
	     */
	    static isCaseSensitiveBase(baseEncodingStr) {
	      return Object.prototype.hasOwnProperty.call(caseSensitiveBases, baseEncodingStr) ? caseSensitiveBases[baseEncodingStr] : true;
	    }

	    /**
	     * Encode a UUID
	     * @param {string} uuid Properly formatted UUID
	     * @returns {string} Encoded UUID
	     * @public
	     */
	    encode(uuid) {
	      const cleanUuid = uuid.replace(/-/g, '');
	      const {
	        base,
	        encStr
	      } = this;
	      let iUuid = bigInt(cleanUuid, 16);
	      let str = '';
	      do {
	        str = encStr.substr(iUuid.mod(base).valueOf(), 1) + str;
	        iUuid = iUuid.divide(base);
	      } while (iUuid.greater(0));
	      return str;
	    }

	    /**
	     * Decode an encoded UUID
	     * @public
	     * @param {string} str Previously encoded string
	     * @returns {string} Properly formatted UUID
	     * @throws Throws an {Error} when encountering invalid data
	     */
	    decode(str) {
	      let iUuid = bigInt(0);
	      const {
	        base,
	        encStr
	      } = this;
	      const len = str.length;
	      const finalStr = this.isCaseSensitive ? str : str.toLowerCase();
	      for (let pos = 0; pos < len; pos += 1) {
	        const ch = finalStr.substr(pos, 1);
	        const encPos = encStr.indexOf(ch);
	        if (encPos < 0) {
	          throw new Error('Invalid encoded data');
	        }
	        iUuid = iUuid.add(encPos);
	        if (pos < len - 1) {
	          iUuid = iUuid.multiply(base);
	        }
	      }
	      const uuid = iUuid.toString(16).padStart(32, '0');
	      return `${uuid.substr(0, 8)}-${uuid.substr(8, 4)}-${uuid.substr(12, 4)}-${uuid.substr(16, 4)}-${uuid.substr(20)}`;
	    }
	  }
	  lib = UuidEncoder;
	  return lib;
	}

	var colorName;
	var hasRequiredColorName;
	function requireColorName() {
	  if (hasRequiredColorName) return colorName;
	  hasRequiredColorName = 1;
	  colorName = {
	    "aliceblue": [240, 248, 255],
	    "antiquewhite": [250, 235, 215],
	    "aqua": [0, 255, 255],
	    "aquamarine": [127, 255, 212],
	    "azure": [240, 255, 255],
	    "beige": [245, 245, 220],
	    "bisque": [255, 228, 196],
	    "black": [0, 0, 0],
	    "blanchedalmond": [255, 235, 205],
	    "blue": [0, 0, 255],
	    "blueviolet": [138, 43, 226],
	    "brown": [165, 42, 42],
	    "burlywood": [222, 184, 135],
	    "cadetblue": [95, 158, 160],
	    "chartreuse": [127, 255, 0],
	    "chocolate": [210, 105, 30],
	    "coral": [255, 127, 80],
	    "cornflowerblue": [100, 149, 237],
	    "cornsilk": [255, 248, 220],
	    "crimson": [220, 20, 60],
	    "cyan": [0, 255, 255],
	    "darkblue": [0, 0, 139],
	    "darkcyan": [0, 139, 139],
	    "darkgoldenrod": [184, 134, 11],
	    "darkgray": [169, 169, 169],
	    "darkgreen": [0, 100, 0],
	    "darkgrey": [169, 169, 169],
	    "darkkhaki": [189, 183, 107],
	    "darkmagenta": [139, 0, 139],
	    "darkolivegreen": [85, 107, 47],
	    "darkorange": [255, 140, 0],
	    "darkorchid": [153, 50, 204],
	    "darkred": [139, 0, 0],
	    "darksalmon": [233, 150, 122],
	    "darkseagreen": [143, 188, 143],
	    "darkslateblue": [72, 61, 139],
	    "darkslategray": [47, 79, 79],
	    "darkslategrey": [47, 79, 79],
	    "darkturquoise": [0, 206, 209],
	    "darkviolet": [148, 0, 211],
	    "deeppink": [255, 20, 147],
	    "deepskyblue": [0, 191, 255],
	    "dimgray": [105, 105, 105],
	    "dimgrey": [105, 105, 105],
	    "dodgerblue": [30, 144, 255],
	    "firebrick": [178, 34, 34],
	    "floralwhite": [255, 250, 240],
	    "forestgreen": [34, 139, 34],
	    "fuchsia": [255, 0, 255],
	    "gainsboro": [220, 220, 220],
	    "ghostwhite": [248, 248, 255],
	    "gold": [255, 215, 0],
	    "goldenrod": [218, 165, 32],
	    "gray": [128, 128, 128],
	    "green": [0, 128, 0],
	    "greenyellow": [173, 255, 47],
	    "grey": [128, 128, 128],
	    "honeydew": [240, 255, 240],
	    "hotpink": [255, 105, 180],
	    "indianred": [205, 92, 92],
	    "indigo": [75, 0, 130],
	    "ivory": [255, 255, 240],
	    "khaki": [240, 230, 140],
	    "lavender": [230, 230, 250],
	    "lavenderblush": [255, 240, 245],
	    "lawngreen": [124, 252, 0],
	    "lemonchiffon": [255, 250, 205],
	    "lightblue": [173, 216, 230],
	    "lightcoral": [240, 128, 128],
	    "lightcyan": [224, 255, 255],
	    "lightgoldenrodyellow": [250, 250, 210],
	    "lightgray": [211, 211, 211],
	    "lightgreen": [144, 238, 144],
	    "lightgrey": [211, 211, 211],
	    "lightpink": [255, 182, 193],
	    "lightsalmon": [255, 160, 122],
	    "lightseagreen": [32, 178, 170],
	    "lightskyblue": [135, 206, 250],
	    "lightslategray": [119, 136, 153],
	    "lightslategrey": [119, 136, 153],
	    "lightsteelblue": [176, 196, 222],
	    "lightyellow": [255, 255, 224],
	    "lime": [0, 255, 0],
	    "limegreen": [50, 205, 50],
	    "linen": [250, 240, 230],
	    "magenta": [255, 0, 255],
	    "maroon": [128, 0, 0],
	    "mediumaquamarine": [102, 205, 170],
	    "mediumblue": [0, 0, 205],
	    "mediumorchid": [186, 85, 211],
	    "mediumpurple": [147, 112, 219],
	    "mediumseagreen": [60, 179, 113],
	    "mediumslateblue": [123, 104, 238],
	    "mediumspringgreen": [0, 250, 154],
	    "mediumturquoise": [72, 209, 204],
	    "mediumvioletred": [199, 21, 133],
	    "midnightblue": [25, 25, 112],
	    "mintcream": [245, 255, 250],
	    "mistyrose": [255, 228, 225],
	    "moccasin": [255, 228, 181],
	    "navajowhite": [255, 222, 173],
	    "navy": [0, 0, 128],
	    "oldlace": [253, 245, 230],
	    "olive": [128, 128, 0],
	    "olivedrab": [107, 142, 35],
	    "orange": [255, 165, 0],
	    "orangered": [255, 69, 0],
	    "orchid": [218, 112, 214],
	    "palegoldenrod": [238, 232, 170],
	    "palegreen": [152, 251, 152],
	    "paleturquoise": [175, 238, 238],
	    "palevioletred": [219, 112, 147],
	    "papayawhip": [255, 239, 213],
	    "peachpuff": [255, 218, 185],
	    "peru": [205, 133, 63],
	    "pink": [255, 192, 203],
	    "plum": [221, 160, 221],
	    "powderblue": [176, 224, 230],
	    "purple": [128, 0, 128],
	    "rebeccapurple": [102, 51, 153],
	    "red": [255, 0, 0],
	    "rosybrown": [188, 143, 143],
	    "royalblue": [65, 105, 225],
	    "saddlebrown": [139, 69, 19],
	    "salmon": [250, 128, 114],
	    "sandybrown": [244, 164, 96],
	    "seagreen": [46, 139, 87],
	    "seashell": [255, 245, 238],
	    "sienna": [160, 82, 45],
	    "silver": [192, 192, 192],
	    "skyblue": [135, 206, 235],
	    "slateblue": [106, 90, 205],
	    "slategray": [112, 128, 144],
	    "slategrey": [112, 128, 144],
	    "snow": [255, 250, 250],
	    "springgreen": [0, 255, 127],
	    "steelblue": [70, 130, 180],
	    "tan": [210, 180, 140],
	    "teal": [0, 128, 128],
	    "thistle": [216, 191, 216],
	    "tomato": [255, 99, 71],
	    "turquoise": [64, 224, 208],
	    "violet": [238, 130, 238],
	    "wheat": [245, 222, 179],
	    "white": [255, 255, 255],
	    "whitesmoke": [245, 245, 245],
	    "yellow": [255, 255, 0],
	    "yellowgreen": [154, 205, 50]
	  };
	  return colorName;
	}

	/* MIT license */
	var conversions;
	var hasRequiredConversions;
	function requireConversions() {
	  if (hasRequiredConversions) return conversions;
	  hasRequiredConversions = 1;
	  /* eslint-disable no-mixed-operators */
	  const cssKeywords = requireColorName();

	  // NOTE: conversions should only return primitive values (i.e. arrays, or
	  //       values that give correct `typeof` results).
	  //       do not use box values types (i.e. Number(), String(), etc.)

	  const reverseKeywords = {};
	  for (const key of Object.keys(cssKeywords)) {
	    reverseKeywords[cssKeywords[key]] = key;
	  }
	  const convert = {
	    rgb: {
	      channels: 3,
	      labels: 'rgb'
	    },
	    hsl: {
	      channels: 3,
	      labels: 'hsl'
	    },
	    hsv: {
	      channels: 3,
	      labels: 'hsv'
	    },
	    hwb: {
	      channels: 3,
	      labels: 'hwb'
	    },
	    cmyk: {
	      channels: 4,
	      labels: 'cmyk'
	    },
	    xyz: {
	      channels: 3,
	      labels: 'xyz'
	    },
	    lab: {
	      channels: 3,
	      labels: 'lab'
	    },
	    lch: {
	      channels: 3,
	      labels: 'lch'
	    },
	    hex: {
	      channels: 1,
	      labels: ['hex']
	    },
	    keyword: {
	      channels: 1,
	      labels: ['keyword']
	    },
	    ansi16: {
	      channels: 1,
	      labels: ['ansi16']
	    },
	    ansi256: {
	      channels: 1,
	      labels: ['ansi256']
	    },
	    hcg: {
	      channels: 3,
	      labels: ['h', 'c', 'g']
	    },
	    apple: {
	      channels: 3,
	      labels: ['r16', 'g16', 'b16']
	    },
	    gray: {
	      channels: 1,
	      labels: ['gray']
	    }
	  };
	  conversions = convert;

	  // Hide .channels and .labels properties
	  for (const model of Object.keys(convert)) {
	    if (!('channels' in convert[model])) {
	      throw new Error('missing channels property: ' + model);
	    }
	    if (!('labels' in convert[model])) {
	      throw new Error('missing channel labels property: ' + model);
	    }
	    if (convert[model].labels.length !== convert[model].channels) {
	      throw new Error('channel and label counts mismatch: ' + model);
	    }
	    const {
	      channels,
	      labels
	    } = convert[model];
	    delete convert[model].channels;
	    delete convert[model].labels;
	    Object.defineProperty(convert[model], 'channels', {
	      value: channels
	    });
	    Object.defineProperty(convert[model], 'labels', {
	      value: labels
	    });
	  }
	  convert.rgb.hsl = function (rgb) {
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const min = Math.min(r, g, b);
	    const max = Math.max(r, g, b);
	    const delta = max - min;
	    let h;
	    let s;
	    if (max === min) {
	      h = 0;
	    } else if (r === max) {
	      h = (g - b) / delta;
	    } else if (g === max) {
	      h = 2 + (b - r) / delta;
	    } else if (b === max) {
	      h = 4 + (r - g) / delta;
	    }
	    h = Math.min(h * 60, 360);
	    if (h < 0) {
	      h += 360;
	    }
	    const l = (min + max) / 2;
	    if (max === min) {
	      s = 0;
	    } else if (l <= 0.5) {
	      s = delta / (max + min);
	    } else {
	      s = delta / (2 - max - min);
	    }
	    return [h, s * 100, l * 100];
	  };
	  convert.rgb.hsv = function (rgb) {
	    let rdif;
	    let gdif;
	    let bdif;
	    let h;
	    let s;
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const v = Math.max(r, g, b);
	    const diff = v - Math.min(r, g, b);
	    const diffc = function (c) {
	      return (v - c) / 6 / diff + 1 / 2;
	    };
	    if (diff === 0) {
	      h = 0;
	      s = 0;
	    } else {
	      s = diff / v;
	      rdif = diffc(r);
	      gdif = diffc(g);
	      bdif = diffc(b);
	      if (r === v) {
	        h = bdif - gdif;
	      } else if (g === v) {
	        h = 1 / 3 + rdif - bdif;
	      } else if (b === v) {
	        h = 2 / 3 + gdif - rdif;
	      }
	      if (h < 0) {
	        h += 1;
	      } else if (h > 1) {
	        h -= 1;
	      }
	    }
	    return [h * 360, s * 100, v * 100];
	  };
	  convert.rgb.hwb = function (rgb) {
	    const r = rgb[0];
	    const g = rgb[1];
	    let b = rgb[2];
	    const h = convert.rgb.hsl(rgb)[0];
	    const w = 1 / 255 * Math.min(r, Math.min(g, b));
	    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
	    return [h, w * 100, b * 100];
	  };
	  convert.rgb.cmyk = function (rgb) {
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const k = Math.min(1 - r, 1 - g, 1 - b);
	    const c = (1 - r - k) / (1 - k) || 0;
	    const m = (1 - g - k) / (1 - k) || 0;
	    const y = (1 - b - k) / (1 - k) || 0;
	    return [c * 100, m * 100, y * 100, k * 100];
	  };
	  function comparativeDistance(x, y) {
	    /*
	    	See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	    */
	    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
	  }
	  convert.rgb.keyword = function (rgb) {
	    const reversed = reverseKeywords[rgb];
	    if (reversed) {
	      return reversed;
	    }
	    let currentClosestDistance = Infinity;
	    let currentClosestKeyword;
	    for (const keyword of Object.keys(cssKeywords)) {
	      const value = cssKeywords[keyword];

	      // Compute comparative distance
	      const distance = comparativeDistance(rgb, value);

	      // Check if its less, if so set as closest
	      if (distance < currentClosestDistance) {
	        currentClosestDistance = distance;
	        currentClosestKeyword = keyword;
	      }
	    }
	    return currentClosestKeyword;
	  };
	  convert.keyword.rgb = function (keyword) {
	    return cssKeywords[keyword];
	  };
	  convert.rgb.xyz = function (rgb) {
	    let r = rgb[0] / 255;
	    let g = rgb[1] / 255;
	    let b = rgb[2] / 255;

	    // Assume sRGB
	    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
	    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
	    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
	    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
	    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
	    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
	    return [x * 100, y * 100, z * 100];
	  };
	  convert.rgb.lab = function (rgb) {
	    const xyz = convert.rgb.xyz(rgb);
	    let x = xyz[0];
	    let y = xyz[1];
	    let z = xyz[2];
	    x /= 95.047;
	    y /= 100;
	    z /= 108.883;
	    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
	    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
	    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
	    const l = 116 * y - 16;
	    const a = 500 * (x - y);
	    const b = 200 * (y - z);
	    return [l, a, b];
	  };
	  convert.hsl.rgb = function (hsl) {
	    const h = hsl[0] / 360;
	    const s = hsl[1] / 100;
	    const l = hsl[2] / 100;
	    let t2;
	    let t3;
	    let val;
	    if (s === 0) {
	      val = l * 255;
	      return [val, val, val];
	    }
	    if (l < 0.5) {
	      t2 = l * (1 + s);
	    } else {
	      t2 = l + s - l * s;
	    }
	    const t1 = 2 * l - t2;
	    const rgb = [0, 0, 0];
	    for (let i = 0; i < 3; i++) {
	      t3 = h + 1 / 3 * -(i - 1);
	      if (t3 < 0) {
	        t3++;
	      }
	      if (t3 > 1) {
	        t3--;
	      }
	      if (6 * t3 < 1) {
	        val = t1 + (t2 - t1) * 6 * t3;
	      } else if (2 * t3 < 1) {
	        val = t2;
	      } else if (3 * t3 < 2) {
	        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
	      } else {
	        val = t1;
	      }
	      rgb[i] = val * 255;
	    }
	    return rgb;
	  };
	  convert.hsl.hsv = function (hsl) {
	    const h = hsl[0];
	    let s = hsl[1] / 100;
	    let l = hsl[2] / 100;
	    let smin = s;
	    const lmin = Math.max(l, 0.01);
	    l *= 2;
	    s *= l <= 1 ? l : 2 - l;
	    smin *= lmin <= 1 ? lmin : 2 - lmin;
	    const v = (l + s) / 2;
	    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
	    return [h, sv * 100, v * 100];
	  };
	  convert.hsv.rgb = function (hsv) {
	    const h = hsv[0] / 60;
	    const s = hsv[1] / 100;
	    let v = hsv[2] / 100;
	    const hi = Math.floor(h) % 6;
	    const f = h - Math.floor(h);
	    const p = 255 * v * (1 - s);
	    const q = 255 * v * (1 - s * f);
	    const t = 255 * v * (1 - s * (1 - f));
	    v *= 255;
	    switch (hi) {
	      case 0:
	        return [v, t, p];
	      case 1:
	        return [q, v, p];
	      case 2:
	        return [p, v, t];
	      case 3:
	        return [p, q, v];
	      case 4:
	        return [t, p, v];
	      case 5:
	        return [v, p, q];
	    }
	  };
	  convert.hsv.hsl = function (hsv) {
	    const h = hsv[0];
	    const s = hsv[1] / 100;
	    const v = hsv[2] / 100;
	    const vmin = Math.max(v, 0.01);
	    let sl;
	    let l;
	    l = (2 - s) * v;
	    const lmin = (2 - s) * vmin;
	    sl = s * vmin;
	    sl /= lmin <= 1 ? lmin : 2 - lmin;
	    sl = sl || 0;
	    l /= 2;
	    return [h, sl * 100, l * 100];
	  };

	  // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
	  convert.hwb.rgb = function (hwb) {
	    const h = hwb[0] / 360;
	    let wh = hwb[1] / 100;
	    let bl = hwb[2] / 100;
	    const ratio = wh + bl;
	    let f;

	    // Wh + bl cant be > 1
	    if (ratio > 1) {
	      wh /= ratio;
	      bl /= ratio;
	    }
	    const i = Math.floor(6 * h);
	    const v = 1 - bl;
	    f = 6 * h - i;
	    if ((i & 0x01) !== 0) {
	      f = 1 - f;
	    }
	    const n = wh + f * (v - wh); // Linear interpolation

	    let r;
	    let g;
	    let b;
	    /* eslint-disable max-statements-per-line,no-multi-spaces */
	    switch (i) {
	      default:
	      case 6:
	      case 0:
	        r = v;
	        g = n;
	        b = wh;
	        break;
	      case 1:
	        r = n;
	        g = v;
	        b = wh;
	        break;
	      case 2:
	        r = wh;
	        g = v;
	        b = n;
	        break;
	      case 3:
	        r = wh;
	        g = n;
	        b = v;
	        break;
	      case 4:
	        r = n;
	        g = wh;
	        b = v;
	        break;
	      case 5:
	        r = v;
	        g = wh;
	        b = n;
	        break;
	    }
	    /* eslint-enable max-statements-per-line,no-multi-spaces */

	    return [r * 255, g * 255, b * 255];
	  };
	  convert.cmyk.rgb = function (cmyk) {
	    const c = cmyk[0] / 100;
	    const m = cmyk[1] / 100;
	    const y = cmyk[2] / 100;
	    const k = cmyk[3] / 100;
	    const r = 1 - Math.min(1, c * (1 - k) + k);
	    const g = 1 - Math.min(1, m * (1 - k) + k);
	    const b = 1 - Math.min(1, y * (1 - k) + k);
	    return [r * 255, g * 255, b * 255];
	  };
	  convert.xyz.rgb = function (xyz) {
	    const x = xyz[0] / 100;
	    const y = xyz[1] / 100;
	    const z = xyz[2] / 100;
	    let r;
	    let g;
	    let b;
	    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
	    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
	    b = x * 0.0557 + y * -0.2040 + z * 1.0570;

	    // Assume sRGB
	    r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
	    g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
	    b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
	    r = Math.min(Math.max(0, r), 1);
	    g = Math.min(Math.max(0, g), 1);
	    b = Math.min(Math.max(0, b), 1);
	    return [r * 255, g * 255, b * 255];
	  };
	  convert.xyz.lab = function (xyz) {
	    let x = xyz[0];
	    let y = xyz[1];
	    let z = xyz[2];
	    x /= 95.047;
	    y /= 100;
	    z /= 108.883;
	    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
	    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
	    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
	    const l = 116 * y - 16;
	    const a = 500 * (x - y);
	    const b = 200 * (y - z);
	    return [l, a, b];
	  };
	  convert.lab.xyz = function (lab) {
	    const l = lab[0];
	    const a = lab[1];
	    const b = lab[2];
	    let x;
	    let y;
	    let z;
	    y = (l + 16) / 116;
	    x = a / 500 + y;
	    z = y - b / 200;
	    const y2 = y ** 3;
	    const x2 = x ** 3;
	    const z2 = z ** 3;
	    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
	    x *= 95.047;
	    y *= 100;
	    z *= 108.883;
	    return [x, y, z];
	  };
	  convert.lab.lch = function (lab) {
	    const l = lab[0];
	    const a = lab[1];
	    const b = lab[2];
	    let h;
	    const hr = Math.atan2(b, a);
	    h = hr * 360 / 2 / Math.PI;
	    if (h < 0) {
	      h += 360;
	    }
	    const c = Math.sqrt(a * a + b * b);
	    return [l, c, h];
	  };
	  convert.lch.lab = function (lch) {
	    const l = lch[0];
	    const c = lch[1];
	    const h = lch[2];
	    const hr = h / 360 * 2 * Math.PI;
	    const a = c * Math.cos(hr);
	    const b = c * Math.sin(hr);
	    return [l, a, b];
	  };
	  convert.rgb.ansi16 = function (args, saturation = null) {
	    const [r, g, b] = args;
	    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	    value = Math.round(value / 50);
	    if (value === 0) {
	      return 30;
	    }
	    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
	    if (value === 2) {
	      ansi += 60;
	    }
	    return ansi;
	  };
	  convert.hsv.ansi16 = function (args) {
	    // Optimization here; we already know the value and don't need to get
	    // it converted for us.
	    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
	  };
	  convert.rgb.ansi256 = function (args) {
	    const r = args[0];
	    const g = args[1];
	    const b = args[2];

	    // We use the extended greyscale palette here, with the exception of
	    // black and white. normal palette only has 4 greyscale shades.
	    if (r === g && g === b) {
	      if (r < 8) {
	        return 16;
	      }
	      if (r > 248) {
	        return 231;
	      }
	      return Math.round((r - 8) / 247 * 24) + 232;
	    }
	    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
	    return ansi;
	  };
	  convert.ansi16.rgb = function (args) {
	    let color = args % 10;

	    // Handle greyscale
	    if (color === 0 || color === 7) {
	      if (args > 50) {
	        color += 3.5;
	      }
	      color = color / 10.5 * 255;
	      return [color, color, color];
	    }
	    const mult = (~~(args > 50) + 1) * 0.5;
	    const r = (color & 1) * mult * 255;
	    const g = (color >> 1 & 1) * mult * 255;
	    const b = (color >> 2 & 1) * mult * 255;
	    return [r, g, b];
	  };
	  convert.ansi256.rgb = function (args) {
	    // Handle greyscale
	    if (args >= 232) {
	      const c = (args - 232) * 10 + 8;
	      return [c, c, c];
	    }
	    args -= 16;
	    let rem;
	    const r = Math.floor(args / 36) / 5 * 255;
	    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	    const b = rem % 6 / 5 * 255;
	    return [r, g, b];
	  };
	  convert.rgb.hex = function (args) {
	    const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
	    const string = integer.toString(16).toUpperCase();
	    return '000000'.substring(string.length) + string;
	  };
	  convert.hex.rgb = function (args) {
	    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	    if (!match) {
	      return [0, 0, 0];
	    }
	    let colorString = match[0];
	    if (match[0].length === 3) {
	      colorString = colorString.split('').map(char => {
	        return char + char;
	      }).join('');
	    }
	    const integer = parseInt(colorString, 16);
	    const r = integer >> 16 & 0xFF;
	    const g = integer >> 8 & 0xFF;
	    const b = integer & 0xFF;
	    return [r, g, b];
	  };
	  convert.rgb.hcg = function (rgb) {
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const max = Math.max(Math.max(r, g), b);
	    const min = Math.min(Math.min(r, g), b);
	    const chroma = max - min;
	    let grayscale;
	    let hue;
	    if (chroma < 1) {
	      grayscale = min / (1 - chroma);
	    } else {
	      grayscale = 0;
	    }
	    if (chroma <= 0) {
	      hue = 0;
	    } else if (max === r) {
	      hue = (g - b) / chroma % 6;
	    } else if (max === g) {
	      hue = 2 + (b - r) / chroma;
	    } else {
	      hue = 4 + (r - g) / chroma;
	    }
	    hue /= 6;
	    hue %= 1;
	    return [hue * 360, chroma * 100, grayscale * 100];
	  };
	  convert.hsl.hcg = function (hsl) {
	    const s = hsl[1] / 100;
	    const l = hsl[2] / 100;
	    const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
	    let f = 0;
	    if (c < 1.0) {
	      f = (l - 0.5 * c) / (1.0 - c);
	    }
	    return [hsl[0], c * 100, f * 100];
	  };
	  convert.hsv.hcg = function (hsv) {
	    const s = hsv[1] / 100;
	    const v = hsv[2] / 100;
	    const c = s * v;
	    let f = 0;
	    if (c < 1.0) {
	      f = (v - c) / (1 - c);
	    }
	    return [hsv[0], c * 100, f * 100];
	  };
	  convert.hcg.rgb = function (hcg) {
	    const h = hcg[0] / 360;
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    if (c === 0.0) {
	      return [g * 255, g * 255, g * 255];
	    }
	    const pure = [0, 0, 0];
	    const hi = h % 1 * 6;
	    const v = hi % 1;
	    const w = 1 - v;
	    let mg = 0;

	    /* eslint-disable max-statements-per-line */
	    switch (Math.floor(hi)) {
	      case 0:
	        pure[0] = 1;
	        pure[1] = v;
	        pure[2] = 0;
	        break;
	      case 1:
	        pure[0] = w;
	        pure[1] = 1;
	        pure[2] = 0;
	        break;
	      case 2:
	        pure[0] = 0;
	        pure[1] = 1;
	        pure[2] = v;
	        break;
	      case 3:
	        pure[0] = 0;
	        pure[1] = w;
	        pure[2] = 1;
	        break;
	      case 4:
	        pure[0] = v;
	        pure[1] = 0;
	        pure[2] = 1;
	        break;
	      default:
	        pure[0] = 1;
	        pure[1] = 0;
	        pure[2] = w;
	    }
	    /* eslint-enable max-statements-per-line */

	    mg = (1.0 - c) * g;
	    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
	  };
	  convert.hcg.hsv = function (hcg) {
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    const v = c + g * (1.0 - c);
	    let f = 0;
	    if (v > 0.0) {
	      f = c / v;
	    }
	    return [hcg[0], f * 100, v * 100];
	  };
	  convert.hcg.hsl = function (hcg) {
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    const l = g * (1.0 - c) + 0.5 * c;
	    let s = 0;
	    if (l > 0.0 && l < 0.5) {
	      s = c / (2 * l);
	    } else if (l >= 0.5 && l < 1.0) {
	      s = c / (2 * (1 - l));
	    }
	    return [hcg[0], s * 100, l * 100];
	  };
	  convert.hcg.hwb = function (hcg) {
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    const v = c + g * (1.0 - c);
	    return [hcg[0], (v - c) * 100, (1 - v) * 100];
	  };
	  convert.hwb.hcg = function (hwb) {
	    const w = hwb[1] / 100;
	    const b = hwb[2] / 100;
	    const v = 1 - b;
	    const c = v - w;
	    let g = 0;
	    if (c < 1) {
	      g = (v - c) / (1 - c);
	    }
	    return [hwb[0], c * 100, g * 100];
	  };
	  convert.apple.rgb = function (apple) {
	    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
	  };
	  convert.rgb.apple = function (rgb) {
	    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
	  };
	  convert.gray.rgb = function (args) {
	    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
	  };
	  convert.gray.hsl = function (args) {
	    return [0, 0, args[0]];
	  };
	  convert.gray.hsv = convert.gray.hsl;
	  convert.gray.hwb = function (gray) {
	    return [0, 100, gray[0]];
	  };
	  convert.gray.cmyk = function (gray) {
	    return [0, 0, 0, gray[0]];
	  };
	  convert.gray.lab = function (gray) {
	    return [gray[0], 0, 0];
	  };
	  convert.gray.hex = function (gray) {
	    const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	    const integer = (val << 16) + (val << 8) + val;
	    const string = integer.toString(16).toUpperCase();
	    return '000000'.substring(string.length) + string;
	  };
	  convert.rgb.gray = function (rgb) {
	    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	    return [val / 255 * 100];
	  };
	  return conversions;
	}

	var route;
	var hasRequiredRoute;
	function requireRoute() {
	  if (hasRequiredRoute) return route;
	  hasRequiredRoute = 1;
	  const conversions = requireConversions();

	  /*
	  	This function routes a model to all other models.
	  		all functions that are routed have a property `.conversion` attached
	  	to the returned synthetic function. This property is an array
	  	of strings, each with the steps in between the 'from' and 'to'
	  	color models (inclusive).
	  		conversions that are not possible simply are not included.
	  */

	  function buildGraph() {
	    const graph = {};
	    // https://jsperf.com/object-keys-vs-for-in-with-closure/3
	    const models = Object.keys(conversions);
	    for (let len = models.length, i = 0; i < len; i++) {
	      graph[models[i]] = {
	        // http://jsperf.com/1-vs-infinity
	        // micro-opt, but this is simple.
	        distance: -1,
	        parent: null
	      };
	    }
	    return graph;
	  }

	  // https://en.wikipedia.org/wiki/Breadth-first_search
	  function deriveBFS(fromModel) {
	    const graph = buildGraph();
	    const queue = [fromModel]; // Unshift -> queue -> pop

	    graph[fromModel].distance = 0;
	    while (queue.length) {
	      const current = queue.pop();
	      const adjacents = Object.keys(conversions[current]);
	      for (let len = adjacents.length, i = 0; i < len; i++) {
	        const adjacent = adjacents[i];
	        const node = graph[adjacent];
	        if (node.distance === -1) {
	          node.distance = graph[current].distance + 1;
	          node.parent = current;
	          queue.unshift(adjacent);
	        }
	      }
	    }
	    return graph;
	  }
	  function link(from, to) {
	    return function (args) {
	      return to(from(args));
	    };
	  }
	  function wrapConversion(toModel, graph) {
	    const path = [graph[toModel].parent, toModel];
	    let fn = conversions[graph[toModel].parent][toModel];
	    let cur = graph[toModel].parent;
	    while (graph[cur].parent) {
	      path.unshift(graph[cur].parent);
	      fn = link(conversions[graph[cur].parent][cur], fn);
	      cur = graph[cur].parent;
	    }
	    fn.conversion = path;
	    return fn;
	  }
	  route = function (fromModel) {
	    const graph = deriveBFS(fromModel);
	    const conversion = {};
	    const models = Object.keys(graph);
	    for (let len = models.length, i = 0; i < len; i++) {
	      const toModel = models[i];
	      const node = graph[toModel];
	      if (node.parent === null) {
	        // No possible conversion, or this node is the source model.
	        continue;
	      }
	      conversion[toModel] = wrapConversion(toModel, graph);
	    }
	    return conversion;
	  };
	  return route;
	}

	var colorConvert;
	var hasRequiredColorConvert;
	function requireColorConvert() {
	  if (hasRequiredColorConvert) return colorConvert;
	  hasRequiredColorConvert = 1;
	  const conversions = requireConversions();
	  const route = requireRoute();
	  const convert = {};
	  const models = Object.keys(conversions);
	  function wrapRaw(fn) {
	    const wrappedFn = function (...args) {
	      const arg0 = args[0];
	      if (arg0 === undefined || arg0 === null) {
	        return arg0;
	      }
	      if (arg0.length > 1) {
	        args = arg0;
	      }
	      return fn(args);
	    };

	    // Preserve .conversion property if there is one
	    if ('conversion' in fn) {
	      wrappedFn.conversion = fn.conversion;
	    }
	    return wrappedFn;
	  }
	  function wrapRounded(fn) {
	    const wrappedFn = function (...args) {
	      const arg0 = args[0];
	      if (arg0 === undefined || arg0 === null) {
	        return arg0;
	      }
	      if (arg0.length > 1) {
	        args = arg0;
	      }
	      const result = fn(args);

	      // We're assuming the result is an array here.
	      // see notice in conversions.js; don't use box types
	      // in conversion functions.
	      if (typeof result === 'object') {
	        for (let len = result.length, i = 0; i < len; i++) {
	          result[i] = Math.round(result[i]);
	        }
	      }
	      return result;
	    };

	    // Preserve .conversion property if there is one
	    if ('conversion' in fn) {
	      wrappedFn.conversion = fn.conversion;
	    }
	    return wrappedFn;
	  }
	  models.forEach(fromModel => {
	    convert[fromModel] = {};
	    Object.defineProperty(convert[fromModel], 'channels', {
	      value: conversions[fromModel].channels
	    });
	    Object.defineProperty(convert[fromModel], 'labels', {
	      value: conversions[fromModel].labels
	    });
	    const routes = route(fromModel);
	    const routeModels = Object.keys(routes);
	    routeModels.forEach(toModel => {
	      const fn = routes[toModel];
	      convert[fromModel][toModel] = wrapRounded(fn);
	      convert[fromModel][toModel].raw = wrapRaw(fn);
	    });
	  });
	  colorConvert = convert;
	  return colorConvert;
	}

	var hasRequiredLib;
	function requireLib() {
	  if (hasRequiredLib) return lib$1;
	  hasRequiredLib = 1;
	  var __spreadArray = lib$1 && lib$1.__spreadArray || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	      if (ar || !(i in from)) {
	        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	        ar[i] = from[i];
	      }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	  };
	  Object.defineProperty(lib$1, "__esModule", {
	    value: true
	  });
	  lib$1.colorFromUuid = void 0;
	  var uuid_1 = esmBrowser;
	  var UuidEncoder = requireLib$1();
	  var convert = requireColorConvert();
	  var DEFAULT_COLOR_FORMAT = "hex";
	  var DEFAULT_IS_RAW = false;
	  var encoder = new UuidEncoder("base10");
	  /**
	   * Returns the generated color associated with the given uuid.
	   *
	   * @param uuid - The uuid for which to generate a color
	   * @param options - An optional object to configure the color generation, and attach callbacks that directly receive the generated color code or components in various formats
	   * @returns The generated color as a CSS `<color>` notation string
	   *
	   * @throws {@link https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/error | Error}
	   * This exception is thrown if the input uuid string is not a valid UUID.
	   *
	   * @public
	   */
	  function colorFromUuid(uuid, options) {
	    if (options === void 0) {
	      options = {};
	    }
	    if (!(0, uuid_1.validate)(uuid)) {
	      throw new Error("Given string is not a valid UUID.");
	    }
	    var encodedUuid = BigInt(encoder.encode(uuid));
	    var colorCode = Number(encodedUuid % BigInt(0x1000000));
	    var red = colorCode >> 16;
	    var green = colorCode >> 8 & 0xff;
	    var blue = colorCode & 0xff;
	    var receivers = {};
	    if (options.hasOwnProperty("receivers")) {
	      ["rgb", "hsl", "hex"].forEach(function (format) {
	        if (options.receivers.hasOwnProperty(format)) {
	          receivers[format] = options.receivers[format]; // link to callbacks
	        }
	      });
	    }
	    var isRaw = DEFAULT_IS_RAW;
	    if (options.hasOwnProperty("raw")) {
	      isRaw = options.raw;
	    }
	    var alpha;
	    if (options.hasOwnProperty("alpha")) {
	      alpha = Math.min(Math.max(options.alpha, 0), 1); // clamp to [0; 1]
	    }
	    if ("rgb" in receivers) {
	      if (alpha === undefined) {
	        receivers.rgb(red, green, blue);
	      } else {
	        receivers.rgb(red, green, blue, alpha);
	      }
	    }
	    if ("hsl" in receivers) {
	      var hsl = isRaw ? convert.rgb.hsl.raw(red, green, blue) : convert.rgb.hsl(red, green, blue);
	      if (alpha === undefined) {
	        receivers.hsl.apply(receivers, hsl);
	      } else {
	        receivers.hsl.apply(receivers, __spreadArray(__spreadArray([], hsl, true), [alpha], false));
	      }
	    }
	    if ("hex" in receivers) {
	      var hexColorCode = convert.rgb.hex(red, green, blue).toLowerCase();
	      if (alpha === undefined) {
	        receivers.hex(hexColorCode);
	      } else {
	        var hexAlphaCode = Math.floor(alpha * 255).toString(16);
	        receivers.hex(hexColorCode + hexAlphaCode);
	      }
	    }
	    var format = DEFAULT_COLOR_FORMAT;
	    if (options.hasOwnProperty("format")) {
	      format = options.format;
	    }
	    switch (format) {
	      case "rgb":
	        return alpha === undefined ? "rgb(".concat(red, ", ").concat(green, ", ").concat(blue, ")") : "rgb(".concat(red, ", ").concat(green, ", ").concat(blue, ", ").concat(alpha, ")");
	      case "hsl":
	        var hsl = isRaw ? convert.rgb.hsl.raw(red, green, blue) : convert.rgb.hsl(red, green, blue);
	        return alpha === undefined ? "hsl(".concat(hsl[0], ", ").concat(hsl[1], "%, ").concat(hsl[2], "%)") : "hsl(".concat(hsl[0], ", ").concat(hsl[1], "%, ").concat(hsl[2], "%, ").concat(alpha, ")");
	      default: // don't error
	      case "hex":
	        var hexColorCode = convert.rgb.hex(red, green, blue).toLowerCase();
	        var hexAlphaCode = Math.floor(alpha * 255).toString(16);
	        return alpha === undefined ? "#".concat(hexColorCode) : "#".concat(hexColorCode).concat(hexAlphaCode);
	    }
	  }
	  lib$1.colorFromUuid = colorFromUuid;
	  return lib$1;
	}

	var libExports = /*@__PURE__*/ requireLib();

	class Playground {
	  camera;
	  scene;
	  renderer;
	  cameraControls;
	  ambientLight;
	  light;

	  /**
	   * @type {[THREE.Mesh]}
	   */
	  boxes = [];

	  /**
	   * @type {[THREE.Mesh]}
	   */
	  items = [];
	  materials = {};
	  constructor(container) {
	    this.camera = new PerspectiveCamera(45, container.offsetWidth / window.innerHeight, 1, 80000);
	    this.camera.position.set(-600, 550, 1300);
	    this.ambientLight = new AmbientLight(0x7c7c7c, 3.0);
	    this.light = new DirectionalLight(0xFFFFFF, 3.0);
	    this.light.position.set(0.32, 0.39, 0.7);
	    const canvasWidth = container.offsetWidth;
	    const canvasHeight = window.innerHeight;
	    this.renderer = new WebGLRenderer({
	      antialias: true
	    });
	    this.renderer.setPixelRatio(window.devicePixelRatio);
	    this.renderer.setSize(canvasWidth, canvasHeight);
	    container.appendChild(this.renderer.domElement);
	    window.addEventListener('resize', e => this.onWindowResize(e, container));
	    window.addEventListener('keydown', e => this.onKeyboard(e));
	    this.cameraControls = new OrbitControls(this.camera, this.renderer.domElement);
	    this.cameraControls.addEventListener('change', () => this.renderer.render(this.scene, this.camera));
	    this.materials['wireframe'] = new MeshBasicMaterial({
	      wireframe: true
	    });
	    this.materials['flat'] = new MeshPhongMaterial({
	      specular: 0x000000,
	      flatShading: true,
	      side: DoubleSide
	    });
	    this.materials['smooth'] = new MeshLambertMaterial({
	      side: DoubleSide
	    });
	    this.materials['glossy'] = new MeshPhongMaterial({
	      side: DoubleSide
	    });
	    this.scene = new Scene();
	    this.scene.background = null;
	    this.scene.add(this.ambientLight);
	    this.scene.add(this.light);
	  }
	  render(request) {
	    if (request !== undefined && typeof request.boxes !== 'undefined' && request.boxes.length > 0) {
	      this.createObjects(request);
	    }
	    this.renderer.render(this.scene, this.camera);
	  }
	  onWindowResize(e, container) {
	    const canvasWidth = container.offsetWidth;
	    const canvasHeight = window.innerHeight;
	    this.renderer.setSize(canvasWidth, canvasHeight);
	    this.camera.aspect = canvasWidth / canvasHeight;
	    this.camera.updateProjectionMatrix();
	    this.render();
	  }
	  onKeyboard(e) {
	    const delta = 200;
	    switch (e.code) {
	      case "KeyA":
	      case "ArrowLeft":
	        this.camera.position.set(this.camera.position.x - delta, this.camera.position.y, this.camera.position.z);
	        break;
	      case "KeyW":
	      case "ArrowUp":
	        this.camera.position.set(this.camera.position.x, this.camera.position.y, this.camera.position.z - delta);
	        break;
	      case "KeyD":
	      case "ArrowRight":
	        this.camera.position.set(this.camera.position.x + delta, this.camera.position.y, this.camera.position.z);
	        break;
	      case "KeyS":
	      case "ArrowDown":
	        this.camera.position.set(this.camera.position.x, this.camera.position.y, this.camera.position.z + delta);
	        break;
	    }
	    this.cameraControls.update();
	  }
	  destroy() {
	    for (const item of this.items) {
	      item.geometry.dispose();
	      this.scene.remove(item);
	    }
	    for (const box of this.boxes) {
	      box.geometry.dispose();
	      this.scene.remove(box);
	    }
	    this.boxes = [];
	    this.items = [];
	  }
	  createObjects(request) {
	    this.destroy();
	    const delta = 50;
	    let point = {
	      x: 0,
	      y: 0,
	      z: 0
	    };
	    let zMax = 0;

	    // boxes
	    for (const box of request.boxes) {
	      const boxGeometry = new BoxGeometry(box.width, box.height, box.depth);
	      const boxMesh = new Mesh(boxGeometry, this.materials['wireframe']);
	      point.x += box.width;
	      boxMesh.position.set(point.x, point.y, point.z);
	      this.boxes = this.boxes.concat(boxMesh);
	      this.scene.add(boxMesh);
	      for (const item of box.items) {
	        const color = libExports.colorFromUuid(item.id);
	        const itemGeometry = new BoxGeometry(item.width, item.height, item.depth);
	        const itemMesh = new Mesh(itemGeometry, new MeshPhongMaterial({
	          color: color,
	          flatShading: true,
	          side: DoubleSide
	        }));
	        itemMesh.position.set(item.position.x - box.width / 2 + item.width / 2, item.position.y - box.height / 2 + item.height / 2, item.position.z - box.depth / 2 + item.depth / 2);
	        this.items = this.items.concat(itemMesh);
	        boxMesh.add(itemMesh);
	      }
	      point.x += delta;
	      zMax = Math.max(box.depth, zMax);
	    }
	    point = {
	      x: 0,
	      y: 0,
	      z: zMax + delta
	    };
	    for (const item of request.items) {
	      const color = libExports.colorFromUuid(item.id);
	      const itemGeometry = new BoxGeometry(item.width, item.height, item.depth);
	      const itemMesh = new Mesh(itemGeometry, new MeshPhongMaterial({
	        color: color,
	        flatShading: true,
	        side: DoubleSide
	      }));
	      console.log('unfit item', item, point);
	      itemMesh.position.set(point.x, point.y, point.z);
	      point.z += item.width + delta;
	      this.items = this.items.concat(itemMesh);
	      this.scene.add(itemMesh);
	    }
	  }
	}

	var n,
	  l$1,
	  u$1,
	  i$1,
	  r$1,
	  o$1,
	  e$1,
	  f$1,
	  c$1,
	  s$1,
	  a$1,
	  h$1,
	  p$1 = {},
	  v$1 = [],
	  y$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,
	  d$1 = Array.isArray;
	function w$2(n, l) {
	  for (var u in l) n[u] = l[u];
	  return n;
	}
	function _$1(n) {
	  n && n.parentNode && n.parentNode.removeChild(n);
	}
	function g$2(l, u, t) {
	  var i,
	    r,
	    o,
	    e = {};
	  for (o in u) "key" == o ? i = u[o] : "ref" == o ? r = u[o] : e[o] = u[o];
	  if (arguments.length > 2 && (e.children = arguments.length > 3 ? n.call(arguments, 2) : t), "function" == typeof l && null != l.defaultProps) for (o in l.defaultProps) void 0 === e[o] && (e[o] = l.defaultProps[o]);
	  return m$1(l, e, i, r, null);
	}
	function m$1(n, t, i, r, o) {
	  var e = {
	    type: n,
	    props: t,
	    key: i,
	    ref: r,
	    __k: null,
	    __: null,
	    __b: 0,
	    __e: null,
	    __c: null,
	    constructor: void 0,
	    __v: null == o ? ++u$1 : o,
	    __i: -1,
	    __u: 0
	  };
	  return null == o && null != l$1.vnode && l$1.vnode(e), e;
	}
	function b() {
	  return {
	    current: null
	  };
	}
	function k$2(n) {
	  return n.children;
	}
	function x$2(n, l) {
	  this.props = n, this.context = l;
	}
	function C$2(n, l) {
	  if (null == l) return n.__ ? C$2(n.__, n.__i + 1) : null;
	  for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
	  return "function" == typeof n.type ? C$2(n) : null;
	}
	function S(n) {
	  var l, u;
	  if (null != (n = n.__) && null != n.__c) {
	    for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
	      n.__e = n.__c.base = u.__e;
	      break;
	    }
	    return S(n);
	  }
	}
	function M$1(n) {
	  (!n.__d && (n.__d = !0) && i$1.push(n) && !P$2.__r++ || r$1 !== l$1.debounceRendering) && ((r$1 = l$1.debounceRendering) || o$1)(P$2);
	}
	function P$2() {
	  var n, u, t, r, o, f, c, s;
	  for (i$1.sort(e$1); n = i$1.shift();) n.__d && (u = i$1.length, r = void 0, f = (o = (t = n).__v).__e, c = [], s = [], t.__P && ((r = w$2({}, o)).__v = o.__v + 1, l$1.vnode && l$1.vnode(r), j$2(t.__P, r, o, t.__n, t.__P.namespaceURI, 32 & o.__u ? [f] : null, c, null == f ? C$2(o) : f, !!(32 & o.__u), s), r.__v = o.__v, r.__.__k[r.__i] = r, z$2(c, r, s), r.__e != f && S(r)), i$1.length > u && i$1.sort(e$1));
	  P$2.__r = 0;
	}
	function $$1(n, l, u, t, i, r, o, e, f, c, s) {
	  var a,
	    h,
	    y,
	    d,
	    w,
	    _,
	    g = t && t.__k || v$1,
	    m = l.length;
	  for (f = I$1(u, l, g, f), a = 0; a < m; a++) null != (y = u.__k[a]) && (h = -1 === y.__i ? p$1 : g[y.__i] || p$1, y.__i = a, _ = j$2(n, y, h, i, r, o, e, f, c, s), d = y.__e, y.ref && h.ref != y.ref && (h.ref && V$1(h.ref, null, y), s.push(y.ref, y.__c || d, y)), null == w && null != d && (w = d), 4 & y.__u || h.__k === y.__k ? f = H$1(y, f, n) : "function" == typeof y.type && void 0 !== _ ? f = _ : d && (f = d.nextSibling), y.__u &= -7);
	  return u.__e = w, f;
	}
	function I$1(n, l, u, t) {
	  var i,
	    r,
	    o,
	    e,
	    f,
	    c = l.length,
	    s = u.length,
	    a = s,
	    h = 0;
	  for (n.__k = [], i = 0; i < c; i++) null != (r = l[i]) && "boolean" != typeof r && "function" != typeof r ? (e = i + h, (r = n.__k[i] = "string" == typeof r || "number" == typeof r || "bigint" == typeof r || r.constructor == String ? m$1(null, r, null, null, null) : d$1(r) ? m$1(k$2, {
	    children: r
	  }, null, null, null) : void 0 === r.constructor && r.__b > 0 ? m$1(r.type, r.props, r.key, r.ref ? r.ref : null, r.__v) : r).__ = n, r.__b = n.__b + 1, o = null, -1 !== (f = r.__i = T$2(r, u, e, a)) && (a--, (o = u[f]) && (o.__u |= 2)), null == o || null === o.__v ? (-1 == f && h--, "function" != typeof r.type && (r.__u |= 4)) : f !== e && (f == e - 1 ? h-- : f == e + 1 ? h++ : (f > e ? h-- : h++, r.__u |= 4))) : r = n.__k[i] = null;
	  if (a) for (i = 0; i < s; i++) null != (o = u[i]) && 0 == (2 & o.__u) && (o.__e == t && (t = C$2(o)), q$2(o, o));
	  return t;
	}
	function H$1(n, l, u) {
	  var t, i;
	  if ("function" == typeof n.type) {
	    for (t = n.__k, i = 0; t && i < t.length; i++) t[i] && (t[i].__ = n, l = H$1(t[i], l, u));
	    return l;
	  }
	  n.__e != l && (l && n.type && !u.contains(l) && (l = C$2(n)), u.insertBefore(n.__e, l || null), l = n.__e);
	  do {
	    l = l && l.nextSibling;
	  } while (null != l && 8 === l.nodeType);
	  return l;
	}
	function L$1(n, l) {
	  return l = l || [], null == n || "boolean" == typeof n || (d$1(n) ? n.some(function (n) {
	    L$1(n, l);
	  }) : l.push(n)), l;
	}
	function T$2(n, l, u, t) {
	  var i = n.key,
	    r = n.type,
	    o = u - 1,
	    e = u + 1,
	    f = l[u];
	  if (null === f || f && i == f.key && r === f.type && 0 == (2 & f.__u)) return u;
	  if (("function" != typeof r || r === k$2 || i) && t > (null != f && 0 == (2 & f.__u) ? 1 : 0)) for (; o >= 0 || e < l.length;) {
	    if (o >= 0) {
	      if ((f = l[o]) && 0 == (2 & f.__u) && i == f.key && r === f.type) return o;
	      o--;
	    }
	    if (e < l.length) {
	      if ((f = l[e]) && 0 == (2 & f.__u) && i == f.key && r === f.type) return e;
	      e++;
	    }
	  }
	  return -1;
	}
	function A$2(n, l, u) {
	  "-" === l[0] ? n.setProperty(l, null == u ? "" : u) : n[l] = null == u ? "" : "number" != typeof u || y$1.test(l) ? u : u + "px";
	}
	function F$2(n, l, u, t, i) {
	  var r;
	  n: if ("style" === l) {
	    if ("string" == typeof u) n.style.cssText = u;else {
	      if ("string" == typeof t && (n.style.cssText = t = ""), t) for (l in t) u && l in u || A$2(n.style, l, "");
	      if (u) for (l in u) t && u[l] === t[l] || A$2(n.style, l, u[l]);
	    }
	  } else if ("o" === l[0] && "n" === l[1]) r = l !== (l = l.replace(f$1, "$1")), l = l.toLowerCase() in n || "onFocusOut" === l || "onFocusIn" === l ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + r] = u, u ? t ? u.u = t.u : (u.u = c$1, n.addEventListener(l, r ? a$1 : s$1, r)) : n.removeEventListener(l, r ? a$1 : s$1, r);else {
	    if ("http://www.w3.org/2000/svg" == i) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("width" != l && "height" != l && "href" != l && "list" != l && "form" != l && "tabIndex" != l && "download" != l && "rowSpan" != l && "colSpan" != l && "role" != l && "popover" != l && l in n) try {
	      n[l] = null == u ? "" : u;
	      break n;
	    } catch (n) {}
	    "function" == typeof u || (null == u || !1 === u && "-" !== l[4] ? n.removeAttribute(l) : n.setAttribute(l, "popover" == l && 1 == u ? "" : u));
	  }
	}
	function O$1(n) {
	  return function (u) {
	    if (this.l) {
	      var t = this.l[u.type + n];
	      if (null == u.t) u.t = c$1++;else if (u.t < t.u) return;
	      return t(l$1.event ? l$1.event(u) : u);
	    }
	  };
	}
	function j$2(n, u, t, i, r, o, e, f, c, s) {
	  var a,
	    h,
	    p,
	    v,
	    y,
	    g,
	    m,
	    b,
	    C,
	    S,
	    M,
	    P,
	    I,
	    H,
	    L,
	    T,
	    A,
	    F = u.type;
	  if (void 0 !== u.constructor) return null;
	  128 & t.__u && (c = !!(32 & t.__u), o = [f = u.__e = t.__e]), (a = l$1.__b) && a(u);
	  n: if ("function" == typeof F) try {
	    if (b = u.props, C = "prototype" in F && F.prototype.render, S = (a = F.contextType) && i[a.__c], M = a ? S ? S.props.value : a.__ : i, t.__c ? m = (h = u.__c = t.__c).__ = h.__E : (C ? u.__c = h = new F(b, M) : (u.__c = h = new x$2(b, M), h.constructor = F, h.render = B$2), S && S.sub(h), h.props = b, h.state || (h.state = {}), h.context = M, h.__n = i, p = h.__d = !0, h.__h = [], h._sb = []), C && null == h.__s && (h.__s = h.state), C && null != F.getDerivedStateFromProps && (h.__s == h.state && (h.__s = w$2({}, h.__s)), w$2(h.__s, F.getDerivedStateFromProps(b, h.__s))), v = h.props, y = h.state, h.__v = u, p) C && null == F.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), C && null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
	      if (C && null == F.getDerivedStateFromProps && b !== v && null != h.componentWillReceiveProps && h.componentWillReceiveProps(b, M), !h.__e && (null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(b, h.__s, M) || u.__v === t.__v)) {
	        for (u.__v !== t.__v && (h.props = b, h.state = h.__s, h.__d = !1), u.__e = t.__e, u.__k = t.__k, u.__k.some(function (n) {
	          n && (n.__ = u);
	        }), P = 0; P < h._sb.length; P++) h.__h.push(h._sb[P]);
	        h._sb = [], h.__h.length && e.push(h);
	        break n;
	      }
	      null != h.componentWillUpdate && h.componentWillUpdate(b, h.__s, M), C && null != h.componentDidUpdate && h.__h.push(function () {
	        h.componentDidUpdate(v, y, g);
	      });
	    }
	    if (h.context = M, h.props = b, h.__P = n, h.__e = !1, I = l$1.__r, H = 0, C) {
	      for (h.state = h.__s, h.__d = !1, I && I(u), a = h.render(h.props, h.state, h.context), L = 0; L < h._sb.length; L++) h.__h.push(h._sb[L]);
	      h._sb = [];
	    } else do {
	      h.__d = !1, I && I(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
	    } while (h.__d && ++H < 25);
	    h.state = h.__s, null != h.getChildContext && (i = w$2(w$2({}, i), h.getChildContext())), C && !p && null != h.getSnapshotBeforeUpdate && (g = h.getSnapshotBeforeUpdate(v, y)), f = $$1(n, d$1(T = null != a && a.type === k$2 && null == a.key ? a.props.children : a) ? T : [T], u, t, i, r, o, e, f, c, s), h.base = u.__e, u.__u &= -161, h.__h.length && e.push(h), m && (h.__E = h.__ = null);
	  } catch (n) {
	    if (u.__v = null, c || null != o) {
	      if (n.then) {
	        for (u.__u |= c ? 160 : 128; f && 8 === f.nodeType && f.nextSibling;) f = f.nextSibling;
	        o[o.indexOf(f)] = null, u.__e = f;
	      } else for (A = o.length; A--;) _$1(o[A]);
	    } else u.__e = t.__e, u.__k = t.__k;
	    l$1.__e(n, u, t);
	  } else null == o && u.__v === t.__v ? (u.__k = t.__k, u.__e = t.__e) : f = u.__e = N$1(t.__e, u, t, i, r, o, e, c, s);
	  return (a = l$1.diffed) && a(u), 128 & u.__u ? void 0 : f;
	}
	function z$2(n, u, t) {
	  for (var i = 0; i < t.length; i++) V$1(t[i], t[++i], t[++i]);
	  l$1.__c && l$1.__c(u, n), n.some(function (u) {
	    try {
	      n = u.__h, u.__h = [], n.some(function (n) {
	        n.call(u);
	      });
	    } catch (n) {
	      l$1.__e(n, u.__v);
	    }
	  });
	}
	function N$1(u, t, i, r, o, e, f, c, s) {
	  var a,
	    h,
	    v,
	    y,
	    w,
	    g,
	    m,
	    b = i.props,
	    k = t.props,
	    x = t.type;
	  if ("svg" === x ? o = "http://www.w3.org/2000/svg" : "math" === x ? o = "http://www.w3.org/1998/Math/MathML" : o || (o = "http://www.w3.org/1999/xhtml"), null != e) for (a = 0; a < e.length; a++) if ((w = e[a]) && "setAttribute" in w == !!x && (x ? w.localName === x : 3 === w.nodeType)) {
	    u = w, e[a] = null;
	    break;
	  }
	  if (null == u) {
	    if (null === x) return document.createTextNode(k);
	    u = document.createElementNS(o, x, k.is && k), c && (l$1.__m && l$1.__m(t, e), c = !1), e = null;
	  }
	  if (null === x) b === k || c && u.data === k || (u.data = k);else {
	    if (e = e && n.call(u.childNodes), b = i.props || p$1, !c && null != e) for (b = {}, a = 0; a < u.attributes.length; a++) b[(w = u.attributes[a]).name] = w.value;
	    for (a in b) if (w = b[a], "children" == a) ;else if ("dangerouslySetInnerHTML" == a) v = w;else if (!(a in k)) {
	      if ("value" == a && "defaultValue" in k || "checked" == a && "defaultChecked" in k) continue;
	      F$2(u, a, null, w, o);
	    }
	    for (a in k) w = k[a], "children" == a ? y = w : "dangerouslySetInnerHTML" == a ? h = w : "value" == a ? g = w : "checked" == a ? m = w : c && "function" != typeof w || b[a] === w || F$2(u, a, w, b[a], o);
	    if (h) c || v && (h.__html === v.__html || h.__html === u.innerHTML) || (u.innerHTML = h.__html), t.__k = [];else if (v && (u.innerHTML = ""), $$1(u, d$1(y) ? y : [y], t, i, r, "foreignObject" === x ? "http://www.w3.org/1999/xhtml" : o, e, f, e ? e[0] : i.__k && C$2(i, 0), c, s), null != e) for (a = e.length; a--;) _$1(e[a]);
	    c || (a = "value", "progress" === x && null == g ? u.removeAttribute("value") : void 0 !== g && (g !== u[a] || "progress" === x && !g || "option" === x && g !== b[a]) && F$2(u, a, g, b[a], o), a = "checked", void 0 !== m && m !== u[a] && F$2(u, a, m, b[a], o));
	  }
	  return u;
	}
	function V$1(n, u, t) {
	  try {
	    if ("function" == typeof n) {
	      var i = "function" == typeof n.__u;
	      i && n.__u(), i && null == u || (n.__u = n(u));
	    } else n.current = u;
	  } catch (n) {
	    l$1.__e(n, t);
	  }
	}
	function q$2(n, u, t) {
	  var i, r;
	  if (l$1.unmount && l$1.unmount(n), (i = n.ref) && (i.current && i.current !== n.__e || V$1(i, null, u)), null != (i = n.__c)) {
	    if (i.componentWillUnmount) try {
	      i.componentWillUnmount();
	    } catch (n) {
	      l$1.__e(n, u);
	    }
	    i.base = i.__P = null;
	  }
	  if (i = n.__k) for (r = 0; r < i.length; r++) i[r] && q$2(i[r], u, t || "function" != typeof n.type);
	  t || _$1(n.__e), n.__c = n.__ = n.__e = void 0;
	}
	function B$2(n, l, u) {
	  return this.constructor(n, u);
	}
	function D$2(u, t, i) {
	  var r, o, e, f;
	  t === document && (t = document.documentElement), l$1.__ && l$1.__(u, t), o = (r = "function" == typeof i) ? null : i && i.__k || t.__k, e = [], f = [], j$2(t, u = (!r && i || t).__k = g$2(k$2, null, [u]), o || p$1, p$1, t.namespaceURI, !r && i ? [i] : o ? null : t.firstChild ? n.call(t.childNodes) : null, e, !r && i ? i : o ? o.__e : t.firstChild, r, f), z$2(e, u, f);
	}
	function E$1(n, l) {
	  D$2(n, l, E$1);
	}
	function G$1(l, u, t) {
	  var i,
	    r,
	    o,
	    e,
	    f = w$2({}, l.props);
	  for (o in l.type && l.type.defaultProps && (e = l.type.defaultProps), u) "key" == o ? i = u[o] : "ref" == o ? r = u[o] : f[o] = void 0 === u[o] && void 0 !== e ? e[o] : u[o];
	  return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : t), m$1(l.type, f, i || l.key, r || l.ref, null);
	}
	function J$1(n, l) {
	  var u = {
	    __c: l = "__cC" + h$1++,
	    __: n,
	    Consumer: function (n, l) {
	      return n.children(l);
	    },
	    Provider: function (n) {
	      var u, t;
	      return this.getChildContext || (u = new Set(), (t = {})[l] = this, this.getChildContext = function () {
	        return t;
	      }, this.componentWillUnmount = function () {
	        u = null;
	      }, this.shouldComponentUpdate = function (n) {
	        this.props.value !== n.value && u.forEach(function (n) {
	          n.__e = !0, M$1(n);
	        });
	      }, this.sub = function (n) {
	        u.add(n);
	        var l = n.componentWillUnmount;
	        n.componentWillUnmount = function () {
	          u && u.delete(n), l && l.call(n);
	        };
	      }), n.children;
	    }
	  };
	  return u.Provider.__ = u.Consumer.contextType = u;
	}
	n = v$1.slice, l$1 = {
	  __e: function (n, l, u, t) {
	    for (var i, r, o; l = l.__;) if ((i = l.__c) && !i.__) try {
	      if ((r = i.constructor) && null != r.getDerivedStateFromError && (i.setState(r.getDerivedStateFromError(n)), o = i.__d), null != i.componentDidCatch && (i.componentDidCatch(n, t || {}), o = i.__d), o) return i.__E = i;
	    } catch (l) {
	      n = l;
	    }
	    throw n;
	  }
	}, u$1 = 0, x$2.prototype.setState = function (n, l) {
	  var u;
	  u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = w$2({}, this.state), "function" == typeof n && (n = n(w$2({}, u), this.props)), n && w$2(u, n), null != n && this.__v && (l && this._sb.push(l), M$1(this));
	}, x$2.prototype.forceUpdate = function (n) {
	  this.__v && (this.__e = !0, n && this.__h.push(n), M$1(this));
	}, x$2.prototype.render = k$2, i$1 = [], o$1 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e$1 = function (n, l) {
	  return n.__v.__b - l.__v.__b;
	}, P$2.__r = 0, f$1 = /(PointerCapture)$|Capture$/i, c$1 = 0, s$1 = O$1(!1), a$1 = O$1(!0), h$1 = 0;

	var t,
	  r,
	  u,
	  i,
	  o = 0,
	  f = [],
	  c = l$1,
	  e = c.__b,
	  a = c.__r,
	  v = c.diffed,
	  l = c.__c,
	  m = c.unmount,
	  s = c.__;
	function d(n, t) {
	  c.__h && c.__h(r, n, o || t), o = 0;
	  var u = r.__H || (r.__H = {
	    __: [],
	    __h: []
	  });
	  return n >= u.__.length && u.__.push({}), u.__[n];
	}
	function h(n) {
	  return o = 1, p(D$1, n);
	}
	function p(n, u, i) {
	  var o = d(t++, 2);
	  if (o.t = n, !o.__c && (o.__ = [i ? i(u) : D$1(void 0, u), function (n) {
	    var t = o.__N ? o.__N[0] : o.__[0],
	      r = o.t(t, n);
	    t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
	  }], o.__c = r, !r.u)) {
	    var f = function (n, t, r) {
	      if (!o.__c.__H) return !0;
	      var u = o.__c.__H.__.filter(function (n) {
	        return !!n.__c;
	      });
	      if (u.every(function (n) {
	        return !n.__N;
	      })) return !c || c.call(this, n, t, r);
	      var i = o.__c.props !== n;
	      return u.forEach(function (n) {
	        if (n.__N) {
	          var t = n.__[0];
	          n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
	        }
	      }), c && c.call(this, n, t, r) || i;
	    };
	    r.u = !0;
	    var c = r.shouldComponentUpdate,
	      e = r.componentWillUpdate;
	    r.componentWillUpdate = function (n, t, r) {
	      if (this.__e) {
	        var u = c;
	        c = void 0, f(n, t, r), c = u;
	      }
	      e && e.call(this, n, t, r);
	    }, r.shouldComponentUpdate = f;
	  }
	  return o.__N || o.__;
	}
	function y(n, u) {
	  var i = d(t++, 3);
	  !c.__s && C$1(i.__H, u) && (i.__ = n, i.i = u, r.__H.__h.push(i));
	}
	function _(n, u) {
	  var i = d(t++, 4);
	  !c.__s && C$1(i.__H, u) && (i.__ = n, i.i = u, r.__h.push(i));
	}
	function A$1(n) {
	  return o = 5, T$1(function () {
	    return {
	      current: n
	    };
	  }, []);
	}
	function F$1(n, t, r) {
	  o = 6, _(function () {
	    return "function" == typeof n ? (n(t()), function () {
	      return n(null);
	    }) : n ? (n.current = t(), function () {
	      return n.current = null;
	    }) : void 0;
	  }, null == r ? r : r.concat(n));
	}
	function T$1(n, r) {
	  var u = d(t++, 7);
	  return C$1(u.__H, r) && (u.__ = n(), u.__H = r, u.__h = n), u.__;
	}
	function q$1(n, t) {
	  return o = 8, T$1(function () {
	    return n;
	  }, t);
	}
	function x$1(n) {
	  var u = r.context[n.__c],
	    i = d(t++, 9);
	  return i.c = n, u ? (null == i.__ && (i.__ = !0, u.sub(r)), u.props.value) : n.__;
	}
	function P$1(n, t) {
	  c.useDebugValue && c.useDebugValue(t ? t(n) : n);
	}
	function g$1() {
	  var n = d(t++, 11);
	  if (!n.__) {
	    for (var u = r.__v; null !== u && !u.__m && null !== u.__;) u = u.__;
	    var i = u.__m || (u.__m = [0, 0]);
	    n.__ = "P" + i[0] + "-" + i[1]++;
	  }
	  return n.__;
	}
	function j$1() {
	  for (var n; n = f.shift();) if (n.__P && n.__H) try {
	    n.__H.__h.forEach(z$1), n.__H.__h.forEach(B$1), n.__H.__h = [];
	  } catch (t) {
	    n.__H.__h = [], c.__e(t, n.__v);
	  }
	}
	c.__b = function (n) {
	  r = null, e && e(n);
	}, c.__ = function (n, t) {
	  n && t.__k && t.__k.__m && (n.__m = t.__k.__m), s && s(n, t);
	}, c.__r = function (n) {
	  a && a(n), t = 0;
	  var i = (r = n.__c).__H;
	  i && (u === r ? (i.__h = [], r.__h = [], i.__.forEach(function (n) {
	    n.__N && (n.__ = n.__N), n.i = n.__N = void 0;
	  })) : (i.__h.forEach(z$1), i.__h.forEach(B$1), i.__h = [], t = 0)), u = r;
	}, c.diffed = function (n) {
	  v && v(n);
	  var t = n.__c;
	  t && t.__H && (t.__H.__h.length && (1 !== f.push(t) && i === c.requestAnimationFrame || ((i = c.requestAnimationFrame) || w$1)(j$1)), t.__H.__.forEach(function (n) {
	    n.i && (n.__H = n.i), n.i = void 0;
	  })), u = r = null;
	}, c.__c = function (n, t) {
	  t.some(function (n) {
	    try {
	      n.__h.forEach(z$1), n.__h = n.__h.filter(function (n) {
	        return !n.__ || B$1(n);
	      });
	    } catch (r) {
	      t.some(function (n) {
	        n.__h && (n.__h = []);
	      }), t = [], c.__e(r, n.__v);
	    }
	  }), l && l(n, t);
	}, c.unmount = function (n) {
	  m && m(n);
	  var t,
	    r = n.__c;
	  r && r.__H && (r.__H.__.forEach(function (n) {
	    try {
	      z$1(n);
	    } catch (n) {
	      t = n;
	    }
	  }), r.__H = void 0, t && c.__e(t, r.__v));
	};
	var k$1 = "function" == typeof requestAnimationFrame;
	function w$1(n) {
	  var t,
	    r = function () {
	      clearTimeout(u), k$1 && cancelAnimationFrame(t), setTimeout(n);
	    },
	    u = setTimeout(r, 100);
	  k$1 && (t = requestAnimationFrame(r));
	}
	function z$1(n) {
	  var t = r,
	    u = n.__c;
	  "function" == typeof u && (n.__c = void 0, u()), r = t;
	}
	function B$1(n) {
	  var t = r;
	  n.__c = n.__(), r = t;
	}
	function C$1(n, t) {
	  return !n || n.length !== t.length || t.some(function (t, r) {
	    return t !== n[r];
	  });
	}
	function D$1(n, t) {
	  return "function" == typeof t ? t(n) : t;
	}

	function g(n, t) {
	  for (var e in n) if ("__source" !== e && !(e in t)) return !0;
	  for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;
	  return !1;
	}
	function E(n, t) {
	  var e = t(),
	    r = h({
	      t: {
	        __: e,
	        u: t
	      }
	    }),
	    u = r[0].t,
	    o = r[1];
	  return _(function () {
	    u.__ = e, u.u = t, C(u) && o({
	      t: u
	    });
	  }, [n, e, t]), y(function () {
	    return C(u) && o({
	      t: u
	    }), n(function () {
	      C(u) && o({
	        t: u
	      });
	    });
	  }, [n]), e;
	}
	function C(n) {
	  var t,
	    e,
	    r = n.u,
	    u = n.__;
	  try {
	    var o = r();
	    return !((t = u) === (e = o) && (0 !== t || 1 / t == 1 / e) || t != t && e != e);
	  } catch (n) {
	    return !0;
	  }
	}
	function x(n) {
	  n();
	}
	function R(n) {
	  return n;
	}
	function w() {
	  return [!1, x];
	}
	var k = _;
	function I(n, t) {
	  this.props = n, this.context = t;
	}
	function N(n, e) {
	  function r(n) {
	    var t = this.props.ref,
	      r = t == n.ref;
	    return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : g(this.props, n);
	  }
	  function u(e) {
	    return this.shouldComponentUpdate = r, g$2(n, e);
	  }
	  return u.displayName = "Memo(" + (n.displayName || n.name) + ")", u.prototype.isReactComponent = !0, u.__f = !0, u;
	}
	(I.prototype = new x$2()).isPureReactComponent = !0, I.prototype.shouldComponentUpdate = function (n, t) {
	  return g(this.props, n) || g(this.state, t);
	};
	var M = l$1.__b;
	l$1.__b = function (n) {
	  n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), M && M(n);
	};
	var T = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
	function A(n) {
	  function t(t) {
	    if (!("ref" in t)) return n(t, null);
	    var e = t.ref;
	    delete t.ref;
	    var r = n(t, e);
	    return t.ref = e, r;
	  }
	  return t.$$typeof = T, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
	}
	var D = function (n, t) {
	    return null == n ? null : L$1(L$1(n).map(t));
	  },
	  L = {
	    map: D,
	    forEach: D,
	    count: function (n) {
	      return n ? L$1(n).length : 0;
	    },
	    only: function (n) {
	      var t = L$1(n);
	      if (1 !== t.length) throw "Children.only";
	      return t[0];
	    },
	    toArray: L$1
	  },
	  O = l$1.__e;
	l$1.__e = function (n, t, e, r) {
	  if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
	  O(n, t, e, r);
	};
	var F = l$1.unmount;
	function U(n, t, e) {
	  return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
	    "function" == typeof n.__c && n.__c();
	  }), n.__c.__H = null), null != (n = function (n, t) {
	    for (var e in t) n[e] = t[e];
	    return n;
	  }({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
	    return U(n, t, e);
	  })), n;
	}
	function V(n, t, e) {
	  return n && e && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
	    return V(n, t, e);
	  }), n.__c && n.__c.__P === t && (n.__e && e.appendChild(n.__e), n.__c.__e = !0, n.__c.__P = e)), n;
	}
	function W() {
	  this.__u = 0, this.o = null, this.__b = null;
	}
	function P(n) {
	  var t = n.__.__c;
	  return t && t.__a && t.__a(n);
	}
	function j(n) {
	  var e, r, u;
	  function o(o) {
	    if (e || (e = n()).then(function (n) {
	      r = n.default || n;
	    }, function (n) {
	      u = n;
	    }), u) throw u;
	    if (!r) throw e;
	    return g$2(r, o);
	  }
	  return o.displayName = "Lazy", o.__f = !0, o;
	}
	function z() {
	  this.i = null, this.l = null;
	}
	l$1.unmount = function (n) {
	  var t = n.__c;
	  t && t.__R && t.__R(), t && 32 & n.__u && (n.type = null), F && F(n);
	}, (W.prototype = new x$2()).__c = function (n, t) {
	  var e = t.__c,
	    r = this;
	  null == r.o && (r.o = []), r.o.push(e);
	  var u = P(r.__v),
	    o = !1,
	    i = function () {
	      o || (o = !0, e.__R = null, u ? u(c) : c());
	    };
	  e.__R = i;
	  var c = function () {
	    if (! --r.__u) {
	      if (r.state.__a) {
	        var n = r.state.__a;
	        r.__v.__k[0] = V(n, n.__c.__P, n.__c.__O);
	      }
	      var t;
	      for (r.setState({
	        __a: r.__b = null
	      }); t = r.o.pop();) t.forceUpdate();
	    }
	  };
	  r.__u++ || 32 & t.__u || r.setState({
	    __a: r.__b = r.__v.__k[0]
	  }), n.then(i, i);
	}, W.prototype.componentWillUnmount = function () {
	  this.o = [];
	}, W.prototype.render = function (n, e) {
	  if (this.__b) {
	    if (this.__v.__k) {
	      var r = document.createElement("div"),
	        o = this.__v.__k[0].__c;
	      this.__v.__k[0] = U(this.__b, r, o.__O = o.__P);
	    }
	    this.__b = null;
	  }
	  var i = e.__a && g$2(k$2, null, n.fallback);
	  return i && (i.__u &= -33), [g$2(k$2, null, e.__a ? null : n.children), i];
	};
	var B = function (n, t, e) {
	  if (++e[1] === e[0] && n.l.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.l.size)) for (e = n.i; e;) {
	    for (; e.length > 3;) e.pop()();
	    if (e[1] < e[0]) break;
	    n.i = e = e[2];
	  }
	};
	function H(n) {
	  return this.getChildContext = function () {
	    return n.context;
	  }, n.children;
	}
	function Z(n) {
	  var e = this,
	    r = n.h;
	  e.componentWillUnmount = function () {
	    D$2(null, e.v), e.v = null, e.h = null;
	  }, e.h && e.h !== r && e.componentWillUnmount(), e.v || (e.h = r, e.v = {
	    nodeType: 1,
	    parentNode: r,
	    childNodes: [],
	    contains: function () {
	      return !0;
	    },
	    appendChild: function (n) {
	      this.childNodes.push(n), e.h.appendChild(n);
	    },
	    insertBefore: function (n, t) {
	      this.childNodes.push(n), e.h.insertBefore(n, t);
	    },
	    removeChild: function (n) {
	      this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), e.h.removeChild(n);
	    }
	  }), D$2(g$2(H, {
	    context: e.context
	  }, n.__v), e.v);
	}
	function Y(n, e) {
	  var r = g$2(Z, {
	    __v: n,
	    h: e
	  });
	  return r.containerInfo = e, r;
	}
	(z.prototype = new x$2()).__a = function (n) {
	  var t = this,
	    e = P(t.__v),
	    r = t.l.get(n);
	  return r[0]++, function (u) {
	    var o = function () {
	      t.props.revealOrder ? (r.push(u), B(t, n, r)) : u();
	    };
	    e ? e(o) : o();
	  };
	}, z.prototype.render = function (n) {
	  this.i = null, this.l = new Map();
	  var t = L$1(n.children);
	  n.revealOrder && "b" === n.revealOrder[0] && t.reverse();
	  for (var e = t.length; e--;) this.l.set(t[e], this.i = [1, 0, this.i]);
	  return n.children;
	}, z.prototype.componentDidUpdate = z.prototype.componentDidMount = function () {
	  var n = this;
	  this.l.forEach(function (t, e) {
	    B(n, e, t);
	  });
	};
	var $ = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
	  q = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
	  G = /^on(Ani|Tra|Tou|BeforeInp|Compo)/,
	  J = /[A-Z0-9]/g,
	  K = "undefined" != typeof document,
	  Q = function (n) {
	    return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n);
	  };
	function X(n, t, e) {
	  return null == t.__k && (t.textContent = ""), D$2(n, t), "function" == typeof e && e(), n ? n.__c : null;
	}
	function nn(n, t, e) {
	  return E$1(n, t), "function" == typeof e && e(), n ? n.__c : null;
	}
	x$2.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
	  Object.defineProperty(x$2.prototype, t, {
	    configurable: !0,
	    get: function () {
	      return this["UNSAFE_" + t];
	    },
	    set: function (n) {
	      Object.defineProperty(this, t, {
	        configurable: !0,
	        writable: !0,
	        value: n
	      });
	    }
	  });
	});
	var tn = l$1.event;
	function en() {}
	function rn() {
	  return this.cancelBubble;
	}
	function un() {
	  return this.defaultPrevented;
	}
	l$1.event = function (n) {
	  return tn && (n = tn(n)), n.persist = en, n.isPropagationStopped = rn, n.isDefaultPrevented = un, n.nativeEvent = n;
	};
	var on,
	  cn = {
	    enumerable: !1,
	    configurable: !0,
	    get: function () {
	      return this.class;
	    }
	  },
	  fn = l$1.vnode;
	l$1.vnode = function (n) {
	  "string" == typeof n.type && function (n) {
	    var t = n.props,
	      e = n.type,
	      u = {},
	      o = -1 === e.indexOf("-");
	    for (var i in t) {
	      var c = t[i];
	      if (!("value" === i && "defaultValue" in t && null == c || K && "children" === i && "noscript" === e || "class" === i || "className" === i)) {
	        var f = i.toLowerCase();
	        "defaultValue" === i && "value" in t && null == t.value ? i = "value" : "download" === i && !0 === c ? c = "" : "translate" === f && "no" === c ? c = !1 : "o" === f[0] && "n" === f[1] ? "ondoubleclick" === f ? i = "ondblclick" : "onchange" !== f || "input" !== e && "textarea" !== e || Q(t.type) ? "onfocus" === f ? i = "onfocusin" : "onblur" === f ? i = "onfocusout" : G.test(i) && (i = f) : f = i = "oninput" : o && q.test(i) ? i = i.replace(J, "-$&").toLowerCase() : null === c && (c = void 0), "oninput" === f && u[i = f] && (i = "oninputCapture"), u[i] = c;
	      }
	    }
	    "select" == e && u.multiple && Array.isArray(u.value) && (u.value = L$1(t.children).forEach(function (n) {
	      n.props.selected = -1 != u.value.indexOf(n.props.value);
	    })), "select" == e && null != u.defaultValue && (u.value = L$1(t.children).forEach(function (n) {
	      n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
	    })), t.class && !t.className ? (u.class = t.class, Object.defineProperty(u, "className", cn)) : (t.className && !t.class || t.class && t.className) && (u.class = u.className = t.className), n.props = u;
	  }(n), n.$$typeof = $, fn && fn(n);
	};
	var ln = l$1.__r;
	l$1.__r = function (n) {
	  ln && ln(n), on = n.__c;
	};
	var an = l$1.diffed;
	l$1.diffed = function (n) {
	  an && an(n);
	  var t = n.props,
	    e = n.__e;
	  null != e && "textarea" === n.type && "value" in t && t.value !== e.value && (e.value = null == t.value ? "" : t.value), on = null;
	};
	var sn = {
	    ReactCurrentDispatcher: {
	      current: {
	        readContext: function (n) {
	          return on.__n[n.__c].props.value;
	        },
	        useCallback: q$1,
	        useContext: x$1,
	        useDebugValue: P$1,
	        useDeferredValue: R,
	        useEffect: y,
	        useId: g$1,
	        useImperativeHandle: F$1,
	        useInsertionEffect: k,
	        useLayoutEffect: _,
	        useMemo: T$1,
	        useReducer: p,
	        useRef: A$1,
	        useState: h,
	        useSyncExternalStore: E,
	        useTransition: w
	      }
	    }
	  };
	function vn(n) {
	  return g$2.bind(null, n);
	}
	function dn(n) {
	  return !!n && n.$$typeof === $;
	}
	function pn(n) {
	  return dn(n) && n.type === k$2;
	}
	function mn(n) {
	  return !!n && !!n.displayName && ("string" == typeof n.displayName || n.displayName instanceof String) && n.displayName.startsWith("Memo(");
	}
	function yn(n) {
	  return dn(n) ? G$1.apply(null, arguments) : n;
	}
	function _n(n) {
	  return !!n.__k && (D$2(null, n), !0);
	}
	function bn(n) {
	  return n && (n.base || 1 === n.nodeType && n) || null;
	}
	var Sn = function (n, t) {
	    return n(t);
	  },
	  gn = function (n, t) {
	    return n(t);
	  },
	  En = k$2,
	  Cn = dn,
	  xn = {
	    useState: h,
	    useId: g$1,
	    useReducer: p,
	    useEffect: y,
	    useLayoutEffect: _,
	    useInsertionEffect: k,
	    useTransition: w,
	    useDeferredValue: R,
	    useSyncExternalStore: E,
	    startTransition: x,
	    useRef: A$1,
	    useImperativeHandle: F$1,
	    useMemo: T$1,
	    useCallback: q$1,
	    useContext: x$1,
	    useDebugValue: P$1,
	    version: "18.3.1",
	    Children: L,
	    render: X,
	    hydrate: nn,
	    unmountComponentAtNode: _n,
	    createPortal: Y,
	    createElement: g$2,
	    createContext: J$1,
	    createFactory: vn,
	    cloneElement: yn,
	    createRef: b,
	    Fragment: k$2,
	    isValidElement: dn,
	    isElement: Cn,
	    isFragment: pn,
	    isMemo: mn,
	    findDOMNode: bn,
	    Component: x$2,
	    PureComponent: I,
	    memo: N,
	    forwardRef: A,
	    flushSync: gn,
	    unstable_batchedUpdates: Sn,
	    StrictMode: En,
	    Suspense: W,
	    SuspenseList: z,
	    lazy: j,
	    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: sn
	  };

	function bind(fn, thisArg) {
	  return function wrap() {
	    return fn.apply(thisArg, arguments);
	  };
	}

	// utils is a library of generic helper functions non-specific to axios

	const {
	  toString
	} = Object.prototype;
	const {
	  getPrototypeOf
	} = Object;
	const kindOf = (cache => thing => {
	  const str = toString.call(thing);
	  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
	})(Object.create(null));
	const kindOfTest = type => {
	  type = type.toLowerCase();
	  return thing => kindOf(thing) === type;
	};
	const typeOfTest = type => thing => typeof thing === type;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 *
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	const {
	  isArray
	} = Array;

	/**
	 * Determine if a value is undefined
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	const isUndefined = typeOfTest('undefined');

	/**
	 * Determine if a value is a Buffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Buffer, otherwise false
	 */
	function isBuffer(val) {
	  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	const isArrayBuffer = kindOfTest('ArrayBuffer');

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  let result;
	  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = val && val.buffer && isArrayBuffer(val.buffer);
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	const isString = typeOfTest('string');

	/**
	 * Determine if a value is a Function
	 *
	 * @param {*} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	const isFunction = typeOfTest('function');

	/**
	 * Determine if a value is a Number
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	const isNumber = typeOfTest('number');

	/**
	 * Determine if a value is an Object
	 *
	 * @param {*} thing The value to test
	 *
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	const isObject = thing => thing !== null && typeof thing === 'object';

	/**
	 * Determine if a value is a Boolean
	 *
	 * @param {*} thing The value to test
	 * @returns {boolean} True if value is a Boolean, otherwise false
	 */
	const isBoolean = thing => thing === true || thing === false;

	/**
	 * Determine if a value is a plain Object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a plain Object, otherwise false
	 */
	const isPlainObject = val => {
	  if (kindOf(val) !== 'object') {
	    return false;
	  }
	  const prototype = getPrototypeOf(val);
	  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
	};

	/**
	 * Determine if a value is a Date
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	const isDate = kindOfTest('Date');

	/**
	 * Determine if a value is a File
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	const isFile = kindOfTest('File');

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	const isBlob = kindOfTest('Blob');

	/**
	 * Determine if a value is a FileList
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	const isFileList = kindOfTest('FileList');

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	const isStream = val => isObject(val) && isFunction(val.pipe);

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {*} thing The value to test
	 *
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	const isFormData = thing => {
	  let kind;
	  return thing && (typeof FormData === 'function' && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === 'formdata' ||
	  // detect form-data instance
	  kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]'));
	};

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	const isURLSearchParams = kindOfTest('URLSearchParams');
	const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 *
	 * @returns {String} The String freed of excess whitespace
	 */
	const trim = str => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 *
	 * @param {Boolean} [allOwnKeys = false]
	 * @returns {any}
	 */
	function forEach(obj, fn, {
	  allOwnKeys = false
	} = {}) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }
	  let i;
	  let l;

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }
	  if (isArray(obj)) {
	    // Iterate over array values
	    for (i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
	    const len = keys.length;
	    let key;
	    for (i = 0; i < len; i++) {
	      key = keys[i];
	      fn.call(null, obj[key], key, obj);
	    }
	  }
	}
	function findKey(obj, key) {
	  key = key.toLowerCase();
	  const keys = Object.keys(obj);
	  let i = keys.length;
	  let _key;
	  while (i-- > 0) {
	    _key = keys[i];
	    if (key === _key.toLowerCase()) {
	      return _key;
	    }
	  }
	  return null;
	}
	const _global = (() => {
	  /*eslint no-undef:0*/
	  if (typeof globalThis !== "undefined") return globalThis;
	  return typeof self !== "undefined" ? self : typeof window !== 'undefined' ? window : global;
	})();
	const isContextDefined = context => !isUndefined(context) && context !== _global;

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 *
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */
	) {
	  const {
	    caseless
	  } = isContextDefined(this) && this || {};
	  const result = {};
	  const assignValue = (val, key) => {
	    const targetKey = caseless && findKey(result, key) || key;
	    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
	      result[targetKey] = merge(result[targetKey], val);
	    } else if (isPlainObject(val)) {
	      result[targetKey] = merge({}, val);
	    } else if (isArray(val)) {
	      result[targetKey] = val.slice();
	    } else {
	      result[targetKey] = val;
	    }
	  };
	  for (let i = 0, l = arguments.length; i < l; i++) {
	    arguments[i] && forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 *
	 * @param {Boolean} [allOwnKeys]
	 * @returns {Object} The resulting value of object a
	 */
	const extend = (a, b, thisArg, {
	  allOwnKeys
	} = {}) => {
	  forEach(b, (val, key) => {
	    if (thisArg && isFunction(val)) {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  }, {
	    allOwnKeys
	  });
	  return a;
	};

	/**
	 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
	 *
	 * @param {string} content with BOM
	 *
	 * @returns {string} content value without BOM
	 */
	const stripBOM = content => {
	  if (content.charCodeAt(0) === 0xFEFF) {
	    content = content.slice(1);
	  }
	  return content;
	};

	/**
	 * Inherit the prototype methods from one constructor into another
	 * @param {function} constructor
	 * @param {function} superConstructor
	 * @param {object} [props]
	 * @param {object} [descriptors]
	 *
	 * @returns {void}
	 */
	const inherits = (constructor, superConstructor, props, descriptors) => {
	  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
	  constructor.prototype.constructor = constructor;
	  Object.defineProperty(constructor, 'super', {
	    value: superConstructor.prototype
	  });
	  props && Object.assign(constructor.prototype, props);
	};

	/**
	 * Resolve object with deep prototype chain to a flat object
	 * @param {Object} sourceObj source object
	 * @param {Object} [destObj]
	 * @param {Function|Boolean} [filter]
	 * @param {Function} [propFilter]
	 *
	 * @returns {Object}
	 */
	const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
	  let props;
	  let i;
	  let prop;
	  const merged = {};
	  destObj = destObj || {};
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  if (sourceObj == null) return destObj;
	  do {
	    props = Object.getOwnPropertyNames(sourceObj);
	    i = props.length;
	    while (i-- > 0) {
	      prop = props[i];
	      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
	        destObj[prop] = sourceObj[prop];
	        merged[prop] = true;
	      }
	    }
	    sourceObj = filter !== false && getPrototypeOf(sourceObj);
	  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
	  return destObj;
	};

	/**
	 * Determines whether a string ends with the characters of a specified string
	 *
	 * @param {String} str
	 * @param {String} searchString
	 * @param {Number} [position= 0]
	 *
	 * @returns {boolean}
	 */
	const endsWith = (str, searchString, position) => {
	  str = String(str);
	  if (position === undefined || position > str.length) {
	    position = str.length;
	  }
	  position -= searchString.length;
	  const lastIndex = str.indexOf(searchString, position);
	  return lastIndex !== -1 && lastIndex === position;
	};

	/**
	 * Returns new array from array like object or null if failed
	 *
	 * @param {*} [thing]
	 *
	 * @returns {?Array}
	 */
	const toArray = thing => {
	  if (!thing) return null;
	  if (isArray(thing)) return thing;
	  let i = thing.length;
	  if (!isNumber(i)) return null;
	  const arr = new Array(i);
	  while (i-- > 0) {
	    arr[i] = thing[i];
	  }
	  return arr;
	};

	/**
	 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
	 * thing passed in is an instance of Uint8Array
	 *
	 * @param {TypedArray}
	 *
	 * @returns {Array}
	 */
	// eslint-disable-next-line func-names
	const isTypedArray = (TypedArray => {
	  // eslint-disable-next-line func-names
	  return thing => {
	    return TypedArray && thing instanceof TypedArray;
	  };
	})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

	/**
	 * For each entry in the object, call the function with the key and value.
	 *
	 * @param {Object<any, any>} obj - The object to iterate over.
	 * @param {Function} fn - The function to call for each entry.
	 *
	 * @returns {void}
	 */
	const forEachEntry = (obj, fn) => {
	  const generator = obj && obj[Symbol.iterator];
	  const iterator = generator.call(obj);
	  let result;
	  while ((result = iterator.next()) && !result.done) {
	    const pair = result.value;
	    fn.call(obj, pair[0], pair[1]);
	  }
	};

	/**
	 * It takes a regular expression and a string, and returns an array of all the matches
	 *
	 * @param {string} regExp - The regular expression to match against.
	 * @param {string} str - The string to search.
	 *
	 * @returns {Array<boolean>}
	 */
	const matchAll = (regExp, str) => {
	  let matches;
	  const arr = [];
	  while ((matches = regExp.exec(str)) !== null) {
	    arr.push(matches);
	  }
	  return arr;
	};

	/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
	const isHTMLForm = kindOfTest('HTMLFormElement');
	const toCamelCase = str => {
	  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
	    return p1.toUpperCase() + p2;
	  });
	};

	/* Creating a function that will check if an object has a property. */
	const hasOwnProperty = (({
	  hasOwnProperty
	}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

	/**
	 * Determine if a value is a RegExp object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a RegExp object, otherwise false
	 */
	const isRegExp = kindOfTest('RegExp');
	const reduceDescriptors = (obj, reducer) => {
	  const descriptors = Object.getOwnPropertyDescriptors(obj);
	  const reducedDescriptors = {};
	  forEach(descriptors, (descriptor, name) => {
	    let ret;
	    if ((ret = reducer(descriptor, name, obj)) !== false) {
	      reducedDescriptors[name] = ret || descriptor;
	    }
	  });
	  Object.defineProperties(obj, reducedDescriptors);
	};

	/**
	 * Makes all methods read-only
	 * @param {Object} obj
	 */

	const freezeMethods = obj => {
	  reduceDescriptors(obj, (descriptor, name) => {
	    // skip restricted props in strict mode
	    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
	      return false;
	    }
	    const value = obj[name];
	    if (!isFunction(value)) return;
	    descriptor.enumerable = false;
	    if ('writable' in descriptor) {
	      descriptor.writable = false;
	      return;
	    }
	    if (!descriptor.set) {
	      descriptor.set = () => {
	        throw Error('Can not rewrite read-only method \'' + name + '\'');
	      };
	    }
	  });
	};
	const toObjectSet = (arrayOrString, delimiter) => {
	  const obj = {};
	  const define = arr => {
	    arr.forEach(value => {
	      obj[value] = true;
	    });
	  };
	  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
	  return obj;
	};
	const noop = () => {};
	const toFiniteNumber = (value, defaultValue) => {
	  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
	};
	const ALPHA = 'abcdefghijklmnopqrstuvwxyz';
	const DIGIT = '0123456789';
	const ALPHABET = {
	  DIGIT,
	  ALPHA,
	  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
	};
	const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
	  let str = '';
	  const {
	    length
	  } = alphabet;
	  while (size--) {
	    str += alphabet[Math.random() * length | 0];
	  }
	  return str;
	};

	/**
	 * If the thing is a FormData object, return true, otherwise return false.
	 *
	 * @param {unknown} thing - The thing to check.
	 *
	 * @returns {boolean}
	 */
	function isSpecCompliantForm(thing) {
	  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
	}
	const toJSONObject = obj => {
	  const stack = new Array(10);
	  const visit = (source, i) => {
	    if (isObject(source)) {
	      if (stack.indexOf(source) >= 0) {
	        return;
	      }
	      if (!('toJSON' in source)) {
	        stack[i] = source;
	        const target = isArray(source) ? [] : {};
	        forEach(source, (value, key) => {
	          const reducedValue = visit(value, i + 1);
	          !isUndefined(reducedValue) && (target[key] = reducedValue);
	        });
	        stack[i] = undefined;
	        return target;
	      }
	    }
	    return source;
	  };
	  return visit(obj, 0);
	};
	const isAsyncFn = kindOfTest('AsyncFunction');
	const isThenable = thing => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

	// original code
	// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

	const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
	  if (setImmediateSupported) {
	    return setImmediate;
	  }
	  return postMessageSupported ? ((token, callbacks) => {
	    _global.addEventListener("message", ({
	      source,
	      data
	    }) => {
	      if (source === _global && data === token) {
	        callbacks.length && callbacks.shift()();
	      }
	    }, false);
	    return cb => {
	      callbacks.push(cb);
	      _global.postMessage(token, "*");
	    };
	  })(`axios@${Math.random()}`, []) : cb => setTimeout(cb);
	})(typeof setImmediate === 'function', isFunction(_global.postMessage));
	const asap = typeof queueMicrotask !== 'undefined' ? queueMicrotask.bind(_global) : typeof process !== 'undefined' && process.nextTick || _setImmediate;

	// *********************

	var utils$1 = {
	  isArray,
	  isArrayBuffer,
	  isBuffer,
	  isFormData,
	  isArrayBufferView,
	  isString,
	  isNumber,
	  isBoolean,
	  isObject,
	  isPlainObject,
	  isReadableStream,
	  isRequest,
	  isResponse,
	  isHeaders,
	  isUndefined,
	  isDate,
	  isFile,
	  isBlob,
	  isRegExp,
	  isFunction,
	  isStream,
	  isURLSearchParams,
	  isTypedArray,
	  isFileList,
	  forEach,
	  merge,
	  extend,
	  trim,
	  stripBOM,
	  inherits,
	  toFlatObject,
	  kindOf,
	  kindOfTest,
	  endsWith,
	  toArray,
	  forEachEntry,
	  matchAll,
	  isHTMLForm,
	  hasOwnProperty,
	  hasOwnProp: hasOwnProperty,
	  // an alias to avoid ESLint no-prototype-builtins detection
	  reduceDescriptors,
	  freezeMethods,
	  toObjectSet,
	  toCamelCase,
	  noop,
	  toFiniteNumber,
	  findKey,
	  global: _global,
	  isContextDefined,
	  ALPHABET,
	  generateString,
	  isSpecCompliantForm,
	  toJSONObject,
	  isAsyncFn,
	  isThenable,
	  setImmediate: _setImmediate,
	  asap
	};

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [config] The config.
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 *
	 * @returns {Error} The created error.
	 */
	function AxiosError(message, code, config, request, response) {
	  Error.call(this);
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.message = message;
	  this.name = 'AxiosError';
	  code && (this.code = code);
	  config && (this.config = config);
	  request && (this.request = request);
	  if (response) {
	    this.response = response;
	    this.status = response.status ? response.status : null;
	  }
	}
	utils$1.inherits(AxiosError, Error, {
	  toJSON: function toJSON() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: utils$1.toJSONObject(this.config),
	      code: this.code,
	      status: this.status
	    };
	  }
	});
	const prototype$1 = AxiosError.prototype;
	const descriptors = {};
	['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED', 'ERR_NOT_SUPPORT', 'ERR_INVALID_URL'
	// eslint-disable-next-line func-names
	].forEach(code => {
	  descriptors[code] = {
	    value: code
	  };
	});
	Object.defineProperties(AxiosError, descriptors);
	Object.defineProperty(prototype$1, 'isAxiosError', {
	  value: true
	});

	// eslint-disable-next-line func-names
	AxiosError.from = (error, code, config, request, response, customProps) => {
	  const axiosError = Object.create(prototype$1);
	  utils$1.toFlatObject(error, axiosError, function filter(obj) {
	    return obj !== Error.prototype;
	  }, prop => {
	    return prop !== 'isAxiosError';
	  });
	  AxiosError.call(axiosError, error.message, code, config, request, response);
	  axiosError.cause = error;
	  axiosError.name = error.name;
	  customProps && Object.assign(axiosError, customProps);
	  return axiosError;
	};

	// eslint-disable-next-line strict
	var httpAdapter = null;

	/**
	 * Determines if the given thing is a array or js object.
	 *
	 * @param {string} thing - The object or array to be visited.
	 *
	 * @returns {boolean}
	 */
	function isVisitable(thing) {
	  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
	}

	/**
	 * It removes the brackets from the end of a string
	 *
	 * @param {string} key - The key of the parameter.
	 *
	 * @returns {string} the key without the brackets.
	 */
	function removeBrackets(key) {
	  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
	}

	/**
	 * It takes a path, a key, and a boolean, and returns a string
	 *
	 * @param {string} path - The path to the current key.
	 * @param {string} key - The key of the current object being iterated over.
	 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
	 *
	 * @returns {string} The path to the current key.
	 */
	function renderKey(path, key, dots) {
	  if (!path) return key;
	  return path.concat(key).map(function each(token, i) {
	    // eslint-disable-next-line no-param-reassign
	    token = removeBrackets(token);
	    return !dots && i ? '[' + token + ']' : token;
	  }).join(dots ? '.' : '');
	}

	/**
	 * If the array is an array and none of its elements are visitable, then it's a flat array.
	 *
	 * @param {Array<any>} arr - The array to check
	 *
	 * @returns {boolean}
	 */
	function isFlatArray(arr) {
	  return utils$1.isArray(arr) && !arr.some(isVisitable);
	}
	const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
	  return /^is[A-Z]/.test(prop);
	});

	/**
	 * Convert a data object to FormData
	 *
	 * @param {Object} obj
	 * @param {?Object} [formData]
	 * @param {?Object} [options]
	 * @param {Function} [options.visitor]
	 * @param {Boolean} [options.metaTokens = true]
	 * @param {Boolean} [options.dots = false]
	 * @param {?Boolean} [options.indexes = false]
	 *
	 * @returns {Object}
	 **/

	/**
	 * It converts an object into a FormData object
	 *
	 * @param {Object<any, any>} obj - The object to convert to form data.
	 * @param {string} formData - The FormData object to append to.
	 * @param {Object<string, any>} options
	 *
	 * @returns
	 */
	function toFormData(obj, formData, options) {
	  if (!utils$1.isObject(obj)) {
	    throw new TypeError('target must be an object');
	  }

	  // eslint-disable-next-line no-param-reassign
	  formData = formData || new (FormData)();

	  // eslint-disable-next-line no-param-reassign
	  options = utils$1.toFlatObject(options, {
	    metaTokens: true,
	    dots: false,
	    indexes: false
	  }, false, function defined(option, source) {
	    // eslint-disable-next-line no-eq-null,eqeqeq
	    return !utils$1.isUndefined(source[option]);
	  });
	  const metaTokens = options.metaTokens;
	  // eslint-disable-next-line no-use-before-define
	  const visitor = options.visitor || defaultVisitor;
	  const dots = options.dots;
	  const indexes = options.indexes;
	  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
	  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
	  if (!utils$1.isFunction(visitor)) {
	    throw new TypeError('visitor must be a function');
	  }
	  function convertValue(value) {
	    if (value === null) return '';
	    if (utils$1.isDate(value)) {
	      return value.toISOString();
	    }
	    if (!useBlob && utils$1.isBlob(value)) {
	      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
	    }
	    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
	      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
	    }
	    return value;
	  }

	  /**
	   * Default visitor.
	   *
	   * @param {*} value
	   * @param {String|Number} key
	   * @param {Array<String|Number>} path
	   * @this {FormData}
	   *
	   * @returns {boolean} return true to visit the each prop of the value recursively
	   */
	  function defaultVisitor(value, key, path) {
	    let arr = value;
	    if (value && !path && typeof value === 'object') {
	      if (utils$1.endsWith(key, '{}')) {
	        // eslint-disable-next-line no-param-reassign
	        key = metaTokens ? key : key.slice(0, -2);
	        // eslint-disable-next-line no-param-reassign
	        value = JSON.stringify(value);
	      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))) {
	        // eslint-disable-next-line no-param-reassign
	        key = removeBrackets(key);
	        arr.forEach(function each(el, index) {
	          !(utils$1.isUndefined(el) || el === null) && formData.append(
	          // eslint-disable-next-line no-nested-ternary
	          indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + '[]', convertValue(el));
	        });
	        return false;
	      }
	    }
	    if (isVisitable(value)) {
	      return true;
	    }
	    formData.append(renderKey(path, key, dots), convertValue(value));
	    return false;
	  }
	  const stack = [];
	  const exposedHelpers = Object.assign(predicates, {
	    defaultVisitor,
	    convertValue,
	    isVisitable
	  });
	  function build(value, path) {
	    if (utils$1.isUndefined(value)) return;
	    if (stack.indexOf(value) !== -1) {
	      throw Error('Circular reference detected in ' + path.join('.'));
	    }
	    stack.push(value);
	    utils$1.forEach(value, function each(el, key) {
	      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers);
	      if (result === true) {
	        build(el, path ? path.concat(key) : [key]);
	      }
	    });
	    stack.pop();
	  }
	  if (!utils$1.isObject(obj)) {
	    throw new TypeError('data must be an object');
	  }
	  build(obj);
	  return formData;
	}

	/**
	 * It encodes a string by replacing all characters that are not in the unreserved set with
	 * their percent-encoded equivalents
	 *
	 * @param {string} str - The string to encode.
	 *
	 * @returns {string} The encoded string.
	 */
	function encode$1(str) {
	  const charMap = {
	    '!': '%21',
	    "'": '%27',
	    '(': '%28',
	    ')': '%29',
	    '~': '%7E',
	    '%20': '+',
	    '%00': '\x00'
	  };
	  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
	    return charMap[match];
	  });
	}

	/**
	 * It takes a params object and converts it to a FormData object
	 *
	 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
	 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
	 *
	 * @returns {void}
	 */
	function AxiosURLSearchParams(params, options) {
	  this._pairs = [];
	  params && toFormData(params, this, options);
	}
	const prototype = AxiosURLSearchParams.prototype;
	prototype.append = function append(name, value) {
	  this._pairs.push([name, value]);
	};
	prototype.toString = function toString(encoder) {
	  const _encode = encoder ? function (value) {
	    return encoder.call(this, value, encode$1);
	  } : encode$1;
	  return this._pairs.map(function each(pair) {
	    return _encode(pair[0]) + '=' + _encode(pair[1]);
	  }, '').join('&');
	};

	/**
	 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
	 * URI encoded counterparts
	 *
	 * @param {string} val The value to be encoded.
	 *
	 * @returns {string} The encoded value.
	 */
	function encode(val) {
	  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @param {?(object|Function)} options
	 *
	 * @returns {string} The formatted url
	 */
	function buildURL(url, params, options) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }
	  const _encode = options && options.encode || encode;
	  if (utils$1.isFunction(options)) {
	    options = {
	      serialize: options
	    };
	  }
	  const serializeFn = options && options.serialize;
	  let serializedParams;
	  if (serializeFn) {
	    serializedParams = serializeFn(params, options);
	  } else {
	    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
	  }
	  if (serializedParams) {
	    const hashmarkIndex = url.indexOf("#");
	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }
	  return url;
	}

	class InterceptorManager {
	  constructor() {
	    this.handlers = [];
	  }

	  /**
	   * Add a new interceptor to the stack
	   *
	   * @param {Function} fulfilled The function to handle `then` for a `Promise`
	   * @param {Function} rejected The function to handle `reject` for a `Promise`
	   *
	   * @return {Number} An ID used to remove interceptor later
	   */
	  use(fulfilled, rejected, options) {
	    this.handlers.push({
	      fulfilled,
	      rejected,
	      synchronous: options ? options.synchronous : false,
	      runWhen: options ? options.runWhen : null
	    });
	    return this.handlers.length - 1;
	  }

	  /**
	   * Remove an interceptor from the stack
	   *
	   * @param {Number} id The ID that was returned by `use`
	   *
	   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
	   */
	  eject(id) {
	    if (this.handlers[id]) {
	      this.handlers[id] = null;
	    }
	  }

	  /**
	   * Clear all interceptors from the stack
	   *
	   * @returns {void}
	   */
	  clear() {
	    if (this.handlers) {
	      this.handlers = [];
	    }
	  }

	  /**
	   * Iterate over all the registered interceptors
	   *
	   * This method is particularly useful for skipping over any
	   * interceptors that may have become `null` calling `eject`.
	   *
	   * @param {Function} fn The function to call for each interceptor
	   *
	   * @returns {void}
	   */
	  forEach(fn) {
	    utils$1.forEach(this.handlers, function forEachHandler(h) {
	      if (h !== null) {
	        fn(h);
	      }
	    });
	  }
	}

	var transitionalDefaults = {
	  silentJSONParsing: true,
	  forcedJSONParsing: true,
	  clarifyTimeoutError: false
	};

	var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

	var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

	var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

	var platform$1 = {
	  isBrowser: true,
	  classes: {
	    URLSearchParams: URLSearchParams$1,
	    FormData: FormData$1,
	    Blob: Blob$1
	  },
	  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
	};

	const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';
	const _navigator = typeof navigator === 'object' && navigator || undefined;

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 * nativescript
	 *  navigator.product -> 'NativeScript' or 'NS'
	 *
	 * @returns {boolean}
	 */
	const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

	/**
	 * Determine if we're running in a standard browser webWorker environment
	 *
	 * Although the `isStandardBrowserEnv` method indicates that
	 * `allows axios to run in a web worker`, the WebWorker will still be
	 * filtered out due to its judgment standard
	 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
	 * This leads to a problem when axios post `FormData` in webWorker
	 */
	const hasStandardBrowserWebWorkerEnv = (() => {
	  return typeof WorkerGlobalScope !== 'undefined' &&
	  // eslint-disable-next-line no-undef
	  self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';
	})();
	const origin = hasBrowserEnv && window.location.href || 'http://localhost';

	var utils = /*#__PURE__*/Object.freeze({
		__proto__: null,
		hasBrowserEnv: hasBrowserEnv,
		hasStandardBrowserEnv: hasStandardBrowserEnv,
		hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
		navigator: _navigator,
		origin: origin
	});

	var platform = {
	  ...utils,
	  ...platform$1
	};

	function toURLEncodedForm(data, options) {
	  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
	    visitor: function (value, key, path, helpers) {
	      if (platform.isNode && utils$1.isBuffer(value)) {
	        this.append(key, value.toString('base64'));
	        return false;
	      }
	      return helpers.defaultVisitor.apply(this, arguments);
	    }
	  }, options));
	}

	/**
	 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
	 *
	 * @param {string} name - The name of the property to get.
	 *
	 * @returns An array of strings.
	 */
	function parsePropPath(name) {
	  // foo[x][y][z]
	  // foo.x.y.z
	  // foo-x-y-z
	  // foo x y z
	  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
	    return match[0] === '[]' ? '' : match[1] || match[0];
	  });
	}

	/**
	 * Convert an array to an object.
	 *
	 * @param {Array<any>} arr - The array to convert to an object.
	 *
	 * @returns An object with the same keys and values as the array.
	 */
	function arrayToObject(arr) {
	  const obj = {};
	  const keys = Object.keys(arr);
	  let i;
	  const len = keys.length;
	  let key;
	  for (i = 0; i < len; i++) {
	    key = keys[i];
	    obj[key] = arr[key];
	  }
	  return obj;
	}

	/**
	 * It takes a FormData object and returns a JavaScript object
	 *
	 * @param {string} formData The FormData object to convert to JSON.
	 *
	 * @returns {Object<string, any> | null} The converted object.
	 */
	function formDataToJSON(formData) {
	  function buildPath(path, value, target, index) {
	    let name = path[index++];
	    if (name === '__proto__') return true;
	    const isNumericKey = Number.isFinite(+name);
	    const isLast = index >= path.length;
	    name = !name && utils$1.isArray(target) ? target.length : name;
	    if (isLast) {
	      if (utils$1.hasOwnProp(target, name)) {
	        target[name] = [target[name], value];
	      } else {
	        target[name] = value;
	      }
	      return !isNumericKey;
	    }
	    if (!target[name] || !utils$1.isObject(target[name])) {
	      target[name] = [];
	    }
	    const result = buildPath(path, value, target[name], index);
	    if (result && utils$1.isArray(target[name])) {
	      target[name] = arrayToObject(target[name]);
	    }
	    return !isNumericKey;
	  }
	  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
	    const obj = {};
	    utils$1.forEachEntry(formData, (name, value) => {
	      buildPath(parsePropPath(name), value, obj, 0);
	    });
	    return obj;
	  }
	  return null;
	}

	/**
	 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
	 * of the input
	 *
	 * @param {any} rawValue - The value to be stringified.
	 * @param {Function} parser - A function that parses a string into a JavaScript object.
	 * @param {Function} encoder - A function that takes a value and returns a string.
	 *
	 * @returns {string} A stringified version of the rawValue.
	 */
	function stringifySafely(rawValue, parser, encoder) {
	  if (utils$1.isString(rawValue)) {
	    try {
	      (parser || JSON.parse)(rawValue);
	      return utils$1.trim(rawValue);
	    } catch (e) {
	      if (e.name !== 'SyntaxError') {
	        throw e;
	      }
	    }
	  }
	  return (0, JSON.stringify)(rawValue);
	}
	const defaults = {
	  transitional: transitionalDefaults,
	  adapter: ['xhr', 'http', 'fetch'],
	  transformRequest: [function transformRequest(data, headers) {
	    const contentType = headers.getContentType() || '';
	    const hasJSONContentType = contentType.indexOf('application/json') > -1;
	    const isObjectPayload = utils$1.isObject(data);
	    if (isObjectPayload && utils$1.isHTMLForm(data)) {
	      data = new FormData(data);
	    }
	    const isFormData = utils$1.isFormData(data);
	    if (isFormData) {
	      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
	    }
	    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
	      return data;
	    }
	    if (utils$1.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils$1.isURLSearchParams(data)) {
	      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
	      return data.toString();
	    }
	    let isFileList;
	    if (isObjectPayload) {
	      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
	        return toURLEncodedForm(data, this.formSerializer).toString();
	      }
	      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
	        const _FormData = this.env && this.env.FormData;
	        return toFormData(isFileList ? {
	          'files[]': data
	        } : data, _FormData && new _FormData(), this.formSerializer);
	      }
	    }
	    if (isObjectPayload || hasJSONContentType) {
	      headers.setContentType('application/json', false);
	      return stringifySafely(data);
	    }
	    return data;
	  }],
	  transformResponse: [function transformResponse(data) {
	    const transitional = this.transitional || defaults.transitional;
	    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
	    const JSONRequested = this.responseType === 'json';
	    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
	      return data;
	    }
	    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
	      const silentJSONParsing = transitional && transitional.silentJSONParsing;
	      const strictJSONParsing = !silentJSONParsing && JSONRequested;
	      try {
	        return JSON.parse(data);
	      } catch (e) {
	        if (strictJSONParsing) {
	          if (e.name === 'SyntaxError') {
	            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
	          }
	          throw e;
	        }
	      }
	    }
	    return data;
	  }],
	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,
	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',
	  maxContentLength: -1,
	  maxBodyLength: -1,
	  env: {
	    FormData: platform.classes.FormData,
	    Blob: platform.classes.Blob
	  },
	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  },
	  headers: {
	    common: {
	      'Accept': 'application/json, text/plain, */*',
	      'Content-Type': undefined
	    }
	  }
	};
	utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], method => {
	  defaults.headers[method] = {};
	});

	// RawAxiosHeaders whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	const ignoreDuplicateOf = utils$1.toObjectSet(['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']);

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} rawHeaders Headers needing to be parsed
	 *
	 * @returns {Object} Headers parsed into an object
	 */
	var parseHeaders = rawHeaders => {
	  const parsed = {};
	  let key;
	  let val;
	  let i;
	  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
	    i = line.indexOf(':');
	    key = line.substring(0, i).trim().toLowerCase();
	    val = line.substring(i + 1).trim();
	    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
	      return;
	    }
	    if (key === 'set-cookie') {
	      if (parsed[key]) {
	        parsed[key].push(val);
	      } else {
	        parsed[key] = [val];
	      }
	    } else {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });
	  return parsed;
	};

	const $internals = Symbol('internals');
	function normalizeHeader(header) {
	  return header && String(header).trim().toLowerCase();
	}
	function normalizeValue(value) {
	  if (value === false || value == null) {
	    return value;
	  }
	  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
	}
	function parseTokens(str) {
	  const tokens = Object.create(null);
	  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
	  let match;
	  while (match = tokensRE.exec(str)) {
	    tokens[match[1]] = match[2];
	  }
	  return tokens;
	}
	const isValidHeaderName = str => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
	function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
	  if (utils$1.isFunction(filter)) {
	    return filter.call(this, value, header);
	  }
	  if (isHeaderNameFilter) {
	    value = header;
	  }
	  if (!utils$1.isString(value)) return;
	  if (utils$1.isString(filter)) {
	    return value.indexOf(filter) !== -1;
	  }
	  if (utils$1.isRegExp(filter)) {
	    return filter.test(value);
	  }
	}
	function formatHeader(header) {
	  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
	    return char.toUpperCase() + str;
	  });
	}
	function buildAccessors(obj, header) {
	  const accessorName = utils$1.toCamelCase(' ' + header);
	  ['get', 'set', 'has'].forEach(methodName => {
	    Object.defineProperty(obj, methodName + accessorName, {
	      value: function (arg1, arg2, arg3) {
	        return this[methodName].call(this, header, arg1, arg2, arg3);
	      },
	      configurable: true
	    });
	  });
	}
	class AxiosHeaders {
	  constructor(headers) {
	    headers && this.set(headers);
	  }
	  set(header, valueOrRewrite, rewrite) {
	    const self = this;
	    function setHeader(_value, _header, _rewrite) {
	      const lHeader = normalizeHeader(_header);
	      if (!lHeader) {
	        throw new Error('header name must be a non-empty string');
	      }
	      const key = utils$1.findKey(self, lHeader);
	      if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {
	        self[key || _header] = normalizeValue(_value);
	      }
	    }
	    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
	    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
	      setHeaders(header, valueOrRewrite);
	    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
	      setHeaders(parseHeaders(header), valueOrRewrite);
	    } else if (utils$1.isHeaders(header)) {
	      for (const [key, value] of header.entries()) {
	        setHeader(value, key, rewrite);
	      }
	    } else {
	      header != null && setHeader(valueOrRewrite, header, rewrite);
	    }
	    return this;
	  }
	  get(header, parser) {
	    header = normalizeHeader(header);
	    if (header) {
	      const key = utils$1.findKey(this, header);
	      if (key) {
	        const value = this[key];
	        if (!parser) {
	          return value;
	        }
	        if (parser === true) {
	          return parseTokens(value);
	        }
	        if (utils$1.isFunction(parser)) {
	          return parser.call(this, value, key);
	        }
	        if (utils$1.isRegExp(parser)) {
	          return parser.exec(value);
	        }
	        throw new TypeError('parser must be boolean|regexp|function');
	      }
	    }
	  }
	  has(header, matcher) {
	    header = normalizeHeader(header);
	    if (header) {
	      const key = utils$1.findKey(this, header);
	      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
	    }
	    return false;
	  }
	  delete(header, matcher) {
	    const self = this;
	    let deleted = false;
	    function deleteHeader(_header) {
	      _header = normalizeHeader(_header);
	      if (_header) {
	        const key = utils$1.findKey(self, _header);
	        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
	          delete self[key];
	          deleted = true;
	        }
	      }
	    }
	    if (utils$1.isArray(header)) {
	      header.forEach(deleteHeader);
	    } else {
	      deleteHeader(header);
	    }
	    return deleted;
	  }
	  clear(matcher) {
	    const keys = Object.keys(this);
	    let i = keys.length;
	    let deleted = false;
	    while (i--) {
	      const key = keys[i];
	      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
	        delete this[key];
	        deleted = true;
	      }
	    }
	    return deleted;
	  }
	  normalize(format) {
	    const self = this;
	    const headers = {};
	    utils$1.forEach(this, (value, header) => {
	      const key = utils$1.findKey(headers, header);
	      if (key) {
	        self[key] = normalizeValue(value);
	        delete self[header];
	        return;
	      }
	      const normalized = format ? formatHeader(header) : String(header).trim();
	      if (normalized !== header) {
	        delete self[header];
	      }
	      self[normalized] = normalizeValue(value);
	      headers[normalized] = true;
	    });
	    return this;
	  }
	  concat(...targets) {
	    return this.constructor.concat(this, ...targets);
	  }
	  toJSON(asStrings) {
	    const obj = Object.create(null);
	    utils$1.forEach(this, (value, header) => {
	      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
	    });
	    return obj;
	  }
	  [Symbol.iterator]() {
	    return Object.entries(this.toJSON())[Symbol.iterator]();
	  }
	  toString() {
	    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
	  }
	  get [Symbol.toStringTag]() {
	    return 'AxiosHeaders';
	  }
	  static from(thing) {
	    return thing instanceof this ? thing : new this(thing);
	  }
	  static concat(first, ...targets) {
	    const computed = new this(first);
	    targets.forEach(target => computed.set(target));
	    return computed;
	  }
	  static accessor(header) {
	    const internals = this[$internals] = this[$internals] = {
	      accessors: {}
	    };
	    const accessors = internals.accessors;
	    const prototype = this.prototype;
	    function defineAccessor(_header) {
	      const lHeader = normalizeHeader(_header);
	      if (!accessors[lHeader]) {
	        buildAccessors(prototype, _header);
	        accessors[lHeader] = true;
	      }
	    }
	    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
	    return this;
	  }
	}
	AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

	// reserved names hotfix
	utils$1.reduceDescriptors(AxiosHeaders.prototype, ({
	  value
	}, key) => {
	  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
	  return {
	    get: () => value,
	    set(headerValue) {
	      this[mapped] = headerValue;
	    }
	  };
	});
	utils$1.freezeMethods(AxiosHeaders);

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Array|Function} fns A single function or Array of functions
	 * @param {?Object} response The response object
	 *
	 * @returns {*} The resulting transformed data
	 */
	function transformData(fns, response) {
	  const config = this || defaults;
	  const context = response || config;
	  const headers = AxiosHeaders.from(context.headers);
	  let data = context.data;
	  utils$1.forEach(fns, function transform(fn) {
	    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
	  });
	  headers.normalize();
	  return data;
	}

	function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	}

	/**
	 * A `CanceledError` is an object that is thrown when an operation is canceled.
	 *
	 * @param {string=} message The message.
	 * @param {Object=} config The config.
	 * @param {Object=} request The request.
	 *
	 * @returns {CanceledError} The created error.
	 */
	function CanceledError(message, config, request) {
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
	  this.name = 'CanceledError';
	}
	utils$1.inherits(CanceledError, AxiosError, {
	  __CANCEL__: true
	});

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 *
	 * @returns {object} The response.
	 */
	function settle(resolve, reject, response) {
	  const validateStatus = response.config.validateStatus;
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(new AxiosError('Request failed with status code ' + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
	  }
	}

	function parseProtocol(url) {
	  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
	  return match && match[1] || '';
	}

	/**
	 * Calculate data maxRate
	 * @param {Number} [samplesCount= 10]
	 * @param {Number} [min= 1000]
	 * @returns {Function}
	 */
	function speedometer(samplesCount, min) {
	  samplesCount = samplesCount || 10;
	  const bytes = new Array(samplesCount);
	  const timestamps = new Array(samplesCount);
	  let head = 0;
	  let tail = 0;
	  let firstSampleTS;
	  min = min !== undefined ? min : 1000;
	  return function push(chunkLength) {
	    const now = Date.now();
	    const startedAt = timestamps[tail];
	    if (!firstSampleTS) {
	      firstSampleTS = now;
	    }
	    bytes[head] = chunkLength;
	    timestamps[head] = now;
	    let i = tail;
	    let bytesCount = 0;
	    while (i !== head) {
	      bytesCount += bytes[i++];
	      i = i % samplesCount;
	    }
	    head = (head + 1) % samplesCount;
	    if (head === tail) {
	      tail = (tail + 1) % samplesCount;
	    }
	    if (now - firstSampleTS < min) {
	      return;
	    }
	    const passed = startedAt && now - startedAt;
	    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
	  };
	}

	/**
	 * Throttle decorator
	 * @param {Function} fn
	 * @param {Number} freq
	 * @return {Function}
	 */
	function throttle(fn, freq) {
	  let timestamp = 0;
	  let threshold = 1000 / freq;
	  let lastArgs;
	  let timer;
	  const invoke = (args, now = Date.now()) => {
	    timestamp = now;
	    lastArgs = null;
	    if (timer) {
	      clearTimeout(timer);
	      timer = null;
	    }
	    fn.apply(null, args);
	  };
	  const throttled = (...args) => {
	    const now = Date.now();
	    const passed = now - timestamp;
	    if (passed >= threshold) {
	      invoke(args, now);
	    } else {
	      lastArgs = args;
	      if (!timer) {
	        timer = setTimeout(() => {
	          timer = null;
	          invoke(lastArgs);
	        }, threshold - passed);
	      }
	    }
	  };
	  const flush = () => lastArgs && invoke(lastArgs);
	  return [throttled, flush];
	}

	const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
	  let bytesNotified = 0;
	  const _speedometer = speedometer(50, 250);
	  return throttle(e => {
	    const loaded = e.loaded;
	    const total = e.lengthComputable ? e.total : undefined;
	    const progressBytes = loaded - bytesNotified;
	    const rate = _speedometer(progressBytes);
	    const inRange = loaded <= total;
	    bytesNotified = loaded;
	    const data = {
	      loaded,
	      total,
	      progress: total ? loaded / total : undefined,
	      bytes: progressBytes,
	      rate: rate ? rate : undefined,
	      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
	      event: e,
	      lengthComputable: total != null,
	      [isDownloadStream ? 'download' : 'upload']: true
	    };
	    listener(data);
	  }, freq);
	};
	const progressEventDecorator = (total, throttled) => {
	  const lengthComputable = total != null;
	  return [loaded => throttled[0]({
	    lengthComputable,
	    total,
	    loaded
	  }), throttled[1]];
	};
	const asyncDecorator = fn => (...args) => utils$1.asap(() => fn(...args));

	var isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => url => {
	  url = new URL(url, platform.origin);
	  return origin.protocol === url.protocol && origin.host === url.host && (isMSIE || origin.port === url.port);
	})(new URL(platform.origin), platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)) : () => true;

	var cookies = platform.hasStandardBrowserEnv ?
	// Standard browser envs support document.cookie
	{
	  write(name, value, expires, path, domain, secure) {
	    const cookie = [name + '=' + encodeURIComponent(value)];
	    utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());
	    utils$1.isString(path) && cookie.push('path=' + path);
	    utils$1.isString(domain) && cookie.push('domain=' + domain);
	    secure === true && cookie.push('secure');
	    document.cookie = cookie.join('; ');
	  },
	  read(name) {
	    const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	    return match ? decodeURIComponent(match[3]) : null;
	  },
	  remove(name) {
	    this.write(name, '', Date.now() - 86400000);
	  }
	} :
	// Non-standard browser env (web workers, react-native) lack needed support.
	{
	  write() {},
	  read() {
	    return null;
	  },
	  remove() {}
	};

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 *
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
	}

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 *
	 * @returns {string} The combined URL
	 */
	function combineURLs(baseURL, relativeURL) {
	  return relativeURL ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
	}

	/**
	 * Creates a new URL by combining the baseURL with the requestedURL,
	 * only when the requestedURL is not already an absolute URL.
	 * If the requestURL is absolute, this function returns the requestedURL untouched.
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} requestedURL Absolute or relative URL to combine
	 *
	 * @returns {string} The combined full path
	 */
	function buildFullPath(baseURL, requestedURL) {
	  if (baseURL && !isAbsoluteURL(requestedURL)) {
	    return combineURLs(baseURL, requestedURL);
	  }
	  return requestedURL;
	}

	const headersToObject = thing => thing instanceof AxiosHeaders ? {
	  ...thing
	} : thing;

	/**
	 * Config-specific merge-function which creates a new config-object
	 * by merging two configuration objects together.
	 *
	 * @param {Object} config1
	 * @param {Object} config2
	 *
	 * @returns {Object} New object resulting from merging config2 to config1
	 */
	function mergeConfig(config1, config2) {
	  // eslint-disable-next-line no-param-reassign
	  config2 = config2 || {};
	  const config = {};
	  function getMergedValue(target, source, prop, caseless) {
	    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
	      return utils$1.merge.call({
	        caseless
	      }, target, source);
	    } else if (utils$1.isPlainObject(source)) {
	      return utils$1.merge({}, source);
	    } else if (utils$1.isArray(source)) {
	      return source.slice();
	    }
	    return source;
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDeepProperties(a, b, prop, caseless) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(a, b, prop, caseless);
	    } else if (!utils$1.isUndefined(a)) {
	      return getMergedValue(undefined, a, prop, caseless);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function valueFromConfig2(a, b) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(undefined, b);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function defaultToConfig2(a, b) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(undefined, b);
	    } else if (!utils$1.isUndefined(a)) {
	      return getMergedValue(undefined, a);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDirectKeys(a, b, prop) {
	    if (prop in config2) {
	      return getMergedValue(a, b);
	    } else if (prop in config1) {
	      return getMergedValue(undefined, a);
	    }
	  }
	  const mergeMap = {
	    url: valueFromConfig2,
	    method: valueFromConfig2,
	    data: valueFromConfig2,
	    baseURL: defaultToConfig2,
	    transformRequest: defaultToConfig2,
	    transformResponse: defaultToConfig2,
	    paramsSerializer: defaultToConfig2,
	    timeout: defaultToConfig2,
	    timeoutMessage: defaultToConfig2,
	    withCredentials: defaultToConfig2,
	    withXSRFToken: defaultToConfig2,
	    adapter: defaultToConfig2,
	    responseType: defaultToConfig2,
	    xsrfCookieName: defaultToConfig2,
	    xsrfHeaderName: defaultToConfig2,
	    onUploadProgress: defaultToConfig2,
	    onDownloadProgress: defaultToConfig2,
	    decompress: defaultToConfig2,
	    maxContentLength: defaultToConfig2,
	    maxBodyLength: defaultToConfig2,
	    beforeRedirect: defaultToConfig2,
	    transport: defaultToConfig2,
	    httpAgent: defaultToConfig2,
	    httpsAgent: defaultToConfig2,
	    cancelToken: defaultToConfig2,
	    socketPath: defaultToConfig2,
	    responseEncoding: defaultToConfig2,
	    validateStatus: mergeDirectKeys,
	    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
	  };
	  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
	    const merge = mergeMap[prop] || mergeDeepProperties;
	    const configValue = merge(config1[prop], config2[prop], prop);
	    utils$1.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
	  });
	  return config;
	}

	var resolveConfig = config => {
	  const newConfig = mergeConfig({}, config);
	  let {
	    data,
	    withXSRFToken,
	    xsrfHeaderName,
	    xsrfCookieName,
	    headers,
	    auth
	  } = newConfig;
	  newConfig.headers = headers = AxiosHeaders.from(headers);
	  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);

	  // HTTP basic authentication
	  if (auth) {
	    headers.set('Authorization', 'Basic ' + btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : '')));
	  }
	  let contentType;
	  if (utils$1.isFormData(data)) {
	    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
	      headers.setContentType(undefined); // Let the browser set it
	    } else if ((contentType = headers.getContentType()) !== false) {
	      // fix semicolon duplication issue for ReactNative FormData implementation
	      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
	      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
	    }
	  }

	  // Add xsrf header
	  // This is only done if running in a standard browser environment.
	  // Specifically not if we're in a web worker, or react-native.

	  if (platform.hasStandardBrowserEnv) {
	    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
	    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
	      // Add xsrf header
	      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
	      if (xsrfValue) {
	        headers.set(xsrfHeaderName, xsrfValue);
	      }
	    }
	  }
	  return newConfig;
	};

	const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
	var xhrAdapter = isXHRAdapterSupported && function (config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    const _config = resolveConfig(config);
	    let requestData = _config.data;
	    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();
	    let {
	      responseType,
	      onUploadProgress,
	      onDownloadProgress
	    } = _config;
	    let onCanceled;
	    let uploadThrottled, downloadThrottled;
	    let flushUpload, flushDownload;
	    function done() {
	      flushUpload && flushUpload(); // flush events
	      flushDownload && flushDownload(); // flush events

	      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
	      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
	    }
	    let request = new XMLHttpRequest();
	    request.open(_config.method.toUpperCase(), _config.url, true);

	    // Set the request timeout in MS
	    request.timeout = _config.timeout;
	    function onloadend() {
	      if (!request) {
	        return;
	      }
	      // Prepare the response
	      const responseHeaders = AxiosHeaders.from('getAllResponseHeaders' in request && request.getAllResponseHeaders());
	      const responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
	      const response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config,
	        request
	      };
	      settle(function _resolve(value) {
	        resolve(value);
	        done();
	      }, function _reject(err) {
	        reject(err);
	        done();
	      }, response);

	      // Clean up request
	      request = null;
	    }
	    if ('onloadend' in request) {
	      // Use onloadend if available
	      request.onloadend = onloadend;
	    } else {
	      // Listen for ready state to emulate onloadend
	      request.onreadystatechange = function handleLoad() {
	        if (!request || request.readyState !== 4) {
	          return;
	        }

	        // The request errored out and we didn't get a response, this will be
	        // handled by onerror instead
	        // With one exception: request that using file: protocol, most browsers
	        // will return status as 0 even though it's a successful request
	        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	          return;
	        }
	        // readystate handler is calling before onerror or ontimeout handlers,
	        // so we should call onloadend on the next 'tick'
	        setTimeout(onloadend);
	      };
	    }

	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }
	      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
	      const transitional = _config.transitional || transitionalDefaults;
	      if (_config.timeoutErrorMessage) {
	        timeoutErrorMessage = _config.timeoutErrorMessage;
	      }
	      reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Remove Content-Type if data is undefined
	    requestData === undefined && requestHeaders.setContentType(null);

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
	        request.setRequestHeader(key, val);
	      });
	    }

	    // Add withCredentials to request if needed
	    if (!utils$1.isUndefined(_config.withCredentials)) {
	      request.withCredentials = !!_config.withCredentials;
	    }

	    // Add responseType to request if needed
	    if (responseType && responseType !== 'json') {
	      request.responseType = _config.responseType;
	    }

	    // Handle progress if needed
	    if (onDownloadProgress) {
	      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
	      request.addEventListener('progress', downloadThrottled);
	    }

	    // Not all browsers support upload events
	    if (onUploadProgress && request.upload) {
	      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
	      request.upload.addEventListener('progress', uploadThrottled);
	      request.upload.addEventListener('loadend', flushUpload);
	    }
	    if (_config.cancelToken || _config.signal) {
	      // Handle cancellation
	      // eslint-disable-next-line func-names
	      onCanceled = cancel => {
	        if (!request) {
	          return;
	        }
	        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
	        request.abort();
	        request = null;
	      };
	      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
	      if (_config.signal) {
	        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
	      }
	    }
	    const protocol = parseProtocol(_config.url);
	    if (protocol && platform.protocols.indexOf(protocol) === -1) {
	      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
	      return;
	    }

	    // Send the request
	    request.send(requestData || null);
	  });
	};

	const composeSignals = (signals, timeout) => {
	  const {
	    length
	  } = signals = signals ? signals.filter(Boolean) : [];
	  if (timeout || length) {
	    let controller = new AbortController();
	    let aborted;
	    const onabort = function (reason) {
	      if (!aborted) {
	        aborted = true;
	        unsubscribe();
	        const err = reason instanceof Error ? reason : this.reason;
	        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
	      }
	    };
	    let timer = timeout && setTimeout(() => {
	      timer = null;
	      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
	    }, timeout);
	    const unsubscribe = () => {
	      if (signals) {
	        timer && clearTimeout(timer);
	        timer = null;
	        signals.forEach(signal => {
	          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
	        });
	        signals = null;
	      }
	    };
	    signals.forEach(signal => signal.addEventListener('abort', onabort));
	    const {
	      signal
	    } = controller;
	    signal.unsubscribe = () => utils$1.asap(unsubscribe);
	    return signal;
	  }
	};

	const streamChunk = function* (chunk, chunkSize) {
	  let len = chunk.byteLength;
	  if (len < chunkSize) {
	    yield chunk;
	    return;
	  }
	  let pos = 0;
	  let end;
	  while (pos < len) {
	    end = pos + chunkSize;
	    yield chunk.slice(pos, end);
	    pos = end;
	  }
	};
	const readBytes = async function* (iterable, chunkSize) {
	  for await (const chunk of readStream(iterable)) {
	    yield* streamChunk(chunk, chunkSize);
	  }
	};
	const readStream = async function* (stream) {
	  if (stream[Symbol.asyncIterator]) {
	    yield* stream;
	    return;
	  }
	  const reader = stream.getReader();
	  try {
	    for (;;) {
	      const {
	        done,
	        value
	      } = await reader.read();
	      if (done) {
	        break;
	      }
	      yield value;
	    }
	  } finally {
	    await reader.cancel();
	  }
	};
	const trackStream = (stream, chunkSize, onProgress, onFinish) => {
	  const iterator = readBytes(stream, chunkSize);
	  let bytes = 0;
	  let done;
	  let _onFinish = e => {
	    if (!done) {
	      done = true;
	      onFinish && onFinish(e);
	    }
	  };
	  return new ReadableStream({
	    async pull(controller) {
	      try {
	        const {
	          done,
	          value
	        } = await iterator.next();
	        if (done) {
	          _onFinish();
	          controller.close();
	          return;
	        }
	        let len = value.byteLength;
	        if (onProgress) {
	          let loadedBytes = bytes += len;
	          onProgress(loadedBytes);
	        }
	        controller.enqueue(new Uint8Array(value));
	      } catch (err) {
	        _onFinish(err);
	        throw err;
	      }
	    },
	    cancel(reason) {
	      _onFinish(reason);
	      return iterator.return();
	    }
	  }, {
	    highWaterMark: 2
	  });
	};

	const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
	const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

	// used only inside the fetch adapter
	const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? (encoder => str => encoder.encode(str))(new TextEncoder()) : async str => new Uint8Array(await new Response(str).arrayBuffer()));
	const test = (fn, ...args) => {
	  try {
	    return !!fn(...args);
	  } catch (e) {
	    return false;
	  }
	};
	const supportsRequestStream = isReadableStreamSupported && test(() => {
	  let duplexAccessed = false;
	  const hasContentType = new Request(platform.origin, {
	    body: new ReadableStream(),
	    method: 'POST',
	    get duplex() {
	      duplexAccessed = true;
	      return 'half';
	    }
	  }).headers.has('Content-Type');
	  return duplexAccessed && !hasContentType;
	});
	const DEFAULT_CHUNK_SIZE = 64 * 1024;
	const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response('').body));
	const resolvers = {
	  stream: supportsResponseStream && (res => res.body)
	};
	isFetchSupported && (res => {
	  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
	    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? res => res[type]() : (_, config) => {
	      throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
	    });
	  });
	})(new Response());
	const getBodyLength = async body => {
	  if (body == null) {
	    return 0;
	  }
	  if (utils$1.isBlob(body)) {
	    return body.size;
	  }
	  if (utils$1.isSpecCompliantForm(body)) {
	    const _request = new Request(platform.origin, {
	      method: 'POST',
	      body
	    });
	    return (await _request.arrayBuffer()).byteLength;
	  }
	  if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
	    return body.byteLength;
	  }
	  if (utils$1.isURLSearchParams(body)) {
	    body = body + '';
	  }
	  if (utils$1.isString(body)) {
	    return (await encodeText(body)).byteLength;
	  }
	};
	const resolveBodyLength = async (headers, body) => {
	  const length = utils$1.toFiniteNumber(headers.getContentLength());
	  return length == null ? getBodyLength(body) : length;
	};
	var fetchAdapter = isFetchSupported && (async config => {
	  let {
	    url,
	    method,
	    data,
	    signal,
	    cancelToken,
	    timeout,
	    onDownloadProgress,
	    onUploadProgress,
	    responseType,
	    headers,
	    withCredentials = 'same-origin',
	    fetchOptions
	  } = resolveConfig(config);
	  responseType = responseType ? (responseType + '').toLowerCase() : 'text';
	  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
	  let request;
	  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
	    composedSignal.unsubscribe();
	  });
	  let requestContentLength;
	  try {
	    if (onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
	      let _request = new Request(url, {
	        method: 'POST',
	        body: data,
	        duplex: "half"
	      });
	      let contentTypeHeader;
	      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
	        headers.setContentType(contentTypeHeader);
	      }
	      if (_request.body) {
	        const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));
	        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
	      }
	    }
	    if (!utils$1.isString(withCredentials)) {
	      withCredentials = withCredentials ? 'include' : 'omit';
	    }

	    // Cloudflare Workers throws when credentials are defined
	    // see https://github.com/cloudflare/workerd/issues/902
	    const isCredentialsSupported = "credentials" in Request.prototype;
	    request = new Request(url, {
	      ...fetchOptions,
	      signal: composedSignal,
	      method: method.toUpperCase(),
	      headers: headers.normalize().toJSON(),
	      body: data,
	      duplex: "half",
	      credentials: isCredentialsSupported ? withCredentials : undefined
	    });
	    let response = await fetch(request);
	    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');
	    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
	      const options = {};
	      ['status', 'statusText', 'headers'].forEach(prop => {
	        options[prop] = response[prop];
	      });
	      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));
	      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];
	      response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
	        flush && flush();
	        unsubscribe && unsubscribe();
	      }), options);
	    }
	    responseType = responseType || 'text';
	    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);
	    !isStreamResponse && unsubscribe && unsubscribe();
	    return await new Promise((resolve, reject) => {
	      settle(resolve, reject, {
	        data: responseData,
	        headers: AxiosHeaders.from(response.headers),
	        status: response.status,
	        statusText: response.statusText,
	        config,
	        request
	      });
	    });
	  } catch (err) {
	    unsubscribe && unsubscribe();
	    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {
	      throw Object.assign(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request), {
	        cause: err.cause || err
	      });
	    }
	    throw AxiosError.from(err, err && err.code, config, request);
	  }
	});

	const knownAdapters = {
	  http: httpAdapter,
	  xhr: xhrAdapter,
	  fetch: fetchAdapter
	};
	utils$1.forEach(knownAdapters, (fn, value) => {
	  if (fn) {
	    try {
	      Object.defineProperty(fn, 'name', {
	        value
	      });
	    } catch (e) {
	      // eslint-disable-next-line no-empty
	    }
	    Object.defineProperty(fn, 'adapterName', {
	      value
	    });
	  }
	});
	const renderReason = reason => `- ${reason}`;
	const isResolvedHandle = adapter => utils$1.isFunction(adapter) || adapter === null || adapter === false;
	var adapters = {
	  getAdapter: adapters => {
	    adapters = utils$1.isArray(adapters) ? adapters : [adapters];
	    const {
	      length
	    } = adapters;
	    let nameOrAdapter;
	    let adapter;
	    const rejectedReasons = {};
	    for (let i = 0; i < length; i++) {
	      nameOrAdapter = adapters[i];
	      let id;
	      adapter = nameOrAdapter;
	      if (!isResolvedHandle(nameOrAdapter)) {
	        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
	        if (adapter === undefined) {
	          throw new AxiosError(`Unknown adapter '${id}'`);
	        }
	      }
	      if (adapter) {
	        break;
	      }
	      rejectedReasons[id || '#' + i] = adapter;
	    }
	    if (!adapter) {
	      const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? 'is not supported by the environment' : 'is not available in the build'));
	      let s = length ? reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0]) : 'as no adapter specified';
	      throw new AxiosError(`There is no suitable adapter to dispatch the request ` + s, 'ERR_NOT_SUPPORT');
	    }
	    return adapter;
	  },
	  adapters: knownAdapters
	};

	/**
	 * Throws a `CanceledError` if cancellation has been requested.
	 *
	 * @param {Object} config The config that is to be used for the request
	 *
	 * @returns {void}
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	  if (config.signal && config.signal.aborted) {
	    throw new CanceledError(null, config);
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 *
	 * @returns {Promise} The Promise to be fulfilled
	 */
	function dispatchRequest(config) {
	  throwIfCancellationRequested(config);
	  config.headers = AxiosHeaders.from(config.headers);

	  // Transform request data
	  config.data = transformData.call(config, config.transformRequest);
	  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
	    config.headers.setContentType('application/x-www-form-urlencoded', false);
	  }
	  const adapter = adapters.getAdapter(config.adapter || defaults.adapter);
	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData.call(config, config.transformResponse, response);
	    response.headers = AxiosHeaders.from(response.headers);
	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
	        reason.response.headers = AxiosHeaders.from(reason.response.headers);
	      }
	    }
	    return Promise.reject(reason);
	  });
	}

	const VERSION = "1.7.8";

	const validators$1 = {};

	// eslint-disable-next-line func-names
	['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
	  validators$1[type] = function validator(thing) {
	    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
	  };
	});
	const deprecatedWarnings = {};

	/**
	 * Transitional option validator
	 *
	 * @param {function|boolean?} validator - set to false if the transitional option has been removed
	 * @param {string?} version - deprecated version / removed since version
	 * @param {string?} message - some message with additional info
	 *
	 * @returns {function}
	 */
	validators$1.transitional = function transitional(validator, version, message) {
	  function formatMessage(opt, desc) {
	    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
	  }

	  // eslint-disable-next-line func-names
	  return (value, opt, opts) => {
	    if (validator === false) {
	      throw new AxiosError(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError.ERR_DEPRECATED);
	    }
	    if (version && !deprecatedWarnings[opt]) {
	      deprecatedWarnings[opt] = true;
	      // eslint-disable-next-line no-console
	      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
	    }
	    return validator ? validator(value, opt, opts) : true;
	  };
	};
	validators$1.spelling = function spelling(correctSpelling) {
	  return (value, opt) => {
	    // eslint-disable-next-line no-console
	    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
	    return true;
	  };
	};

	/**
	 * Assert object's properties type
	 *
	 * @param {object} options
	 * @param {object} schema
	 * @param {boolean?} allowUnknown
	 *
	 * @returns {object}
	 */

	function assertOptions(options, schema, allowUnknown) {
	  if (typeof options !== 'object') {
	    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
	  }
	  const keys = Object.keys(options);
	  let i = keys.length;
	  while (i-- > 0) {
	    const opt = keys[i];
	    const validator = schema[opt];
	    if (validator) {
	      const value = options[opt];
	      const result = value === undefined || validator(value, opt, options);
	      if (result !== true) {
	        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
	      }
	      continue;
	    }
	    if (allowUnknown !== true) {
	      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
	    }
	  }
	}
	var validator = {
	  assertOptions,
	  validators: validators$1
	};

	const validators = validator.validators;

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 *
	 * @return {Axios} A new instance of Axios
	 */
	class Axios {
	  constructor(instanceConfig) {
	    this.defaults = instanceConfig;
	    this.interceptors = {
	      request: new InterceptorManager(),
	      response: new InterceptorManager()
	    };
	  }

	  /**
	   * Dispatch a request
	   *
	   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
	   * @param {?Object} config
	   *
	   * @returns {Promise} The Promise to be fulfilled
	   */
	  async request(configOrUrl, config) {
	    try {
	      return await this._request(configOrUrl, config);
	    } catch (err) {
	      if (err instanceof Error) {
	        let dummy = {};
	        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();

	        // slice off the Error: ... line
	        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
	        try {
	          if (!err.stack) {
	            err.stack = stack;
	            // match without the 2 top stack lines
	          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
	            err.stack += '\n' + stack;
	          }
	        } catch (e) {
	          // ignore the case where "stack" is an un-writable property
	        }
	      }
	      throw err;
	    }
	  }
	  _request(configOrUrl, config) {
	    /*eslint no-param-reassign:0*/
	    // Allow for axios('example/url'[, config]) a la fetch API
	    if (typeof configOrUrl === 'string') {
	      config = config || {};
	      config.url = configOrUrl;
	    } else {
	      config = configOrUrl || {};
	    }
	    config = mergeConfig(this.defaults, config);
	    const {
	      transitional,
	      paramsSerializer,
	      headers
	    } = config;
	    if (transitional !== undefined) {
	      validator.assertOptions(transitional, {
	        silentJSONParsing: validators.transitional(validators.boolean),
	        forcedJSONParsing: validators.transitional(validators.boolean),
	        clarifyTimeoutError: validators.transitional(validators.boolean)
	      }, false);
	    }
	    if (paramsSerializer != null) {
	      if (utils$1.isFunction(paramsSerializer)) {
	        config.paramsSerializer = {
	          serialize: paramsSerializer
	        };
	      } else {
	        validator.assertOptions(paramsSerializer, {
	          encode: validators.function,
	          serialize: validators.function
	        }, true);
	      }
	    }
	    validator.assertOptions(config, {
	      baseUrl: validators.spelling('baseURL'),
	      withXsrfToken: validators.spelling('withXSRFToken')
	    }, true);

	    // Set config.method
	    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

	    // Flatten headers
	    let contextHeaders = headers && utils$1.merge(headers.common, headers[config.method]);
	    headers && utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], method => {
	      delete headers[method];
	    });
	    config.headers = AxiosHeaders.concat(contextHeaders, headers);

	    // filter out skipped interceptors
	    const requestInterceptorChain = [];
	    let synchronousRequestInterceptors = true;
	    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
	        return;
	      }
	      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
	      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
	    });
	    const responseInterceptorChain = [];
	    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
	    });
	    let promise;
	    let i = 0;
	    let len;
	    if (!synchronousRequestInterceptors) {
	      const chain = [dispatchRequest.bind(this), undefined];
	      chain.unshift.apply(chain, requestInterceptorChain);
	      chain.push.apply(chain, responseInterceptorChain);
	      len = chain.length;
	      promise = Promise.resolve(config);
	      while (i < len) {
	        promise = promise.then(chain[i++], chain[i++]);
	      }
	      return promise;
	    }
	    len = requestInterceptorChain.length;
	    let newConfig = config;
	    i = 0;
	    while (i < len) {
	      const onFulfilled = requestInterceptorChain[i++];
	      const onRejected = requestInterceptorChain[i++];
	      try {
	        newConfig = onFulfilled(newConfig);
	      } catch (error) {
	        onRejected.call(this, error);
	        break;
	      }
	    }
	    try {
	      promise = dispatchRequest.call(this, newConfig);
	    } catch (error) {
	      return Promise.reject(error);
	    }
	    i = 0;
	    len = responseInterceptorChain.length;
	    while (i < len) {
	      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
	    }
	    return promise;
	  }
	  getUri(config) {
	    config = mergeConfig(this.defaults, config);
	    const fullPath = buildFullPath(config.baseURL, config.url);
	    return buildURL(fullPath, config.params, config.paramsSerializer);
	  }
	}

	// Provide aliases for supported request methods
	utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function (url, config) {
	    return this.request(mergeConfig(config || {}, {
	      method,
	      url,
	      data: (config || {}).data
	    }));
	  };
	});
	utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/

	  function generateHTTPMethod(isForm) {
	    return function httpMethod(url, data, config) {
	      return this.request(mergeConfig(config || {}, {
	        method,
	        headers: isForm ? {
	          'Content-Type': 'multipart/form-data'
	        } : {},
	        url,
	        data
	      }));
	    };
	  }
	  Axios.prototype[method] = generateHTTPMethod();
	  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
	});

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @param {Function} executor The executor function.
	 *
	 * @returns {CancelToken}
	 */
	class CancelToken {
	  constructor(executor) {
	    if (typeof executor !== 'function') {
	      throw new TypeError('executor must be a function.');
	    }
	    let resolvePromise;
	    this.promise = new Promise(function promiseExecutor(resolve) {
	      resolvePromise = resolve;
	    });
	    const token = this;

	    // eslint-disable-next-line func-names
	    this.promise.then(cancel => {
	      if (!token._listeners) return;
	      let i = token._listeners.length;
	      while (i-- > 0) {
	        token._listeners[i](cancel);
	      }
	      token._listeners = null;
	    });

	    // eslint-disable-next-line func-names
	    this.promise.then = onfulfilled => {
	      let _resolve;
	      // eslint-disable-next-line func-names
	      const promise = new Promise(resolve => {
	        token.subscribe(resolve);
	        _resolve = resolve;
	      }).then(onfulfilled);
	      promise.cancel = function reject() {
	        token.unsubscribe(_resolve);
	      };
	      return promise;
	    };
	    executor(function cancel(message, config, request) {
	      if (token.reason) {
	        // Cancellation has already been requested
	        return;
	      }
	      token.reason = new CanceledError(message, config, request);
	      resolvePromise(token.reason);
	    });
	  }

	  /**
	   * Throws a `CanceledError` if cancellation has been requested.
	   */
	  throwIfRequested() {
	    if (this.reason) {
	      throw this.reason;
	    }
	  }

	  /**
	   * Subscribe to the cancel signal
	   */

	  subscribe(listener) {
	    if (this.reason) {
	      listener(this.reason);
	      return;
	    }
	    if (this._listeners) {
	      this._listeners.push(listener);
	    } else {
	      this._listeners = [listener];
	    }
	  }

	  /**
	   * Unsubscribe from the cancel signal
	   */

	  unsubscribe(listener) {
	    if (!this._listeners) {
	      return;
	    }
	    const index = this._listeners.indexOf(listener);
	    if (index !== -1) {
	      this._listeners.splice(index, 1);
	    }
	  }
	  toAbortSignal() {
	    const controller = new AbortController();
	    const abort = err => {
	      controller.abort(err);
	    };
	    this.subscribe(abort);
	    controller.signal.unsubscribe = () => this.unsubscribe(abort);
	    return controller.signal;
	  }

	  /**
	   * Returns an object that contains a new `CancelToken` and a function that, when called,
	   * cancels the `CancelToken`.
	   */
	  static source() {
	    let cancel;
	    const token = new CancelToken(function executor(c) {
	      cancel = c;
	    });
	    return {
	      token,
	      cancel
	    };
	  }
	}

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 *
	 * @returns {Function}
	 */
	function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	}

	/**
	 * Determines whether the payload is an error thrown by Axios
	 *
	 * @param {*} payload The value to test
	 *
	 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
	 */
	function isAxiosError(payload) {
	  return utils$1.isObject(payload) && payload.isAxiosError === true;
	}

	const HttpStatusCode = {
	  Continue: 100,
	  SwitchingProtocols: 101,
	  Processing: 102,
	  EarlyHints: 103,
	  Ok: 200,
	  Created: 201,
	  Accepted: 202,
	  NonAuthoritativeInformation: 203,
	  NoContent: 204,
	  ResetContent: 205,
	  PartialContent: 206,
	  MultiStatus: 207,
	  AlreadyReported: 208,
	  ImUsed: 226,
	  MultipleChoices: 300,
	  MovedPermanently: 301,
	  Found: 302,
	  SeeOther: 303,
	  NotModified: 304,
	  UseProxy: 305,
	  Unused: 306,
	  TemporaryRedirect: 307,
	  PermanentRedirect: 308,
	  BadRequest: 400,
	  Unauthorized: 401,
	  PaymentRequired: 402,
	  Forbidden: 403,
	  NotFound: 404,
	  MethodNotAllowed: 405,
	  NotAcceptable: 406,
	  ProxyAuthenticationRequired: 407,
	  RequestTimeout: 408,
	  Conflict: 409,
	  Gone: 410,
	  LengthRequired: 411,
	  PreconditionFailed: 412,
	  PayloadTooLarge: 413,
	  UriTooLong: 414,
	  UnsupportedMediaType: 415,
	  RangeNotSatisfiable: 416,
	  ExpectationFailed: 417,
	  ImATeapot: 418,
	  MisdirectedRequest: 421,
	  UnprocessableEntity: 422,
	  Locked: 423,
	  FailedDependency: 424,
	  TooEarly: 425,
	  UpgradeRequired: 426,
	  PreconditionRequired: 428,
	  TooManyRequests: 429,
	  RequestHeaderFieldsTooLarge: 431,
	  UnavailableForLegalReasons: 451,
	  InternalServerError: 500,
	  NotImplemented: 501,
	  BadGateway: 502,
	  ServiceUnavailable: 503,
	  GatewayTimeout: 504,
	  HttpVersionNotSupported: 505,
	  VariantAlsoNegotiates: 506,
	  InsufficientStorage: 507,
	  LoopDetected: 508,
	  NotExtended: 510,
	  NetworkAuthenticationRequired: 511
	};
	Object.entries(HttpStatusCode).forEach(([key, value]) => {
	  HttpStatusCode[value] = key;
	});

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 *
	 * @returns {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  const context = new Axios(defaultConfig);
	  const instance = bind(Axios.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils$1.extend(instance, Axios.prototype, context, {
	    allOwnKeys: true
	  });

	  // Copy context to instance
	  utils$1.extend(instance, context, null, {
	    allOwnKeys: true
	  });

	  // Factory for creating new instances
	  instance.create = function create(instanceConfig) {
	    return createInstance(mergeConfig(defaultConfig, instanceConfig));
	  };
	  return instance;
	}

	// Create the default instance to be exported
	const axios = createInstance(defaults);

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;

	// Expose Cancel & CancelToken
	axios.CanceledError = CanceledError;
	axios.CancelToken = CancelToken;
	axios.isCancel = isCancel;
	axios.VERSION = VERSION;
	axios.toFormData = toFormData;

	// Expose AxiosError class
	axios.AxiosError = AxiosError;

	// alias for CanceledError for backward compatibility
	axios.Cancel = axios.CanceledError;

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = spread;

	// Expose isAxiosError
	axios.isAxiosError = isAxiosError;

	// Expose mergeConfig
	axios.mergeConfig = mergeConfig;
	axios.AxiosHeaders = AxiosHeaders;
	axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
	axios.getAdapter = adapters.getAdapter;
	axios.HttpStatusCode = HttpStatusCode;
	axios.default = axios;

	async function api (url, data) {
	  return await axios.post(url, data).then(resp => resp.data);
	}

	const datumValidate = /^(\d+);(\d+);(\d+);(\d+)$/;
	const boxType = 0;
	const itemType = 1;
	class Datum {
	  constructor(id, type, width, height, depth, weight) {
	    this.id = id;
	    this.type = type;
	    this.width = parseInt(width);
	    this.height = parseInt(height);
	    this.depth = parseInt(depth);
	    this.weight = parseInt(weight);
	    this.enabled = true;
	  }
	  toString() {
	    return this.width + 'x' + this.height + 'x' + this.depth + ' wg' + this.weight;
	  }
	  toExport() {
	    return [this.id, this.width, this.type, this.height, this.depth, this.weight].join(';');
	  }
	}
	class ItemComponent extends xn.Component {
	  state = {
	    hasError: false,
	    text: '',
	    type: itemType,
	    elements: []
	  };
	  constructor() {
	    super(...arguments);
	  }
	  async componentDidMount() {
	    let {
	      elements
	    } = this.state;
	    for (const box of await api('/bp3boxes', {})) {
	      elements = elements.concat(new Datum(box.id, boxType, box.width, box.height, box.depth, box.weight));
	    }
	    this.setState({
	      elements
	    });
	    await this.playgroundRender(elements);
	  }
	  setText = e => {
	    this.setState({
	      text: e.target.value
	    });
	  };
	  setType = v => {
	    this.setState({
	      type: v
	    });
	  };
	  switchEnabled = async id => {
	    const {
	      elements
	    } = this.state;
	    const element = elements.find(e => e.id === id);
	    element.enabled = !element.enabled;
	    this.setState({
	      elements
	    });
	    await this.playgroundRender(elements);
	  };
	  addElement = async () => {
	    let {
	      elements,
	      type,
	      text
	    } = this.state;
	    const matchResult = text.match(datumValidate);
	    if (matchResult === null) {
	      this.setState({
	        hasError: true
	      });
	      return;
	    }
	    const id = generateUUID();
	    const datum = new Datum(id, type, matchResult[1], matchResult[2], matchResult[3], matchResult[4]);
	    elements = elements.concat(datum);
	    this.setState({
	      elements,
	      text: '',
	      hasError: false
	    });
	    await this.playgroundRender(elements);
	  };
	  playgroundRender = async elements => {
	    const items = elements.filter(e => e.enabled);
	    this.props.playground.render(await api('/bp3', {
	      boxes: items.filter(i => i.type === boxType),
	      items: items.filter(i => i.type === itemType)
	    }));
	  };
	  onImport = () => {
	    alert('planned to develop');
	  };
	  onExport = () => {
	    const {
	      elements
	    } = this.state;
	    const csvContent = "data:text/csv;charset=utf-8," + "id;type;width;height;depth;weight\n" + elements.filter(e => e.enabled).map(e => e.toExport()).join("\n");
	    const link = document.createElement("a");
	    link.setAttribute("href", encodeURI(csvContent));
	    link.setAttribute("download", "export.csv");
	    link.click();
	  };
	  render({}, {
	    elements,
	    type,
	    text,
	    hasError
	  }) {
	    return /*#__PURE__*/xn.createElement("nav", {
	      className: "panel"
	    }, /*#__PURE__*/xn.createElement("p", {
	      className: "panel-heading field"
	    }, /*#__PURE__*/xn.createElement("div", {
	      className: "level"
	    }, /*#__PURE__*/xn.createElement("div", {
	      className: "level-left"
	    }, /*#__PURE__*/xn.createElement("div", {
	      className: "level-item"
	    }, /*#__PURE__*/xn.createElement("p", {
	      className: "subtitle is-5"
	    }, /*#__PURE__*/xn.createElement("strong", null, "Settings")))), /*#__PURE__*/xn.createElement("div", {
	      className: "level-right"
	    }, /*#__PURE__*/xn.createElement("div", {
	      className: "level-item"
	    }, /*#__PURE__*/xn.createElement("div", {
	      className: "field has-addons"
	    }, /*#__PURE__*/xn.createElement("p", {
	      className: "control"
	    }, /*#__PURE__*/xn.createElement("a", {
	      href: "#",
	      onClick: this.onImport,
	      className: "button is-info is-light is-small is-rounded"
	    }, "import")), /*#__PURE__*/xn.createElement("p", {
	      className: "control"
	    }, /*#__PURE__*/xn.createElement("a", {
	      href: "#",
	      onClick: this.onExport,
	      className: "button is-success is-light is-small is-rounded"
	    }, "export"))))))), /*#__PURE__*/xn.createElement("form", {
	      onSubmit: this.addElement,
	      action: "javascript:"
	    }, /*#__PURE__*/xn.createElement("div", {
	      className: "panel-block"
	    }, /*#__PURE__*/xn.createElement("p", {
	      className: "control has-icons-right"
	    }, /*#__PURE__*/xn.createElement("input", {
	      value: text,
	      onInput: this.setText,
	      className: "input is-primary",
	      type: "text",
	      placeholder: "w;h;d;wg"
	    }), hasError && /*#__PURE__*/xn.createElement("p", {
	      className: "help is-danger"
	    }, "Incorrect syntax"))), /*#__PURE__*/xn.createElement("p", {
	      className: "panel-tabs"
	    }, /*#__PURE__*/xn.createElement("a", {
	      href: "#",
	      className: type === boxType ? "is-active" : "",
	      onClick: () => this.setType(boxType)
	    }, "Boxes"), /*#__PURE__*/xn.createElement("a", {
	      href: "#",
	      className: type === itemType ? "is-active" : "",
	      onClick: () => this.setType(itemType)
	    }, "Items"))), elements.filter(datum => datum.type === type).map(datum => /*#__PURE__*/xn.createElement("label", {
	      key: datum.id,
	      className: "panel-block"
	    }, /*#__PURE__*/xn.createElement("input", {
	      type: "checkbox",
	      checked: datum.enabled,
	      onChange: () => this.switchEnabled(datum.id)
	    }), datum.toString())));
	  }
	}

	const playground = new Playground(document.getElementById('bp3'));
	xn.render(/*#__PURE__*/xn.createElement(ItemComponent, {
	  playground: playground
	}), document.getElementById('bp3-input'));

})();
//# sourceMappingURL=index.js.map
